{
  "config": "CODEGEN_COMPLETE_CODEFORM_NOCOMMENT",
  "data": {
    "BITCOUNT": {
      "loc": "15-16",
      "input": "public static int bitcount(int n) {\n    int count = 0;\n    while (n != 0) {",
      "function range": "12,5-19,5",
      "output": [
        "public static int bitcount(int n) {\n    int count = 0;\n    while (n!= 0) {\n      n &= (n - 1);\n      count++;\n    }\n    return count;\n  }\n\n  public static int bitcount(long n) {\n    long count = 0;\n    while (n!= 0) {\n      n &= (n - 1);\n      count++;\n    }\n    return (int) count;\n  }\n\n  public static int bitcount(long n, int start) {\n    long count = 0;\n    while (n!= 0) {\n      n &= (n - 1);\n      count++;\n    ",
        "public static int bitcount(int n) {\n    int count = 0;\n    while (n!= 0) {\n      count += n & 1;\n      n >>>= 1;\n    }\n    return count;\n  }\n\n  public static int bitcount(long n) {\n    long count = 0;\n    while (n!= 0) {\n      count += n & 1;\n      n >>>= 1;\n    }\n    return (int) count;\n  }\n\n  public static int bitcount(float n) {\n    int count = 0;\n    while (n!= 0) {\n      count += n & 1;\n      n >>>= 1;\n    ",
        "public static int bitcount(int n) {\n    int count = 0;\n    while (n!= 0) {\n      n &= (n - 1);\n      count++;\n    }\n    return count;\n  }\n\n  public static int bitcount(long n) {\n    long count = 0;\n    while (n!= 0) {\n      n &= (n - 1);\n      count++;\n    }\n    return (int) count;\n  }\n\n  public static int bitcount(long n, int from) {\n    long count = 0;\n    while (n!= 0) {\n      n &= (n - 1);\n      count++;\n    ",
        "public static int bitcount(int n) {\n    int count = 0;\n    while (n!= 0) {\n      count += (n & 1);\n      n >>= 1;\n    }\n    return count;\n  }\n\n  public static int bitcount(long n) {\n    long count = 0;\n    while (n!= 0) {\n      count += (n & 1);\n      n >>= 1;\n    }\n    return (int) count;\n  }\n\n  public static int bitcount(float n) {\n    int count = 0;\n    while (n!= 0) {\n      count += (n & 1);\n      n >>= 1",
        "public static int bitcount(int n) {\n    int count = 0;\n    while (n!= 0) {\n      count += (n & 1);\n      n >>= 1;\n    }\n    return count;\n  }\n\n  public static int bitcount(long n) {\n    long count = 0;\n    while (n!= 0) {\n      count += (n & 1);\n      n >>= 1;\n    }\n    return (int) count;\n  }\n\n  public static int bitcount(float n) {\n    int count = 0;\n    while (n!= 0) {\n      count += (int) (n & 1);\n      n",
        "public static int bitcount(int n) {\n    int count = 0;\n    while (n!= 0) {\n      n &= (n - 1);\n      count++;\n    }\n    return count;\n  }\n\n  public static int bitcount(long n) {\n    long count = 0;\n    while (n!= 0) {\n      n &= (n - 1);\n      count++;\n    }\n    return (int) count;\n  }\n\n  public static int bitcount(long n, int from) {\n    long count = 0;\n    for (int i = from; i < 64; i++) {\n      if ((n & (1L",
        "public static int bitcount(int n) {\n    int count = 0;\n    while (n!= 0) {\n      count += (n & 1);\n      n >>= 1;\n    }\n    return count;\n  }\n\n  public static int bitcount(long n) {\n    long count = 0;\n    while (n!= 0) {\n      count += (n & 1);\n      n >>= 1;\n    }\n    return (int) count;\n  }\n\n  public static int bitcount(float n) {\n    int count = 0;\n    while (n!= 0.0f) {\n      count += (int) (n & 1);",
        "public static int bitcount(int n) {\n    int count = 0;\n    while (n!= 0) {\n      n &= (n - 1);\n      count++;\n    }\n    return count;\n  }\n\n  public static int bitcount(long n) {\n    long count = 0;\n    while (n!= 0) {\n      n &= (n - 1);\n      count++;\n    }\n    return (int) count;\n  }\n\n  public static int bitcount(long n, int start) {\n    long count = 0;\n    for (int i = start; i < 64; i++) {\n      if ((n & (1L",
        "public static int bitcount(int n) {\n    int count = 0;\n    while (n!= 0) {\n      count += n & 1;\n      n >>>= 1;\n    }\n    return count;\n  }\n\n  public static int bitcount(long n) {\n    long count = 0;\n    while (n!= 0) {\n      count += n & 1;\n      n >>>= 1;\n    }\n    return (int) count;\n  }\n\n  public static int bitcount(float n) {\n    int count = 0;\n    while (n!= 0.0f) {\n      count += (int) (n & 1);\n      ",
        "public static int bitcount(int n) {\n    int count = 0;\n    while (n!= 0) {\n      count += n & 1;\n      n >>>= 1;\n    }\n    return count;\n  }\n\n  public static int bitcount(long n) {\n    long count = 0;\n    while (n!= 0) {\n      count += n & 1;\n      n >>>= 1;\n    }\n    return (int) count;\n  }\n\n  public static int bitcount(long n, int bits) {\n    long count = 0;\n    for (int i = 0; i < bits; i++) {\n      count += (n &"
      ]
    },
    "BREADTH_FIRST_SEARCH": {
      "loc": "26-27",
      "input": "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n    Deque<Node> queue = new ArrayDeque<>();\n    queue.addLast(startnode);\n    nodesvisited.add(startnode);",
      "function range": "20,5-45,5",
      "output": [
        "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n    Deque<Node> queue = new ArrayDeque<>();\n    queue.addLast(startnode);\n    nodesvisited.add(startnode);\n    while (!queue.isEmpty()) {\n      Node currentnode = queue.removeFirst();\n      if (currentnode.equals(goalnode)) {\n        return true;\n      }\n      for (Node child : currentnode.children) {\n        if (!nodesvisited.contains(child)) {\n          queue.addLast(child);\n          nodesvisited.add(child);\n        }\n      }\n    }\n    return false;\n  }\n}\n",
        "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n    Deque<Node> queue = new ArrayDeque<>();\n    queue.addLast(startnode);\n    nodesvisited.add(startnode);\n    while (!queue.isEmpty()) {\n      Node current = queue.removeFirst();\n      if (current.equals(goalnode)) {\n        return true;\n      }\n      for (Node child : current.children) {\n        if (!nodesvisited.contains(child)) {\n          queue.addLast(child);\n          nodesvisited.add(child);\n        }\n      }\n    }\n    return false;\n  }\n}\n",
        "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n    Deque<Node> queue = new ArrayDeque<>();\n    queue.addLast(startnode);\n    nodesvisited.add(startnode);\n    while (!queue.isEmpty()) {\n      Node currentnode = queue.removeFirst();\n      if (currentnode.equals(goalnode)) {\n        return true;\n      }\n      for (Node child : currentnode.getChildren()) {\n        if (!nodesvisited.contains(child)) {\n          queue.addLast(child);\n          nodesvisited.add(child);\n        }\n      }\n    }\n    return false;\n  }\n}\n",
        "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n    Deque<Node> queue = new ArrayDeque<>();\n    queue.addLast(startnode);\n    nodesvisited.add(startnode);\n    while (!queue.isEmpty()) {\n      Node current = queue.removeFirst();\n      if (current.equals(goalnode)) {\n        return true;\n      }\n      for (Node child : current.getChildren()) {\n        if (!nodesvisited.contains(child)) {\n          queue.addLast(child);\n          nodesvisited.add(child);\n        }\n      }\n    }\n    return false;\n  }\n}\n",
        "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n    Deque<Node> queue = new ArrayDeque<>();\n    queue.addLast(startnode);\n    nodesvisited.add(startnode);\n    while (!queue.isEmpty()) {\n      Node currentnode = queue.removeFirst();\n      if (currentnode.equals(goalnode)) {\n        return true;\n      }\n      for (Node child : currentnode.children) {\n        if (!nodesvisited.contains(child)) {\n          queue.addLast(child);\n          nodesvisited.add(child);\n        }\n      }\n    }\n    return false;\n  }\n\n  public static boolean depth_first_search(Node startnode, Node goalnode) {",
        "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n    Deque<Node> queue = new ArrayDeque<>();\n    queue.addLast(startnode);\n    nodesvisited.add(startnode);\n    while (!queue.isEmpty()) {\n      Node current = queue.removeFirst();\n      if (current.equals(goalnode)) {\n        return true;\n      }\n      for (Node child : current.getChildren()) {\n        if (!nodesvisited.contains(child)) {\n          queue.addLast(child);\n          nodesvisited.add(child);\n        }\n      }\n    }\n    return false;\n  }\n\n  public static boolean depth_first_search(Node startnode, Node goalnode) {\n    ",
        "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n    Deque<Node> queue = new ArrayDeque<>();\n    queue.addLast(startnode);\n    nodesvisited.add(startnode);\n    while (!queue.isEmpty()) {\n      Node currentnode = queue.removeFirst();\n      if (currentnode.equals(goalnode)) {\n        return true;\n      }\n      for (Node child : currentnode.getChildren()) {\n        if (!nodesvisited.contains(child)) {\n          queue.addLast(child);\n          nodesvisited.add(child);\n        }\n      }\n    }\n    return false;\n  }\n\n  public static boolean depth_first_search(Node startnode, Node goalnode)",
        "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n    Deque<Node> queue = new ArrayDeque<>();\n    queue.addLast(startnode);\n    nodesvisited.add(startnode);\n    while (!queue.isEmpty()) {\n      Node node = queue.removeFirst();\n      if (node.equals(goalnode)) {\n        return true;\n      }\n      for (Node child : node.getChildren()) {\n        if (!nodesvisited.contains(child)) {\n          queue.addLast(child);\n          nodesvisited.add(child);\n        }\n      }\n    }\n    return false;\n  }\n\n  public static boolean depth_first_search(Node startnode, Node goalnode) {\n    ",
        "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n    Deque<Node> queue = new ArrayDeque<>();\n    queue.addLast(startnode);\n    nodesvisited.add(startnode);\n    while (!queue.isEmpty()) {\n      Node currentnode = queue.removeFirst();\n      if (currentnode.equals(goalnode)) {\n        return true;\n      }\n      for (Node child : currentnode.children) {\n        if (!nodesvisited.contains(child)) {\n          queue.addLast(child);\n          nodesvisited.add(child);\n        }\n      }\n    }\n    return false;\n  }\n\n  public static void main(String[] args) {\n    Node startnode = new Node",
        "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n    Deque<Node> queue = new ArrayDeque<>();\n    queue.addLast(startnode);\n    nodesvisited.add(startnode);\n    while (!queue.isEmpty()) {\n      Node currentnode = queue.removeFirst();\n      if (currentnode.equals(goalnode)) {\n        return true;\n      }\n      for (Node child : currentnode.getChildren()) {\n        if (!nodesvisited.contains(child)) {\n          queue.addLast(child);\n          nodesvisited.add(child);\n        }\n      }\n    }\n    return false;\n  }\n\n  public static void main(String[] args) {\n    Node root = new Node"
      ]
    },
    "BUCKETSORT": {
      "loc": "24-25",
      "input": "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n    ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n    for (Integer x : arr) {\n        counts.set(x,counts.get(x)+1);\n    }\n    ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\nint i = 0;",
      "function range": "16,5-30,5",
      "output": [
        "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n    ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n    for (Integer x : arr) {\n        counts.set(x,counts.get(x)+1);\n    }\n    ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\nint i = 0;\n    for (Integer x : counts) {\n        sorted_arr.add(i,x);\n        i++;\n    }\n    return sorted_arr;\n}\n}\n",
        "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n    ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n    for (Integer x : arr) {\n        counts.set(x,counts.get(x)+1);\n    }\n    ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\nint i = 0;\n    for (Integer x : counts) {\n        for (int j = 0; j < x; j++) {\n            sorted_arr.add(i);\n            i++;\n        }\n    }\n    return sorted_arr;\n}\n}\n",
        "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n    ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n    for (Integer x : arr) {\n        counts.set(x,counts.get(x)+1);\n    }\n    ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\nint i = 0;\n    for (Integer count : counts) {\n        for (int j = 0; j < count; j++) {\n            sorted_arr.add(i,arr.get(i));\n            i++;\n        }\n    }\n    return sorted_arr;\n}\n}\n",
        "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n    ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n    for (Integer x : arr) {\n        counts.set(x,counts.get(x)+1);\n    }\n    ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\nint i = 0;\n    for (Integer x : counts) {\n        for (int j = 0; j < x; j++) {\n            sorted_arr.add(i);\n        }\n        i++;\n    }\n    return sorted_arr;\n}\n}\n",
        "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n    ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n    for (Integer x : arr) {\n        counts.set(x,counts.get(x)+1);\n    }\n    ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\nint i = 0;\n    for (Integer x : counts) {\n        for (int j = 0; j < x; j++) {\n            sorted_arr.add(i);\n            i++;\n        }\n    }\n    return sorted_arr;\n}\n}",
        "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n    ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n    for (Integer x : arr) {\n        counts.set(x,counts.get(x)+1);\n    }\n    ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\nint i = 0;\n    for (int j = 0; j < k; j++) {\n        sorted_arr.add(counts.get(j));\n    }\n    return sorted_arr;\n}\n}\n",
        "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n    ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n    for (Integer x : arr) {\n        counts.set(x,counts.get(x)+1);\n    }\n    ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\nint i = 0;\n    for (Integer count : counts) {\n        for (int j = 0; j < count; j++) {\n            sorted_arr.add(i,arr.get(i));\n            i++;\n        }\n    }\n    return sorted_arr;\n}\n}",
        "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n    ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n    for (Integer x : arr) {\n        counts.set(x,counts.get(x)+1);\n    }\n    ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\nint i = 0;\n    for (Integer x : counts) {\n        for (int j = 0; j < x; j++) {\n            sorted_arr.add(i);\n            i++;\n        }\n    }\n    return sorted_arr;\n    }\n}\n",
        "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n    ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n    for (Integer x : arr) {\n        counts.set(x,counts.get(x)+1);\n    }\n    ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\nint i = 0;\n    for (Integer count : counts) {\n        for (int j = 0; j < count; j++) {\n            sorted_arr.add(i,arr.get(i));\n            i++;\n        }\n    }\n    return sorted_arr;\n    }\n}\n",
        "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n    ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n    for (Integer x : arr) {\n        counts.set(x,counts.get(x)+1);\n    }\n    ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\nint i = 0;\n    for (Integer count : counts) {\n        for (int j = 0; j < count; j++) {\n            sorted_arr.add(i,arr.get(i));\n            i++;\n        }\n    }\n    return sorted_arr;\n}\n\n}\n"
      ]
    },
    "DEPTH_FIRST_SEARCH": {
      "loc": "23-23",
      "input": "boolean search(Node node) {\n    if (nodesvisited.contains(node)) {\n        return false;\n    } else if (node == goalnode) {\n        return true;\n    } else {",
      "function range": "17,13-28,13",
      "output": [
        "boolean search(Node node) {\n    if (nodesvisited.contains(node)) {\n        return false;\n    } else if (node == goalnode) {\n        return true;\n    } else {\n        nodesvisited.add(node);\n        for (Node child : node.getChildren()) {\n            if (search(child)) {\n                return true;\n            }\n        }\n        nodesvisited.remove(node);\n        return false;\n    }\n}\n}\n",
        "boolean search(Node node) {\n    if (nodesvisited.contains(node)) {\n        return false;\n    } else if (node == goalnode) {\n        return true;\n    } else {\n        nodesvisited.add(node);\n        for (Node child : node.getChildren()) {\n            if (search(child)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
        "boolean search(Node node) {\n    if (nodesvisited.contains(node)) {\n        return false;\n    } else if (node == goalnode) {\n        return true;\n    } else {\n        nodesvisited.add(node);\n        for (Node child : node.getChildren()) {\n            if (search(child)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n}\n",
        "boolean search(Node node) {\n    if (nodesvisited.contains(node)) {\n        return false;\n    } else if (node == goalnode) {\n        return true;\n    } else {\n        nodesvisited.add(node);\n        for (Node child : node.getChildren()) {\n            if (search(child)) {\n                return true;\n            }\n        }\n        nodesvisited.remove(node);\n        return false;\n    }\n}\n",
        "boolean search(Node node) {\n    if (nodesvisited.contains(node)) {\n        return false;\n    } else if (node == goalnode) {\n        return true;\n    } else {\n        for (Node child : node.getChildren()) {\n            if (search(child)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n}\n",
        "boolean search(Node node) {\n    if (nodesvisited.contains(node)) {\n        return false;\n    } else if (node == goalnode) {\n        return true;\n    } else {\n        nodesvisited.add(node);\n        for (Node child : node.getChildren()) {\n            if (search(child)) {\n                return true;\n            }\n        }\n        nodesvisited.remove(node);\n        return false;\n    }\n}\n\n}\n",
        "boolean search(Node node) {\n    if (nodesvisited.contains(node)) {\n        return false;\n    } else if (node == goalnode) {\n        return true;\n    } else {\n        nodesvisited.add(node);\n        for (Node child : node.children) {\n            if (search(child)) {\n                return true;\n            }\n        }\n        nodesvisited.remove(node);\n        return false;\n    }\n}\n",
        "boolean search(Node node) {\n    if (nodesvisited.contains(node)) {\n        return false;\n    } else if (node == goalnode) {\n        return true;\n    } else {\n        nodesvisited.add(node);\n        for (Node n : node.neighbors) {\n            if (search(n)) {\n                return true;\n            }\n        }\n        nodesvisited.remove(node);\n        return false;\n    }\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int t = in.nextInt();\n    for (int a0 = 0; a0 < t; a0++) {\n        int n = in.",
        "boolean search(Node node) {\n    if (nodesvisited.contains(node)) {\n        return false;\n    } else if (node == goalnode) {\n        return true;\n    } else {\n        nodesvisited.add(node);\n        for (Node n : node.neighbors) {\n            if (search(n)) {\n                return true;\n            }\n        }\n        nodesvisited.remove(node);\n        return false;\n    }\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    Node[] nodes = new Node[n];\n    for (int i = 0; i < n; i++)",
        "boolean search(Node node) {\n    if (nodesvisited.contains(node)) {\n        return false;\n    } else if (node == goalnode) {\n        return true;\n    } else {\n        nodesvisited.add(node);\n        for (Node n : node.neighbors) {\n            if (search(n)) {\n                return true;\n            }\n        }\n        nodesvisited.remove(node);\n        return false;\n    }\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int t = in.nextInt();\n    for (int i = 0; i < t; i++) {\n        int n = in.nextInt();"
      ]
    },
    "DETECT_CYCLE": {
      "loc": "18-19",
      "input": "public static boolean detect_cycle(Node node) {\n    Node hare = node;\n    Node tortoise = node;\n    while (true) {",
      "function range": "13,5-27,5",
      "output": [
        "public static boolean detect_cycle(Node node) {\n    Node hare = node;\n    Node tortoise = node;\n    while (true) {\n      tortoise = tortoise.next;\n      if (tortoise == null) {\n        return false;\n      }\n      hare = hare.next;\n      if (hare == null) {\n        return false;\n      }\n      if (tortoise == hare) {\n        return true;\n      }\n    }\n  }\n}\n",
        "public static boolean detect_cycle(Node node) {\n    Node hare = node;\n    Node tortoise = node;\n    while (true) {\n      if (tortoise == null) {\n        return false;\n      }\n      if (tortoise == hare) {\n        return true;\n      }\n      hare = hare.next;\n      tortoise = tortoise.next;\n      if (hare == null || tortoise == null) {\n        return false;\n      }\n      hare = hare.next;\n      tortoise = tortoise.next;\n    }\n  }\n}\n",
        "public static boolean detect_cycle(Node node) {\n    Node hare = node;\n    Node tortoise = node;\n    while (true) {\n      if (tortoise == null) {\n        return false;\n      }\n      if (tortoise == hare) {\n        return true;\n      }\n      hare = hare.next;\n      tortoise = tortoise.next;\n      if (hare == null || tortoise == null) {\n        return false;\n      }\n      hare = hare.next;\n      tortoise = tortoise.next;\n      if (hare == null || tortoise == null) {\n        return false;\n      }\n    }\n  ",
        "public static boolean detect_cycle(Node node) {\n    Node hare = node;\n    Node tortoise = node;\n    while (true) {\n      if (tortoise == null) {\n        return false;\n      }\n      if (tortoise == hare) {\n        return true;\n      }\n      hare = hare.next;\n      tortoise = tortoise.next;\n      if (hare == null) {\n        hare = hare.next;\n      }\n      if (tortoise == null) {\n        tortoise = tortoise.next;\n      }\n    }\n  }\n}\n",
        "public static boolean detect_cycle(Node node) {\n    Node hare = node;\n    Node tortoise = node;\n    while (true) {\n      if (tortoise == null) {\n        return false;\n      }\n      if (tortoise == hare) {\n        return true;\n      }\n      hare = hare.next;\n      tortoise = tortoise.next;\n      if (hare == null || tortoise == null) {\n        return false;\n      }\n      hare = hare.next;\n      tortoise = tortoise.next;\n      if (hare == null || tortoise == null) {\n        return false;\n      }\n      hare = ha",
        "public static boolean detect_cycle(Node node) {\n    Node hare = node;\n    Node tortoise = node;\n    while (true) {\n      if (tortoise == null) {\n        return false;\n      }\n      if (tortoise == hare) {\n        return true;\n      }\n      hare = hare.next;\n      tortoise = tortoise.next;\n      if (hare == null || tortoise == null) {\n        return false;\n      }\n      if (hare == tortoise) {\n        return true;\n      }\n      hare = hare.next;\n      tortoise = tortoise.next;\n    }\n  }\n\n  public",
        "public static boolean detect_cycle(Node node) {\n    Node hare = node;\n    Node tortoise = node;\n    while (true) {\n      if (tortoise == null || hare == null) {\n        return false;\n      }\n      if (tortoise == hare) {\n        return true;\n      }\n      hare = hare.next;\n      tortoise = tortoise.next;\n      if (hare == null || tortoise == null) {\n        return false;\n      }\n      if (hare == tortoise) {\n        return true;\n      }\n    }\n  }\n}\n",
        "public static boolean detect_cycle(Node node) {\n    Node hare = node;\n    Node tortoise = node;\n    while (true) {\n      if (tortoise == null) {\n        return false;\n      }\n      if (tortoise == hare) {\n        return true;\n      }\n      hare = hare.next;\n      tortoise = tortoise.next;\n      if (hare == null || tortoise == null) {\n        return false;\n      }\n      if (hare == tortoise) {\n        return true;\n      }\n      hare = hare.next;\n      tortoise = tortoise.next;\n    }\n  }\n}\n",
        "public static boolean detect_cycle(Node node) {\n    Node hare = node;\n    Node tortoise = node;\n    while (true) {\n      if (tortoise == null) {\n        return false;\n      }\n      if (tortoise == hare) {\n        return true;\n      }\n      hare = hare.next;\n      tortoise = tortoise.next;\n      if (hare == null || tortoise == null) {\n        return false;\n      }\n      if (hare == tortoise) {\n        return true;\n      }\n    }\n  }\n}\n",
        "public static boolean detect_cycle(Node node) {\n    Node hare = node;\n    Node tortoise = node;\n    while (true) {\n      if (tortoise == null) {\n        return false;\n      }\n      if (tortoise == hare) {\n        return true;\n      }\n      hare = hare.next;\n      tortoise = tortoise.next;\n      if (hare == null) {\n        hare = hare.next;\n      }\n      if (hare == null) {\n        hare = hare.next;\n      }\n      if (hare == null) {\n        return false;\n      }\n      if (hare == tortoise) {"
      ]
    },
    "FIND_FIRST_IN_SORTED": {
      "loc": "19-20",
      "input": "public static int find_first_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;",
      "function range": "15,5-32,5",
      "output": [
        "public static int find_first_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) {\n        int mid = lo + (hi - lo) / 2;\n        if (arr[mid] < x) {\n            lo = mid + 1;\n        } else {\n            hi = mid;\n        }\n    }\n    return lo;\n}\n\npublic static int find_last_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) {\n        int mid = lo + (hi - lo) /",
        "public static int find_first_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) {\n        int mid = (lo + hi) / 2;\n        if (arr[mid] < x) {\n            lo = mid + 1;\n        } else {\n            hi = mid;\n        }\n    }\n    return lo;\n}\n\npublic static int find_last_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) {\n        int mid = (lo + hi) / 2;\n        ",
        "public static int find_first_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) {\n      int mid = lo + (hi - lo) / 2;\n      if (arr[mid] < x) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n    return lo;\n  }\n\n  public static int find_last_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) {\n      int mid = lo + (hi - lo)",
        "public static int find_first_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) {\n      int mid = (lo + hi) / 2;\n      if (arr[mid] < x) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n    return lo;\n  }\n\n  public static int find_last_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) {\n      int mid = (lo + hi) / 2;\n",
        "public static int find_first_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) {\n        int mid = lo + (hi - lo) / 2;\n        if (arr[mid] < x) {\n            lo = mid + 1;\n        } else {\n            hi = mid;\n        }\n    }\n    return lo;\n}\n\npublic static int find_last_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length - 1;\n    while (lo < hi) {\n        int mid = lo + (hi - lo",
        "public static int find_first_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) {\n        int mid = (lo + hi) / 2;\n        if (arr[mid] < x) {\n            lo = mid + 1;\n        } else {\n            hi = mid;\n        }\n    }\n    return lo;\n}\n\npublic static int find_last_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length - 1;\n    while (lo < hi) {\n        int mid = (lo + hi) / 2;",
        "public static int find_first_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) {\n      int mid = lo + (hi - lo) / 2;\n      if (arr[mid] < x) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n    return lo;\n  }\n\n  public static int find_last_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length - 1;\n    while (lo < hi) {\n      int mid = lo + (hi -",
        "public static int find_first_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) {\n        int mid = lo + (hi - lo) / 2;\n        if (arr[mid] < x) {\n            lo = mid + 1;\n        } else {\n            hi = mid;\n        }\n    }\n    return lo;\n}\n",
        "public static int find_first_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) {\n        int mid = lo + (hi - lo) / 2;\n        if (arr[mid] < x) {\n            lo = mid + 1;\n        } else if (arr[mid] > x) {\n            hi = mid;\n        } else {\n            return mid;\n        }\n    }\n    return lo;\n}\n\npublic static int find_last_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while",
        "public static int find_first_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) {\n      int mid = lo + (hi - lo) / 2;\n      if (arr[mid] < x) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n    return lo;\n  }\n}\n"
      ]
    },
    "FIND_IN_SORTED": {
      "loc": "20-21",
      "input": "public static int binsearch(int[] arr, int x, int start, int end) {\n    if (start == end) {\n        return -1;\n    }\n    int mid = start + (end - start) / 2; \n    if (x < arr[mid]) {\n        return binsearch(arr, x, start, mid);\n    } else if (x > arr[mid]) {",
      "function range": "12,5-24,5",
      "output": [
        "public static int binsearch(int[] arr, int x, int start, int end) {\n    if (start == end) {\n        return -1;\n    }\n    int mid = start + (end - start) / 2; \n    if (x < arr[mid]) {\n        return binsearch(arr, x, start, mid);\n    } else if (x > arr[mid]) {\n        return binsearch(arr, x, mid + 1, end);\n    } else {\n        return mid;\n    }\n}\n",
        "public static int binsearch(int[] arr, int x, int start, int end) {\n    if (start == end) {\n        return -1;\n    }\n    int mid = start + (end - start) / 2; \n    if (x < arr[mid]) {\n        return binsearch(arr, x, start, mid);\n    } else if (x > arr[mid]) {\n        return binsearch(arr, x, mid + 1, end);\n    } else {\n        return mid;\n    }\n}\n}\n",
        "public static int binsearch(int[] arr, int x, int start, int end) {\n    if (start == end) {\n        return -1;\n    }\n    int mid = start + (end - start) / 2; \n    if (x < arr[mid]) {\n        return binsearch(arr, x, start, mid);\n    } else if (x > arr[mid]) {\n        return binsearch(arr, x, mid + 1, end);\n    } else {\n        return mid;\n    }\n}",
        "public static int binsearch(int[] arr, int x, int start, int end) {\n    if (start == end) {\n        return -1;\n    }\n    int mid = start + (end - start) / 2; \n    if (x < arr[mid]) {\n        return binsearch(arr, x, start, mid);\n    } else if (x > arr[mid]) {\n        return binsearch(arr, x, mid+1, end);\n    } else {\n        return mid;\n    }\n}\n",
        "public static int binsearch(int[] arr, int x, int start, int end) {\n    if (start == end) {\n        return -1;\n    }\n    int mid = start + (end - start) / 2; \n    if (x < arr[mid]) {\n        return binsearch(arr, x, start, mid);\n    } else if (x > arr[mid]) {\n        return binsearch(arr, x, mid, end);\n    } else {\n        return mid;\n    }\n}\n",
        "public static int binsearch(int[] arr, int x, int start, int end) {\n    if (start == end) {\n        return -1;\n    }\n    int mid = start + (end - start) / 2; \n    if (x < arr[mid]) {\n        return binsearch(arr, x, start, mid);\n    } else if (x > arr[mid]) {\n        return binsearch(arr, x, mid + 1, end);\n    }\n    return mid;\n}\n",
        "public static int binsearch(int[] arr, int x, int start, int end) {\n    if (start == end) {\n        return -1;\n    }\n    int mid = start + (end - start) / 2; \n    if (x < arr[mid]) {\n        return binsearch(arr, x, start, mid);\n    } else if (x > arr[mid]) {\n        return binsearch(arr, x, mid + 1, end);\n    } else {\n        return mid;\n    }\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    int[] arr = new int[n];\n    for (int i = 0; i < n; i++) {\n        arr[i] = in.nextInt();\n    }\n    int x = in.nextInt();\n    System.out.println(bin",
        "public static int binsearch(int[] arr, int x, int start, int end) {\n    if (start == end) {\n        return -1;\n    }\n    int mid = start + (end - start) / 2; \n    if (x < arr[mid]) {\n        return binsearch(arr, x, start, mid);\n    } else if (x > arr[mid]) {\n        return binsearch(arr, x, mid + 1, end);\n    } else {\n        return mid;\n    }\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    int[] arr = new int[n];\n    for (int i = 0; i < n; i++) {\n        arr[i] = in.nextInt();\n    }\n    int q = in.nextInt();\n    for (int i = 0;",
        "public static int binsearch(int[] arr, int x, int start, int end) {\n    if (start == end) {\n        return -1;\n    }\n    int mid = start + (end - start) / 2; \n    if (x < arr[mid]) {\n        return binsearch(arr, x, start, mid);\n    } else if (x > arr[mid]) {\n        return binsearch(arr, x, mid + 1, end);\n    } else {\n        return mid;\n    }\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    int[] arr = new int[n];\n    for (int i = 0; i < n; i++) {\n        arr[i] = in.nextInt();\n    }\n    System.out.println(binsearch(arr, in.nextInt(), 0",
        "public static int binsearch(int[] arr, int x, int start, int end) {\n    if (start == end) {\n        return -1;\n    }\n    int mid = start + (end - start) / 2; \n    if (x < arr[mid]) {\n        return binsearch(arr, x, start, mid);\n    } else if (x > arr[mid]) {\n        return binsearch(arr, x, mid + 1, end);\n    } else {\n        return mid;\n    }\n}\n\npublic static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    int n = scanner.nextInt();\n    int[] arr = new int[n];\n    for (int i = 0; i < n; i++) {\n        arr[i] = scanner.nextInt();\n    }\n    int x = scanner.nextInt();\n    System.out.println(bin"
      ]
    },
    "FLATTEN": {
      "loc": "22-28",
      "input": "public static Object flatten(Object arr) {\nif(arr instanceof ArrayList) {\n        ArrayList narr = (ArrayList) arr;\n ArrayList result = new ArrayList(50);\n for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {",
      "function range": "14,5-29,5",
      "output": [
        "public static Object flatten(Object arr) {\nif(arr instanceof ArrayList) {\n        ArrayList narr = (ArrayList) arr;\n ArrayList result = new ArrayList(50);\n for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else if (arr instanceof Object[]) {\n        Object[] narr = (Object[]) arr;\n        Object[] result = new Object[narr.length];\n        for (int i = 0; i < narr.length; i++) {\n            if (narr[i] instanceof ArrayList) {\n                result[i] = flatten(narr[i]);\n            } else {\n                result[i] = narr[i];\n            }\n        }",
        "public static Object flatten(Object arr) {\nif(arr instanceof ArrayList) {\n        ArrayList narr = (ArrayList) arr;\n ArrayList result = new ArrayList(50);\n for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else if (arr instanceof Object[]) {\n        Object[] narr = (Object[]) arr;\n ArrayList result = new ArrayList(50);\n for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else {\n        return arr;\n    }\n",
        "public static Object flatten(Object arr) {\nif(arr instanceof ArrayList) {\n        ArrayList narr = (ArrayList) arr;\n ArrayList result = new ArrayList(50);\n for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else if (arr instanceof Object[]) {\n        Object[] narr = (Object[]) arr;\n        ArrayList result = new ArrayList(50);\n        for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else {\n        return arr;\n    ",
        "public static Object flatten(Object arr) {\nif(arr instanceof ArrayList) {\n        ArrayList narr = (ArrayList) arr;\n ArrayList result = new ArrayList(50);\n for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else if(arr instanceof Object[]) {\n        Object[] narr = (Object[]) arr;\n ArrayList result = new ArrayList(50);\n for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else {\n        return arr;\n    }\n",
        "public static Object flatten(Object arr) {\nif(arr instanceof ArrayList) {\n        ArrayList narr = (ArrayList) arr;\n ArrayList result = new ArrayList(50);\n for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else if(arr instanceof Object[]) {\n        Object[] narr = (Object[]) arr;\n        ArrayList result = new ArrayList(50);\n        for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else {\n        return arr;\n    ",
        "public static Object flatten(Object arr) {\nif(arr instanceof ArrayList) {\n        ArrayList narr = (ArrayList) arr;\n ArrayList result = new ArrayList(50);\n for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else {\n        return arr;\n    }\n}\n}\n",
        "public static Object flatten(Object arr) {\nif(arr instanceof ArrayList) {\n        ArrayList narr = (ArrayList) arr;\n ArrayList result = new ArrayList(50);\n for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else {\n        return arr;\n    }\n}\n",
        "public static Object flatten(Object arr) {\nif(arr instanceof ArrayList) {\n        ArrayList narr = (ArrayList) arr;\n ArrayList result = new ArrayList(50);\n for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else {\n        return arr;\n    }\n}\n\n}\n",
        "public static Object flatten(Object arr) {\nif(arr instanceof ArrayList) {\n        ArrayList narr = (ArrayList) arr;\n ArrayList result = new ArrayList(50);\n for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else if (arr instanceof Object[]) {\n        Object[] narr = (Object[]) arr;\n ArrayList result = new ArrayList(50);\n for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else if (arr instanceof List) {\n        ",
        "public static Object flatten(Object arr) {\nif(arr instanceof ArrayList) {\n        ArrayList narr = (ArrayList) arr;\n ArrayList result = new ArrayList(50);\n for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else if (arr instanceof Object[]) {\n        Object[] narr = (Object[]) arr;\n ArrayList result = new ArrayList(50);\n for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(x);\n            }\n        }\n        return result;\n    } else if (arr instanceof Map) {\n        "
      ]
    },
    "GCD": {
      "loc": "19-20",
      "input": "public static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {",
      "function range": "15,5-21,5",
      "output": [
        "public static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static long gcd(long a, long b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static int lcm(int a, int b) {\n    return a * (b / gcd(a, b));\n}\n\npublic static long lcm(long a, long b) {\n    return a * (b / gcd(a,",
        "public static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static long gcd(long a, long b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static float gcd(float a, float b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static double gcd(double",
        "public static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static long gcd(long a, long b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static double gcd(double a, double b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static float gcd(float",
        "public static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n}\n",
        "public static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static long gcd(long a, long b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static int lcm(int a, int b) {\n    return (a * b) / gcd(a, b);\n}\n\npublic static long lcm(long a, long b) {\n    return (a * b) / gcd(",
        "public static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n",
        "public static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static long gcd(long a, long b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static double gcd(double a, double b) {\n    if (b == 0.0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static float gcd",
        "public static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static long gcd(long a, long b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static int lcm(int a, int b) {\n    return (a * (b / gcd(a, b)));\n}\n\npublic static long lcm(long a, long b) {\n    return (a * (b / gcd",
        "public static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static long gcd(long a, long b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static double gcd(double a, double b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static double lcm(double",
        "public static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static long gcd(long a, long b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static double gcd(double a, double b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\npublic static void main(String[]"
      ]
    },
    "GET_FACTORS": {
      "loc": "20-21",
      "input": "public static ArrayList<Integer> get_factors(int n) {\n    if (n == 1) {\n        return new ArrayList<Integer>();\n    }\n    int max = (int)(Math.sqrt(n) + 1.0);\n    for (int i=2; i < max; i++) {\n        if (n % i == 0) {\n            ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n            prepend.add(i);\n            prepend.addAll(get_factors(n / i));\n            return prepend;\n        }\n    }",
      "function range": "6,5-21,5",
      "output": [
        "public static ArrayList<Integer> get_factors(int n) {\n    if (n == 1) {\n        return new ArrayList<Integer>();\n    }\n    int max = (int)(Math.sqrt(n) + 1.0);\n    for (int i=2; i < max; i++) {\n        if (n % i == 0) {\n            ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n            prepend.add(i);\n            prepend.addAll(get_factors(n / i));\n            return prepend;\n        }\n    }\n    return new ArrayList<Integer>();\n}\n}\n",
        "public static ArrayList<Integer> get_factors(int n) {\n    if (n == 1) {\n        return new ArrayList<Integer>();\n    }\n    int max = (int)(Math.sqrt(n) + 1.0);\n    for (int i=2; i < max; i++) {\n        if (n % i == 0) {\n            ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n            prepend.add(i);\n            prepend.addAll(get_factors(n / i));\n            return prepend;\n        }\n    }\n    return new ArrayList<Integer>();\n}\n",
        "public static ArrayList<Integer> get_factors(int n) {\n    if (n == 1) {\n        return new ArrayList<Integer>();\n    }\n    int max = (int)(Math.sqrt(n) + 1.0);\n    for (int i=2; i < max; i++) {\n        if (n % i == 0) {\n            ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n            prepend.add(i);\n            prepend.addAll(get_factors(n / i));\n            return prepend;\n        }\n    }\n    ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n    prepend.add(n);\n    return prepend;\n}\n}\n",
        "public static ArrayList<Integer> get_factors(int n) {\n    if (n == 1) {\n        return new ArrayList<Integer>();\n    }\n    int max = (int)(Math.sqrt(n) + 1.0);\n    for (int i=2; i < max; i++) {\n        if (n % i == 0) {\n            ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n            prepend.add(i);\n            prepend.addAll(get_factors(n / i));\n            return prepend;\n        }\n    }\n    return new ArrayList<Integer>();\n}",
        "public static ArrayList<Integer> get_factors(int n) {\n    if (n == 1) {\n        return new ArrayList<Integer>();\n    }\n    int max = (int)(Math.sqrt(n) + 1.0);\n    for (int i=2; i < max; i++) {\n        if (n % i == 0) {\n            ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n            prepend.add(i);\n            prepend.addAll(get_factors(n / i));\n            return prepend;\n        }\n    }\n    ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n    prepend.add(n);\n    return prepend;\n}",
        "public static ArrayList<Integer> get_factors(int n) {\n    if (n == 1) {\n        return new ArrayList<Integer>();\n    }\n    int max = (int)(Math.sqrt(n) + 1.0);\n    for (int i=2; i < max; i++) {\n        if (n % i == 0) {\n            ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n            prepend.add(i);\n            prepend.addAll(get_factors(n / i));\n            return prepend;\n        }\n    }\n    ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n    prepend.add(n);\n    return prepend;\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    System.out.println(get_factors(n));\n}\n}\n",
        "public static ArrayList<Integer> get_factors(int n) {\n    if (n == 1) {\n        return new ArrayList<Integer>();\n    }\n    int max = (int)(Math.sqrt(n) + 1.0);\n    for (int i=2; i < max; i++) {\n        if (n % i == 0) {\n            ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n            prepend.add(i);\n            prepend.addAll(get_factors(n / i));\n            return prepend;\n        }\n    }\n    ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n    prepend.add(n);\n    return prepend;\n}\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    System.out.println(get_factors(n));\n}\n}\n",
        "public static ArrayList<Integer> get_factors(int n) {\n    if (n == 1) {\n        return new ArrayList<Integer>();\n    }\n    int max = (int)(Math.sqrt(n) + 1.0);\n    for (int i=2; i < max; i++) {\n        if (n % i == 0) {\n            ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n            prepend.add(i);\n            prepend.addAll(get_factors(n / i));\n            return prepend;\n        }\n    }\n    ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n    prepend.add(n);\n    return prepend;\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    ArrayList<Integer> factors = get_factors(n);\n    System.out.println(factors);\n}\n}\n",
        "public static ArrayList<Integer> get_factors(int n) {\n    if (n == 1) {\n        return new ArrayList<Integer>();\n    }\n    int max = (int)(Math.sqrt(n) + 1.0);\n    for (int i=2; i < max; i++) {\n        if (n % i == 0) {\n            ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n            prepend.add(i);\n            prepend.addAll(get_factors(n / i));\n            return prepend;\n        }\n    }\n    ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n    prepend.add(n);\n    return prepend;\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    ArrayList<Integer> factors = get_factors(n);\n    for (int i=0; i < factors.size(); i++) {\n        System.out.println(factors.get(i));\n    }\n}\n",
        "public static ArrayList<Integer> get_factors(int n) {\n    if (n == 1) {\n        return new ArrayList<Integer>();\n    }\n    int max = (int)(Math.sqrt(n) + 1.0);\n    for (int i=2; i < max; i++) {\n        if (n % i == 0) {\n            ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n            prepend.add(i);\n            prepend.addAll(get_factors(n / i));\n            return prepend;\n        }\n    }\n    ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n    prepend.add(n);\n    return prepend;\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    ArrayList<Integer> factors = get_factors(n);\n    System.out.println(factors.size());\n}\n}\n"
      ]
    },
    "HANOI": {
      "loc": "29-30",
      "input": "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n    ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n    if (height > 0) {\n        PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n        crap_set.add(1);\n        crap_set.add(2);\n        crap_set.add(3);\n        crap_set.remove(start);\n        crap_set.remove(end);\n        int helper = crap_set.poll();\n        steps.addAll(hanoi(height-1, start, helper));",
      "function range": "17,5-34,5",
      "output": [
        "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n    ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n    if (height > 0) {\n        PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n        crap_set.add(1);\n        crap_set.add(2);\n        crap_set.add(3);\n        crap_set.remove(start);\n        crap_set.remove(end);\n        int helper = crap_set.poll();\n        steps.addAll(hanoi(height-1, start, helper));\n        steps.addAll(hanoi(height-1, helper, end));\n    }\n    return steps;\n}\n}\n",
        "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n    ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n    if (height > 0) {\n        PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n        crap_set.add(1);\n        crap_set.add(2);\n        crap_set.add(3);\n        crap_set.remove(start);\n        crap_set.remove(end);\n        int helper = crap_set.poll();\n        steps.addAll(hanoi(height-1, start, helper));\n        steps.addAll(hanoi(height-1, helper, end));\n    }\n    return steps;\n  }\n}\n",
        "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n    ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n    if (height > 0) {\n        PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n        crap_set.add(1);\n        crap_set.add(2);\n        crap_set.add(3);\n        crap_set.remove(start);\n        crap_set.remove(end);\n        int helper = crap_set.poll();\n        steps.addAll(hanoi(height-1, start, helper));\n        steps.add(new Pair<Integer,Integer>(start, helper));\n        steps.addAll(hanoi(height-1, helper, end));\n    }\n    return steps;\n}\n}\n",
        "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n    ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n    if (height > 0) {\n        PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n        crap_set.add(1);\n        crap_set.add(2);\n        crap_set.add(3);\n        crap_set.remove(start);\n        crap_set.remove(end);\n        int helper = crap_set.poll();\n        steps.addAll(hanoi(height-1, start, helper));\n        steps.add(new Pair<Integer,Integer>(helper, end));\n        steps.addAll(hanoi(height-1, helper, end));\n    }\n    return steps;\n}\n}\n",
        "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n    ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n    if (height > 0) {\n        PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n        crap_set.add(1);\n        crap_set.add(2);\n        crap_set.add(3);\n        crap_set.remove(start);\n        crap_set.remove(end);\n        int helper = crap_set.poll();\n        steps.addAll(hanoi(height-1, start, helper));\n        steps.add(new Pair<Integer,Integer>(helper, start));\n        steps.addAll(hanoi(height-1, helper, end));\n    }\n    return steps;\n}\n}\n",
        "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n    ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n    if (height > 0) {\n        PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n        crap_set.add(1);\n        crap_set.add(2);\n        crap_set.add(3);\n        crap_set.remove(start);\n        crap_set.remove(end);\n        int helper = crap_set.poll();\n        steps.addAll(hanoi(height-1, start, helper));\n        steps.add(new Pair<Integer,Integer>(helper, end));\n        steps.addAll(hanoi(height-1, helper, end));\n    }\n    return steps;\n}\n\npublic static void main(String[] args) {\n    List<Pair<Integer,Integer>> steps = hanoi(3, 1, 3);\n    for (Pair<Integer,Integer> step : steps) {\n        System.out.println(step);\n    }\n}\n",
        "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n    ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n    if (height > 0) {\n        PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n        crap_set.add(1);\n        crap_set.add(2);\n        crap_set.add(3);\n        crap_set.remove(start);\n        crap_set.remove(end);\n        int helper = crap_set.poll();\n        steps.addAll(hanoi(height-1, start, helper));\n        steps.add(new Pair<Integer,Integer>(start, helper));\n        steps.addAll(hanoi(height-1, helper, end));\n    }\n    return steps;\n}\n\npublic static void main(String[] args) {\n    List<Pair<Integer,Integer>> steps = hanoi(3, 1, 3);\n    for (Pair<Integer,Integer> step : steps) {\n        System.out.println(step.first + \" \" + step.second);\n    }\n}\n",
        "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n    ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n    if (height > 0) {\n        PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n        crap_set.add(1);\n        crap_set.add(2);\n        crap_set.add(3);\n        crap_set.remove(start);\n        crap_set.remove(end);\n        int helper = crap_set.poll();\n        steps.addAll(hanoi(height-1, start, helper));\n        steps.add(new Pair<Integer,Integer>(helper, end));\n        steps.addAll(hanoi(height-1, helper, end));\n    }\n    return steps;\n}\n\npublic static void main(String[] args) {\n    List<Pair<Integer,Integer>> steps = hanoi(3, 1, 3);\n    for (Pair<Integer,Integer> step : steps) {\n        System.out.println(step.first + \" \" + step.second);\n    }\n}\n",
        "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n    ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n    if (height > 0) {\n        PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n        crap_set.add(1);\n        crap_set.add(2);\n        crap_set.add(3);\n        crap_set.remove(start);\n        crap_set.remove(end);\n        int helper = crap_set.poll();\n        steps.addAll(hanoi(height-1, start, helper));\n        steps.add(new Pair<Integer,Integer>(helper, end));\n        steps.addAll(hanoi(height-1, helper, end));\n    }\n    return steps;\n}\n\npublic static void main(String[] args) {\n    List<Pair<Integer,Integer>> steps = hanoi(3, 1, 2);\n    for (Pair<Integer,Integer> step : steps) {\n        System.out.println(step.first + \" \" + step.second);\n    }\n}\n",
        "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n    ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n    if (height > 0) {\n        PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n        crap_set.add(1);\n        crap_set.add(2);\n        crap_set.add(3);\n        crap_set.remove(start);\n        crap_set.remove(end);\n        int helper = crap_set.poll();\n        steps.addAll(hanoi(height-1, start, helper));\n        steps.add(new Pair<Integer,Integer>(helper, end));\n        steps.addAll(hanoi(height-1, helper, end));\n    }\n    return steps;\n}\n\npublic static void main(String[] args) {\n    List<Pair<Integer,Integer>> steps = hanoi(3, 1, 3);\n    for (Pair<Integer,Integer> step : steps) {\n        System.out.println(step);\n    }\n}\n}\n"
      ]
    },
    "IS_VALID_PARENTHESIZATION": {
      "loc": "17-18",
      "input": "public static Boolean is_valid_parenthesization(String parens) {\n    int depth = 0;\nfor (int i = 0; i < parens.length(); i++) {\n Character paren = parens.charAt(i);\n if (paren.equals('(')) {\n            depth++;\n } else {\ndepth--;\nif (depth < 0) { return false; }\n }\n}",
      "function range": "6,5-18,5",
      "output": [
        "public static Boolean is_valid_parenthesization(String parens) {\n    int depth = 0;\nfor (int i = 0; i < parens.length(); i++) {\n Character paren = parens.charAt(i);\n if (paren.equals('(')) {\n            depth++;\n } else {\ndepth--;\nif (depth < 0) { return false; }\n }\n}\nreturn (depth == 0);\n}\n}\n",
        "public static Boolean is_valid_parenthesization(String parens) {\n    int depth = 0;\nfor (int i = 0; i < parens.length(); i++) {\n Character paren = parens.charAt(i);\n if (paren.equals('(')) {\n            depth++;\n } else {\ndepth--;\nif (depth < 0) { return false; }\n }\n}\nreturn depth == 0;\n}\n}\n",
        "public static Boolean is_valid_parenthesization(String parens) {\n    int depth = 0;\nfor (int i = 0; i < parens.length(); i++) {\n Character paren = parens.charAt(i);\n if (paren.equals('(')) {\n            depth++;\n } else {\ndepth--;\nif (depth < 0) { return false; }\n }\n}\nreturn true;\n}\n}\n",
        "public static Boolean is_valid_parenthesization(String parens) {\n    int depth = 0;\nfor (int i = 0; i < parens.length(); i++) {\n Character paren = parens.charAt(i);\n if (paren.equals('(')) {\n            depth++;\n } else {\ndepth--;\nif (depth < 0) { return false; }\n }\n}\nreturn (depth == 0);\n}\n\n}\n",
        "public static Boolean is_valid_parenthesization(String parens) {\n    int depth = 0;\nfor (int i = 0; i < parens.length(); i++) {\n Character paren = parens.charAt(i);\n if (paren.equals('(')) {\n            depth++;\n } else {\ndepth--;\nif (depth < 0) { return false; }\n }\n}\nif (depth!= 0) { return false; }\nreturn true;\n}\n}\n",
        "public static Boolean is_valid_parenthesization(String parens) {\n    int depth = 0;\nfor (int i = 0; i < parens.length(); i++) {\n Character paren = parens.charAt(i);\n if (paren.equals('(')) {\n            depth++;\n } else {\ndepth--;\nif (depth < 0) { return false; }\n }\n}\n    return (depth == 0);\n}\n}\n",
        "public static Boolean is_valid_parenthesization(String parens) {\n    int depth = 0;\nfor (int i = 0; i < parens.length(); i++) {\n Character paren = parens.charAt(i);\n if (paren.equals('(')) {\n            depth++;\n } else {\ndepth--;\nif (depth < 0) { return false; }\n }\n}\nif (depth!= 0) { return false; }\nreturn true;\n}\n\n}\n",
        "public static Boolean is_valid_parenthesization(String parens) {\n    int depth = 0;\nfor (int i = 0; i < parens.length(); i++) {\n Character paren = parens.charAt(i);\n if (paren.equals('(')) {\n            depth++;\n } else {\ndepth--;\nif (depth < 0) { return false; }\n }\n}\nif (depth!= 0) { return false; }\nreturn true;\n}\n}",
        "public static Boolean is_valid_parenthesization(String parens) {\n    int depth = 0;\nfor (int i = 0; i < parens.length(); i++) {\n Character paren = parens.charAt(i);\n if (paren.equals('(')) {\n            depth++;\n } else {\ndepth--;\nif (depth < 0) { return false; }\n }\n}\nif (depth!= 0) { return false; }\nelse { return true; }\n}\n}\n",
        "public static Boolean is_valid_parenthesization(String parens) {\n    int depth = 0;\nfor (int i = 0; i < parens.length(); i++) {\n Character paren = parens.charAt(i);\n if (paren.equals('(')) {\n            depth++;\n } else {\ndepth--;\nif (depth < 0) { return false; }\n }\n}\nif (depth!= 0) { return false; }\nelse { return true; }\n}\n\n}\n"
      ]
    },
    "KHEAPSORT": {
      "loc": "28-29",
      "input": "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n    PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n    for (Integer v : arr.subList(0,k)) {\n        heap.add(v);\n    }\n    ArrayList<Integer> output = new ArrayList<Integer>();",
      "function range": "21,5-40,5",
      "output": [
        "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n    PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n    for (Integer v : arr.subList(0,k)) {\n        heap.add(v);\n    }\n    ArrayList<Integer> output = new ArrayList<Integer>();\n    while (!heap.isEmpty()) {\n        output.add(heap.remove());\n    }\n    return output;\n}\n}\n",
        "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n    PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n    for (Integer v : arr.subList(0,k)) {\n        heap.add(v);\n    }\n    ArrayList<Integer> output = new ArrayList<Integer>();\n    while (!heap.isEmpty()) {\n        output.add(heap.remove());\n    }\n    return output;\n}\n",
        "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n    PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n    for (Integer v : arr.subList(0,k)) {\n        heap.add(v);\n    }\n    ArrayList<Integer> output = new ArrayList<Integer>();\n    while (!heap.isEmpty()) {\n        output.add(heap.poll());\n    }\n    return output;\n}\n}\n",
        "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n    PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n    for (Integer v : arr.subList(0,k)) {\n        heap.add(v);\n    }\n    ArrayList<Integer> output = new ArrayList<Integer>();\n    while (heap.size() > 0) {\n        output.add(heap.remove());\n    }\n    return output;\n}\n}\n",
        "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n    PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n    for (Integer v : arr.subList(0,k)) {\n        heap.add(v);\n    }\n    ArrayList<Integer> output = new ArrayList<Integer>();\n    while(!heap.isEmpty()) {\n        output.add(heap.remove());\n    }\n    return output;\n}\n}\n",
        "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n    PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n    for (Integer v : arr.subList(0,k)) {\n        heap.add(v);\n    }\n    ArrayList<Integer> output = new ArrayList<Integer>();\n    while (!heap.isEmpty()) {\n        output.add(heap.remove());\n    }\n    return output;\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    ArrayList<Integer> arr = new ArrayList<Integer>();\n    for (int i = 0; i < n; i++) {\n        arr.add(in.nextInt());\n    }\n    System.out.println(kheapsort(arr",
        "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n    PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n    for (Integer v : arr.subList(0,k)) {\n        heap.add(v);\n    }\n    ArrayList<Integer> output = new ArrayList<Integer>();\n    while (!heap.isEmpty()) {\n        output.add(heap.remove());\n    }\n    return output;\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    ArrayList<Integer> arr = new ArrayList<Integer>();\n    for (int i = 0; i < n; i++) {\n        arr.add(in.nextInt());\n    }\n    int k = in.nextInt();\n    ArrayList",
        "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n    PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n    for (Integer v : arr.subList(0,k)) {\n        heap.add(v);\n    }\n    ArrayList<Integer> output = new ArrayList<Integer>();\n    while (!heap.isEmpty()) {\n        output.add(heap.remove());\n    }\n    return output;\n}\n\npublic static void main(String[] args) {\n    ArrayList<Integer> arr = new ArrayList<Integer>();\n    arr.add(1);\n    arr.add(2);\n    arr.add(3);\n    arr.add(4);\n    arr.add(5);\n    arr.add(6);\n    arr.add(7);\n    arr.add(8);\n    arr.",
        "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n    PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n    for (Integer v : arr.subList(0,k)) {\n        heap.add(v);\n    }\n    ArrayList<Integer> output = new ArrayList<Integer>();\n    while (!heap.isEmpty()) {\n        output.add(heap.remove());\n    }\n    return output;\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    ArrayList<Integer> arr = new ArrayList<Integer>();\n    for (int i = 0; i < n; i++) {\n        arr.add(in.nextInt());\n    }\n    int k = in.nextInt();\n    System.",
        "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n    PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n    for (Integer v : arr.subList(0,k)) {\n        heap.add(v);\n    }\n    ArrayList<Integer> output = new ArrayList<Integer>();\n    while (!heap.isEmpty()) {\n        output.add(heap.remove());\n    }\n    return output;\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    int k = in.nextInt();\n    ArrayList<Integer> arr = new ArrayList<Integer>();\n    for (int i = 0; i < n; i++) {\n        arr.add(in.nextInt());\n    }\n    ArrayList"
      ]
    },
    "KNAPSACK": {
      "loc": "30-31",
      "input": "public static int knapsack(int capacity, int [][] items) {\n    int weight = 0, value = 0;\n    int n = items.length;\n    int memo[][] = new int[n + 1][capacity + 1];\n    for (int i = 0; i <= n ; i++)\n    {\n        if (i - 1 >= 0) {\n            weight = items[i - 1][0];\n            value = items[i - 1][1];\n        }\n        for (int j = 0; j <= capacity; j++)\n        {\n            if (i == 0 || j == 0) {\n                memo[i][j] = 0;\n            }",
      "function range": "14,5-40,5",
      "output": [
        "public static int knapsack(int capacity, int [][] items) {\n    int weight = 0, value = 0;\n    int n = items.length;\n    int memo[][] = new int[n + 1][capacity + 1];\n    for (int i = 0; i <= n ; i++)\n    {\n        if (i - 1 >= 0) {\n            weight = items[i - 1][0];\n            value = items[i - 1][1];\n        }\n        for (int j = 0; j <= capacity; j++)\n        {\n            if (i == 0 || j == 0) {\n                memo[i][j] = 0;\n            } else if (weight <= j) {\n                memo[i][j] = Math.max(memo[i - 1][j], memo[i - 1][j - weight] + value);\n            } else {\n                memo[i][j] = memo[i - 1][j];\n            }\n        }\n    }\n    return memo[n][capacity];\n}\n",
        "public static int knapsack(int capacity, int [][] items) {\n    int weight = 0, value = 0;\n    int n = items.length;\n    int memo[][] = new int[n + 1][capacity + 1];\n    for (int i = 0; i <= n ; i++)\n    {\n        if (i - 1 >= 0) {\n            weight = items[i - 1][0];\n            value = items[i - 1][1];\n        }\n        for (int j = 0; j <= capacity; j++)\n        {\n            if (i == 0 || j == 0) {\n                memo[i][j] = 0;\n            } else if (weight <= j) {\n                memo[i][j] = Math.max(memo[i - 1][j], memo[i - 1][j - weight] + value);\n            } else {\n                memo[i][j] = memo[i - 1][j];\n            }\n        }\n    }\n    return memo[n][capacity];\n}\n}\n",
        "public static int knapsack(int capacity, int [][] items) {\n    int weight = 0, value = 0;\n    int n = items.length;\n    int memo[][] = new int[n + 1][capacity + 1];\n    for (int i = 0; i <= n ; i++)\n    {\n        if (i - 1 >= 0) {\n            weight = items[i - 1][0];\n            value = items[i - 1][1];\n        }\n        for (int j = 0; j <= capacity; j++)\n        {\n            if (i == 0 || j == 0) {\n                memo[i][j] = 0;\n            }\n            else if (weight <= j) {\n                memo[i][j] = Math.max(memo[i - 1][j], memo[i - 1][j - weight] + value);\n            }\n            else {\n                memo[i][j] = memo[i - 1][j];\n            }\n        }\n    }\n    return memo[n][capacity];\n}\n",
        "public static int knapsack(int capacity, int [][] items) {\n    int weight = 0, value = 0;\n    int n = items.length;\n    int memo[][] = new int[n + 1][capacity + 1];\n    for (int i = 0; i <= n ; i++)\n    {\n        if (i - 1 >= 0) {\n            weight = items[i - 1][0];\n            value = items[i - 1][1];\n        }\n        for (int j = 0; j <= capacity; j++)\n        {\n            if (i == 0 || j == 0) {\n                memo[i][j] = 0;\n            } else {\n                memo[i][j] = Math.max(memo[i - 1][j], memo[i - 1][j - weight]);\n            }\n        }\n    }\n    return memo[n][capacity];\n}\n}\n",
        "public static int knapsack(int capacity, int [][] items) {\n    int weight = 0, value = 0;\n    int n = items.length;\n    int memo[][] = new int[n + 1][capacity + 1];\n    for (int i = 0; i <= n ; i++)\n    {\n        if (i - 1 >= 0) {\n            weight = items[i - 1][0];\n            value = items[i - 1][1];\n        }\n        for (int j = 0; j <= capacity; j++)\n        {\n            if (i == 0 || j == 0) {\n                memo[i][j] = 0;\n            } else if (weight <= j) {\n                memo[i][j] = Math.max(memo[i - 1][j], memo[i - 1][j - weight] + value);\n            } else {\n                memo[i][j] = memo[i - 1][j];\n            }\n        }\n    }\n    return memo[n][capacity];\n}",
        "public static int knapsack(int capacity, int [][] items) {\n    int weight = 0, value = 0;\n    int n = items.length;\n    int memo[][] = new int[n + 1][capacity + 1];\n    for (int i = 0; i <= n ; i++)\n    {\n        if (i - 1 >= 0) {\n            weight = items[i - 1][0];\n            value = items[i - 1][1];\n        }\n        for (int j = 0; j <= capacity; j++)\n        {\n            if (i == 0 || j == 0) {\n                memo[i][j] = 0;\n            } else if (weight > j) {\n                memo[i][j] = memo[i - 1][j];\n            } else {\n                memo[i][j] = Math.max(memo[i - 1][j], memo[i - 1][j - weight] + value);\n            }\n        }\n    }\n    return memo[n][capacity];\n}\n}\n",
        "public static int knapsack(int capacity, int [][] items) {\n    int weight = 0, value = 0;\n    int n = items.length;\n    int memo[][] = new int[n + 1][capacity + 1];\n    for (int i = 0; i <= n ; i++)\n    {\n        if (i - 1 >= 0) {\n            weight = items[i - 1][0];\n            value = items[i - 1][1];\n        }\n        for (int j = 0; j <= capacity; j++)\n        {\n            if (i == 0 || j == 0) {\n                memo[i][j] = 0;\n            } else if (weight <= j) {\n                memo[i][j] = Math.max(memo[i - 1][j], memo[i - 1][j - weight] + value);\n            } else {\n                memo[i][j] = memo[i - 1][j];\n            }\n        }\n    }\n    return memo[n][capacity];\n  }\n}\n",
        "public static int knapsack(int capacity, int [][] items) {\n    int weight = 0, value = 0;\n    int n = items.length;\n    int memo[][] = new int[n + 1][capacity + 1];\n    for (int i = 0; i <= n ; i++)\n    {\n        if (i - 1 >= 0) {\n            weight = items[i - 1][0];\n            value = items[i - 1][1];\n        }\n        for (int j = 0; j <= capacity; j++)\n        {\n            if (i == 0 || j == 0) {\n                memo[i][j] = 0;\n            } else if (weight <= j) {\n                memo[i][j] = Math.max(memo[i - 1][j], memo[i - 1][j - weight]);\n            } else {\n                memo[i][j] = memo[i - 1][j];\n            }\n        }\n    }\n    return memo[n][capacity];\n}\n",
        "public static int knapsack(int capacity, int [][] items) {\n    int weight = 0, value = 0;\n    int n = items.length;\n    int memo[][] = new int[n + 1][capacity + 1];\n    for (int i = 0; i <= n ; i++)\n    {\n        if (i - 1 >= 0) {\n            weight = items[i - 1][0];\n            value = items[i - 1][1];\n        }\n        for (int j = 0; j <= capacity; j++)\n        {\n            if (i == 0 || j == 0) {\n                memo[i][j] = 0;\n            }\n            else if (weight <= j) {\n                memo[i][j] = Math.max(memo[i - 1][j], memo[i - 1][j - weight] + value);\n            }\n            else {\n                memo[i][j] = memo[i - 1][j];\n            }\n        }\n    }\n    return memo[n][capacity];\n}",
        "public static int knapsack(int capacity, int [][] items) {\n    int weight = 0, value = 0;\n    int n = items.length;\n    int memo[][] = new int[n + 1][capacity + 1];\n    for (int i = 0; i <= n ; i++)\n    {\n        if (i - 1 >= 0) {\n            weight = items[i - 1][0];\n            value = items[i - 1][1];\n        }\n        for (int j = 0; j <= capacity; j++)\n        {\n            if (i == 0 || j == 0) {\n                memo[i][j] = 0;\n            } else if (items[i - 1][0] <= j) {\n                memo[i][j] = Math.max(memo[i - 1][j], memo[i - 1][j - items[i - 1][0]] + value);\n            }\n        }\n    }\n    return memo[n][capacity];\n}\n"
      ]
    },
    "KTH": {
      "loc": "26-27",
      "input": "public static Integer kth(ArrayList<Integer> arr, int k) {\n    int pivot = arr.get(0);\n    ArrayList<Integer> below, above;\n    below = new ArrayList<Integer>(arr.size());\n    above = new ArrayList<Integer>(arr.size());\n    for (Integer x : arr) {\n        if (x < pivot) {\n            below.add(x);\n        } else if (x > pivot) {\n            above.add(x);\n        }\n    }\n    int num_less = below.size();\n    int num_lessoreq = arr.size() - above.size();\n    if (k < num_less) {\n        return kth(below, k);\n    } else if (k >= num_lessoreq) {",
      "function range": "8,5-30,5",
      "output": [
        "public static Integer kth(ArrayList<Integer> arr, int k) {\n    int pivot = arr.get(0);\n    ArrayList<Integer> below, above;\n    below = new ArrayList<Integer>(arr.size());\n    above = new ArrayList<Integer>(arr.size());\n    for (Integer x : arr) {\n        if (x < pivot) {\n            below.add(x);\n        } else if (x > pivot) {\n            above.add(x);\n        }\n    }\n    int num_less = below.size();\n    int num_lessoreq = arr.size() - above.size();\n    if (k < num_less) {\n        return kth(below, k);\n    } else if (k >= num_lessoreq) {\n        return kth(above, k - num_lessoreq);\n    } else {\n        return pivot;\n    }\n}\n",
        "public static Integer kth(ArrayList<Integer> arr, int k) {\n    int pivot = arr.get(0);\n    ArrayList<Integer> below, above;\n    below = new ArrayList<Integer>(arr.size());\n    above = new ArrayList<Integer>(arr.size());\n    for (Integer x : arr) {\n        if (x < pivot) {\n            below.add(x);\n        } else if (x > pivot) {\n            above.add(x);\n        }\n    }\n    int num_less = below.size();\n    int num_lessoreq = arr.size() - above.size();\n    if (k < num_less) {\n        return kth(below, k);\n    } else if (k >= num_lessoreq) {\n        return kth(above, k - num_lessoreq);\n    } else {\n        return pivot;\n    }\n}\n}\n",
        "public static Integer kth(ArrayList<Integer> arr, int k) {\n    int pivot = arr.get(0);\n    ArrayList<Integer> below, above;\n    below = new ArrayList<Integer>(arr.size());\n    above = new ArrayList<Integer>(arr.size());\n    for (Integer x : arr) {\n        if (x < pivot) {\n            below.add(x);\n        } else if (x > pivot) {\n            above.add(x);\n        }\n    }\n    int num_less = below.size();\n    int num_lessoreq = arr.size() - above.size();\n    if (k < num_less) {\n        return kth(below, k);\n    } else if (k >= num_lessoreq) {\n        return kth(above, k - num_less);\n    } else {\n        return pivot;\n    }\n}\n",
        "public static Integer kth(ArrayList<Integer> arr, int k) {\n    int pivot = arr.get(0);\n    ArrayList<Integer> below, above;\n    below = new ArrayList<Integer>(arr.size());\n    above = new ArrayList<Integer>(arr.size());\n    for (Integer x : arr) {\n        if (x < pivot) {\n            below.add(x);\n        } else if (x > pivot) {\n            above.add(x);\n        }\n    }\n    int num_less = below.size();\n    int num_lessoreq = arr.size() - above.size();\n    if (k < num_less) {\n        return kth(below, k);\n    } else if (k >= num_lessoreq) {\n        return kth(above, k - num_less);\n    } else {\n        return pivot;\n    }\n}\n}\n",
        "public static Integer kth(ArrayList<Integer> arr, int k) {\n    int pivot = arr.get(0);\n    ArrayList<Integer> below, above;\n    below = new ArrayList<Integer>(arr.size());\n    above = new ArrayList<Integer>(arr.size());\n    for (Integer x : arr) {\n        if (x < pivot) {\n            below.add(x);\n        } else if (x > pivot) {\n            above.add(x);\n        }\n    }\n    int num_less = below.size();\n    int num_lessoreq = arr.size() - above.size();\n    if (k < num_less) {\n        return kth(below, k);\n    } else if (k >= num_lessoreq) {\n        return kth(above, k - num_lessoreq);\n    } else {\n        return pivot;\n    }\n}",
        "public static Integer kth(ArrayList<Integer> arr, int k) {\n    int pivot = arr.get(0);\n    ArrayList<Integer> below, above;\n    below = new ArrayList<Integer>(arr.size());\n    above = new ArrayList<Integer>(arr.size());\n    for (Integer x : arr) {\n        if (x < pivot) {\n            below.add(x);\n        } else if (x > pivot) {\n            above.add(x);\n        }\n    }\n    int num_less = below.size();\n    int num_lessoreq = arr.size() - above.size();\n    if (k < num_less) {\n        return kth(below, k);\n    } else if (k >= num_lessoreq) {\n        return kth(above, k - num_lessoreq);\n    } else {\n        return pivot;\n    }\n}\n\n}\n",
        "public static Integer kth(ArrayList<Integer> arr, int k) {\n    int pivot = arr.get(0);\n    ArrayList<Integer> below, above;\n    below = new ArrayList<Integer>(arr.size());\n    above = new ArrayList<Integer>(arr.size());\n    for (Integer x : arr) {\n        if (x < pivot) {\n            below.add(x);\n        } else if (x > pivot) {\n            above.add(x);\n        }\n    }\n    int num_less = below.size();\n    int num_lessoreq = arr.size() - above.size();\n    if (k < num_less) {\n        return kth(below, k);\n    } else if (k >= num_lessoreq) {\n        return kth(above, k - num_lessoreq);\n    } else {\n        return pivot;\n    }\n}\n\npublic static void main(String[] args) {\n    ArrayList<Integer> arr = new ArrayList<Integer>();\n    arr.add(1);\n    arr.add(2);\n    arr.add(3);\n    arr.add(4);\n    arr.add(5);\n    arr.add(6);\n    arr.add(7);\n    arr.add(8);\n    arr.add",
        "public static Integer kth(ArrayList<Integer> arr, int k) {\n    int pivot = arr.get(0);\n    ArrayList<Integer> below, above;\n    below = new ArrayList<Integer>(arr.size());\n    above = new ArrayList<Integer>(arr.size());\n    for (Integer x : arr) {\n        if (x < pivot) {\n            below.add(x);\n        } else if (x > pivot) {\n            above.add(x);\n        }\n    }\n    int num_less = below.size();\n    int num_lessoreq = arr.size() - above.size();\n    if (k < num_less) {\n        return kth(below, k);\n    } else if (k >= num_lessoreq) {\n        return kth(above, k - num_lessoreq);\n    } else {\n        return pivot;\n    }\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    ArrayList<Integer> arr = new ArrayList<Integer>(n);\n    for (int i = 0; i < n; i++) {\n        arr.add(in.nextInt());\n    }\n    int k = in.nextInt();\n    System.",
        "public static Integer kth(ArrayList<Integer> arr, int k) {\n    int pivot = arr.get(0);\n    ArrayList<Integer> below, above;\n    below = new ArrayList<Integer>(arr.size());\n    above = new ArrayList<Integer>(arr.size());\n    for (Integer x : arr) {\n        if (x < pivot) {\n            below.add(x);\n        } else if (x > pivot) {\n            above.add(x);\n        }\n    }\n    int num_less = below.size();\n    int num_lessoreq = arr.size() - above.size();\n    if (k < num_less) {\n        return kth(below, k);\n    } else if (k >= num_lessoreq) {\n        return kth(above, k - num_lessoreq);\n    } else {\n        return pivot;\n    }\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    ArrayList<Integer> arr = new ArrayList<Integer>(n);\n    for (int i = 0; i < n; i++) {\n        arr.add(in.nextInt());\n    }\n    System.out.println(kth(arr, in",
        "public static Integer kth(ArrayList<Integer> arr, int k) {\n    int pivot = arr.get(0);\n    ArrayList<Integer> below, above;\n    below = new ArrayList<Integer>(arr.size());\n    above = new ArrayList<Integer>(arr.size());\n    for (Integer x : arr) {\n        if (x < pivot) {\n            below.add(x);\n        } else if (x > pivot) {\n            above.add(x);\n        }\n    }\n    int num_less = below.size();\n    int num_lessoreq = arr.size() - above.size();\n    if (k < num_less) {\n        return kth(below, k);\n    } else if (k >= num_lessoreq) {\n        return kth(above, k - num_less);\n    } else {\n        return pivot;\n    }\n}\n\npublic static void main(String[] args) {\n    ArrayList<Integer> arr = new ArrayList<Integer>();\n    arr.add(1);\n    arr.add(2);\n    arr.add(3);\n    arr.add(4);\n    arr.add(5);\n    arr.add(6);\n    arr.add(7);\n    arr.add(8);\n    arr.add(9"
      ]
    },
    "LCS_LENGTH": {
      "loc": "35-37",
      "input": "public static Integer lcs_length(String s, String t) {\n    Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n    for (int i=0; i < s.length(); i++) {\n        Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n        dp.put(i, initialize);\n        for (int j=0; j < t.length(); j++) {\n            Map<Integer,Integer> internal_map = dp.get(i);\n            internal_map.put(j,0);\n            dp.put(i, internal_map);\n        }\n    }\n    for (int i=0; i < s.length(); i++) {\n        for (int j=0; j < t.length(); j++) {\n            if (s.charAt(i) == t.charAt(j)) {",
      "function range": "13,5-58,5",
      "output": [
        "public static Integer lcs_length(String s, String t) {\n    Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n    for (int i=0; i < s.length(); i++) {\n        Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n        dp.put(i, initialize);\n        for (int j=0; j < t.length(); j++) {\n            Map<Integer,Integer> internal_map = dp.get(i);\n            internal_map.put(j,0);\n            dp.put(i, internal_map);\n        }\n    }\n    for (int i=0; i < s.length(); i++) {\n        for (int j=0; j < t.length(); j++) {\n            if (s.charAt(i) == t.charAt(j)) {\n                dp.get(i).put(j, dp.get(i).get(j)+1);\n            }\n        }\n    }\n    return dp.get(s.length()-1).get(t.length()-1);\n}\n}\n",
        "public static Integer lcs_length(String s, String t) {\n    Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n    for (int i=0; i < s.length(); i++) {\n        Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n        dp.put(i, initialize);\n        for (int j=0; j < t.length(); j++) {\n            Map<Integer,Integer> internal_map = dp.get(i);\n            internal_map.put(j,0);\n            dp.put(i, internal_map);\n        }\n    }\n    for (int i=0; i < s.length(); i++) {\n        for (int j=0; j < t.length(); j++) {\n            if (s.charAt(i) == t.charAt(j)) {\n                dp.get(i).put(j, dp.get(i).get(j)+1);\n            } else {\n                dp.get(i).put(j, Math.max(dp.get(i).get(j-1), dp.get(i).get(j)));\n            }\n        }\n    }\n    return dp.get(s.length()-1).get(t.length()-1);\n}\n}\n",
        "public static Integer lcs_length(String s, String t) {\n    Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n    for (int i=0; i < s.length(); i++) {\n        Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n        dp.put(i, initialize);\n        for (int j=0; j < t.length(); j++) {\n            Map<Integer,Integer> internal_map = dp.get(i);\n            internal_map.put(j,0);\n            dp.put(i, internal_map);\n        }\n    }\n    for (int i=0; i < s.length(); i++) {\n        for (int j=0; j < t.length(); j++) {\n            if (s.charAt(i) == t.charAt(j)) {\n                dp.get(i).put(j, dp.get(i).get(j)+1);\n            } else {\n                dp.get(i).put(j, Math.max(dp.get(i).get(j-1), dp.get(i).get(j)));\n            }\n        }\n    }\n    return dp.get(s.length()-1).get(t.length()-1);\n}\n",
        "public static Integer lcs_length(String s, String t) {\n    Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n    for (int i=0; i < s.length(); i++) {\n        Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n        dp.put(i, initialize);\n        for (int j=0; j < t.length(); j++) {\n            Map<Integer,Integer> internal_map = dp.get(i);\n            internal_map.put(j,0);\n            dp.put(i, internal_map);\n        }\n    }\n    for (int i=0; i < s.length(); i++) {\n        for (int j=0; j < t.length(); j++) {\n            if (s.charAt(i) == t.charAt(j)) {\n                Map<Integer,Integer> internal_map = dp.get(i);\n                internal_map.put(j,dp.get(i).get(j)+1);\n                dp.put(i, internal_map);\n            }\n        }\n    }\n    return dp.get(s.length()-1).get(t.length()-1);\n}\n}\n",
        "public static Integer lcs_length(String s, String t) {\n    Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n    for (int i=0; i < s.length(); i++) {\n        Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n        dp.put(i, initialize);\n        for (int j=0; j < t.length(); j++) {\n            Map<Integer,Integer> internal_map = dp.get(i);\n            internal_map.put(j,0);\n            dp.put(i, internal_map);\n        }\n    }\n    for (int i=0; i < s.length(); i++) {\n        for (int j=0; j < t.length(); j++) {\n            if (s.charAt(i) == t.charAt(j)) {\n                dp.get(i).put(j, dp.get(i).get(j)+1);\n            } else {\n                dp.get(i).put(j, Math.max(dp.get(i).get(j-1), dp.get(i).get(j)));\n            }\n        }\n    }\n    return dp.get(s.length()-1).get(t.length()-1);\n  }\n}\n",
        "public static Integer lcs_length(String s, String t) {\n    Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n    for (int i=0; i < s.length(); i++) {\n        Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n        dp.put(i, initialize);\n        for (int j=0; j < t.length(); j++) {\n            Map<Integer,Integer> internal_map = dp.get(i);\n            internal_map.put(j,0);\n            dp.put(i, internal_map);\n        }\n    }\n    for (int i=0; i < s.length(); i++) {\n        for (int j=0; j < t.length(); j++) {\n            if (s.charAt(i) == t.charAt(j)) {\n                dp.get(i).put(j, dp.get(i).get(j)+1);\n            } else {\n                dp.get(i).put(j, Math.max(dp.get(i).get(j-1), dp.get(i).get(j+1)));\n            }\n        }\n    }\n    return dp.get(s.length()-1).get(t.length()-1);\n}\n}\n",
        "public static Integer lcs_length(String s, String t) {\n    Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n    for (int i=0; i < s.length(); i++) {\n        Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n        dp.put(i, initialize);\n        for (int j=0; j < t.length(); j++) {\n            Map<Integer,Integer> internal_map = dp.get(i);\n            internal_map.put(j,0);\n            dp.put(i, internal_map);\n        }\n    }\n    for (int i=0; i < s.length(); i++) {\n        for (int j=0; j < t.length(); j++) {\n            if (s.charAt(i) == t.charAt(j)) {\n                Map<Integer,Integer> internal_map = dp.get(i);\n                internal_map.put(j, dp.get(i).get(j)+1);\n                dp.put(i, internal_map);\n            }\n        }\n    }\n    return dp.get(s.length()-1).get(t.length()-1);\n}\n}\n",
        "public static Integer lcs_length(String s, String t) {\n    Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n    for (int i=0; i < s.length(); i++) {\n        Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n        dp.put(i, initialize);\n        for (int j=0; j < t.length(); j++) {\n            Map<Integer,Integer> internal_map = dp.get(i);\n            internal_map.put(j,0);\n            dp.put(i, internal_map);\n        }\n    }\n    for (int i=0; i < s.length(); i++) {\n        for (int j=0; j < t.length(); j++) {\n            if (s.charAt(i) == t.charAt(j)) {\n                dp.get(i).put(j, 1 + dp.get(i).get(j-1));\n            } else {\n                dp.get(i).put(j, Math.max(dp.get(i).get(j), dp.get(i).get(j-1)));\n            }\n        }\n    }\n    return dp.get(s.length()-1).get(t.length()-1);\n}\n}\n",
        "public static Integer lcs_length(String s, String t) {\n    Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n    for (int i=0; i < s.length(); i++) {\n        Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n        dp.put(i, initialize);\n        for (int j=0; j < t.length(); j++) {\n            Map<Integer,Integer> internal_map = dp.get(i);\n            internal_map.put(j,0);\n            dp.put(i, internal_map);\n        }\n    }\n    for (int i=0; i < s.length(); i++) {\n        for (int j=0; j < t.length(); j++) {\n            if (s.charAt(i) == t.charAt(j)) {\n                Map<Integer,Integer> internal_map = dp.get(i);\n                internal_map.put(j, dp.get(i).get(j)+1);\n                dp.put(i, internal_map);\n            }\n        }\n    }\n    return dp.get(s.length()-1).get(t.length()-1);\n  }\n}\n",
        "public static Integer lcs_length(String s, String t) {\n    Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n    for (int i=0; i < s.length(); i++) {\n        Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n        dp.put(i, initialize);\n        for (int j=0; j < t.length(); j++) {\n            Map<Integer,Integer> internal_map = dp.get(i);\n            internal_map.put(j,0);\n            dp.put(i, internal_map);\n        }\n    }\n    for (int i=0; i < s.length(); i++) {\n        for (int j=0; j < t.length(); j++) {\n            if (s.charAt(i) == t.charAt(j)) {\n                dp.get(i).put(j, dp.get(i).get(j)+1);\n            } else {\n                dp.get(i).put(j, Math.max(dp.get(i).get(j-1), dp.get(i).get(j)));\n            }\n        }\n    }\n    return dp.get(s.length()-1).get(t.length()-1);\n}"
      ]
    },
    "LEVENSHTEIN": {
      "loc": "17-18",
      "input": "public static int levenshtein(String source, String target) {\n    if (source.isEmpty() || target.isEmpty()) {\n        return source.isEmpty() ? target.length() : source.length();\n    } else if (source.charAt(0) == target.charAt(0)) {",
      "function range": "13,5-25,5",
      "output": [
        "public static int levenshtein(String source, String target) {\n    if (source.isEmpty() || target.isEmpty()) {\n        return source.isEmpty()? target.length() : source.length();\n    } else if (source.charAt(0) == target.charAt(0)) {\n        return levenshtein(source.substring(1), target.substring(1));\n    } else {\n        return 1 + Math.min(\n            levenshtein(source.substring(1), target),\n            levenshtein(source, target.substring(1))\n        );\n    }\n}\n",
        "public static int levenshtein(String source, String target) {\n    if (source.isEmpty() || target.isEmpty()) {\n        return source.isEmpty()? target.length() : source.length();\n    } else if (source.charAt(0) == target.charAt(0)) {\n        return 1 + levenshtein(source.substring(1), target.substring(1));\n    } else {\n        return 1 + Math.min(source.length(), target.length());\n    }\n  }\n}\n",
        "public static int levenshtein(String source, String target) {\n    if (source.isEmpty() || target.isEmpty()) {\n        return source.isEmpty()? target.length() : source.length();\n    } else if (source.charAt(0) == target.charAt(0)) {\n        return 1 + levenshtein(source.substring(1), target.substring(1));\n    } else {\n        return Math.min(source.length(), target.length()) + 1 + levenshtein(source.substring(1), target.substring(1));\n    }\n}\n",
        "public static int levenshtein(String source, String target) {\n    if (source.isEmpty() || target.isEmpty()) {\n        return source.isEmpty()? target.length() : source.length();\n    } else if (source.charAt(0) == target.charAt(0)) {\n        return 1 + levenshtein(source.substring(1), target.substring(1));\n    } else {\n        return Math.min(source.length(), target.length()) + 1 + levenshtein(source.substring(1), target.substring(1));\n    }\n}\n}\n",
        "public static int levenshtein(String source, String target) {\n    if (source.isEmpty() || target.isEmpty()) {\n        return source.isEmpty()? target.length() : source.length();\n    } else if (source.charAt(0) == target.charAt(0)) {\n        return levenshtein(source.substring(1), target.substring(1));\n    } else {\n        return 1 + Math.min(levenshtein(source.substring(1), target), levenshtein(source, target.substring(1)));\n    }\n}\n",
        "public static int levenshtein(String source, String target) {\n    if (source.isEmpty() || target.isEmpty()) {\n        return source.isEmpty()? target.length() : source.length();\n    } else if (source.charAt(0) == target.charAt(0)) {\n        return levenshtein(source.substring(1), target.substring(1));\n    } else {\n        return 1 + Math.min(levenshtein(source.substring(1), target), levenshtein(source, target.substring(1)));\n    }\n}\n}\n",
        "public static int levenshtein(String source, String target) {\n    if (source.isEmpty() || target.isEmpty()) {\n        return source.isEmpty()? target.length() : source.length();\n    } else if (source.charAt(0) == target.charAt(0)) {\n        return levenshtein(source.substring(1), target.substring(1));\n    } else {\n        return 1 + Math.min(\n            levenshtein(source.substring(1), target),\n            levenshtein(source, target.substring(1))\n        );\n    }\n  }\n}\n",
        "public static int levenshtein(String source, String target) {\n    if (source.isEmpty() || target.isEmpty()) {\n        return source.isEmpty()? target.length() : source.length();\n    } else if (source.charAt(0) == target.charAt(0)) {\n        return 1 + levenshtein(source.substring(1), target.substring(1));\n    } else {\n        return Math.min(source.length(), target.length()) + 1 + levenshtein(source.substring(1), target.substring(1));\n    }\n  }\n}\n",
        "public static int levenshtein(String source, String target) {\n    if (source.isEmpty() || target.isEmpty()) {\n        return source.isEmpty()? target.length() : source.length();\n    } else if (source.charAt(0) == target.charAt(0)) {\n        return 1 + levenshtein(source.substring(1), target.substring(1));\n    } else {\n        return Math.min(source.length(), target.length()) + 1;\n    }\n  }\n}\n",
        "public static int levenshtein(String source, String target) {\n    if (source.isEmpty() || target.isEmpty()) {\n        return source.isEmpty()? target.length() : source.length();\n    } else if (source.charAt(0) == target.charAt(0)) {\n        return levenshtein(source.substring(1), target.substring(1));\n    } else {\n        return 1 + Math.min(\n            levenshtein(source.substring(1), target),\n            levenshtein(source, target.substring(1))\n        );\n    }\n}"
      ]
    },
    "LIS": {
      "loc": "31-32",
      "input": "public static int lis(int[] arr) {\n    Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n    int longest = 0;\n    int i = 0;\n    for (int val : arr) {\n        ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n        for (int j=1; j < longest+1; j++) {\n            if (arr[ends.get(j)] < val) {\n                prefix_lengths.add(j);\n            }\n        }\n        int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n        if (length == longest || val < arr[ends.get(length+1)]) {\n            ends.put(length+1, i);",
      "function range": "13,5-37,5",
      "output": [
        "public static int lis(int[] arr) {\n    Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n    int longest = 0;\n    int i = 0;\n    for (int val : arr) {\n        ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n        for (int j=1; j < longest+1; j++) {\n            if (arr[ends.get(j)] < val) {\n                prefix_lengths.add(j);\n            }\n        }\n        int length =!prefix_lengths.isEmpty()? Collections.max(prefix_lengths) : 0;\n        if (length == longest || val < arr[ends.get(length+1)]) {\n            ends.put(length+1, i);\n            longest = length;\n        }\n        i++;\n    }\n    return longest;\n}\n}\n",
        "public static int lis(int[] arr) {\n    Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n    int longest = 0;\n    int i = 0;\n    for (int val : arr) {\n        ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n        for (int j=1; j < longest+1; j++) {\n            if (arr[ends.get(j)] < val) {\n                prefix_lengths.add(j);\n            }\n        }\n        int length =!prefix_lengths.isEmpty()? Collections.max(prefix_lengths) : 0;\n        if (length == longest || val < arr[ends.get(length+1)]) {\n            ends.put(length+1, i);\n            longest = length;\n        }\n        i++;\n    }\n    return longest;\n}\n",
        "public static int lis(int[] arr) {\n    Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n    int longest = 0;\n    int i = 0;\n    for (int val : arr) {\n        ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n        for (int j=1; j < longest+1; j++) {\n            if (arr[ends.get(j)] < val) {\n                prefix_lengths.add(j);\n            }\n        }\n        int length =!prefix_lengths.isEmpty()? Collections.max(prefix_lengths) : 0;\n        if (length == longest || val < arr[ends.get(length+1)]) {\n            ends.put(length+1, i);\n            longest = length+1;\n        }\n        i++;\n    }\n    return longest;\n}\n}\n",
        "public static int lis(int[] arr) {\n    Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n    int longest = 0;\n    int i = 0;\n    for (int val : arr) {\n        ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n        for (int j=1; j < longest+1; j++) {\n            if (arr[ends.get(j)] < val) {\n                prefix_lengths.add(j);\n            }\n        }\n        int length =!prefix_lengths.isEmpty()? Collections.max(prefix_lengths) : 0;\n        if (length == longest || val < arr[ends.get(length+1)]) {\n            ends.put(length+1, i);\n            if (length > longest) {\n                longest = length;\n            }\n        }\n        i++;\n    }\n    return longest;\n}\n}\n",
        "public static int lis(int[] arr) {\n    Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n    int longest = 0;\n    int i = 0;\n    for (int val : arr) {\n        ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n        for (int j=1; j < longest+1; j++) {\n            if (arr[ends.get(j)] < val) {\n                prefix_lengths.add(j);\n            }\n        }\n        int length =!prefix_lengths.isEmpty()? Collections.max(prefix_lengths) : 0;\n        if (length == longest || val < arr[ends.get(length+1)]) {\n            ends.put(length+1, i);\n            longest = length;\n        }\n        i++;\n    }\n    return ends.get(longest+1);\n}\n}\n",
        "public static int lis(int[] arr) {\n    Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n    int longest = 0;\n    int i = 0;\n    for (int val : arr) {\n        ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n        for (int j=1; j < longest+1; j++) {\n            if (arr[ends.get(j)] < val) {\n                prefix_lengths.add(j);\n            }\n        }\n        int length =!prefix_lengths.isEmpty()? Collections.max(prefix_lengths) : 0;\n        if (length == longest || val < arr[ends.get(length+1)]) {\n            ends.put(length+1, i);\n        }\n        if (length > longest) {\n            longest = length;\n        }\n        i++;\n    }\n    return longest;\n}\n}\n",
        "public static int lis(int[] arr) {\n    Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n    int longest = 0;\n    int i = 0;\n    for (int val : arr) {\n        ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n        for (int j=1; j < longest+1; j++) {\n            if (arr[ends.get(j)] < val) {\n                prefix_lengths.add(j);\n            }\n        }\n        int length =!prefix_lengths.isEmpty()? Collections.max(prefix_lengths) : 0;\n        if (length == longest || val < arr[ends.get(length+1)]) {\n            ends.put(length+1, i);\n            longest = length;\n        }\n        i++;\n    }\n    return longest;\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    int[] arr = new int[n];\n    for (int i = 0; i < n; i++) {\n        arr[i] = in.nextInt();\n    }\n    System.out.println(lis(arr));\n}\n}\n",
        "public static int lis(int[] arr) {\n    Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n    int longest = 0;\n    int i = 0;\n    for (int val : arr) {\n        ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n        for (int j=1; j < longest+1; j++) {\n            if (arr[ends.get(j)] < val) {\n                prefix_lengths.add(j);\n            }\n        }\n        int length =!prefix_lengths.isEmpty()? Collections.max(prefix_lengths) : 0;\n        if (length == longest || val < arr[ends.get(length+1)]) {\n            ends.put(length+1, i);\n            longest = length;\n        }\n        i++;\n    }\n    return longest;\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    int[] arr = new int[n];\n    for (int i=0; i < n; i++) {\n        arr[i] = in.nextInt();\n    }\n    System.out.println(lis(arr));\n}\n}\n",
        "public static int lis(int[] arr) {\n    Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n    int longest = 0;\n    int i = 0;\n    for (int val : arr) {\n        ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n        for (int j=1; j < longest+1; j++) {\n            if (arr[ends.get(j)] < val) {\n                prefix_lengths.add(j);\n            }\n        }\n        int length =!prefix_lengths.isEmpty()? Collections.max(prefix_lengths) : 0;\n        if (length == longest || val < arr[ends.get(length+1)]) {\n            ends.put(length+1, i);\n            longest = length;\n        }\n        i++;\n    }\n    return longest;\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    int[] arr = new int[n];\n    for (int i=0; i<n; i++) {\n        arr[i] = in.nextInt();\n    }\n    System.out.println(lis(arr));\n}\n}\n",
        "public static int lis(int[] arr) {\n    Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n    int longest = 0;\n    int i = 0;\n    for (int val : arr) {\n        ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n        for (int j=1; j < longest+1; j++) {\n            if (arr[ends.get(j)] < val) {\n                prefix_lengths.add(j);\n            }\n        }\n        int length =!prefix_lengths.isEmpty()? Collections.max(prefix_lengths) : 0;\n        if (length == longest || val < arr[ends.get(length+1)]) {\n            ends.put(length+1, i);\n            longest = length;\n        }\n        i++;\n    }\n    return longest;\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    int[] arr = new int[n];\n    for (int i = 0; i < n; i++) {\n        arr[i] = in.nextInt();\n    }\n    System.out.println(lis(arr));\n}\n"
      ]
    },
    "LONGEST_COMMON_SUBSEQUENCE": {
      "loc": "18-19",
      "input": "public static String longest_common_subsequence(String a, String b) {\n    if (a.isEmpty() || b.isEmpty()) {\n        return \"\";\n    } else if (a.charAt(0) == b.charAt(0)) {",
      "function range": "14,5-25,5",
      "output": [
        "public static String longest_common_subsequence(String a, String b) {\n    if (a.isEmpty() || b.isEmpty()) {\n        return \"\";\n    } else if (a.charAt(0) == b.charAt(0)) {\n        return a + longest_common_subsequence(a.substring(1), b.substring(1));\n    } else {\n        return longest_common_subsequence(a.substring(1), b.substring(1));\n    }\n}\n",
        "public static String longest_common_subsequence(String a, String b) {\n    if (a.isEmpty() || b.isEmpty()) {\n        return \"\";\n    } else if (a.charAt(0) == b.charAt(0)) {\n        return a.charAt(0) + longest_common_subsequence(a.substring(1), b.substring(1));\n    } else {\n        return longest_common_subsequence(a.substring(1), b.substring(1));\n    }\n}\n",
        "public static String longest_common_subsequence(String a, String b) {\n    if (a.isEmpty() || b.isEmpty()) {\n        return \"\";\n    } else if (a.charAt(0) == b.charAt(0)) {\n        return a + longest_common_subsequence(a.substring(1), b.substring(1));\n    } else {\n        return longest_common_subsequence(a.substring(1), b.substring(1));\n    }\n}\n}\n",
        "public static String longest_common_subsequence(String a, String b) {\n    if (a.isEmpty() || b.isEmpty()) {\n        return \"\";\n    } else if (a.charAt(0) == b.charAt(0)) {\n        return a;\n    } else {\n        return longest_common_subsequence(a.substring(1), b.substring(1));\n    }\n}\n",
        "public static String longest_common_subsequence(String a, String b) {\n    if (a.isEmpty() || b.isEmpty()) {\n        return \"\";\n    } else if (a.charAt(0) == b.charAt(0)) {\n        return a + longest_common_subsequence(a.substring(1), b.substring(1));\n    } else {\n        return longest_common_subsequence(a.substring(1), b.substring(1));\n    }\n}",
        "public static String longest_common_subsequence(String a, String b) {\n    if (a.isEmpty() || b.isEmpty()) {\n        return \"\";\n    } else if (a.charAt(0) == b.charAt(0)) {\n        return a.charAt(0) + longest_common_subsequence(a.substring(1), b.substring(1));\n    } else {\n        return \"\";\n    }\n}\n",
        "public static String longest_common_subsequence(String a, String b) {\n    if (a.isEmpty() || b.isEmpty()) {\n        return \"\";\n    } else if (a.charAt(0) == b.charAt(0)) {\n        return a.charAt(0) + longest_common_subsequence(a.substring(1), b.substring(1));\n    } else {\n        return longest_common_subsequence(a.substring(1), b.substring(1));\n    }\n}",
        "public static String longest_common_subsequence(String a, String b) {\n    if (a.isEmpty() || b.isEmpty()) {\n        return \"\";\n    } else if (a.charAt(0) == b.charAt(0)) {\n        return a;\n    } else {\n        return longest_common_subsequence(a.substring(1), b.substring(1)) + a.charAt(0);\n    }\n}\n",
        "public static String longest_common_subsequence(String a, String b) {\n    if (a.isEmpty() || b.isEmpty()) {\n        return \"\";\n    } else if (a.charAt(0) == b.charAt(0)) {\n        return a + b.substring(1);\n    } else {\n        return longest_common_subsequence(a.substring(1), b.substring(1));\n    }\n}\n",
        "public static String longest_common_subsequence(String a, String b) {\n    if (a.isEmpty() || b.isEmpty()) {\n        return \"\";\n    } else if (a.charAt(0) == b.charAt(0)) {\n        return a + longest_common_subsequence(a.substring(1), b.substring(1));\n    } else {\n        return longest_common_subsequence(a.substring(1), b);\n    }\n}\n"
      ]
    },
    "MAX_SUBLIST_SUM": {
      "loc": "19-20",
      "input": "public static int max_sublist_sum(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {",
      "function range": "14,5-24,5",
      "output": [
        "public static int max_sublist_sum(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {\n      max_ending_here += x;\n      max_so_far = Math.max(max_ending_here, max_so_far);\n    }\n    return max_so_far;\n  }\n}\n",
        "public static int max_sublist_sum(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {\n      max_ending_here = Math.max(max_ending_here + x, x);\n      max_so_far = Math.max(max_so_far, max_ending_here);\n    }\n    return max_so_far;\n  }\n}\n",
        "public static int max_sublist_sum(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {\n      max_ending_here += x;\n      max_so_far = Math.max(max_so_far, max_ending_here);\n    }\n    return max_so_far;\n  }\n}\n",
        "public static int max_sublist_sum(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {\n      max_ending_here = Math.max(max_ending_here + x, x);\n      max_so_far = Math.max(max_ending_here, max_so_far);\n    }\n    return max_so_far;\n  }\n}\n",
        "public static int max_sublist_sum(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {\n        max_ending_here = Math.max(max_ending_here + x, x);\n        max_so_far = Math.max(max_so_far, max_ending_here);\n    }\n    return max_so_far;\n}\n}\n",
        "public static int max_sublist_sum(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {\n      max_ending_here = Math.max(max_ending_here, x);\n      max_so_far = Math.max(max_so_far, max_ending_here);\n    }\n    return max_so_far;\n  }\n}\n",
        "public static int max_sublist_sum(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {\n      max_ending_here = Math.max(max_ending_here + x, x);\n      max_so_far = Math.max(max_so_far, max_ending_here);\n    }\n    return max_so_far;\n  }\n\n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    int[] arr = new int[n];\n    for (int i = 0; i < n; i++) {\n      arr[",
        "public static int max_sublist_sum(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {\n        max_ending_here = Math.max(max_ending_here + x, x);\n        max_so_far = Math.max(max_so_far, max_ending_here);\n    }\n    return max_so_far;\n}\n",
        "public static int max_sublist_sum(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {\n      max_ending_here = Math.max(max_ending_here + x, x);\n      max_so_far = Math.max(max_so_far, max_ending_here);\n    }\n    return max_so_far;\n  }\n\n}\n",
        "public static int max_sublist_sum(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {\n      max_ending_here = Math.max(max_ending_here + x, x);\n      max_so_far = Math.max(max_so_far, max_ending_here);\n    }\n    return max_so_far;\n  }\n\n  public static int max_sublist_sum2(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {\n      max_ending_here = Math.max(max_ending_here"
      ]
    },
    "MERGESORT": {
      "loc": "38-39",
      "input": "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {",
      "function range": "37,5-51,5",
      "output": [
        "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n        mergesort(arr, 0, arr.size() - 1);\n        return arr;\n    }\n\n    private static void mergesort(ArrayList<Integer> arr, int low, int high) {\n        if (low < high) {\n            int mid = low + (high - low) / 2;\n            mergesort(arr, low, mid);\n            mergesort(arr, mid + 1, high);\n            merge(arr, low, mid, high);\n        }\n    }\n\n    private static void merge(ArrayList<Integer",
        "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n        mergesort(arr, 0, arr.size() - 1);\n        return arr;\n    }\n\n    private static void mergesort(ArrayList<Integer> arr, int low, int high) {\n        if (low < high) {\n            int mid = (low + high) / 2;\n            mergesort(arr, low, mid);\n            mergesort(arr, mid + 1, high);\n            merge(arr, low, mid, high);\n        }\n    }\n\n    private static void merge(ArrayList<Integer> arr",
        "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n        mergesort(arr, 0, arr.size() - 1);\n        return arr;\n    }\n\n    private static void mergesort(ArrayList<Integer> arr, int low, int high) {\n        if (low < high) {\n            int middle = low + (high - low) / 2;\n            mergesort(arr, low, middle);\n            mergesort(arr, middle + 1, high);\n            merge(arr, low, middle, high);\n        }\n    }\n\n    private static void merge(ArrayList<Integer",
        "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n        mergesort(arr, 0, arr.size() - 1);\n        return arr;\n    }\n\n    private static void mergesort(ArrayList<Integer> arr, int start, int end) {\n        if (start < end) {\n            int mid = (start + end) / 2;\n            mergesort(arr, start, mid);\n            mergesort(arr, mid + 1, end);\n            merge(arr, start, mid, end);\n        }\n    }\n\n    private static void merge(ArrayList<Integer> arr",
        "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n        mergesort(arr, 0, arr.size() - 1);\n        return arr;\n    }\n\n    public static void mergesort(ArrayList<Integer> arr, int low, int high) {\n        if (low < high) {\n            int mid = low + (high - low) / 2;\n            mergesort(arr, low, mid);\n            mergesort(arr, mid + 1, high);\n            merge(arr, low, mid, high);\n        }\n    }\n\n    public static void merge(ArrayList<Integer",
        "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n        mergesort(arr, 0, arr.size() - 1);\n        return arr;\n    }\n\n    public static void mergesort(ArrayList<Integer> arr, int low, int high) {\n        if (low < high) {\n            int mid = (low + high) / 2;\n            mergesort(arr, low, mid);\n            mergesort(arr, mid + 1, high);\n            merge(arr, low, mid, high);\n        }\n    }\n\n    public static void merge(ArrayList<Integer> arr",
        "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n        return mergesort(arr, 0, arr.size() - 1);\n    }\n\n    private static ArrayList<Integer> mergesort(ArrayList<Integer> arr, int low, int high) {\n        if (low < high) {\n            int mid = low + (high - low) / 2;\n            mergesort(arr, low, mid);\n            mergesort(arr, mid + 1, high);\n            merge(arr, low, mid, high);\n        }\n        return arr;\n    }\n\n    private static void merge",
        "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n        return mergesort(arr, 0, arr.size() - 1);\n    }\n\n    private static ArrayList<Integer> mergesort(ArrayList<Integer> arr, int low, int high) {\n        if (low < high) {\n            int mid = (low + high) / 2;\n            mergesort(arr, low, mid);\n            mergesort(arr, mid + 1, high);\n            merge(arr, low, mid, high);\n        }\n        return arr;\n    }\n\n    private static void merge(Array",
        "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n        ArrayList<Integer> result = new ArrayList<Integer>();\n        mergesort(arr, 0, arr.size() - 1, result);\n        return result;\n    }\n\n    private static void mergesort(ArrayList<Integer> arr, int low, int high, ArrayList<Integer> result) {\n        if (low < high) {\n            int mid = low + (high - low) / 2;\n            mergesort(arr, low, mid, result);\n            mergesort(arr, mid + 1, high, result);\n",
        "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n        ArrayList<Integer> result = new ArrayList<Integer>();\n        mergesort(arr, 0, arr.size() - 1, result);\n        return result;\n    }\n\n    private static void mergesort(ArrayList<Integer> arr, int low, int high, ArrayList<Integer> result) {\n        if (low < high) {\n            int mid = (low + high) / 2;\n            mergesort(arr, low, mid, result);\n            mergesort(arr, mid + 1, high, result);\n            mer"
      ]
    },
    "MINIMUM_SPANNING_TREE": {
      "loc": "29-30",
      "input": "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n    Map<Node,Set<Node>> groupByNode = new HashMap<>();\n    Set<WeightedEdge> minSpanningTree = new HashSet<>();\n    Collections.sort(weightedEdges);\n    for (WeightedEdge edge : weightedEdges) {\n        Node vertex_u = edge.node1;\n        Node vertex_v = edge.node2;\n        if (!groupByNode.containsKey(vertex_u)){\n            groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n        }\n        if (!groupByNode.containsKey(vertex_v)){\n            groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n        }\n        if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n            minSpanningTree.add(edge);\n            groupByNode = update(groupByNode, vertex_u, vertex_v);\n            for (Node node : groupByNode.get(vertex_v)) {",
      "function range": "8,5-34,5",
      "output": [
        "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n    Map<Node,Set<Node>> groupByNode = new HashMap<>();\n    Set<WeightedEdge> minSpanningTree = new HashSet<>();\n    Collections.sort(weightedEdges);\n    for (WeightedEdge edge : weightedEdges) {\n        Node vertex_u = edge.node1;\n        Node vertex_v = edge.node2;\n        if (!groupByNode.containsKey(vertex_u)){\n            groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n        }\n        if (!groupByNode.containsKey(vertex_v)){\n            groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n        }\n        if (groupByNode.get(vertex_u)!= groupByNode.get(vertex_v)) {\n            minSpanningTree.add(edge);\n            groupByNode = update(groupByNode, vertex_u, vertex_v);\n            for (Node node : groupByNode.get(vertex_v)) {\n                minSpanningTree.add(new WeightedEdge(node, vertex_u));\n            }\n        }\n    }\n    return minSpanningTree;\n}\n\nprivate static Map<Node,Set<Node>> update(Map<Node,Set<Node>> groupByNode, Node vertex_u, Node vertex_v) {\n    groupByNode.get(vertex_u).add(vertex_v);\n    groupByNode.get(vertex_v).add(vertex_u);\n    return groupByNode;\n}\n",
        "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n    Map<Node,Set<Node>> groupByNode = new HashMap<>();\n    Set<WeightedEdge> minSpanningTree = new HashSet<>();\n    Collections.sort(weightedEdges);\n    for (WeightedEdge edge : weightedEdges) {\n        Node vertex_u = edge.node1;\n        Node vertex_v = edge.node2;\n        if (!groupByNode.containsKey(vertex_u)){\n            groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n        }\n        if (!groupByNode.containsKey(vertex_v)){\n            groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n        }\n        if (groupByNode.get(vertex_u)!= groupByNode.get(vertex_v)) {\n            minSpanningTree.add(edge);\n            groupByNode = update(groupByNode, vertex_u, vertex_v);\n            for (Node node : groupByNode.get(vertex_v)) {\n                minSpanningTree.add(new WeightedEdge(node, vertex_u));\n            }\n        }\n    }\n    return minSpanningTree;\n}\n\nprivate static Map<Node,Set<Node>> update(Map<Node,Set<Node>> groupByNode, Node vertex_u, Node vertex_v) {\n    groupByNode.get(vertex_u).remove(vertex_v);\n    groupByNode.get(vertex_v).remove(vertex_u);\n    groupByNode.get(vertex",
        "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n    Map<Node,Set<Node>> groupByNode = new HashMap<>();\n    Set<WeightedEdge> minSpanningTree = new HashSet<>();\n    Collections.sort(weightedEdges);\n    for (WeightedEdge edge : weightedEdges) {\n        Node vertex_u = edge.node1;\n        Node vertex_v = edge.node2;\n        if (!groupByNode.containsKey(vertex_u)){\n            groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n        }\n        if (!groupByNode.containsKey(vertex_v)){\n            groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n        }\n        if (groupByNode.get(vertex_u)!= groupByNode.get(vertex_v)) {\n            minSpanningTree.add(edge);\n            groupByNode = update(groupByNode, vertex_u, vertex_v);\n            for (Node node : groupByNode.get(vertex_v)) {\n                minSpanningTree.add(new WeightedEdge(vertex_u, node, edge.weight));\n            }\n        }\n    }\n    return minSpanningTree;\n}\n\nprivate static Map<Node,Set<Node>> update(Map<Node,Set<Node>> groupByNode, Node vertex_u, Node vertex_v) {\n    Set<Node> group_u = groupByNode.get(vertex_u);\n    Set<Node> group_v = groupByNode.get(vertex_v);\n    group",
        "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n    Map<Node,Set<Node>> groupByNode = new HashMap<>();\n    Set<WeightedEdge> minSpanningTree = new HashSet<>();\n    Collections.sort(weightedEdges);\n    for (WeightedEdge edge : weightedEdges) {\n        Node vertex_u = edge.node1;\n        Node vertex_v = edge.node2;\n        if (!groupByNode.containsKey(vertex_u)){\n            groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n        }\n        if (!groupByNode.containsKey(vertex_v)){\n            groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n        }\n        if (groupByNode.get(vertex_u)!= groupByNode.get(vertex_v)) {\n            minSpanningTree.add(edge);\n            groupByNode = update(groupByNode, vertex_u, vertex_v);\n            for (Node node : groupByNode.get(vertex_v)) {\n                minSpanningTree.add(new WeightedEdge(node, vertex_u));\n            }\n        }\n    }\n    return minSpanningTree;\n}\n\nprivate static Map<Node,Set<Node>> update(Map<Node,Set<Node>> groupByNode, Node vertex_u, Node vertex_v) {\n    Set<Node> group_u = groupByNode.get(vertex_u);\n    Set<Node> group_v = groupByNode.get(vertex_v);\n    group_u.remove(",
        "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n    Map<Node,Set<Node>> groupByNode = new HashMap<>();\n    Set<WeightedEdge> minSpanningTree = new HashSet<>();\n    Collections.sort(weightedEdges);\n    for (WeightedEdge edge : weightedEdges) {\n        Node vertex_u = edge.node1;\n        Node vertex_v = edge.node2;\n        if (!groupByNode.containsKey(vertex_u)){\n            groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n        }\n        if (!groupByNode.containsKey(vertex_v)){\n            groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n        }\n        if (groupByNode.get(vertex_u)!= groupByNode.get(vertex_v)) {\n            minSpanningTree.add(edge);\n            groupByNode = update(groupByNode, vertex_u, vertex_v);\n            for (Node node : groupByNode.get(vertex_v)) {\n                minSpanningTree.add(new WeightedEdge(node, vertex_u));\n            }\n        }\n    }\n    return minSpanningTree;\n}\n\nprivate static Map<Node, Set<Node>> update(Map<Node, Set<Node>> groupByNode, Node vertex_u, Node vertex_v) {\n    Set<Node> group_u = groupByNode.get(vertex_u);\n    Set<Node> group_v = groupByNode.get(vertex_v);\n    group_u.remove(",
        "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n    Map<Node,Set<Node>> groupByNode = new HashMap<>();\n    Set<WeightedEdge> minSpanningTree = new HashSet<>();\n    Collections.sort(weightedEdges);\n    for (WeightedEdge edge : weightedEdges) {\n        Node vertex_u = edge.node1;\n        Node vertex_v = edge.node2;\n        if (!groupByNode.containsKey(vertex_u)){\n            groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n        }\n        if (!groupByNode.containsKey(vertex_v)){\n            groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n        }\n        if (groupByNode.get(vertex_u)!= groupByNode.get(vertex_v)) {\n            minSpanningTree.add(edge);\n            groupByNode = update(groupByNode, vertex_u, vertex_v);\n            for (Node node : groupByNode.get(vertex_v)) {\n                minSpanningTree.add(new WeightedEdge(node, vertex_u));\n            }\n        }\n    }\n    return minSpanningTree;\n}\n\nprivate static Map<Node,Set<Node>> update(Map<Node,Set<Node>> groupByNode, Node vertex_u, Node vertex_v) {\n    Set<Node> group_u = groupByNode.get(vertex_u);\n    Set<Node> group_v = groupByNode.get(vertex_v);\n    groupByNode.remove(",
        "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n    Map<Node,Set<Node>> groupByNode = new HashMap<>();\n    Set<WeightedEdge> minSpanningTree = new HashSet<>();\n    Collections.sort(weightedEdges);\n    for (WeightedEdge edge : weightedEdges) {\n        Node vertex_u = edge.node1;\n        Node vertex_v = edge.node2;\n        if (!groupByNode.containsKey(vertex_u)){\n            groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n        }\n        if (!groupByNode.containsKey(vertex_v)){\n            groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n        }\n        if (groupByNode.get(vertex_u)!= groupByNode.get(vertex_v)) {\n            minSpanningTree.add(edge);\n            groupByNode = update(groupByNode, vertex_u, vertex_v);\n            for (Node node : groupByNode.get(vertex_v)) {\n                minSpanningTree.add(new WeightedEdge(node, vertex_u));\n            }\n        }\n    }\n    return minSpanningTree;\n  }\n\n  private static Map<Node,Set<Node>> update(Map<Node,Set<Node>> groupByNode, Node vertex_u, Node vertex_v) {\n    Set<Node> group_u = groupByNode.get(vertex_u);\n    Set<Node> group_v = groupByNode.get(vertex_v);\n    group_u.remove",
        "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n    Map<Node,Set<Node>> groupByNode = new HashMap<>();\n    Set<WeightedEdge> minSpanningTree = new HashSet<>();\n    Collections.sort(weightedEdges);\n    for (WeightedEdge edge : weightedEdges) {\n        Node vertex_u = edge.node1;\n        Node vertex_v = edge.node2;\n        if (!groupByNode.containsKey(vertex_u)){\n            groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n        }\n        if (!groupByNode.containsKey(vertex_v)){\n            groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n        }\n        if (groupByNode.get(vertex_u)!= groupByNode.get(vertex_v)) {\n            minSpanningTree.add(edge);\n            groupByNode = update(groupByNode, vertex_u, vertex_v);\n            for (Node node : groupByNode.get(vertex_v)) {\n                minSpanningTree.add(new WeightedEdge(node, vertex_u));\n            }\n        }\n    }\n    return minSpanningTree;\n  }\n\n  private static Map<Node, Set<Node>> update(Map<Node, Set<Node>> groupByNode, Node vertex_u, Node vertex_v) {\n    Set<Node> group_u = groupByNode.get(vertex_u);\n    Set<Node> group_v = groupByNode.get(vertex_v);\n    group_u.remove",
        "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n    Map<Node,Set<Node>> groupByNode = new HashMap<>();\n    Set<WeightedEdge> minSpanningTree = new HashSet<>();\n    Collections.sort(weightedEdges);\n    for (WeightedEdge edge : weightedEdges) {\n        Node vertex_u = edge.node1;\n        Node vertex_v = edge.node2;\n        if (!groupByNode.containsKey(vertex_u)){\n            groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n        }\n        if (!groupByNode.containsKey(vertex_v)){\n            groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n        }\n        if (groupByNode.get(vertex_u)!= groupByNode.get(vertex_v)) {\n            minSpanningTree.add(edge);\n            groupByNode = update(groupByNode, vertex_u, vertex_v);\n            for (Node node : groupByNode.get(vertex_v)) {\n                minSpanningTree.add(new WeightedEdge(node, vertex_u));\n            }\n        }\n    }\n    return minSpanningTree;\n}\n\nprivate static Map<Node,Set<Node>> update(Map<Node,Set<Node>> groupByNode, Node vertex_u, Node vertex_v) {\n    groupByNode.get(vertex_u).add(vertex_v);\n    groupByNode.get(vertex_v).add(vertex_u);\n    return groupByNode;\n}\n\n",
        "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n    Map<Node,Set<Node>> groupByNode = new HashMap<>();\n    Set<WeightedEdge> minSpanningTree = new HashSet<>();\n    Collections.sort(weightedEdges);\n    for (WeightedEdge edge : weightedEdges) {\n        Node vertex_u = edge.node1;\n        Node vertex_v = edge.node2;\n        if (!groupByNode.containsKey(vertex_u)){\n            groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n        }\n        if (!groupByNode.containsKey(vertex_v)){\n            groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n        }\n        if (groupByNode.get(vertex_u)!= groupByNode.get(vertex_v)) {\n            minSpanningTree.add(edge);\n            groupByNode = update(groupByNode, vertex_u, vertex_v);\n            for (Node node : groupByNode.get(vertex_v)) {\n                minSpanningTree.add(new WeightedEdge(node, vertex_u));\n            }\n        }\n    }\n    return minSpanningTree;\n  }\n\n  private static Map<Node,Set<Node>> update(Map<Node,Set<Node>> groupByNode, Node vertex_u, Node vertex_v) {\n    Set<Node> group_u = groupByNode.get(vertex_u);\n    Set<Node> group_v = groupByNode.get(vertex_v);\n    group_u.add"
      ]
    },
    "NEXT_PALINDROME": {
      "loc": "37-38",
      "input": "public static String next_palindrome(int[] digit_list) {\n    int high_mid = Math.floorDiv(digit_list.length, 2);\n    int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n    while (high_mid < digit_list.length && low_mid >= 0) {\n        if (digit_list[high_mid] == 9) {\n            digit_list[high_mid] = 0;\n            digit_list[low_mid] = 0;\n            high_mid += 1;\n            low_mid -= 1;\n        } else {\n            digit_list[high_mid] += 1;\n            if (low_mid != high_mid) {\n                digit_list[low_mid] += 1;\n            }\n            return Arrays.toString(digit_list);\n        }\n    }\n    ArrayList<Integer> otherwise = new ArrayList<Integer>();\notherwise.add(1);",
      "function range": "16,5-41,5",
      "output": [
        "public static String next_palindrome(int[] digit_list) {\n    int high_mid = Math.floorDiv(digit_list.length, 2);\n    int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n    while (high_mid < digit_list.length && low_mid >= 0) {\n        if (digit_list[high_mid] == 9) {\n            digit_list[high_mid] = 0;\n            digit_list[low_mid] = 0;\n            high_mid += 1;\n            low_mid -= 1;\n        } else {\n            digit_list[high_mid] += 1;\n            if (low_mid!= high_mid) {\n                digit_list[low_mid] += 1;\n            }\n            return Arrays.toString(digit_list);\n        }\n    }\n    ArrayList<Integer> otherwise = new ArrayList<Integer>();\notherwise.add(1);\nreturn Arrays.toString(otherwise.toArray());\n}\n}\n",
        "public static String next_palindrome(int[] digit_list) {\n    int high_mid = Math.floorDiv(digit_list.length, 2);\n    int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n    while (high_mid < digit_list.length && low_mid >= 0) {\n        if (digit_list[high_mid] == 9) {\n            digit_list[high_mid] = 0;\n            digit_list[low_mid] = 0;\n            high_mid += 1;\n            low_mid -= 1;\n        } else {\n            digit_list[high_mid] += 1;\n            if (low_mid!= high_mid) {\n                digit_list[low_mid] += 1;\n            }\n            return Arrays.toString(digit_list);\n        }\n    }\n    ArrayList<Integer> otherwise = new ArrayList<Integer>();\notherwise.add(1);\nreturn otherwise.toString();\n}\n}\n",
        "public static String next_palindrome(int[] digit_list) {\n    int high_mid = Math.floorDiv(digit_list.length, 2);\n    int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n    while (high_mid < digit_list.length && low_mid >= 0) {\n        if (digit_list[high_mid] == 9) {\n            digit_list[high_mid] = 0;\n            digit_list[low_mid] = 0;\n            high_mid += 1;\n            low_mid -= 1;\n        } else {\n            digit_list[high_mid] += 1;\n            if (low_mid!= high_mid) {\n                digit_list[low_mid] += 1;\n            }\n            return Arrays.toString(digit_list);\n        }\n    }\n    ArrayList<Integer> otherwise = new ArrayList<Integer>();\notherwise.add(1);\n    return Arrays.toString(otherwise.toArray());\n}\n}\n",
        "public static String next_palindrome(int[] digit_list) {\n    int high_mid = Math.floorDiv(digit_list.length, 2);\n    int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n    while (high_mid < digit_list.length && low_mid >= 0) {\n        if (digit_list[high_mid] == 9) {\n            digit_list[high_mid] = 0;\n            digit_list[low_mid] = 0;\n            high_mid += 1;\n            low_mid -= 1;\n        } else {\n            digit_list[high_mid] += 1;\n            if (low_mid!= high_mid) {\n                digit_list[low_mid] += 1;\n            }\n            return Arrays.toString(digit_list);\n        }\n    }\n    ArrayList<Integer> otherwise = new ArrayList<Integer>();\notherwise.add(1);\nreturn Arrays.toString(otherwise.toArray(new Integer[otherwise.size()]));\n}\n}\n",
        "public static String next_palindrome(int[] digit_list) {\n    int high_mid = Math.floorDiv(digit_list.length, 2);\n    int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n    while (high_mid < digit_list.length && low_mid >= 0) {\n        if (digit_list[high_mid] == 9) {\n            digit_list[high_mid] = 0;\n            digit_list[low_mid] = 0;\n            high_mid += 1;\n            low_mid -= 1;\n        } else {\n            digit_list[high_mid] += 1;\n            if (low_mid!= high_mid) {\n                digit_list[low_mid] += 1;\n            }\n            return Arrays.toString(digit_list);\n        }\n    }\n    ArrayList<Integer> otherwise = new ArrayList<Integer>();\notherwise.add(1);\notherwise.add(0);\nreturn Arrays.toString(otherwise.toArray());\n}\n}\n",
        "public static String next_palindrome(int[] digit_list) {\n    int high_mid = Math.floorDiv(digit_list.length, 2);\n    int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n    while (high_mid < digit_list.length && low_mid >= 0) {\n        if (digit_list[high_mid] == 9) {\n            digit_list[high_mid] = 0;\n            digit_list[low_mid] = 0;\n            high_mid += 1;\n            low_mid -= 1;\n        } else {\n            digit_list[high_mid] += 1;\n            if (low_mid!= high_mid) {\n                digit_list[low_mid] += 1;\n            }\n            return Arrays.toString(digit_list);\n        }\n    }\n    ArrayList<Integer> otherwise = new ArrayList<Integer>();\notherwise.add(1);\notherwise.add(9);\nreturn Arrays.toString(otherwise.toArray());\n}\n}\n",
        "public static String next_palindrome(int[] digit_list) {\n    int high_mid = Math.floorDiv(digit_list.length, 2);\n    int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n    while (high_mid < digit_list.length && low_mid >= 0) {\n        if (digit_list[high_mid] == 9) {\n            digit_list[high_mid] = 0;\n            digit_list[low_mid] = 0;\n            high_mid += 1;\n            low_mid -= 1;\n        } else {\n            digit_list[high_mid] += 1;\n            if (low_mid!= high_mid) {\n                digit_list[low_mid] += 1;\n            }\n            return Arrays.toString(digit_list);\n        }\n    }\n    ArrayList<Integer> otherwise = new ArrayList<Integer>();\notherwise.add(1);\n    return Arrays.toString(otherwise.toArray(new Integer[otherwise.size()]));\n}\n}\n",
        "public static String next_palindrome(int[] digit_list) {\n    int high_mid = Math.floorDiv(digit_list.length, 2);\n    int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n    while (high_mid < digit_list.length && low_mid >= 0) {\n        if (digit_list[high_mid] == 9) {\n            digit_list[high_mid] = 0;\n            digit_list[low_mid] = 0;\n            high_mid += 1;\n            low_mid -= 1;\n        } else {\n            digit_list[high_mid] += 1;\n            if (low_mid!= high_mid) {\n                digit_list[low_mid] += 1;\n            }\n            return Arrays.toString(digit_list);\n        }\n    }\n    ArrayList<Integer> otherwise = new ArrayList<Integer>();\notherwise.add(1);\nfor (int i = 0; i < digit_list.length; i++) {\n    otherwise.add(digit_list[i]);\n}\nreturn Arrays.toString(otherwise.toArray());\n}\n}\n",
        "public static String next_palindrome(int[] digit_list) {\n    int high_mid = Math.floorDiv(digit_list.length, 2);\n    int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n    while (high_mid < digit_list.length && low_mid >= 0) {\n        if (digit_list[high_mid] == 9) {\n            digit_list[high_mid] = 0;\n            digit_list[low_mid] = 0;\n            high_mid += 1;\n            low_mid -= 1;\n        } else {\n            digit_list[high_mid] += 1;\n            if (low_mid!= high_mid) {\n                digit_list[low_mid] += 1;\n            }\n            return Arrays.toString(digit_list);\n        }\n    }\n    ArrayList<Integer> otherwise = new ArrayList<Integer>();\notherwise.add(1);\nreturn Arrays.toString(otherwise.toArray(new Integer[otherwise.size()]));\n}\n}",
        "public static String next_palindrome(int[] digit_list) {\n    int high_mid = Math.floorDiv(digit_list.length, 2);\n    int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n    while (high_mid < digit_list.length && low_mid >= 0) {\n        if (digit_list[high_mid] == 9) {\n            digit_list[high_mid] = 0;\n            digit_list[low_mid] = 0;\n            high_mid += 1;\n            low_mid -= 1;\n        } else {\n            digit_list[high_mid] += 1;\n            if (low_mid!= high_mid) {\n                digit_list[low_mid] += 1;\n            }\n            return Arrays.toString(digit_list);\n        }\n    }\n    ArrayList<Integer> otherwise = new ArrayList<Integer>();\notherwise.add(1);\n    for (int i = 0; i < digit_list.length; i++) {\n        otherwise.add(digit_list[i]);\n    }\n    return Arrays.toString(otherwise.toArray());\n}\n}\n"
      ]
    },
    "NEXT_PERMUTATION": {
      "loc": "19-20",
      "input": "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n    for (int i=perm.size()-2; i!=-1; i--) {\n        if (perm.get(i) < perm.get(i+1)) {\n            for (int j=perm.size()-1; j!=i; j--) {",
      "function range": "15,5-44,5",
      "output": [
        "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n    for (int i=perm.size()-2; i!=-1; i--) {\n        if (perm.get(i) < perm.get(i+1)) {\n            for (int j=perm.size()-1; j!=i; j--) {\n                if (perm.get(j) > perm.get(i)) {\n                    int temp = perm.get(j);\n                    perm.set(j, perm.get(i));\n                    perm.set(i, temp);\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    return perm;\n}\n",
        "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n    for (int i=perm.size()-2; i!=-1; i--) {\n        if (perm.get(i) < perm.get(i+1)) {\n            for (int j=perm.size()-1; j!=i; j--) {\n                if (perm.get(j) > perm.get(i)) {\n                    int temp = perm.get(j);\n                    perm.set(j, perm.get(i));\n                    perm.set(i, temp);\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    return perm;\n}\n}\n",
        "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n    for (int i=perm.size()-2; i!=-1; i--) {\n        if (perm.get(i) < perm.get(i+1)) {\n            for (int j=perm.size()-1; j!=i; j--) {\n                if (perm.get(j) > perm.get(i)) {\n                    swap(perm, i, j);\n                    break;\n                }\n            }\n        }\n    }\n    return perm;\n}\n\npublic static void swap(ArrayList<Integer> perm, int i, int j) {\n    int tmp = perm.get(i);\n    perm.set(i, perm.get(j));\n    perm.set(j, tmp);\n}\n}\n",
        "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n    for (int i=perm.size()-2; i!=-1; i--) {\n        if (perm.get(i) < perm.get(i+1)) {\n            for (int j=perm.size()-1; j!=i; j--) {\n                if (perm.get(j) > perm.get(i)) {\n                    swap(perm, i, j);\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    return perm;\n}\n\npublic static void swap(ArrayList<Integer> perm, int i, int j) {\n    int tmp = perm.get(i);\n    perm.set(i, perm.get(j));\n    perm.set(j, tmp);\n}\n}\n",
        "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n    for (int i=perm.size()-2; i!=-1; i--) {\n        if (perm.get(i) < perm.get(i+1)) {\n            for (int j=perm.size()-1; j!=i; j--) {\n                if (perm.get(j) > perm.get(i)) {\n                    swap(perm, i, j);\n                    break;\n                }\n            }\n        }\n    }\n    return perm;\n}\n\npublic static void swap(ArrayList<Integer> perm, int i, int j) {\n    int tmp = perm.get(i);\n    perm.set(i, perm.get(j));\n    perm.set(j, tmp);\n}\n",
        "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n    for (int i=perm.size()-2; i!=-1; i--) {\n        if (perm.get(i) < perm.get(i+1)) {\n            for (int j=perm.size()-1; j!=i; j--) {\n                if (perm.get(j) > perm.get(i)) {\n                    swap(perm, i, j);\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    return perm;\n}\n\npublic static void swap(ArrayList<Integer> perm, int i, int j) {\n    int tmp = perm.get(i);\n    perm.set(i, perm.get(j));\n    perm.set(j, tmp);\n}\n",
        "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n    for (int i=perm.size()-2; i!=-1; i--) {\n        if (perm.get(i) < perm.get(i+1)) {\n            for (int j=perm.size()-1; j!=i; j--) {\n                if (perm.get(j) > perm.get(i)) {\n                    swap(perm, i, j);\n                    break;\n                }\n            }\n        }\n    }\n    return perm;\n}\n\npublic static void swap(ArrayList<Integer> perm, int i, int j) {\n    int tmp = perm.get(i);\n    perm.set(i, perm.get(j));\n    perm.set(j, tmp);\n}\n\n}\n",
        "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n    for (int i=perm.size()-2; i!=-1; i--) {\n        if (perm.get(i) < perm.get(i+1)) {\n            for (int j=perm.size()-1; j!=i; j--) {\n                if (perm.get(j) > perm.get(i)) {\n                    swap(perm, i, j);\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    return perm;\n}\n\npublic static void swap(ArrayList<Integer> perm, int i, int j) {\n    int tmp = perm.get(i);\n    perm.set(i, perm.get(j));\n    perm.set(j, tmp);\n}\n\n}\n",
        "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n    for (int i=perm.size()-2; i!=-1; i--) {\n        if (perm.get(i) < perm.get(i+1)) {\n            for (int j=perm.size()-1; j!=i; j--) {\n                if (perm.get(j) > perm.get(i)) {\n                    swap(perm, i, j);\n                    break;\n                }\n            }\n        }\n    }\n    return perm;\n}\n\npublic static void swap(ArrayList<Integer> perm, int i, int j) {\n    int tmp = perm.get(i);\n    perm.set(i, perm.get(j));\n    perm.set(j, tmp);\n}",
        "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n    for (int i=perm.size()-2; i!=-1; i--) {\n        if (perm.get(i) < perm.get(i+1)) {\n            for (int j=perm.size()-1; j!=i; j--) {\n                if (perm.get(j) > perm.get(i)) {\n                    swap(perm, i, j);\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    return perm;\n}\n\npublic static void swap(ArrayList<Integer> perm, int i, int j) {\n    int tmp = perm.get(i);\n    perm.set(i, perm.get(j));\n    perm.set(j, tmp);\n}"
      ]
    },
    "PASCAL": {
      "loc": "22-23",
      "input": "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n    ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> init = new ArrayList<Integer>();\n    init.add(1);\n    rows.add(init);\n    for (int r=1; r<n; r++) {\n        ArrayList<Integer> row = new ArrayList<Integer>();",
      "function range": "14,5-40,5",
      "output": [
        "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n    ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> init = new ArrayList<Integer>();\n    init.add(1);\n    rows.add(init);\n    for (int r=1; r<n; r++) {\n        ArrayList<Integer> row = new ArrayList<Integer>();\n        for (int i=0; i<r; i++) {\n            for (int j=0; j<rows.get(i).size(); j++) {\n                row.add(rows.get(i).get(j)+rows.get(i+1).get(j));\n            }\n        }\n        rows.add(row);\n    }\n    return rows;\n}\n}\n",
        "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n    ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> init = new ArrayList<Integer>();\n    init.add(1);\n    rows.add(init);\n    for (int r=1; r<n; r++) {\n        ArrayList<Integer> row = new ArrayList<Integer>();\n        for (int i=0; i<r; i++) {\n            for (int j=0; j<rows.get(i).size(); j++) {\n                row.add(rows.get(i).get(j) + rows.get(i+1).get(j));\n            }\n        }\n        rows.add(row);\n    }\n    return rows;\n}\n}\n",
        "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n    ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> init = new ArrayList<Integer>();\n    init.add(1);\n    rows.add(init);\n    for (int r=1; r<n; r++) {\n        ArrayList<Integer> row = new ArrayList<Integer>();\n        for (int i=0; i<rows.get(r-1).size(); i++) {\n            row.add(rows.get(r-1).get(i) + rows.get(r).get(i));\n        }\n        rows.add(row);\n    }\n    return rows;\n}\n}\n",
        "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n    ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> init = new ArrayList<Integer>();\n    init.add(1);\n    rows.add(init);\n    for (int r=1; r<n; r++) {\n        ArrayList<Integer> row = new ArrayList<Integer>();\n        for (int i=0; i<r; i++) {\n            for (int j=0; j<rows.get(i).size(); j++) {\n                row.add(rows.get(i).get(j)+rows.get(i+1).get(j));\n            }\n        }\n        rows.add(row);\n    }\n    return rows;\n  }\n}\n",
        "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n    ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> init = new ArrayList<Integer>();\n    init.add(1);\n    rows.add(init);\n    for (int r=1; r<n; r++) {\n        ArrayList<Integer> row = new ArrayList<Integer>();\n        for (int i=0; i<r; i++) {\n            for (int j=0; j<rows.get(i).size(); j++) {\n                row.add(rows.get(i).get(j)+rows.get(i+1).get(j));\n            }\n        }\n        rows.add(row);\n    }\n    return rows;\n}\n",
        "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n    ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> init = new ArrayList<Integer>();\n    init.add(1);\n    rows.add(init);\n    for (int r=1; r<n; r++) {\n        ArrayList<Integer> row = new ArrayList<Integer>();\n        for (int i=0; i<r; i++) {\n            for (int j=0; j<rows.get(i).size(); j++) {\n                row.add(rows.get(i).get(j)+rows.get(i+1).get(j));\n            }\n        }\n        rows.add(row);\n    }\n    return rows;\n}",
        "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n    ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> init = new ArrayList<Integer>();\n    init.add(1);\n    rows.add(init);\n    for (int r=1; r<n; r++) {\n        ArrayList<Integer> row = new ArrayList<Integer>();\n        for (int i=0; i<rows.get(r-1).size(); i++) {\n            row.add(rows.get(r-1).get(i) + rows.get(r-1).get(i+1));\n        }\n        row.add(1);\n        rows.add(row);\n    }\n    return rows;\n}\n}\n",
        "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n    ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> init = new ArrayList<Integer>();\n    init.add(1);\n    rows.add(init);\n    for (int r=1; r<n; r++) {\n        ArrayList<Integer> row = new ArrayList<Integer>();\n        for (int i=0; i<rows.get(r-1).size(); i++) {\n            row.add(rows.get(r-1).get(i) + rows.get(r-1).get(i));\n        }\n        row.add(1);\n        rows.add(row);\n    }\n    return rows;\n}\n}\n",
        "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n    ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> init = new ArrayList<Integer>();\n    init.add(1);\n    rows.add(init);\n    for (int r=1; r<n; r++) {\n        ArrayList<Integer> row = new ArrayList<Integer>();\n        for (int i=0; i<rows.get(r-1).size(); i++) {\n            row.add(rows.get(r-1).get(i)+rows.get(r-1).get(i));\n        }\n        row.add(1);\n        rows.add(row);\n    }\n    return rows;\n}\n}\n",
        "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n    ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> init = new ArrayList<Integer>();\n    init.add(1);\n    rows.add(init);\n    for (int r=1; r<n; r++) {\n        ArrayList<Integer> row = new ArrayList<Integer>();\n        for (int i=0; i<rows.get(r-1).size(); i++) {\n            row.add(rows.get(r-1).get(i) + rows.get(r).get(i));\n        }\n        rows.add(row);\n    }\n    return rows;\n  }\n}\n"
      ]
    },
    "POSSIBLE_CHANGE": {
      "loc": "17-18",
      "input": "public static int possible_change(int[] coins, int total) {\n    if (total == 0) {\n        return 1;\n    }",
      "function range": "13,5-24,5",
      "output": [
        "public static int possible_change(int[] coins, int total) {\n    if (total == 0) {\n        return 1;\n    }\n    int[][] dp = new int[total + 1][coins.length + 1];\n    for (int i = 1; i <= total; i++) {\n        for (int j = 1; j <= coins.length; j++) {\n            if (i - coins[j - 1] >= 0) {\n                dp[i][j] = dp[i - coins[j - 1]][j];\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    return dp[total][",
        "public static int possible_change(int[] coins, int total) {\n    if (total == 0) {\n        return 1;\n    }\n    int[][] dp = new int[total + 1][coins.length + 1];\n    for (int i = 1; i <= total; i++) {\n        for (int j = 1; j <= coins.length; j++) {\n            if (i >= coins[j - 1]) {\n                dp[i][j] = dp[i - coins[j - 1]][j - 1];\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    return dp[total][coins",
        "public static int possible_change(int[] coins, int total) {\n    if (total == 0) {\n        return 1;\n    }\n    int[] dp = new int[total + 1];\n    dp[0] = 1;\n    for (int i = 1; i <= total; i++) {\n        for (int j = 0; j < coins.length; j++) {\n            if (i - coins[j] >= 0) {\n                dp[i] += dp[i - coins[j]];\n            }\n        }\n    }\n    return dp[total];\n}\n}\n",
        "public static int possible_change(int[] coins, int total) {\n    if (total == 0) {\n        return 1;\n    }\n    int[][] dp = new int[total + 1][coins.length + 1];\n    for (int i = 1; i <= total; i++) {\n        dp[i][0] = 1;\n    }\n    for (int i = 1; i <= coins.length; i++) {\n        dp[0][i] = 1;\n    }\n    for (int i = 1; i <= total; i++) {\n        for (int j = 1; j <= coins.length; j++) {\n            if (i - coins[j -",
        "public static int possible_change(int[] coins, int total) {\n    if (total == 0) {\n        return 1;\n    }\n    int[] dp = new int[total + 1];\n    dp[0] = 1;\n    for (int i = 1; i <= total; i++) {\n        for (int j = 0; j < coins.length; j++) {\n            if (i >= coins[j]) {\n                dp[i] += dp[i - coins[j]];\n            }\n        }\n    }\n    return dp[total];\n}\n}\n",
        "public static int possible_change(int[] coins, int total) {\n    if (total == 0) {\n        return 1;\n    }\n    int[][] dp = new int[total + 1][coins.length + 1];\n    for (int i = 1; i <= total; i++) {\n        dp[i][0] = 1;\n    }\n    for (int i = 1; i <= coins.length; i++) {\n        dp[0][i] = 1;\n    }\n    for (int i = 1; i <= total; i++) {\n        for (int j = 1; j <= coins.length; j++) {\n            dp[i][j] = d",
        "public static int possible_change(int[] coins, int total) {\n    if (total == 0) {\n        return 1;\n    }\n    int[] dp = new int[total + 1];\n    dp[0] = 1;\n    for (int i = 1; i <= total; i++) {\n        for (int j = 0; j < coins.length; j++) {\n            if (i - coins[j] >= 0) {\n                dp[i] += dp[i - coins[j]];\n            }\n        }\n    }\n    return dp[total];\n}\n",
        "public static int possible_change(int[] coins, int total) {\n    if (total == 0) {\n        return 1;\n    }\n    int[][] dp = new int[total + 1][coins.length + 1];\n    for (int i = 1; i <= total; i++) {\n        dp[i][0] = 1;\n    }\n    for (int i = 1; i <= coins.length; i++) {\n        for (int j = 1; j <= total; j++) {\n            if (j >= coins[i - 1]) {\n                dp[j][i] = dp[j][i - 1];\n            } else {\n                dp[j][",
        "public static int possible_change(int[] coins, int total) {\n    if (total == 0) {\n        return 1;\n    }\n    int[][] dp = new int[total + 1][coins.length + 1];\n    for (int i = 1; i <= total; i++) {\n        dp[i][0] = 1;\n    }\n    for (int i = 1; i <= coins.length; i++) {\n        for (int j = 1; j <= total; j++) {\n            if (j >= coins[i - 1]) {\n                dp[j][i] = dp[j - coins[i - 1]][i - 1];\n            } else",
        "public static int possible_change(int[] coins, int total) {\n    if (total == 0) {\n        return 1;\n    }\n    int[] dp = new int[total + 1];\n    dp[0] = 1;\n    for (int i = 1; i <= total; i++) {\n        for (int j = 0; j < coins.length; j++) {\n            if (i >= coins[j]) {\n                dp[i] += dp[i - coins[j]];\n            }\n        }\n    }\n    return dp[total];\n}\n"
      ]
    },
    "QUICKSORT": {
      "loc": "26-27",
      "input": "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n    if (arr.isEmpty()) {\n        return new ArrayList<Integer>();\n    }\n    Integer pivot = arr.get(0);\n    ArrayList<Integer> lesser = new ArrayList<Integer>();\n    ArrayList<Integer> greater = new ArrayList<Integer>();\n    for (Integer x : arr.subList(1, arr.size())) {\n        if (x < pivot) {\n            lesser.add(x);",
      "function range": "14,5-38,5",
      "output": [
        "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n    if (arr.isEmpty()) {\n        return new ArrayList<Integer>();\n    }\n    Integer pivot = arr.get(0);\n    ArrayList<Integer> lesser = new ArrayList<Integer>();\n    ArrayList<Integer> greater = new ArrayList<Integer>();\n    for (Integer x : arr.subList(1, arr.size())) {\n        if (x < pivot) {\n            lesser.add(x);\n        } else if (x > pivot) {\n            greater.add(x);\n        }\n    }\n    return quicksort(lesser) + pivot + quicksort(greater);\n}\n}\n",
        "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n    if (arr.isEmpty()) {\n        return new ArrayList<Integer>();\n    }\n    Integer pivot = arr.get(0);\n    ArrayList<Integer> lesser = new ArrayList<Integer>();\n    ArrayList<Integer> greater = new ArrayList<Integer>();\n    for (Integer x : arr.subList(1, arr.size())) {\n        if (x < pivot) {\n            lesser.add(x);\n        } else {\n            greater.add(x);\n        }\n    }\n    return quicksort(lesser) + pivot + quicksort(greater);\n}\n}\n",
        "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n    if (arr.isEmpty()) {\n        return new ArrayList<Integer>();\n    }\n    Integer pivot = arr.get(0);\n    ArrayList<Integer> lesser = new ArrayList<Integer>();\n    ArrayList<Integer> greater = new ArrayList<Integer>();\n    for (Integer x : arr.subList(1, arr.size())) {\n        if (x < pivot) {\n            lesser.add(x);\n        } else if (x > pivot) {\n            greater.add(x);\n        }\n    }\n    return quicksort(lesser) + pivot + quicksort(greater);\n}\n",
        "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n    if (arr.isEmpty()) {\n        return new ArrayList<Integer>();\n    }\n    Integer pivot = arr.get(0);\n    ArrayList<Integer> lesser = new ArrayList<Integer>();\n    ArrayList<Integer> greater = new ArrayList<Integer>();\n    for (Integer x : arr.subList(1, arr.size())) {\n        if (x < pivot) {\n            lesser.add(x);\n        } else if (x > pivot) {\n            greater.add(x);\n        }\n    }\n    ArrayList<Integer> result = quicksort(lesser);\n    result.add(pivot);\n    result.addAll(quicksort(greater));\n    return result;\n}\n}\n",
        "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n    if (arr.isEmpty()) {\n        return new ArrayList<Integer>();\n    }\n    Integer pivot = arr.get(0);\n    ArrayList<Integer> lesser = new ArrayList<Integer>();\n    ArrayList<Integer> greater = new ArrayList<Integer>();\n    for (Integer x : arr.subList(1, arr.size())) {\n        if (x < pivot) {\n            lesser.add(x);\n        } else {\n            greater.add(x);\n        }\n    }\n    lesser = quicksort(lesser);\n    greater = quicksort(greater);\n    ArrayList<Integer> result = new ArrayList<Integer>();\n    result.add(pivot);\n    result.addAll(lesser);\n    result.addAll(greater);\n    return result;\n}\n}\n",
        "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n    if (arr.isEmpty()) {\n        return new ArrayList<Integer>();\n    }\n    Integer pivot = arr.get(0);\n    ArrayList<Integer> lesser = new ArrayList<Integer>();\n    ArrayList<Integer> greater = new ArrayList<Integer>();\n    for (Integer x : arr.subList(1, arr.size())) {\n        if (x < pivot) {\n            lesser.add(x);\n        } else if (x > pivot) {\n            greater.add(x);\n        }\n    }\n    lesser = quicksort(lesser);\n    greater = quicksort(greater);\n    ArrayList<Integer> result = new ArrayList<Integer>();\n    result.add(pivot);\n    result.addAll(lesser);\n    result.addAll(greater);\n    return result;\n}\n}\n",
        "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n    if (arr.isEmpty()) {\n        return new ArrayList<Integer>();\n    }\n    Integer pivot = arr.get(0);\n    ArrayList<Integer> lesser = new ArrayList<Integer>();\n    ArrayList<Integer> greater = new ArrayList<Integer>();\n    for (Integer x : arr.subList(1, arr.size())) {\n        if (x < pivot) {\n            lesser.add(x);\n        } else if (x > pivot) {\n            greater.add(x);\n        }\n    }\n    quicksort(lesser);\n    quicksort(greater);\n    ArrayList<Integer> result = new ArrayList<Integer>();\n    result.add(pivot);\n    result.addAll(lesser);\n    result.addAll(greater);\n    return result;\n}\n}\n",
        "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n    if (arr.isEmpty()) {\n        return new ArrayList<Integer>();\n    }\n    Integer pivot = arr.get(0);\n    ArrayList<Integer> lesser = new ArrayList<Integer>();\n    ArrayList<Integer> greater = new ArrayList<Integer>();\n    for (Integer x : arr.subList(1, arr.size())) {\n        if (x < pivot) {\n            lesser.add(x);\n        } else if (x > pivot) {\n            greater.add(x);\n        }\n    }\n    ArrayList<Integer> result = quicksort(lesser);\n    result.add(pivot);\n    result.addAll(quicksort(greater));\n    return result;\n}\n",
        "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n    if (arr.isEmpty()) {\n        return new ArrayList<Integer>();\n    }\n    Integer pivot = arr.get(0);\n    ArrayList<Integer> lesser = new ArrayList<Integer>();\n    ArrayList<Integer> greater = new ArrayList<Integer>();\n    for (Integer x : arr.subList(1, arr.size())) {\n        if (x < pivot) {\n            lesser.add(x);\n        } else {\n            greater.add(x);\n        }\n    }\n    lesser = quicksort(lesser);\n    greater = quicksort(greater);\n    ArrayList<Integer> result = new ArrayList<Integer>();\n    result.add(pivot);\n    result.addAll(lesser);\n    result.addAll(greater);\n    return result;\n}\n",
        "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n    if (arr.isEmpty()) {\n        return new ArrayList<Integer>();\n    }\n    Integer pivot = arr.get(0);\n    ArrayList<Integer> lesser = new ArrayList<Integer>();\n    ArrayList<Integer> greater = new ArrayList<Integer>();\n    for (Integer x : arr.subList(1, arr.size())) {\n        if (x < pivot) {\n            lesser.add(x);\n        } else if (x > pivot) {\n            greater.add(x);\n        }\n    }\n    lesser = quicksort(lesser);\n    greater = quicksort(greater);\n    ArrayList<Integer> result = new ArrayList<Integer>();\n    result.add(pivot);\n    result.addAll(lesser);\n    result.addAll(greater);\n    return result;\n}\n"
      ]
    },
    "REVERSE_LINKED_LIST": {
      "loc": "20-20",
      "input": "public static Node reverse_linked_list(Node node) {\n    Node prevnode = null;\n    Node nextnode;\n    while (node != null) {\n        nextnode = node.getSuccessor();\n        node.setSuccessor(prevnode);",
      "function range": "14,5-23,5",
      "output": [
        "public static Node reverse_linked_list(Node node) {\n    Node prevnode = null;\n    Node nextnode;\n    while (node!= null) {\n        nextnode = node.getSuccessor();\n        node.setSuccessor(prevnode);\n        prevnode = node;\n        node = nextnode;\n    }\n    return prevnode;\n}\n}\n",
        "public static Node reverse_linked_list(Node node) {\n    Node prevnode = null;\n    Node nextnode;\n    while (node!= null) {\n        nextnode = node.getSuccessor();\n        node.setSuccessor(prevnode);\n        prevnode = node;\n        node = nextnode;\n    }\n    return prevnode;\n}\n",
        "public static Node reverse_linked_list(Node node) {\n    Node prevnode = null;\n    Node nextnode;\n    while (node!= null) {\n        nextnode = node.getSuccessor();\n        node.setSuccessor(prevnode);\n        prevnode = node;\n        node = nextnode;\n    }\n    return prevnode;\n  }\n}\n",
        "public static Node reverse_linked_list(Node node) {\n    Node prevnode = null;\n    Node nextnode;\n    while (node!= null) {\n        nextnode = node.getSuccessor();\n        node.setSuccessor(prevnode);\n        prevnode = node;\n        node = nextnode;\n    }\n    return prevnode;\n}\n\n}\n",
        "public static Node reverse_linked_list(Node node) {\n    Node prevnode = null;\n    Node nextnode;\n    while (node!= null) {\n        nextnode = node.getSuccessor();\n        node.setSuccessor(prevnode);\n        prevnode = node;\n        node = nextnode;\n    }\n    return prevnode;\n}\n\npublic static void main(String[] args) {\n    Node head = new Node(1);\n    head.setSuccessor(new Node(2));\n    head.getSuccessor().setSuccessor(new Node(3));\n    head.getSuccessor().getSuccessor().setSuccessor(new Node(4));\n    head.getSuccessor().getSuccessor().getSuccessor().setSuccessor(new Node(5));\n    head.get",
        "public static Node reverse_linked_list(Node node) {\n    Node prevnode = null;\n    Node nextnode;\n    while (node!= null) {\n        nextnode = node.getSuccessor();\n        node.setSuccessor(prevnode);\n        prevnode = node;\n        node = nextnode;\n    }\n    return prevnode;\n}\n\n",
        "public static Node reverse_linked_list(Node node) {\n    Node prevnode = null;\n    Node nextnode;\n    while (node!= null) {\n        nextnode = node.getSuccessor();\n        node.setSuccessor(prevnode);\n        prevnode = node;\n        node = nextnode;\n    }\n    return prevnode;\n}",
        "public static Node reverse_linked_list(Node node) {\n    Node prevnode = null;\n    Node nextnode;\n    while (node!= null) {\n        nextnode = node.getSuccessor();\n        node.setSuccessor(prevnode);\n        prevnode = node;\n        node = nextnode;\n    }\n    return prevnode;\n}\n\npublic static void main(String[] args) {\n    Node node1 = new Node(1);\n    Node node2 = new Node(2);\n    Node node3 = new Node(3);\n    Node node4 = new Node(4);\n    Node node5 = new Node(5);\n    node1.setSuccessor(node2);\n    node2.setSuccessor(node3);\n    node3.setSuccessor(node4);",
        "public static Node reverse_linked_list(Node node) {\n    Node prevnode = null;\n    Node nextnode;\n    while (node!= null) {\n        nextnode = node.getSuccessor();\n        node.setSuccessor(prevnode);\n        prevnode = node;\n        node = nextnode;\n    }\n    return prevnode;\n}\n\npublic static void main(String[] args) {\n    Node n1 = new Node(1);\n    Node n2 = new Node(2);\n    Node n3 = new Node(3);\n    Node n4 = new Node(4);\n    Node n5 = new Node(5);\n    n1.setSuccessor(n2);\n    n2.setSuccessor(n3);\n    n3.setSuccessor(n4);",
        "public static Node reverse_linked_list(Node node) {\n    Node prevnode = null;\n    Node nextnode;\n    while (node!= null) {\n        nextnode = node.getSuccessor();\n        node.setSuccessor(prevnode);\n        prevnode = node;\n        node = nextnode;\n    }\n    return prevnode;\n}\n\npublic static void main(String[] args) {\n    Node head = new Node(1);\n    head.setSuccessor(new Node(2));\n    head.getSuccessor().setSuccessor(new Node(3));\n    head.getSuccessor().getSuccessor().setSuccessor(new Node(4));\n    head.getSuccessor().getSuccessor().getSuccessor().setSuccessor(new Node(5));\n    head = reverse"
      ]
    },
    "RPN_EVAL": {
      "loc": "34-35",
      "input": "public static Double rpn_eval(ArrayList tokens) {\nMap<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\nop.put(\"+\", (a, b) -> a + b); \nop.put(\"-\", (a, b) -> a - b); \nop.put(\"*\", (a, b) -> a * b); \nop.put(\"/\", (a, b) -> a / b); \n    Stack stack = new Stack();\n    for (Object token : tokens) {\n        if (Double.class.isInstance(token)) {\n            stack.push((Double) token);\n        } else {\ntoken = (String) token;\n            Double a = (Double) stack.pop();\n            Double b = (Double) stack.pop();\nDouble c = 0.0;\nBinaryOperator<Double> bin_op = op.get(token);",
      "function range": "15,5-40,5",
      "output": [
        "public static Double rpn_eval(ArrayList tokens) {\nMap<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\nop.put(\"+\", (a, b) -> a + b); \nop.put(\"-\", (a, b) -> a - b); \nop.put(\"*\", (a, b) -> a * b); \nop.put(\"/\", (a, b) -> a / b); \n    Stack stack = new Stack();\n    for (Object token : tokens) {\n        if (Double.class.isInstance(token)) {\n            stack.push((Double) token);\n        } else {\ntoken = (String) token;\n            Double a = (Double) stack.pop();\n            Double b = (Double) stack.pop();\nDouble c = 0.0;\nBinaryOperator<Double> bin_op = op.get(token);\n            if (bin_op!= null) {\n                c = bin_op.eval(a, b);\n            }\n            stack.push(c);\n        }\n    }\nreturn stack.pop();\n}\n}\n",
        "public static Double rpn_eval(ArrayList tokens) {\nMap<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\nop.put(\"+\", (a, b) -> a + b); \nop.put(\"-\", (a, b) -> a - b); \nop.put(\"*\", (a, b) -> a * b); \nop.put(\"/\", (a, b) -> a / b); \n    Stack stack = new Stack();\n    for (Object token : tokens) {\n        if (Double.class.isInstance(token)) {\n            stack.push((Double) token);\n        } else {\ntoken = (String) token;\n            Double a = (Double) stack.pop();\n            Double b = (Double) stack.pop();\nDouble c = 0.0;\nBinaryOperator<Double> bin_op = op.get(token);\n            if (bin_op!= null) {\n                c = bin_op.apply(a, b);\n            }\n            stack.push(c);\n        }\n    }\nreturn stack.pop();\n}\n}\n",
        "public static Double rpn_eval(ArrayList tokens) {\nMap<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\nop.put(\"+\", (a, b) -> a + b); \nop.put(\"-\", (a, b) -> a - b); \nop.put(\"*\", (a, b) -> a * b); \nop.put(\"/\", (a, b) -> a / b); \n    Stack stack = new Stack();\n    for (Object token : tokens) {\n        if (Double.class.isInstance(token)) {\n            stack.push((Double) token);\n        } else {\ntoken = (String) token;\n            Double a = (Double) stack.pop();\n            Double b = (Double) stack.pop();\nDouble c = 0.0;\nBinaryOperator<Double> bin_op = op.get(token);\n            if (bin_op!= null) {\n                c = bin_op.operate(a, b);\n            }\n            stack.push(c);\n        }\n    }\nreturn stack.pop();\n}\n}\n",
        "public static Double rpn_eval(ArrayList tokens) {\nMap<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\nop.put(\"+\", (a, b) -> a + b); \nop.put(\"-\", (a, b) -> a - b); \nop.put(\"*\", (a, b) -> a * b); \nop.put(\"/\", (a, b) -> a / b); \n    Stack stack = new Stack();\n    for (Object token : tokens) {\n        if (Double.class.isInstance(token)) {\n            stack.push((Double) token);\n        } else {\ntoken = (String) token;\n            Double a = (Double) stack.pop();\n            Double b = (Double) stack.pop();\nDouble c = 0.0;\nBinaryOperator<Double> bin_op = op.get(token);\n            if (bin_op!= null) {\n                c = bin_op.eval(a, b);\n            }\n            stack.push(c);\n        }\n    }\n    return (Double) stack.pop();\n}\n}\n",
        "public static Double rpn_eval(ArrayList tokens) {\nMap<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\nop.put(\"+\", (a, b) -> a + b); \nop.put(\"-\", (a, b) -> a - b); \nop.put(\"*\", (a, b) -> a * b); \nop.put(\"/\", (a, b) -> a / b); \n    Stack stack = new Stack();\n    for (Object token : tokens) {\n        if (Double.class.isInstance(token)) {\n            stack.push((Double) token);\n        } else {\ntoken = (String) token;\n            Double a = (Double) stack.pop();\n            Double b = (Double) stack.pop();\nDouble c = 0.0;\nBinaryOperator<Double> bin_op = op.get(token);\n            if (bin_op!= null) {\n                c = bin_op.eval(a, b);\n            }\n            stack.push(c);\n        }\n    }\n    return stack.pop();\n}\n}\n",
        "public static Double rpn_eval(ArrayList tokens) {\nMap<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\nop.put(\"+\", (a, b) -> a + b); \nop.put(\"-\", (a, b) -> a - b); \nop.put(\"*\", (a, b) -> a * b); \nop.put(\"/\", (a, b) -> a / b); \n    Stack stack = new Stack();\n    for (Object token : tokens) {\n        if (Double.class.isInstance(token)) {\n            stack.push((Double) token);\n        } else {\ntoken = (String) token;\n            Double a = (Double) stack.pop();\n            Double b = (Double) stack.pop();\nDouble c = 0.0;\nBinaryOperator<Double> bin_op = op.get(token);\n            if (bin_op!= null) {\n                c = bin_op.apply(a, b);\n            }\n            stack.push(c);\n        }\n    }\n    return (Double) stack.pop();\n}\n}\n",
        "public static Double rpn_eval(ArrayList tokens) {\nMap<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\nop.put(\"+\", (a, b) -> a + b); \nop.put(\"-\", (a, b) -> a - b); \nop.put(\"*\", (a, b) -> a * b); \nop.put(\"/\", (a, b) -> a / b); \n    Stack stack = new Stack();\n    for (Object token : tokens) {\n        if (Double.class.isInstance(token)) {\n            stack.push((Double) token);\n        } else {\ntoken = (String) token;\n            Double a = (Double) stack.pop();\n            Double b = (Double) stack.pop();\nDouble c = 0.0;\nBinaryOperator<Double> bin_op = op.get(token);\n            if (bin_op!= null) {\n                c = bin_op.apply(a, b);\n            }\n            stack.push(c);\n        }\n    }\n    return stack.pop();\n}\n}\n",
        "public static Double rpn_eval(ArrayList tokens) {\nMap<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\nop.put(\"+\", (a, b) -> a + b); \nop.put(\"-\", (a, b) -> a - b); \nop.put(\"*\", (a, b) -> a * b); \nop.put(\"/\", (a, b) -> a / b); \n    Stack stack = new Stack();\n    for (Object token : tokens) {\n        if (Double.class.isInstance(token)) {\n            stack.push((Double) token);\n        } else {\ntoken = (String) token;\n            Double a = (Double) stack.pop();\n            Double b = (Double) stack.pop();\nDouble c = 0.0;\nBinaryOperator<Double> bin_op = op.get(token);\n            if (bin_op!= null) {\n                c = bin_op.operate(a, b);\n            }\n            stack.push(c);\n        }\n    }\n    return (Double) stack.pop();\n}\n}\n",
        "public static Double rpn_eval(ArrayList tokens) {\nMap<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\nop.put(\"+\", (a, b) -> a + b); \nop.put(\"-\", (a, b) -> a - b); \nop.put(\"*\", (a, b) -> a * b); \nop.put(\"/\", (a, b) -> a / b); \n    Stack stack = new Stack();\n    for (Object token : tokens) {\n        if (Double.class.isInstance(token)) {\n            stack.push((Double) token);\n        } else {\ntoken = (String) token;\n            Double a = (Double) stack.pop();\n            Double b = (Double) stack.pop();\nDouble c = 0.0;\nBinaryOperator<Double> bin_op = op.get(token);\n            if (bin_op!= null) {\n                c = bin_op.operate(a, b);\n            }\n            stack.push(c);\n        }\n    }\n    return stack.pop();\n}\n}\n",
        "public static Double rpn_eval(ArrayList tokens) {\nMap<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\nop.put(\"+\", (a, b) -> a + b); \nop.put(\"-\", (a, b) -> a - b); \nop.put(\"*\", (a, b) -> a * b); \nop.put(\"/\", (a, b) -> a / b); \n    Stack stack = new Stack();\n    for (Object token : tokens) {\n        if (Double.class.isInstance(token)) {\n            stack.push((Double) token);\n        } else {\ntoken = (String) token;\n            Double a = (Double) stack.pop();\n            Double b = (Double) stack.pop();\nDouble c = 0.0;\nBinaryOperator<Double> bin_op = op.get(token);\n            if (bin_op!= null) {\n                c = bin_op.eval(a, b);\n            }\n            stack.push(c);\n        }\n    }\n    return (Double) stack.pop();\n    }\n}\n"
      ]
    },
    "SHORTEST_PATH_LENGTH": {
      "loc": "39-40",
      "input": "public int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n    int n = length_by_edge.size();\n    Map<Node, Integer> unvisitedNodes = new HashMap<>();\n    Set<Node> visitedNodes = new HashSet<>();\n    unvisitedNodes.put(startnode, 0);\n    while (!unvisitedNodes.isEmpty()) {\n        Node node = getNodeWithMinDistance(unvisitedNodes);\n        int distance = unvisitedNodes.get(node);\n        unvisitedNodes.remove(node);\n        if (node.getValue() == goalnode.getValue()) {\n            return distance;\n        }\n        visitedNodes.add(node);\n        for (Node nextnode : node.getSuccessors()) {\n            if (visitedNodes.contains(nextnode)) {\n                continue;\n            }\n            if (unvisitedNodes.get(nextnode) == null) {\n                unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n            }\n            unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),",
      "function range": "11,5-44,5",
      "output": [
        "public int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n    int n = length_by_edge.size();\n    Map<Node, Integer> unvisitedNodes = new HashMap<>();\n    Set<Node> visitedNodes = new HashSet<>();\n    unvisitedNodes.put(startnode, 0);\n    while (!unvisitedNodes.isEmpty()) {\n        Node node = getNodeWithMinDistance(unvisitedNodes);\n        int distance = unvisitedNodes.get(node);\n        unvisitedNodes.remove(node);\n        if (node.getValue() == goalnode.getValue()) {\n            return distance;\n        }\n        visitedNodes.add(node);\n        for (Node nextnode : node.getSuccessors()) {\n            if (visitedNodes.contains(nextnode)) {\n                continue;\n            }\n            if (unvisitedNodes.get(nextnode) == null) {\n                unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n            }\n            unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode), distance + 1));\n        }\n    }\n    return -1;\n  }\n}\n",
        "public int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n    int n = length_by_edge.size();\n    Map<Node, Integer> unvisitedNodes = new HashMap<>();\n    Set<Node> visitedNodes = new HashSet<>();\n    unvisitedNodes.put(startnode, 0);\n    while (!unvisitedNodes.isEmpty()) {\n        Node node = getNodeWithMinDistance(unvisitedNodes);\n        int distance = unvisitedNodes.get(node);\n        unvisitedNodes.remove(node);\n        if (node.getValue() == goalnode.getValue()) {\n            return distance;\n        }\n        visitedNodes.add(node);\n        for (Node nextnode : node.getSuccessors()) {\n            if (visitedNodes.contains(nextnode)) {\n                continue;\n            }\n            if (unvisitedNodes.get(nextnode) == null) {\n                unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n            }\n            unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode), distance + 1));\n        }\n    }\n    return -1;\n}\n",
        "public int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n    int n = length_by_edge.size();\n    Map<Node, Integer> unvisitedNodes = new HashMap<>();\n    Set<Node> visitedNodes = new HashSet<>();\n    unvisitedNodes.put(startnode, 0);\n    while (!unvisitedNodes.isEmpty()) {\n        Node node = getNodeWithMinDistance(unvisitedNodes);\n        int distance = unvisitedNodes.get(node);\n        unvisitedNodes.remove(node);\n        if (node.getValue() == goalnode.getValue()) {\n            return distance;\n        }\n        visitedNodes.add(node);\n        for (Node nextnode : node.getSuccessors()) {\n            if (visitedNodes.contains(nextnode)) {\n                continue;\n            }\n            if (unvisitedNodes.get(nextnode) == null) {\n                unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n            }\n            unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode), distance + 1));\n        }\n    }\n    return -1;\n}\n}\n",
        "public int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n    int n = length_by_edge.size();\n    Map<Node, Integer> unvisitedNodes = new HashMap<>();\n    Set<Node> visitedNodes = new HashSet<>();\n    unvisitedNodes.put(startnode, 0);\n    while (!unvisitedNodes.isEmpty()) {\n        Node node = getNodeWithMinDistance(unvisitedNodes);\n        int distance = unvisitedNodes.get(node);\n        unvisitedNodes.remove(node);\n        if (node.getValue() == goalnode.getValue()) {\n            return distance;\n        }\n        visitedNodes.add(node);\n        for (Node nextnode : node.getSuccessors()) {\n            if (visitedNodes.contains(nextnode)) {\n                continue;\n            }\n            if (unvisitedNodes.get(nextnode) == null) {\n                unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n            }\n            unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode), distance + 1));\n        }\n    }\n    return Integer.MAX_VALUE;\n  }\n}\n",
        "public int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n    int n = length_by_edge.size();\n    Map<Node, Integer> unvisitedNodes = new HashMap<>();\n    Set<Node> visitedNodes = new HashSet<>();\n    unvisitedNodes.put(startnode, 0);\n    while (!unvisitedNodes.isEmpty()) {\n        Node node = getNodeWithMinDistance(unvisitedNodes);\n        int distance = unvisitedNodes.get(node);\n        unvisitedNodes.remove(node);\n        if (node.getValue() == goalnode.getValue()) {\n            return distance;\n        }\n        visitedNodes.add(node);\n        for (Node nextnode : node.getSuccessors()) {\n            if (visitedNodes.contains(nextnode)) {\n                continue;\n            }\n            if (unvisitedNodes.get(nextnode) == null) {\n                unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n            }\n            unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode), distance + 1));\n        }\n    }\n    return -1;\n  }\n\n  private Node getNodeWithMinDistance(Map<Node, Integer> unvisitedNodes) {\n    int min = Integer.MAX_VALUE;\n    Node minnode = null;\n    for (Node node : unvisitedNodes.keySet()) {\n      if (unvisitedNodes.get(node) < min) {\n        min = unvisitedNodes.get(node);\n        minnode = node;\n      }\n    }\n    return minnode",
        "public int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n    int n = length_by_edge.size();\n    Map<Node, Integer> unvisitedNodes = new HashMap<>();\n    Set<Node> visitedNodes = new HashSet<>();\n    unvisitedNodes.put(startnode, 0);\n    while (!unvisitedNodes.isEmpty()) {\n        Node node = getNodeWithMinDistance(unvisitedNodes);\n        int distance = unvisitedNodes.get(node);\n        unvisitedNodes.remove(node);\n        if (node.getValue() == goalnode.getValue()) {\n            return distance;\n        }\n        visitedNodes.add(node);\n        for (Node nextnode : node.getSuccessors()) {\n            if (visitedNodes.contains(nextnode)) {\n                continue;\n            }\n            if (unvisitedNodes.get(nextnode) == null) {\n                unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n            }\n            unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode), distance + 1));\n        }\n    }\n    return -1;\n}\n\nprivate Node getNodeWithMinDistance(Map<Node, Integer> unvisitedNodes) {\n    int min = Integer.MAX_VALUE;\n    Node minnode = null;\n    for (Node node : unvisitedNodes.keySet()) {\n        if (unvisitedNodes.get(node) < min) {\n            min = unvisitedNodes.get(node);\n            minnode = node;\n        }\n    }\n    return minnode;",
        "public int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n    int n = length_by_edge.size();\n    Map<Node, Integer> unvisitedNodes = new HashMap<>();\n    Set<Node> visitedNodes = new HashSet<>();\n    unvisitedNodes.put(startnode, 0);\n    while (!unvisitedNodes.isEmpty()) {\n        Node node = getNodeWithMinDistance(unvisitedNodes);\n        int distance = unvisitedNodes.get(node);\n        unvisitedNodes.remove(node);\n        if (node.getValue() == goalnode.getValue()) {\n            return distance;\n        }\n        visitedNodes.add(node);\n        for (Node nextnode : node.getSuccessors()) {\n            if (visitedNodes.contains(nextnode)) {\n                continue;\n            }\n            if (unvisitedNodes.get(nextnode) == null) {\n                unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n            }\n            unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode), distance + 1));\n        }\n    }\n    return -1;\n  }\n\n  private Node getNodeWithMinDistance(Map<Node, Integer> unvisitedNodes) {\n    int min = Integer.MAX_VALUE;\n    Node minNode = null;\n    for (Node node : unvisitedNodes.keySet()) {\n      if (unvisitedNodes.get(node) < min) {\n        min = unvisitedNodes.get(node);\n        minNode = node;\n      }\n    }\n    return minNode",
        "public int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n    int n = length_by_edge.size();\n    Map<Node, Integer> unvisitedNodes = new HashMap<>();\n    Set<Node> visitedNodes = new HashSet<>();\n    unvisitedNodes.put(startnode, 0);\n    while (!unvisitedNodes.isEmpty()) {\n        Node node = getNodeWithMinDistance(unvisitedNodes);\n        int distance = unvisitedNodes.get(node);\n        unvisitedNodes.remove(node);\n        if (node.getValue() == goalnode.getValue()) {\n            return distance;\n        }\n        visitedNodes.add(node);\n        for (Node nextnode : node.getSuccessors()) {\n            if (visitedNodes.contains(nextnode)) {\n                continue;\n            }\n            if (unvisitedNodes.get(nextnode) == null) {\n                unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n            }\n            unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode), distance + 1));\n        }\n    }\n    return -1;\n  }\n\n  private Node getNodeWithMinDistance(Map<Node, Integer> unvisitedNodes) {\n    int min = Integer.MAX_VALUE;\n    Node minnode = null;\n    for (Node node : unvisitedNodes.keySet()) {\n        if (unvisitedNodes.get(node) < min) {\n            min = unvisitedNodes.get(node);\n            minnode = node;\n        }\n    }\n    return minnode",
        "public int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n    int n = length_by_edge.size();\n    Map<Node, Integer> unvisitedNodes = new HashMap<>();\n    Set<Node> visitedNodes = new HashSet<>();\n    unvisitedNodes.put(startnode, 0);\n    while (!unvisitedNodes.isEmpty()) {\n        Node node = getNodeWithMinDistance(unvisitedNodes);\n        int distance = unvisitedNodes.get(node);\n        unvisitedNodes.remove(node);\n        if (node.getValue() == goalnode.getValue()) {\n            return distance;\n        }\n        visitedNodes.add(node);\n        for (Node nextnode : node.getSuccessors()) {\n            if (visitedNodes.contains(nextnode)) {\n                continue;\n            }\n            if (unvisitedNodes.get(nextnode) == null) {\n                unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n            }\n            unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode), distance + 1));\n        }\n    }\n    return -1;\n  }\n\n  private Node getNodeWithMinDistance(Map<Node, Integer> unvisitedNodes) {\n    int min = Integer.MAX_VALUE;\n    Node minNode = null;\n    for (Node node : unvisitedNodes.keySet()) {\n        if (unvisitedNodes.get(node) < min) {\n            min = unvisitedNodes.get(node);\n            minNode = node;\n        }\n    }\n    return minNode",
        "public int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n    int n = length_by_edge.size();\n    Map<Node, Integer> unvisitedNodes = new HashMap<>();\n    Set<Node> visitedNodes = new HashSet<>();\n    unvisitedNodes.put(startnode, 0);\n    while (!unvisitedNodes.isEmpty()) {\n        Node node = getNodeWithMinDistance(unvisitedNodes);\n        int distance = unvisitedNodes.get(node);\n        unvisitedNodes.remove(node);\n        if (node.getValue() == goalnode.getValue()) {\n            return distance;\n        }\n        visitedNodes.add(node);\n        for (Node nextnode : node.getSuccessors()) {\n            if (visitedNodes.contains(nextnode)) {\n                continue;\n            }\n            if (unvisitedNodes.get(nextnode) == null) {\n                unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n            }\n            unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode), distance + 1));\n        }\n    }\n    return -1;\n  }\n\n  private Node getNodeWithMinDistance(Map<Node, Integer> unvisitedNodes) {\n    int min = Integer.MAX_VALUE;\n    Node result = null;\n    for (Node node : unvisitedNodes.keySet()) {\n      if (unvisitedNodes.get(node) < min) {\n        min = unvisitedNodes.get(node);\n        result = node;\n      }\n    }\n    return result;\n  "
      ]
    },
    "SHORTEST_PATH_LENGTHS": {
      "loc": "38-39",
      "input": "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n    Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n        for (int j =0; j < numNodes; j++) {\n            List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n            if (i == j) {\n                length_by_path.put(edge, 0);\n            }\n            else if (length_by_edge.containsKey(edge) ) {\n                length_by_path.put(edge, length_by_edge.get(edge));\n            } else {\n                length_by_path.put(edge, INF);\n            }\n        }\n    }\n    for (int k = 0; k < numNodes; k++) {\n        for (int i = 0; i < numNodes; i++) {\n            for (int j = 0; j < numNodes; j++) {\n                int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),",
      "function range": "19,5-44,5",
      "output": [
        "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n    Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n        for (int j =0; j < numNodes; j++) {\n            List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n            if (i == j) {\n                length_by_path.put(edge, 0);\n            }\n            else if (length_by_edge.containsKey(edge) ) {\n                length_by_path.put(edge, length_by_edge.get(edge));\n            } else {\n                length_by_path.put(edge, INF);\n            }\n        }\n    }\n    for (int k = 0; k < numNodes; k++) {\n        for (int i = 0; i < numNodes; i++) {\n            for (int j = 0; j < numNodes; j++) {\n                int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)), length_by_path.get(Arrays.asList(i,k)) + length_by_path.get(Arrays.asList(k,j)));\n                length_by_path.put(Arrays.asList(i,j), update_length);\n            }\n        }\n    }\n    return length_by_path;\n}\n}\n",
        "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n    Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n        for (int j =0; j < numNodes; j++) {\n            List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n            if (i == j) {\n                length_by_path.put(edge, 0);\n            }\n            else if (length_by_edge.containsKey(edge) ) {\n                length_by_path.put(edge, length_by_edge.get(edge));\n            } else {\n                length_by_path.put(edge, INF);\n            }\n        }\n    }\n    for (int k = 0; k < numNodes; k++) {\n        for (int i = 0; i < numNodes; i++) {\n            for (int j = 0; j < numNodes; j++) {\n                int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)), length_by_path.get(Arrays.asList(i,k)) + length_by_path.get(Arrays.asList(k,j)));\n                length_by_path.put(Arrays.asList(i,j), update_length);\n                length_by_path.put(Arrays.asList(i,k), update_length);\n                length_by_path.put(Arrays.asList(k,j), update_length);\n            }\n        }\n    }\n    return length_by_path;",
        "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n    Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n        for (int j =0; j < numNodes; j++) {\n            List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n            if (i == j) {\n                length_by_path.put(edge, 0);\n            }\n            else if (length_by_edge.containsKey(edge) ) {\n                length_by_path.put(edge, length_by_edge.get(edge));\n            } else {\n                length_by_path.put(edge, INF);\n            }\n        }\n    }\n    for (int k = 0; k < numNodes; k++) {\n        for (int i = 0; i < numNodes; i++) {\n            for (int j = 0; j < numNodes; j++) {\n                int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)), length_by_path.get(Arrays.asList(i,k)) + length_by_path.get(Arrays.asList(k,j)));\n                length_by_path.put(Arrays.asList(i,j), update_length);\n            }\n        }\n    }\n    return length_by_path;\n}\n",
        "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n    Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n        for (int j =0; j < numNodes; j++) {\n            List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n            if (i == j) {\n                length_by_path.put(edge, 0);\n            }\n            else if (length_by_edge.containsKey(edge) ) {\n                length_by_path.put(edge, length_by_edge.get(edge));\n            } else {\n                length_by_path.put(edge, INF);\n            }\n        }\n    }\n    for (int k = 0; k < numNodes; k++) {\n        for (int i = 0; i < numNodes; i++) {\n            for (int j = 0; j < numNodes; j++) {\n                int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)), length_by_path.get(Arrays.asList(i,k)) + length_by_path.get(Arrays.asList(k,j)));\n                length_by_path.put(Arrays.asList(i,j), update_length);\n            }\n        }\n    }\n    return length_by_path;\n}\n\n}\n",
        "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n    Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n        for (int j =0; j < numNodes; j++) {\n            List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n            if (i == j) {\n                length_by_path.put(edge, 0);\n            }\n            else if (length_by_edge.containsKey(edge) ) {\n                length_by_path.put(edge, length_by_edge.get(edge));\n            } else {\n                length_by_path.put(edge, INF);\n            }\n        }\n    }\n    for (int k = 0; k < numNodes; k++) {\n        for (int i = 0; i < numNodes; i++) {\n            for (int j = 0; j < numNodes; j++) {\n                int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)), length_by_path.get(Arrays.asList(i,k)) + length_by_path.get(Arrays.asList(k,j)));\n                length_by_path.put(Arrays.asList(i,j), update_length);\n                length_by_path.put(Arrays.asList(i,k), update_length + length_by_path.get(Arrays.asList(i,k)));\n                length_by_path.put(Arrays.asList(k,j), update_length",
        "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n    Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n        for (int j =0; j < numNodes; j++) {\n            List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n            if (i == j) {\n                length_by_path.put(edge, 0);\n            }\n            else if (length_by_edge.containsKey(edge) ) {\n                length_by_path.put(edge, length_by_edge.get(edge));\n            } else {\n                length_by_path.put(edge, INF);\n            }\n        }\n    }\n    for (int k = 0; k < numNodes; k++) {\n        for (int i = 0; i < numNodes; i++) {\n            for (int j = 0; j < numNodes; j++) {\n                int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                             length_by_path.get(Arrays.asList(i,k)) + length_by_path.get(Arrays.asList(k,j)));\n                length_by_path.put(Arrays.asList(i,j), update_length);\n            }\n        }\n    }\n    return length_by_path;\n}\n}\n",
        "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n    Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n        for (int j =0; j < numNodes; j++) {\n            List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n            if (i == j) {\n                length_by_path.put(edge, 0);\n            }\n            else if (length_by_edge.containsKey(edge) ) {\n                length_by_path.put(edge, length_by_edge.get(edge));\n            } else {\n                length_by_path.put(edge, INF);\n            }\n        }\n    }\n    for (int k = 0; k < numNodes; k++) {\n        for (int i = 0; i < numNodes; i++) {\n            for (int j = 0; j < numNodes; j++) {\n                int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                             length_by_path.get(Arrays.asList(i,k)) +\n                                             length_by_path.get(Arrays.asList(k,j)));\n                length_by_path.put(Arrays.asList(i,j), update_length);\n            }\n        }\n    }\n    return length_by_path;\n}\n}\n",
        "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n    Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n        for (int j =0; j < numNodes; j++) {\n            List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n            if (i == j) {\n                length_by_path.put(edge, 0);\n            }\n            else if (length_by_edge.containsKey(edge) ) {\n                length_by_path.put(edge, length_by_edge.get(edge));\n            } else {\n                length_by_path.put(edge, INF);\n            }\n        }\n    }\n    for (int k = 0; k < numNodes; k++) {\n        for (int i = 0; i < numNodes; i++) {\n            for (int j = 0; j < numNodes; j++) {\n                int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                             length_by_path.get(Arrays.asList(i,k)) + length_by_path.get(Arrays.asList(k,j)));\n                length_by_path.put(Arrays.asList(i,j), update_length);\n            }\n        }\n    }\n    return length_by_path;\n}\n\n}\n",
        "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n    Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n        for (int j =0; j < numNodes; j++) {\n            List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n            if (i == j) {\n                length_by_path.put(edge, 0);\n            }\n            else if (length_by_edge.containsKey(edge) ) {\n                length_by_path.put(edge, length_by_edge.get(edge));\n            } else {\n                length_by_path.put(edge, INF);\n            }\n        }\n    }\n    for (int k = 0; k < numNodes; k++) {\n        for (int i = 0; i < numNodes; i++) {\n            for (int j = 0; j < numNodes; j++) {\n                int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)), length_by_path.get(Arrays.asList(i,k)) + length_by_path.get(Arrays.asList(k,j)));\n                length_by_path.put(Arrays.asList(i,j), update_length);\n            }\n        }\n    }\n    return length_by_path;\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int numNodes = in.nextInt();\n    int numEdges = in",
        "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n    Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n        for (int j =0; j < numNodes; j++) {\n            List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n            if (i == j) {\n                length_by_path.put(edge, 0);\n            }\n            else if (length_by_edge.containsKey(edge) ) {\n                length_by_path.put(edge, length_by_edge.get(edge));\n            } else {\n                length_by_path.put(edge, INF);\n            }\n        }\n    }\n    for (int k = 0; k < numNodes; k++) {\n        for (int i = 0; i < numNodes; i++) {\n            for (int j = 0; j < numNodes; j++) {\n                int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)), length_by_path.get(Arrays.asList(i,k)) + length_by_path.get(Arrays.asList(k,j)));\n                length_by_path.put(Arrays.asList(i,j), update_length);\n            }\n        }\n    }\n    return length_by_path;\n}\n\npublic static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    int numNodes = scanner.nextInt();\n    int numEdges = scanner"
      ]
    },
    "SHORTEST_PATHS": {
      "loc": "30-31",
      "input": "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n    Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n    for (List<String> edge : weight_by_edge.keySet()) {\n            weight_by_node.put(edge.get(1), INF);\n            weight_by_node.put(edge.get(0), INF);\n    }\n    weight_by_node.put(source, 0);\n    for (int i = 0; i < weight_by_node.size(); i++) {\n        for (List<String> edge : weight_by_edge.keySet()) {\n            int update_weight = Math.min(\n                    weight_by_node.get(edge.get(0))\n                            + weight_by_edge.get(edge),\n                    weight_by_node.get(edge.get(1)));",
      "function range": "16,5-34,5",
      "output": [
        "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n    Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n    for (List<String> edge : weight_by_edge.keySet()) {\n            weight_by_node.put(edge.get(1), INF);\n            weight_by_node.put(edge.get(0), INF);\n    }\n    weight_by_node.put(source, 0);\n    for (int i = 0; i < weight_by_node.size(); i++) {\n        for (List<String> edge : weight_by_edge.keySet()) {\n            int update_weight = Math.min(\n                    weight_by_node.get(edge.get(0))\n                            + weight_by_edge.get(edge),\n                    weight_by_node.get(edge.get(1)));\n            weight_by_node.put(edge.get(1), update_weight);\n        }\n    }\n    return weight_by_node;\n}\n}\n",
        "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n    Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n    for (List<String> edge : weight_by_edge.keySet()) {\n            weight_by_node.put(edge.get(1), INF);\n            weight_by_node.put(edge.get(0), INF);\n    }\n    weight_by_node.put(source, 0);\n    for (int i = 0; i < weight_by_node.size(); i++) {\n        for (List<String> edge : weight_by_edge.keySet()) {\n            int update_weight = Math.min(\n                    weight_by_node.get(edge.get(0))\n                            + weight_by_edge.get(edge),\n                    weight_by_node.get(edge.get(1)));\n            weight_by_node.put(edge.get(1), update_weight);\n        }\n    }\n    return weight_by_node;\n}\n",
        "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n    Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n    for (List<String> edge : weight_by_edge.keySet()) {\n            weight_by_node.put(edge.get(1), INF);\n            weight_by_node.put(edge.get(0), INF);\n    }\n    weight_by_node.put(source, 0);\n    for (int i = 0; i < weight_by_node.size(); i++) {\n        for (List<String> edge : weight_by_edge.keySet()) {\n            int update_weight = Math.min(\n                    weight_by_node.get(edge.get(0))\n                            + weight_by_edge.get(edge),\n                    weight_by_node.get(edge.get(1)));\n            weight_by_node.put(edge.get(0), update_weight);\n            weight_by_node.put(edge.get(1), update_weight);\n        }\n    }\n    return weight_by_node;\n}\n}\n",
        "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n    Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n    for (List<String> edge : weight_by_edge.keySet()) {\n            weight_by_node.put(edge.get(1), INF);\n            weight_by_node.put(edge.get(0), INF);\n    }\n    weight_by_node.put(source, 0);\n    for (int i = 0; i < weight_by_node.size(); i++) {\n        for (List<String> edge : weight_by_edge.keySet()) {\n            int update_weight = Math.min(\n                    weight_by_node.get(edge.get(0))\n                            + weight_by_edge.get(edge),\n                    weight_by_node.get(edge.get(1)));\n            weight_by_node.put(edge.get(1), update_weight);\n        }\n    }\n    return weight_by_node;\n}\n\n}\n",
        "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n    Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n    for (List<String> edge : weight_by_edge.keySet()) {\n            weight_by_node.put(edge.get(1), INF);\n            weight_by_node.put(edge.get(0), INF);\n    }\n    weight_by_node.put(source, 0);\n    for (int i = 0; i < weight_by_node.size(); i++) {\n        for (List<String> edge : weight_by_edge.keySet()) {\n            int update_weight = Math.min(\n                    weight_by_node.get(edge.get(0))\n                            + weight_by_edge.get(edge),\n                    weight_by_node.get(edge.get(1)));\n            weight_by_node.put(edge.get(0), update_weight);\n        }\n    }\n    return weight_by_node;\n}\n}\n",
        "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n    Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n    for (List<String> edge : weight_by_edge.keySet()) {\n            weight_by_node.put(edge.get(1), INF);\n            weight_by_node.put(edge.get(0), INF);\n    }\n    weight_by_node.put(source, 0);\n    for (int i = 0; i < weight_by_node.size(); i++) {\n        for (List<String> edge : weight_by_edge.keySet()) {\n            int update_weight = Math.min(\n                    weight_by_node.get(edge.get(0))\n                            + weight_by_edge.get(edge),\n                    weight_by_node.get(edge.get(1)));\n            weight_by_node.put(edge.get(1), update_weight);\n            weight_by_node.put(edge.get(0), update_weight);\n        }\n    }\n    return weight_by_node;\n}\n}\n",
        "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n    Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n    for (List<String> edge : weight_by_edge.keySet()) {\n            weight_by_node.put(edge.get(1), INF);\n            weight_by_node.put(edge.get(0), INF);\n    }\n    weight_by_node.put(source, 0);\n    for (int i = 0; i < weight_by_node.size(); i++) {\n        for (List<String> edge : weight_by_edge.keySet()) {\n            int update_weight = Math.min(\n                    weight_by_node.get(edge.get(0))\n                            + weight_by_edge.get(edge),\n                    weight_by_node.get(edge.get(1)));\n            weight_by_node.put(edge.get(0), update_weight);\n            weight_by_node.put(edge.get(1), update_weight);\n        }\n    }\n    return weight_by_node;\n}\n",
        "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n    Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n    for (List<String> edge : weight_by_edge.keySet()) {\n            weight_by_node.put(edge.get(1), INF);\n            weight_by_node.put(edge.get(0), INF);\n    }\n    weight_by_node.put(source, 0);\n    for (int i = 0; i < weight_by_node.size(); i++) {\n        for (List<String> edge : weight_by_edge.keySet()) {\n            int update_weight = Math.min(\n                    weight_by_node.get(edge.get(0))\n                            + weight_by_edge.get(edge),\n                    weight_by_node.get(edge.get(1)));\n            weight_by_node.put(edge.get(0), update_weight);\n            weight_by_node.put(edge.get(1), update_weight);\n        }\n    }\n    return weight_by_node;\n}\n\n}\n",
        "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n    Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n    for (List<String> edge : weight_by_edge.keySet()) {\n            weight_by_node.put(edge.get(1), INF);\n            weight_by_node.put(edge.get(0), INF);\n    }\n    weight_by_node.put(source, 0);\n    for (int i = 0; i < weight_by_node.size(); i++) {\n        for (List<String> edge : weight_by_edge.keySet()) {\n            int update_weight = Math.min(\n                    weight_by_node.get(edge.get(0))\n                            + weight_by_edge.get(edge),\n                    weight_by_node.get(edge.get(1)));\n            weight_by_node.put(edge.get(0), update_weight);\n            weight_by_node.put(edge.get(1), update_weight);\n        }\n    }\n    return weight_by_node;\n}",
        "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n    Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n    for (List<String> edge : weight_by_edge.keySet()) {\n            weight_by_node.put(edge.get(1), INF);\n            weight_by_node.put(edge.get(0), INF);\n    }\n    weight_by_node.put(source, 0);\n    for (int i = 0; i < weight_by_node.size(); i++) {\n        for (List<String> edge : weight_by_edge.keySet()) {\n            int update_weight = Math.min(\n                    weight_by_node.get(edge.get(0))\n                            + weight_by_edge.get(edge),\n                    weight_by_node.get(edge.get(1)));\n            weight_by_node.put(edge.get(0), update_weight);\n            weight_by_node.put(edge.get(1), update_weight);\n        }\n    }\n    return weight_by_node;\n  }\n}\n"
      ]
    },
    "SHUNTING_YARD": {
      "loc": "34-34",
      "input": "public static List shunting_yard(ArrayList tokens) {\n    Map<String, Integer> precedence = new HashMap<String, Integer>();\n    precedence.put(\"+\",1);\n    precedence.put(\"-\",1);\n    precedence.put(\"*\",2);\n    precedence.put(\"/\",2);\n    ArrayList rpntokens = new ArrayList(100);\n    ArrayDeque opstack = new ArrayDeque();\n    for (Object token: tokens) {\n        if (Integer.class.isInstance(token)) {\n            rpntokens.add((Integer) token);\n        } else {\n            String operator = (String) token;\n            while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                rpntokens.add(opstack.pop());\n            }",
      "function range": "15,5-42,5",
      "output": [
        "public static List shunting_yard(ArrayList tokens) {\n    Map<String, Integer> precedence = new HashMap<String, Integer>();\n    precedence.put(\"+\",1);\n    precedence.put(\"-\",1);\n    precedence.put(\"*\",2);\n    precedence.put(\"/\",2);\n    ArrayList rpntokens = new ArrayList(100);\n    ArrayDeque opstack = new ArrayDeque();\n    for (Object token: tokens) {\n        if (Integer.class.isInstance(token)) {\n            rpntokens.add((Integer) token);\n        } else {\n            String operator = (String) token;\n            while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                rpntokens.add(opstack.pop());\n            }\n            opstack.push(operator);\n        }\n    }\n    while (!opstack.isEmpty()) {\n        rpntokens.add(opstack.pop());\n    }\n    return rpntokens;\n}\n}\n",
        "public static List shunting_yard(ArrayList tokens) {\n    Map<String, Integer> precedence = new HashMap<String, Integer>();\n    precedence.put(\"+\",1);\n    precedence.put(\"-\",1);\n    precedence.put(\"*\",2);\n    precedence.put(\"/\",2);\n    ArrayList rpntokens = new ArrayList(100);\n    ArrayDeque opstack = new ArrayDeque();\n    for (Object token: tokens) {\n        if (Integer.class.isInstance(token)) {\n            rpntokens.add((Integer) token);\n        } else {\n            String operator = (String) token;\n            while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                rpntokens.add(opstack.pop());\n            }\n            rpntokens.add(operator);\n            opstack.push(operator);\n        }\n    }\n    while (!opstack.isEmpty()) {\n        rpntokens.add(opstack.pop());\n    }\n    return rpntokens;\n}\n}\n",
        "public static List shunting_yard(ArrayList tokens) {\n    Map<String, Integer> precedence = new HashMap<String, Integer>();\n    precedence.put(\"+\",1);\n    precedence.put(\"-\",1);\n    precedence.put(\"*\",2);\n    precedence.put(\"/\",2);\n    ArrayList rpntokens = new ArrayList(100);\n    ArrayDeque opstack = new ArrayDeque();\n    for (Object token: tokens) {\n        if (Integer.class.isInstance(token)) {\n            rpntokens.add((Integer) token);\n        } else {\n            String operator = (String) token;\n            while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                rpntokens.add(opstack.pop());\n            }\n            opstack.push(operator);\n        }\n    }\n    while (!opstack.isEmpty()) {\n        rpntokens.add(opstack.pop());\n    }\n    return rpntokens;\n}\n\n}\n",
        "public static List shunting_yard(ArrayList tokens) {\n    Map<String, Integer> precedence = new HashMap<String, Integer>();\n    precedence.put(\"+\",1);\n    precedence.put(\"-\",1);\n    precedence.put(\"*\",2);\n    precedence.put(\"/\",2);\n    ArrayList rpntokens = new ArrayList(100);\n    ArrayDeque opstack = new ArrayDeque();\n    for (Object token: tokens) {\n        if (Integer.class.isInstance(token)) {\n            rpntokens.add((Integer) token);\n        } else {\n            String operator = (String) token;\n            while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                rpntokens.add(opstack.pop());\n            }\n            opstack.push(operator);\n        }\n    }\n    while (!opstack.isEmpty()) {\n        rpntokens.add(opstack.pop());\n    }\n    return rpntokens;\n  }\n}\n",
        "public static List shunting_yard(ArrayList tokens) {\n    Map<String, Integer> precedence = new HashMap<String, Integer>();\n    precedence.put(\"+\",1);\n    precedence.put(\"-\",1);\n    precedence.put(\"*\",2);\n    precedence.put(\"/\",2);\n    ArrayList rpntokens = new ArrayList(100);\n    ArrayDeque opstack = new ArrayDeque();\n    for (Object token: tokens) {\n        if (Integer.class.isInstance(token)) {\n            rpntokens.add((Integer) token);\n        } else {\n            String operator = (String) token;\n            while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                rpntokens.add(opstack.pop());\n            }\n            opstack.push(operator);\n            rpntokens.add(token);\n        }\n    }\n    while (!opstack.isEmpty()) {\n        rpntokens.add(opstack.pop());\n    }\n    return rpntokens;\n}\n}\n",
        "public static List shunting_yard(ArrayList tokens) {\n    Map<String, Integer> precedence = new HashMap<String, Integer>();\n    precedence.put(\"+\",1);\n    precedence.put(\"-\",1);\n    precedence.put(\"*\",2);\n    precedence.put(\"/\",2);\n    ArrayList rpntokens = new ArrayList(100);\n    ArrayDeque opstack = new ArrayDeque();\n    for (Object token: tokens) {\n        if (Integer.class.isInstance(token)) {\n            rpntokens.add((Integer) token);\n        } else {\n            String operator = (String) token;\n            while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                rpntokens.add(opstack.pop());\n            }\n            rpntokens.add(operator);\n            opstack.push(operator);\n        }\n    }\n    while (!opstack.isEmpty()) {\n        rpntokens.add(opstack.pop());\n    }\n    return rpntokens;\n}\n\n}\n",
        "public static List shunting_yard(ArrayList tokens) {\n    Map<String, Integer> precedence = new HashMap<String, Integer>();\n    precedence.put(\"+\",1);\n    precedence.put(\"-\",1);\n    precedence.put(\"*\",2);\n    precedence.put(\"/\",2);\n    ArrayList rpntokens = new ArrayList(100);\n    ArrayDeque opstack = new ArrayDeque();\n    for (Object token: tokens) {\n        if (Integer.class.isInstance(token)) {\n            rpntokens.add((Integer) token);\n        } else {\n            String operator = (String) token;\n            while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                rpntokens.add(opstack.pop());\n            }\n            rpntokens.add(operator);\n            opstack.push(operator);\n        }\n    }\n    while (!opstack.isEmpty()) {\n        rpntokens.add(opstack.pop());\n    }\n    return rpntokens;\n  }\n}\n",
        "public static List shunting_yard(ArrayList tokens) {\n    Map<String, Integer> precedence = new HashMap<String, Integer>();\n    precedence.put(\"+\",1);\n    precedence.put(\"-\",1);\n    precedence.put(\"*\",2);\n    precedence.put(\"/\",2);\n    ArrayList rpntokens = new ArrayList(100);\n    ArrayDeque opstack = new ArrayDeque();\n    for (Object token: tokens) {\n        if (Integer.class.isInstance(token)) {\n            rpntokens.add((Integer) token);\n        } else {\n            String operator = (String) token;\n            while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                rpntokens.add(opstack.pop());\n            }\n            rpntokens.add(operator);\n        }\n    }\n    while (!opstack.isEmpty()) {\n        rpntokens.add(opstack.pop());\n    }\n    return rpntokens;\n}\n}\n",
        "public static List shunting_yard(ArrayList tokens) {\n    Map<String, Integer> precedence = new HashMap<String, Integer>();\n    precedence.put(\"+\",1);\n    precedence.put(\"-\",1);\n    precedence.put(\"*\",2);\n    precedence.put(\"/\",2);\n    ArrayList rpntokens = new ArrayList(100);\n    ArrayDeque opstack = new ArrayDeque();\n    for (Object token: tokens) {\n        if (Integer.class.isInstance(token)) {\n            rpntokens.add((Integer) token);\n        } else {\n            String operator = (String) token;\n            while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                rpntokens.add(opstack.pop());\n            }\n            opstack.push(operator);\n            rpntokens.add(token);\n        }\n    }\n    while (!opstack.isEmpty()) {\n        rpntokens.add(opstack.pop());\n    }\n    return rpntokens;\n}\n\n}\n",
        "public static List shunting_yard(ArrayList tokens) {\n    Map<String, Integer> precedence = new HashMap<String, Integer>();\n    precedence.put(\"+\",1);\n    precedence.put(\"-\",1);\n    precedence.put(\"*\",2);\n    precedence.put(\"/\",2);\n    ArrayList rpntokens = new ArrayList(100);\n    ArrayDeque opstack = new ArrayDeque();\n    for (Object token: tokens) {\n        if (Integer.class.isInstance(token)) {\n            rpntokens.add((Integer) token);\n        } else {\n            String operator = (String) token;\n            while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                rpntokens.add(opstack.pop());\n            }\n            rpntokens.add(operator);\n            opstack.push(operator);\n        }\n    }\n    while (!opstack.isEmpty()) {\n        rpntokens.add(opstack.pop());\n    }\n    return rpntokens;\n}\n\npublic static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    int n = scanner.nextInt();\n    ArrayList tokens = new ArrayList(n);\n    for (int i = 0; i < n;"
      ]
    },
    "SIEVE": {
      "loc": "41-42",
      "input": "public static ArrayList<Integer> sieve(Integer max) {\n    ArrayList<Integer> primes = new ArrayList<Integer>();\n    for (int n=2; n<max+1; n++) {",
      "function range": "38,5-46,5",
      "output": [
        "public static ArrayList<Integer> sieve(Integer max) {\n    ArrayList<Integer> primes = new ArrayList<Integer>();\n    for (int n=2; n<max+1; n++) {\n      if (isPrime(n)) {\n        primes.add(n);\n      }\n    }\n    return primes;\n  }\n}\n",
        "public static ArrayList<Integer> sieve(Integer max) {\n    ArrayList<Integer> primes = new ArrayList<Integer>();\n    for (int n=2; n<max+1; n++) {\n      boolean isPrime = true;\n      for (int i=2; i*i<=n; i++) {\n        if (n % i == 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        primes.add(n);\n      }\n    }\n    return primes;\n  }\n}\n",
        "public static ArrayList<Integer> sieve(Integer max) {\n    ArrayList<Integer> primes = new ArrayList<Integer>();\n    for (int n=2; n<max+1; n++) {\n      if (isPrime(n)) {\n        primes.add(n);\n      }\n    }\n    return primes;\n  }\n\n}\n",
        "public static ArrayList<Integer> sieve(Integer max) {\n    ArrayList<Integer> primes = new ArrayList<Integer>();\n    for (int n=2; n<max+1; n++) {\n      boolean isPrime = true;\n      for (int i=2; i*i<=n; i++) {\n        if (n % i == 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        primes.add(n);\n      }\n    }\n    return primes;\n  }\n\n}\n",
        "public static ArrayList<Integer> sieve(Integer max) {\n    ArrayList<Integer> primes = new ArrayList<Integer>();\n    for (int n=2; n<max+1; n++) {\n      boolean isPrime = true;\n      for (int i=2; i*i<=n; i++) {\n        if (n % i == 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) primes.add(n);\n    }\n    return primes;\n  }\n}\n",
        "public static ArrayList<Integer> sieve(Integer max) {\n    ArrayList<Integer> primes = new ArrayList<Integer>();\n    for (int n=2; n<max+1; n++) {\n      boolean isPrime = true;\n      for (int i=2; i*i<=n; i++) {\n        if (n % i == 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        primes.add(n);\n      }\n    }\n    return primes;\n  }\n}",
        "public static ArrayList<Integer> sieve(Integer max) {\n    ArrayList<Integer> primes = new ArrayList<Integer>();\n    for (int n=2; n<max+1; n++) {\n      if (isPrime(n)) primes.add(n);\n    }\n    return primes;\n  }\n}\n",
        "public static ArrayList<Integer> sieve(Integer max) {\n    ArrayList<Integer> primes = new ArrayList<Integer>();\n    for (int n=2; n<max+1; n++) {\n      boolean isPrime = true;\n      for (int i=2; i*i<=n; i++) {\n        if (n % i == 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime)\n        primes.add(n);\n    }\n    return primes;\n  }\n}\n",
        "public static ArrayList<Integer> sieve(Integer max) {\n    ArrayList<Integer> primes = new ArrayList<Integer>();\n    for (int n=2; n<max+1; n++) {\n      boolean isPrime = true;\n      for (int i=2; i*i<=n; i++) {\n        if (n % i == 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        primes.add(n);\n      }\n    }\n    return primes;\n  }\n  \n}\n",
        "public static ArrayList<Integer> sieve(Integer max) {\n    ArrayList<Integer> primes = new ArrayList<Integer>();\n    for (int n=2; n<max+1; n++) {\n      boolean isPrime = true;\n      for (int i=2; i*i<=n; i++) {\n        if (n % i == 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        primes.add(n);\n      }\n    }\n    return primes;\n  }\n  \n  public static void main(String[] args) {\n    ArrayList<Integer> primes = sieve(Integer.parseInt(args[0]));\n    for"
      ]
    },
    "SQRT": {
      "loc": "16-17",
      "input": "public static double sqrt(double x, double epsilon) {\n    double approx = x / 2f;",
      "function range": "14,5-20,5",
      "output": [
        "public static double sqrt(double x, double epsilon) {\n    double approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static float sqrt(float x, float epsilon) {\n    float approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static float sqrt(float x) {\n    float approx = x / 2f;\n    while (approx * approx > x) {\n      app",
        "public static double sqrt(double x, double epsilon) {\n    double approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static float sqrt(float x, float epsilon) {\n    float approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static int sqrt(int x, int epsilon) {\n    int approx = x / 2;\n    while (approx * approx > x)",
        "public static double sqrt(double x, double epsilon) {\n    double approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static float sqrt(float x, float epsilon) {\n    float approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static double pow(double x, double y) {\n    return Math.pow(x, y);\n  }\n\n  public static float pow(float",
        "public static double sqrt(double x, double epsilon) {\n    double approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static float sqrt(float x, float epsilon) {\n    float approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n}\n",
        "public static double sqrt(double x, double epsilon) {\n    double approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static float sqrt(float x, float epsilon) {\n    float approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static float pow(float x, float y) {\n    return (float) Math.pow(x, y);\n  }\n\n  public static float",
        "public static double sqrt(double x, double epsilon) {\n    double approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static float sqrt(float x, float epsilon) {\n    float approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static double cbrt(double x, double epsilon) {\n    double approx = x / 3f;\n    while (approx * approx *",
        "public static double sqrt(double x, double epsilon) {\n    double approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static float sqrt(float x, float epsilon) {\n    float approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static float pow(float x, float y) {\n    return (float) Math.pow(x, y);\n  }\n\n  public static double",
        "public static double sqrt(double x, double epsilon) {\n    double approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static float sqrt(float x, float epsilon) {\n    float approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static float sqrt(float x) {\n    return (float) Math.sqrt(x);\n  }\n\n  public static double sqrt(double",
        "public static double sqrt(double x, double epsilon) {\n    double approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static float sqrt(float x, float epsilon) {\n    float approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static float sqrt(float x) {\n    return (float) Math.sqrt(x);\n  }\n\n  public static float sqrt(float",
        "public static double sqrt(double x, double epsilon) {\n    double approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n  public static float sqrt(float x, float epsilon) {\n    float approx = x / 2f;\n    while (approx * approx > x) {\n      approx /= 2f;\n    }\n    return approx;\n  }\n\n}\n"
      ]
    },
    "SUBSEQUENCES": {
      "loc": "16-17",
      "input": "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n    if (k == 0) {",
      "function range": "14,5-31,5",
      "output": [
        "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n    if (k == 0) {\n        ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n        result.add(new ArrayList<Integer>());\n        return result;\n    }\n    ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n    for (ArrayList<Integer> list : subsequences(a, b, k - 1)) {\n        ArrayList<Integer> newList = new ArrayList<Integer>();\n        for (int i = 0; i < list.size(); i++) {\n            newList.add(list.get(i));",
        "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n    if (k == 0) {\n        ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n        result.add(new ArrayList<Integer>());\n        return result;\n    }\n    ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n    for (ArrayList<Integer> list : subsequences(a, b, k - 1)) {\n        for (int i = 0; i < list.size(); i++) {\n            list.set(i, list.get(i) + a);\n        }\n        result.add(list);\n    ",
        "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n    if (k == 0) {\n        ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n        result.add(new ArrayList<Integer>());\n        return result;\n    }\n    ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n    for (ArrayList<Integer> list : subsequences(a, b, k - 1)) {\n        ArrayList<Integer> newList = new ArrayList<Integer>(list);\n        newList.add(a + b);\n        result.add(newList);\n    }\n    return result;\n}",
        "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n    if (k == 0) {\n        ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n        result.add(new ArrayList<Integer>());\n        return result;\n    }\n    ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n    for (ArrayList<Integer> list : subsequences(a, b, k - 1)) {\n        for (int i = 0; i < list.size(); i++) {\n            ArrayList<Integer> newList = new ArrayList<Integer>(list);\n            newList.add(list.get(i",
        "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n    if (k == 0) {\n        ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n        result.add(new ArrayList<Integer>());\n        return result;\n    }\n    ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n    for (ArrayList<Integer> list : subsequences(a, b, k - 1)) {\n        for (int i = 0; i < list.size(); i++) {\n            ArrayList<Integer> newList = new ArrayList<Integer>(list);\n            newList.add(newList.get(",
        "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n    if (k == 0) {\n        ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n        result.add(new ArrayList<Integer>());\n        return result;\n    }\n    ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n    for (ArrayList<Integer> list : subsequences(a, b, k - 1)) {\n        ArrayList<Integer> newList = new ArrayList<Integer>();\n        for (int i = 0; i < list.size(); i++) {\n            newList.add(list.get(i)",
        "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n    if (k == 0) {\n        ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n        result.add(new ArrayList<Integer>());\n        return result;\n    }\n    ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n    for (ArrayList<Integer> list : subsequences(a, b, k - 1)) {\n        ArrayList<Integer> newList = new ArrayList<Integer>(list);\n        newList.add(b);\n        result.add(newList);\n    }\n    return result;\n}\n\n",
        "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n    if (k == 0) {\n        ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n        result.add(new ArrayList<Integer>());\n        return result;\n    }\n    ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n    for (ArrayList<Integer> list : subsequences(a, b, k - 1)) {\n        for (int i = 0; i < list.size(); i++) {\n            list.set(i, list.get(i) + a);\n        }\n        result.add(list);\n        ",
        "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n    if (k == 0) {\n        ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n        result.add(new ArrayList<Integer>());\n        return result;\n    }\n    ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n    for (ArrayList<Integer> list : subsequences(a, b, k - 1)) {\n        for (int i = 0; i < list.size(); i++) {\n            list.set(i, a + list.get(i));\n        }\n        result.add(list);\n    }",
        "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n    if (k == 0) {\n        ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n        result.add(new ArrayList<Integer>());\n        return result;\n    }\n    ArrayList<ArrayList> result = new ArrayList<ArrayList>();\n    for (ArrayList<Integer> list : subsequences(a, b, k - 1)) {\n        for (int i = 0; i < list.size(); i++) {\n            ArrayList<Integer> newList = new ArrayList<Integer>();\n            newList.addAll(list);\n            new"
      ]
    },
    "TO_BASE": {
      "loc": "21-22",
      "input": "public static String to_base(int num, int b) {\n    String result = \"\";\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    while (num > 0) {\n        i = num % b;\n        num = num / b; ",
      "function range": "14,5-25,5",
      "output": [
        "public static String to_base(int num, int b) {\n    String result = \"\";\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    while (num > 0) {\n        i = num % b;\n        num = num / b; \n        result = alphabet.charAt(i) + result;\n    }\n    return result;\n}\n}\n",
        "public static String to_base(int num, int b) {\n    String result = \"\";\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    while (num > 0) {\n        i = num % b;\n        num = num / b; \n        result = alphabet.charAt(i) + result;\n    }\n    return result;\n}\n",
        "public static String to_base(int num, int b) {\n    String result = \"\";\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    while (num > 0) {\n        i = num % b;\n        num = num / b; \n        result = alphabet.charAt(i) + result;\n    }\n    return result;\n}\n\npublic static int from_base(String str, int b) {\n    int result = 0;\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    for (i = str.length() - 1; i >= 0; i--) {\n        result = result * b + alphabet.indexOf(str.charAt(i));\n    }\n    return result;",
        "public static String to_base(int num, int b) {\n    String result = \"\";\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    while (num > 0) {\n        i = num % b;\n        num = num / b; \n        result = alphabet.charAt(i) + result;\n    }\n    return result;\n}\n\npublic static int from_base(String str, int b) {\n    int result = 0;\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    for (int i = str.length() - 1; i >= 0; i--) {\n        result = result * b + alphabet.indexOf(str.charAt(i));\n    }\n    return result;\n}\n\n",
        "public static String to_base(int num, int b) {\n    String result = \"\";\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    while (num > 0) {\n        i = num % b;\n        num = num / b; \n        result = alphabet.charAt(i) + result;\n    }\n    return result;\n}\n\npublic static int from_base(String str, int b) {\n    int result = 0;\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    for (int i = str.length() - 1; i >= 0; i--) {\n        result += alphabet.indexOf(str.charAt(i)) * Math.pow(b, str.length() - 1 - i",
        "public static String to_base(int num, int b) {\n    String result = \"\";\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    while (num > 0) {\n        i = num % b;\n        num = num / b; \n        result = alphabet.charAt(i) + result;\n    }\n    return result;\n}\n\npublic static int from_base(String str, int b) {\n    int result = 0;\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    for (i = str.length() - 1; i >= 0; i--) {\n        result += alphabet.indexOf(str.charAt(i)) * Math.pow(b, i);\n    ",
        "public static String to_base(int num, int b) {\n    String result = \"\";\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    while (num > 0) {\n        i = num % b;\n        num = num / b; \n        result = alphabet.charAt(i) + result;\n    }\n    return result;\n}\n\npublic static int from_base(String str, int b) {\n    int result = 0;\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    for (i = str.length() - 1; i >= 0; i--) {\n        result += alphabet.indexOf(str.charAt(i)) * Math.pow(b, str.length()",
        "public static String to_base(int num, int b) {\n    String result = \"\";\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    while (num > 0) {\n        i = num % b;\n        num = num / b; \n        result = alphabet.charAt(i) + result;\n    }\n    return result;\n}\n\npublic static int from_base(String str, int b) {\n    int result = 0;\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    for (int i = str.length() - 1; i >= 0; i--) {\n        result += alphabet.indexOf(str.charAt(i)) * Math.pow(b, i);\n    }\n    return",
        "public static String to_base(int num, int b) {\n    String result = \"\";\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    while (num > 0) {\n        i = num % b;\n        num = num / b; \n        result = alphabet.charAt(i) + result;\n    }\n    return result;\n}\n\npublic static int from_base(String str, int b) {\n    int result = 0;\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    for (int i = str.length() - 1; i >= 0; i--) {\n        result += alphabet.indexOf(str.charAt(i)) * Math.pow(b, str.length() - i - 1",
        "public static String to_base(int num, int b) {\n    String result = \"\";\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    while (num > 0) {\n        i = num % b;\n        num = num / b; \n        result = alphabet.charAt(i) + result;\n    }\n    return result;\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int num = in.nextInt();\n    int b = in.nextInt();\n    System.out.println(to_base(num, b));\n}\n}\n"
      ]
    },
    "TOPOLOGICAL_ORDERING": {
      "loc": "17-18",
      "input": "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n    ArrayList<Node> orderedNodes = new ArrayList<Node>();\n    for (Node node : directedGraph) {\n        if (node.getPredecessors().isEmpty()) {\n            orderedNodes.add(node);\n        }\n    }\n    int listSize = orderedNodes.size();\n    for (int i = 0; i < listSize; i++) {\n        Node node = orderedNodes.get(i);\n        for (Node nextNode : node.getSuccessors()) {",
      "function range": "5,5-24,5",
      "output": [
        "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n    ArrayList<Node> orderedNodes = new ArrayList<Node>();\n    for (Node node : directedGraph) {\n        if (node.getPredecessors().isEmpty()) {\n            orderedNodes.add(node);\n        }\n    }\n    int listSize = orderedNodes.size();\n    for (int i = 0; i < listSize; i++) {\n        Node node = orderedNodes.get(i);\n        for (Node nextNode : node.getSuccessors()) {\n            if (!orderedNodes.contains(nextNode)) {\n                orderedNodes.add(nextNode);\n            }\n        }\n    }\n    return orderedNodes;\n}\n}\n",
        "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n    ArrayList<Node> orderedNodes = new ArrayList<Node>();\n    for (Node node : directedGraph) {\n        if (node.getPredecessors().isEmpty()) {\n            orderedNodes.add(node);\n        }\n    }\n    int listSize = orderedNodes.size();\n    for (int i = 0; i < listSize; i++) {\n        Node node = orderedNodes.get(i);\n        for (Node nextNode : node.getSuccessors()) {\n            if (!orderedNodes.contains(nextNode)) {\n                orderedNodes.add(nextNode);\n            }\n        }\n    }\n    return orderedNodes;\n}\n",
        "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n    ArrayList<Node> orderedNodes = new ArrayList<Node>();\n    for (Node node : directedGraph) {\n        if (node.getPredecessors().isEmpty()) {\n            orderedNodes.add(node);\n        }\n    }\n    int listSize = orderedNodes.size();\n    for (int i = 0; i < listSize; i++) {\n        Node node = orderedNodes.get(i);\n        for (Node nextNode : node.getSuccessors()) {\n            if (!orderedNodes.contains(nextNode)) {\n                orderedNodes.add(nextNode);\n            }\n        }\n    }\n    return orderedNodes;\n}\n\n}\n",
        "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n    ArrayList<Node> orderedNodes = new ArrayList<Node>();\n    for (Node node : directedGraph) {\n        if (node.getPredecessors().isEmpty()) {\n            orderedNodes.add(node);\n        }\n    }\n    int listSize = orderedNodes.size();\n    for (int i = 0; i < listSize; i++) {\n        Node node = orderedNodes.get(i);\n        for (Node nextNode : node.getSuccessors()) {\n            orderedNodes.add(nextNode);\n        }\n    }\n    return orderedNodes;\n}\n}\n",
        "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n    ArrayList<Node> orderedNodes = new ArrayList<Node>();\n    for (Node node : directedGraph) {\n        if (node.getPredecessors().isEmpty()) {\n            orderedNodes.add(node);\n        }\n    }\n    int listSize = orderedNodes.size();\n    for (int i = 0; i < listSize; i++) {\n        Node node = orderedNodes.get(i);\n        for (Node nextNode : node.getSuccessors()) {\n            if (!orderedNodes.contains(nextNode)) {\n                orderedNodes.add(nextNode);\n            }\n        }\n    }\n    return orderedNodes;\n}",
        "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n    ArrayList<Node> orderedNodes = new ArrayList<Node>();\n    for (Node node : directedGraph) {\n        if (node.getPredecessors().isEmpty()) {\n            orderedNodes.add(node);\n        }\n    }\n    int listSize = orderedNodes.size();\n    for (int i = 0; i < listSize; i++) {\n        Node node = orderedNodes.get(i);\n        for (Node nextNode : node.getSuccessors()) {\n            if (!orderedNodes.contains(nextNode)) {\n                orderedNodes.add(nextNode);\n            }\n        }\n    }\n    return orderedNodes;\n}\n}",
        "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n    ArrayList<Node> orderedNodes = new ArrayList<Node>();\n    for (Node node : directedGraph) {\n        if (node.getPredecessors().isEmpty()) {\n            orderedNodes.add(node);\n        }\n    }\n    int listSize = orderedNodes.size();\n    for (int i = 0; i < listSize; i++) {\n        Node node = orderedNodes.get(i);\n        for (Node nextNode : node.getSuccessors()) {\n            if (nextNode.getPredecessors().isEmpty()) {\n                orderedNodes.add(nextNode);\n            }\n        }\n    }\n    return orderedNodes;\n}\n}\n",
        "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n    ArrayList<Node> orderedNodes = new ArrayList<Node>();\n    for (Node node : directedGraph) {\n        if (node.getPredecessors().isEmpty()) {\n            orderedNodes.add(node);\n        }\n    }\n    int listSize = orderedNodes.size();\n    for (int i = 0; i < listSize; i++) {\n        Node node = orderedNodes.get(i);\n        for (Node nextNode : node.getSuccessors()) {\n            orderedNodes.add(nextNode);\n        }\n    }\n    return orderedNodes;\n}\n\n}\n",
        "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n    ArrayList<Node> orderedNodes = new ArrayList<Node>();\n    for (Node node : directedGraph) {\n        if (node.getPredecessors().isEmpty()) {\n            orderedNodes.add(node);\n        }\n    }\n    int listSize = orderedNodes.size();\n    for (int i = 0; i < listSize; i++) {\n        Node node = orderedNodes.get(i);\n        for (Node nextNode : node.getSuccessors()) {\n            if (orderedNodes.contains(nextNode) == false) {\n                orderedNodes.add(nextNode);\n            }\n        }\n    }\n    return orderedNodes;\n}\n}\n",
        "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n    ArrayList<Node> orderedNodes = new ArrayList<Node>();\n    for (Node node : directedGraph) {\n        if (node.getPredecessors().isEmpty()) {\n            orderedNodes.add(node);\n        }\n    }\n    int listSize = orderedNodes.size();\n    for (int i = 0; i < listSize; i++) {\n        Node node = orderedNodes.get(i);\n        for (Node nextNode : node.getSuccessors()) {\n            orderedNodes.remove(nextNode);\n            orderedNodes.add(nextNode);\n        }\n    }\n    return orderedNodes;\n}\n}\n"
      ]
    },
    "WRAP": {
      "loc": "32-32",
      "input": "public static ArrayList<String> wrap(String text, int cols) {\n    ArrayList<String> lines = new ArrayList<String>();\n    String line;\n    while (text.length() > cols) {\n        int end = text.lastIndexOf(\" \", cols); \n        if (end == -1) {\n            end = cols;\n        }\n        line = text.substring(0,end);\n        text = text.substring(end);\n        lines.add(line);\n    }",
      "function range": "18,5-33,5",
      "output": [
        "public static ArrayList<String> wrap(String text, int cols) {\n    ArrayList<String> lines = new ArrayList<String>();\n    String line;\n    while (text.length() > cols) {\n        int end = text.lastIndexOf(\" \", cols); \n        if (end == -1) {\n            end = cols;\n        }\n        line = text.substring(0,end);\n        text = text.substring(end);\n        lines.add(line);\n    }\n    if (text.length() > 0) {\n        lines.add(text);\n    }\n    return lines;\n}\n}\n",
        "public static ArrayList<String> wrap(String text, int cols) {\n    ArrayList<String> lines = new ArrayList<String>();\n    String line;\n    while (text.length() > cols) {\n        int end = text.lastIndexOf(\" \", cols); \n        if (end == -1) {\n            end = cols;\n        }\n        line = text.substring(0,end);\n        text = text.substring(end);\n        lines.add(line);\n    }\n    if (text.length() > 0) {\n        lines.add(text);\n    }\n    return lines;\n}\n\n}\n",
        "public static ArrayList<String> wrap(String text, int cols) {\n    ArrayList<String> lines = new ArrayList<String>();\n    String line;\n    while (text.length() > cols) {\n        int end = text.lastIndexOf(\" \", cols); \n        if (end == -1) {\n            end = cols;\n        }\n        line = text.substring(0,end);\n        text = text.substring(end);\n        lines.add(line);\n    }\n    if (text.length() > 0) {\n        lines.add(text);\n    }\n    return lines;\n  }\n}\n",
        "public static ArrayList<String> wrap(String text, int cols) {\n    ArrayList<String> lines = new ArrayList<String>();\n    String line;\n    while (text.length() > cols) {\n        int end = text.lastIndexOf(\" \", cols); \n        if (end == -1) {\n            end = cols;\n        }\n        line = text.substring(0,end);\n        text = text.substring(end);\n        lines.add(line);\n    }\n    lines.add(text);\n    return lines;\n}\n}\n",
        "public static ArrayList<String> wrap(String text, int cols) {\n    ArrayList<String> lines = new ArrayList<String>();\n    String line;\n    while (text.length() > cols) {\n        int end = text.lastIndexOf(\" \", cols); \n        if (end == -1) {\n            end = cols;\n        }\n        line = text.substring(0,end);\n        text = text.substring(end);\n        lines.add(line);\n    }\n    if (text.length() > 0) {\n        line = text;\n        lines.add(line);\n    }\n    return lines;\n}\n}\n",
        "public static ArrayList<String> wrap(String text, int cols) {\n    ArrayList<String> lines = new ArrayList<String>();\n    String line;\n    while (text.length() > cols) {\n        int end = text.lastIndexOf(\" \", cols); \n        if (end == -1) {\n            end = cols;\n        }\n        line = text.substring(0,end);\n        text = text.substring(end);\n        lines.add(line);\n    }\n    if (text.length() > 0) {\n        line = text;\n        lines.add(line);\n    }\n    return lines;\n  }\n}\n",
        "public static ArrayList<String> wrap(String text, int cols) {\n    ArrayList<String> lines = new ArrayList<String>();\n    String line;\n    while (text.length() > cols) {\n        int end = text.lastIndexOf(\" \", cols); \n        if (end == -1) {\n            end = cols;\n        }\n        line = text.substring(0,end);\n        text = text.substring(end);\n        lines.add(line);\n    }\n    if (text.length() > 0) {\n        line = text;\n        lines.add(line);\n    }\n    return lines;\n}\n\n}\n",
        "public static ArrayList<String> wrap(String text, int cols) {\n    ArrayList<String> lines = new ArrayList<String>();\n    String line;\n    while (text.length() > cols) {\n        int end = text.lastIndexOf(\" \", cols); \n        if (end == -1) {\n            end = cols;\n        }\n        line = text.substring(0,end);\n        text = text.substring(end);\n        lines.add(line);\n    }\n    if (text.length() > 0) {\n        lines.add(text);\n    }\n    return lines;\n  }\n\n}\n",
        "public static ArrayList<String> wrap(String text, int cols) {\n    ArrayList<String> lines = new ArrayList<String>();\n    String line;\n    while (text.length() > cols) {\n        int end = text.lastIndexOf(\" \", cols); \n        if (end == -1) {\n            end = cols;\n        }\n        line = text.substring(0,end);\n        text = text.substring(end);\n        lines.add(line);\n    }\n    if (text.length() > 0) {\n        lines.add(text);\n    }\n    return lines;\n}\n    \n}\n",
        "public static ArrayList<String> wrap(String text, int cols) {\n    ArrayList<String> lines = new ArrayList<String>();\n    String line;\n    while (text.length() > cols) {\n        int end = text.lastIndexOf(\" \", cols); \n        if (end == -1) {\n            end = cols;\n        }\n        line = text.substring(0,end);\n        text = text.substring(end);\n        lines.add(line);\n    }\n    line = text;\n    lines.add(line);\n    return lines;\n  }\n}\n"
      ]
    },
    "POWERSET": {
      "loc": "23-30",
      "input": "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n    if (!arr.isEmpty()) {\n        Object first = arr.get(0);\n        arr.remove(0);\n        ArrayList rest = arr;\n        ArrayList<ArrayList> rest_subsets = powerset(rest);\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);",
      "function range": "14,5-35,5",
      "output": [
        "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n    if (!arr.isEmpty()) {\n        Object first = arr.get(0);\n        arr.remove(0);\n        ArrayList rest = arr;\n        ArrayList<ArrayList> rest_subsets = powerset(rest);\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        for (ArrayList subset : rest_subsets) {\n            for (int i = 0; i < subset.size(); i++) {\n                to_add.add(first);\n                to_add.add(subset.get(i));\n            }\n            output.add(to_add);\n            to_add = new ArrayList(100);\n        }\n        return output;\n    } else {\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);",
        "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n    if (!arr.isEmpty()) {\n        Object first = arr.get(0);\n        arr.remove(0);\n        ArrayList rest = arr;\n        ArrayList<ArrayList> rest_subsets = powerset(rest);\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        for (ArrayList subset : rest_subsets) {\n            to_add.clear();\n            for (int i = 0; i < subset.size(); i++) {\n                to_add.add(subset.get(i));\n            }\n            to_add.add(first);\n            output.add(to_add);\n        }\n        return output;\n    } else {\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        output.",
        "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n    if (!arr.isEmpty()) {\n        Object first = arr.get(0);\n        arr.remove(0);\n        ArrayList rest = arr;\n        ArrayList<ArrayList> rest_subsets = powerset(rest);\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        for (ArrayList subset : rest_subsets) {\n            to_add.clear();\n            for (int i = 0; i < subset.size(); i++) {\n                to_add.add(first);\n                to_add.add(subset.get(i));\n            }\n            output.add(to_add);\n        }\n        return output;\n    } else {\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        output.",
        "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n    if (!arr.isEmpty()) {\n        Object first = arr.get(0);\n        arr.remove(0);\n        ArrayList rest = arr;\n        ArrayList<ArrayList> rest_subsets = powerset(rest);\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        for (ArrayList subset : rest_subsets) {\n            to_add.clear();\n            for (int i = 0; i < subset.size(); i++) {\n                to_add.add(subset.get(i));\n            }\n            to_add.add(first);\n            output.add(to_add);\n        }\n        return output;\n    } else {\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(1);\n        output.add(new ArrayList(1));\n        return output;\n",
        "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n    if (!arr.isEmpty()) {\n        Object first = arr.get(0);\n        arr.remove(0);\n        ArrayList rest = arr;\n        ArrayList<ArrayList> rest_subsets = powerset(rest);\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        for (ArrayList subset : rest_subsets) {\n            to_add.clear();\n            for (int i = 0; i < subset.size(); i++) {\n                to_add.add(subset.get(i));\n            }\n            to_add.add(first);\n            output.add(to_add);\n        }\n        return output;\n    } else {\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        for (",
        "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n    if (!arr.isEmpty()) {\n        Object first = arr.get(0);\n        arr.remove(0);\n        ArrayList rest = arr;\n        ArrayList<ArrayList> rest_subsets = powerset(rest);\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        for (ArrayList subset : rest_subsets) {\n            to_add.clear();\n            for (int i = 0; i < subset.size(); i++) {\n                to_add.add(subset.get(i));\n            }\n            to_add.add(first);\n            output.add(to_add);\n        }\n        return output;\n    } else {\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(1);\n        output.add(new ArrayList(0));\n        return output;\n",
        "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n    if (!arr.isEmpty()) {\n        Object first = arr.get(0);\n        arr.remove(0);\n        ArrayList rest = arr;\n        ArrayList<ArrayList> rest_subsets = powerset(rest);\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        for (ArrayList subset : rest_subsets) {\n            for (int i = 0; i < subset.size(); i++) {\n                to_add.add(first);\n                to_add.add(subset.get(i));\n            }\n            output.add(to_add);\n            to_add = new ArrayList(100);\n        }\n        output.add(to_add);\n        return output;\n    } else {\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList",
        "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n    if (!arr.isEmpty()) {\n        Object first = arr.get(0);\n        arr.remove(0);\n        ArrayList rest = arr;\n        ArrayList<ArrayList> rest_subsets = powerset(rest);\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        for (ArrayList subset : rest_subsets) {\n            to_add.clear();\n            for (int i = 0; i < subset.size(); i++) {\n                to_add.add(first);\n                to_add.add(subset.get(i));\n            }\n            output.add(to_add);\n        }\n        output.add(to_add);\n        return output;\n    } else {\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add =",
        "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n    if (!arr.isEmpty()) {\n        Object first = arr.get(0);\n        arr.remove(0);\n        ArrayList rest = arr;\n        ArrayList<ArrayList> rest_subsets = powerset(rest);\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        for (ArrayList subset : rest_subsets) {\n            for (int i = 0; i < subset.size(); i++) {\n                to_add.add(first);\n                to_add.add(subset.get(i));\n            }\n            output.add(to_add);\n            to_add = new ArrayList(100);\n        }\n        output.add(to_add);\n        return output;\n    } else {\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(1);\n        output.",
        "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n    if (!arr.isEmpty()) {\n        Object first = arr.get(0);\n        arr.remove(0);\n        ArrayList rest = arr;\n        ArrayList<ArrayList> rest_subsets = powerset(rest);\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        for (ArrayList subset : rest_subsets) {\n            to_add.clear();\n            for (int i = 0; i < subset.size(); i++) {\n                to_add.add(first);\n                to_add.add(subset.get(i));\n            }\n            output.add(to_add);\n        }\n        return output;\n    } else {\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        for ("
      ]
    }
  },
  "model": "codegen-6B-multi"
}