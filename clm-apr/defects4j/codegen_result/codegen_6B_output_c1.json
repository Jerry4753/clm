{
  "config": "CODEGEN_COMPLETE_CODEFORM_NOCOMMENT",
  "model": "codegen-6B-multi",
  "data": {
    "Chart_14_source/org/jfree/chart/plot/CategoryPlot.java_2166-2167": {
      "loc": "2166-2167",
      "input": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }",
      "output": [
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    markers.remove(marker);\n    if (markers.isEmpty()) {\n        if (layer == Layer.FOREGROUND) {\n            this.foregroundDomainMarkers.remove(new Integer(index));\n        }\n        else {\n            this.backgroundDomainMarkers.remove(new Integer(index));\n        }\n    }\n    if (notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return true;\n  }\n\n  /**\n   * Removes a marker for a specific dataset/renderer and sends a \n   * {@link RendererChangeEvent} to all registered listeners.\n   * \n   * @param index  the dataset/renderer index.\n   * @param marker  the marker.\n   * @param layer  the layer (foreground or background).\n   * \n   * @return A boolean indicating whether or not the marker was actually \n   *         removed.\n   */\n  public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    markers.remove(marker);\n    if (markers.isEmpty()) {\n        if (layer == Layer.FOREGROUND) {\n            this.foregroundRangeMarkers.remove(new Integer(index));\n",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    markers.remove(marker);\n    if (markers.isEmpty()) {\n        if (layer == Layer.FOREGROUND) {\n            this.foregroundDomainMarkers.remove(new Integer(index));\n        }\n        else {\n            this.backgroundDomainMarkers.remove(new Integer(index));\n        }\n    }\n    if (notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return true;\n  }\n\n  /**\n   * Removes a marker for a specific dataset/renderer and sends a \n   * {@link RendererChangeEvent} to all registered listeners.\n   * \n   * @param index  the dataset/renderer index.\n   * @param marker  the marker.\n   * @param layer  the layer (foreground or background).\n   * \n   * @return A boolean indicating whether or not the marker was actually \n   *         removed.\n   */\n  public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    markers.remove(marker);\n    if (markers.isEmpty()) {\n      if (layer == Layer.FOREGROUND) {\n        this.foregroundRangeMarkers.remove(new Integer(index));\n",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    markers.remove(marker);\n    if (markers.size() == 0) {\n        if (layer == Layer.FOREGROUND) {\n            this.foregroundDomainMarkers.remove(new Integer(index));\n        }\n        else {\n            this.backgroundDomainMarkers.remove(new Integer(index));\n        }\n    }\n    if (notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return true;\n  }\n\n  /**\n   * Removes a marker for a specific dataset/renderer and sends a \n   * {@link RendererChangeEvent} to all registered listeners.\n   * \n   * @param index  the dataset/renderer index.\n   * @param marker  the marker.\n   * @param layer  the layer (foreground or background).\n   * \n   * @return A boolean indicating whether or not the marker was actually \n   *         removed.\n   */\n  public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    markers.remove(marker);\n    if (markers.size() == 0) {\n        if (layer == Layer.FOREGROUND) {\n            this.foregroundRangeMarkers.remove(new Integer",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    markers.remove(marker);\n    if (markers.isEmpty()) {\n        if (layer == Layer.FOREGROUND) {\n            this.foregroundDomainMarkers.remove(new Integer(index));\n        }\n        else {\n            this.backgroundDomainMarkers.remove(new Integer(index));\n        }\n    }\n    if (notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return true;\n  }\n\n  /**\n   * Removes a marker for a specific dataset/renderer and sends a \n   * {@link RendererChangeEvent} to all registered listeners.\n   * \n   * @param index  the dataset/renderer index.\n   * @param marker  the marker.\n   * @param layer  the layer (foreground or background).\n   * \n   * @return A boolean indicating whether or not the marker was actually \n   *         removed.\n   */\n  public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n      markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n              index));\n    }\n    else {\n      markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n              index));\n    }\n    if (markers == null) {\n      return false;\n    }\n    markers.remove(marker);\n    if (markers.isEmpty()) {\n      if (layer == Layer.FOREGROUND) {\n        this.foregroundRangeMarkers.remove(new Integer(index));\n",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers!= null) {\n        markers.remove(marker);\n        if (markers.size() == 0) {\n            if (layer == Layer.FOREGROUND) {\n                this.foregroundDomainMarkers.remove(new Integer(index));\n            }\n            else {\n                this.backgroundDomainMarkers.remove(new Integer(index));\n            }\n        }\n        if (notify) {\n            notifyListeners(new RendererChangeEvent(this));\n        }\n        return true;\n    }\n    else {\n        return false;\n    }\n  }\n\n  /**\n   * Removes a marker for a specific dataset/renderer and sends a \n   * {@link RendererChangeEvent} to all registered listeners.\n   * \n   * @param index  the dataset/renderer index.\n   * @param marker  the marker.\n   * @param layer  the layer (foreground or background).\n   * \n   * @return A boolean indicating whether or not the marker was actually \n   *         removed.\n   */\n  public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                index));\n    }\n    if (markers!= null) {\n        markers.remove(marker);\n        if (markers.size() == 0) {\n            if (layer == Layer.FOREGROUND) {\n                this.foregroundRangeMarkers.remove(new Integer(",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    markers.remove(marker);\n    if (markers.isEmpty()) {\n        if (layer == Layer.FOREGROUND) {\n            this.foregroundDomainMarkers.remove(new Integer(index));\n        }\n        else {\n            this.backgroundDomainMarkers.remove(new Integer(index));\n        }\n    }\n    if (notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return true;\n  }\n\n  /**\n   * Removes a marker for a specific dataset/renderer and sends a \n   * {@link RendererChangeEvent} to all registered listeners.\n   * \n   * @param index  the dataset/renderer index.\n   * @param marker  the marker.\n   * @param layer  the layer (foreground or background).\n   * \n   * @return A boolean indicating whether or not the marker was actually \n   *         removed.\n   */\n  public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    return removeRangeMarker(index, marker, layer, true);\n  }\n\n  /**\n   * Removes a marker for a specific dataset/renderer and sends a \n   * {@link RendererChangeEvent} to all registered listeners.\n   * \n   * @param index  the dataset/renderer index.\n   * @param marker  the marker.\n   * @param layer  the layer (foreground or background).\n   * @param notify  notify listeners?\n   * \n   * @return A boolean indicating whether or not the marker was actually \n   *         removed.\n   */\n  public boolean removeRangeMarker",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    markers.remove(marker);\n    if (markers.isEmpty()) {\n        if (layer == Layer.FOREGROUND) {\n            this.foregroundDomainMarkers.remove(new Integer(index));\n        }\n        else {\n            this.backgroundDomainMarkers.remove(new Integer(index));\n        }\n    }\n    if (notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return true;\n  }\n\n  /**\n   * Removes a marker for a specific dataset/renderer and sends a \n   * {@link RendererChangeEvent} to all registered listeners.\n   * \n   * @param index  the dataset/renderer index.\n   * @param marker  the marker.\n   * @param layer  the layer (foreground or background).\n   * \n   * @return A boolean indicating whether or not the marker was actually \n   *         removed.\n   */\n  public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n      markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n          index));\n    }\n    else {\n      markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n          index));\n    }\n    if (markers == null) {\n      return false;\n    }\n    markers.remove(marker);\n    if (markers.isEmpty()) {\n      if (layer == Layer.FOREGROUND) {\n        this.foregroundRangeMarkers.remove(new Integer(index));\n",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    markers.remove(marker);\n    if (markers.isEmpty()) {\n        if (layer == Layer.FOREGROUND) {\n            this.foregroundDomainMarkers.remove(new Integer(index));\n        }\n        else {\n            this.backgroundDomainMarkers.remove(new Integer(index));\n        }\n    }\n    if (notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return true;\n  }\n\n  /**\n   * Removes a marker for a specific dataset/renderer and sends a \n   * {@link RendererChangeEvent} to all registered listeners.\n   * \n   * @param index  the dataset/renderer index.\n   * @param marker  the marker.\n   * @param layer  the layer (foreground or background).\n   * \n   * @return A boolean indicating whether or not the marker was actually \n   *         removed.\n   */\n  public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n      return false;\n    }\n    markers.remove(marker);\n    if (markers.isEmpty()) {\n      if (layer == Layer.FOREGROUND) {\n        this.foregroundRangeMarkers.remove(new Integer(index));\n",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    markers.remove(marker);\n    if (markers.isEmpty()) {\n        if (layer == Layer.FOREGROUND) {\n            this.foregroundDomainMarkers.remove(new Integer(index));\n        }\n        else {\n            this.backgroundDomainMarkers.remove(new Integer(index));\n        }\n    }\n    if (notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return true;\n  }\n\n  /**\n   * Removes a marker for a specific dataset/renderer and sends a \n   * {@link RendererChangeEvent} to all registered listeners.\n   * \n   * @param index  the dataset/renderer index.\n   * @param marker  the marker.\n   * @param layer  the layer (foreground or background).\n   * \n   * @return A boolean indicating whether or not the marker was actually \n   *         removed.\n   */\n  public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n      markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(index));\n    }\n    else {\n      markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(index));\n    }\n    if (markers == null) {\n      return false;\n    }\n    markers.remove(marker);\n    if (markers.isEmpty()) {\n      if (layer == Layer.FOREGROUND) {\n        this.foregroundRangeMarkers.remove(new Integer(index));\n      }\n      ",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    markers.remove(marker);\n    if (markers.size() == 0) {\n        if (layer == Layer.FOREGROUND) {\n            this.foregroundDomainMarkers.remove(new Integer(index));\n        }\n        else {\n            this.backgroundDomainMarkers.remove(new Integer(index));\n        }\n    }\n    if (notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return true;\n  }\n\n  /**\n   * Removes a marker for a specific dataset/renderer and sends a \n   * {@link RendererChangeEvent} to all registered listeners.\n   * \n   * @param index  the dataset/renderer index.\n   * @param marker  the marker.\n   * @param layer  the layer (foreground or background).\n   * \n   * @return A boolean indicating whether or not the marker was actually \n   *         removed.\n   */\n  public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    markers.remove(marker);\n    if (markers.size() == 0) {\n      if (layer == Layer.FOREGROUND) {\n        this.foregroundRangeMarkers.remove(new Integer"
      ],
      "function range": "2155,5-2171,5"
    },
    "Closure_40_src/com/google/javascript/jscomp/NameAnalyzer.java_635-636": {
      "loc": "635-636",
      "input": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns != null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns != null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null && ns.onlyAffectsClassDef) {",
      "output": [
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, true);\n      name.onlyAffectsClassDef = true;\n    }\n  } else if (n.isGetProp()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, true);\n      name",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, true);\n      name.onlyAffectsClassDef = true;\n    }\n  } else if (n.isGetProp()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      recordSet(ns.name, nameNode);\n    }\n  } else if (n.isGetElem",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, true);\n      name.onlyAffectsClassDef = true;\n    }\n  } else if (n.isGetProp()) {\n    if (parent.isExprResult()) {\n      Node nameNode = n.getLastChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        recordSet(ns.name, nameNode);\n      }",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, true);\n      name.onlyAffectsClassDef = true;\n    }\n  } else if (n.isGetProp()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, true);\n      name.onlyAffectsClassDef = true;\n    }\n  } else if (n.isGetProp()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      recordSet(ns.name, nameNode);\n    }\n  }\n}\n\n\n  /**\n   *",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, true);\n      name.onlyAffectsClassDef = true;\n    }\n  } else if (n.isGetProp()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      recordSet(ns.name, nameNode);\n    }\n  } else if (n.isStringKey())",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, true);\n      name.onlyAffectsClassDef = true;\n    }\n  } else if (n.isGetProp()) {\n    Node nameNode = n.getLastChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      recordSet(ns.name, nameNode);\n    }\n  } else if (n.isGetElem",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, true);\n      name.onlyAffectsClassDef = true;\n    }\n  }\n}\n\n\n/**\n * Records the assignment of a value to a name.\n *\n * @param name name being assigned to\n * @param n node containing the assignment\n */\nprivate void recordSet(String name, Node n) {\n  JsName jsn = getName(name, true);\n  jsn.hasSetterReference",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, true);\n      name.onlyAffectsClassDef = true;\n    }\n  } else if (n.isGetProp()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      recordSet(ns.name, nameNode);\n    }\n  }\n}\n\n\n/**\n * Records the",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, true);\n      name.onlyAffectsClassDef = true;\n    }\n  }\n}\n\n\n/**\n * Records the assignment of a value to a name.\n *\n * @param name name being assigned to\n * @param n node containing the assignment\n */\nprivate void recordSet(String name, Node n) {\n  JsName jsn = getName(name, true);\n  jsn.hasSetter ="
      ],
      "function range": "595,5-642,5"
    },
    "Closure_46_src/com/google/javascript/rhino/jstype/RecordType.java_142-145": {
      "loc": "142-145",
      "input": "@Override\npublic JSType getLeastSupertype(JSType that) {",
      "output": [
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public TernaryValue testForEquality(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor, JSType that, JSType other) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor, JSType that, JSType other) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor, JSType that, JSType",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public TernaryValue testForEquality(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor, JSType that, JSType relatedType) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor, JSType that, JSType relatedType) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor, JSType that, J",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public TernaryValue testForEquality(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(String pname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(String pname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public FunctionType getConstructor() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getParameterType() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getIndexType() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public Iterable<JSType> getTemplateTypes() {\n    throw new UnsupportedOperation",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public TernaryValue testForEquality(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(String pname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(String pname) {\n    throw new UnsupportedOperationException();\n",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public TernaryValue testForEquality(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(String pname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(String pname) {\n    throw new UnsupportedOperationException();\n",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public TernaryValue testForEquality(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(String pname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(String pname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public FunctionType getConstructor() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getParameterType() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getIndexType() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getIndexedType() {\n    throw new UnsupportedOperationException();\n",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public TernaryValue testForEquality(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(String pname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(String pname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public FunctionType getConstructor() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType findPropertyType(String propertyName) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSDocInfo getJSDocInfo() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public void setJSDocInfo(JSDocInfo info",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public TernaryValue testForEquality(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(String pname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(String pname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public FunctionType getConstructor() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getParameterType() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getIndexType() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getKeyType() {\n    throw new UnsupportedOperationException();\n  ",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public TernaryValue testForEquality(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(String pname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(String pname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public FunctionType getConstructor() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType findPropertyType(String propertyName) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType findPropertyType(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public TernaryValue testForEquality(JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PreOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public <T> T visit(PostOrderVisitor<T> visitor, JSType that) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getProp(String pname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasProp(String pname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public FunctionType getConstructor() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType findPropertyType(String propertyName) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType findPropertyType(QualifiedName qname) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public JSType getParameterType() {\n"
      ],
      "function range": "140,3-155,3"
    },
    "Closure_77_src/com/google/javascript/jscomp/CodeGenerator.java_967-967": {
      "loc": "967-967",
      "input": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;",
      "output": [
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null && outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          sb.append(String.format(\"\\\\u%04x\", (int) c));\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null && outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          sb.append(String.format(\"\\\\u%04x\", (int) c));\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null && outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          sb.append(String.format(\"\\\\u%04x\", (int) c));\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (c < 32 || c >= 127 || outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n          sb.append(backslashEscape);\n          sb.append(Integer.toHexString(c));\n          sb.append(backslashEscape);\n        } else {\n          sb.append(c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null && outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          sb.append(String.format(\"\\\\u%04x\", (int) c));\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (c < 32 || c >= 127 || outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n          sb.append(backslashEscape);\n          sb.append(Integer.toHexString(c));\n          sb.append(backslashEscape);\n        } else {\n          sb.append(c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (c < 32 || c >= 127 || outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n          sb.append(backslashEscape);\n          sb.append(Integer.toHexString(c));\n          sb.append(backslashEscape);\n        } else {\n          sb.append(c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (c < 32 || c >= 127 || outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n          sb.append(backslashEscape);\n          sb.append(Integer.toHexString(c));\n          sb.append(backslashEscape);\n        } else {\n          sb.append(c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (c < 32 || c >= 127 || outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n          sb.append(backslashEscape);\n          sb.append(Integer.toHexString(c));\n          sb.append(backslashEscape);\n        } else {\n          sb.append(c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (c < 32 || c >= 127 || outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n          sb.append(backslashEscape);\n          sb.append(Integer.toHexString(c));\n          sb.append(backslashEscape);\n        } else {\n          sb.append(c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n *"
      ],
      "function range": "956,3-1025,3"
    },
    "Closure_119_src/com/google/javascript/jscomp/GlobalNamespace.java_366-366": {
      "loc": "366-366",
      "input": "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent != null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;",
      "output": [
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n        }\n      }\n      name = n.getString();\n      break;\n    case Token.",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          case Token.CATCH:\n            type = Name.Type.CATCH;\n            break;\n",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          case Token.CALL:\n            Node callee = parent.getFirstChild();\n            if (",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n        }\n      }\n      break;\n    case Token.GETPROP:\n      if (parent",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n        }\n      }\n      break;\n    case Token.GETPROP:\n      if (n",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          default:\n            return;\n        }\n      }\n      break;\n    case Token.GET",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          case Token.STRING_KEY:\n            type = getValueType(n.getFirstChild());",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n        }\n      }\n      break;\n    case Token.GETPROP:\n      Preconditions",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          case Token.NEW:\n            Node callee = parent.getFirstChild();\n            type = cal",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          case Token.OBJECTLIT:\n            if (n == parent.getFirstChild()) {\n"
      ],
      "function range": "306,5-430,5"
    },
    "Lang_10_src/main/java/org/apache/commons/lang3/time/FastDateParser.java_307-314": {
      "loc": "307-314",
      "input": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);",
      "output": [
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n          case '\\\\':\n            regex.append(\"\\\\\\\\\");\n            wasWhite= false;\n            break;\n          case '?':\n            regex.append(\"\\\\?\");\n            wasWhite= false;\n            break;\n          case '*':\n            regex.append(\"\\\\*\");\n            wasWhite= false;\n            break;\n          case '+':\n            regex.append(\"\\\\+\");\n            wasWhite= false;\n            break;\n          case '|':\n            regex.append(\"\\\\|\");\n            wasWhite= false;\n            break;\n          case '$':\n            regex.append(\"\\\\$\");\n            wasWhite= false;\n            break;\n          case '(':\n            regex.append(\"\\\\(\");\n            wasWhite= false;\n            break;\n          case ')':\n            regex.append(\"\\\\)\");\n            wasWhite= false;\n            break;\n          case '[':\n            regex.append(\"\\\\[\");\n            wasWhite= false;\n            break;\n          case ']':\n            regex.append(\"\\\\]\");\n            wasWhite= false;\n            break;\n          case '^':\n            regex.append(\"\\\\^\");\n            wasWhite= false;\n            break;\n          case '{':\n            regex.append(\"\\\\{\");\n            wasWhite= false;\n            break;\n          case '}':\n            regex.append(\"\\\\}\");\n            wasWhite= false;\n            break;\n          case'':\n            regex.append(\"\\\\s\");\n            wasWhite= true;\n            break;\n          case '\\t':\n            regex.append(\"\\\\t\");\n            wasWhite= true;\n            break;\n          case '\\n':\n            regex.append(\"\\\\n\");\n            wasWhite= true;\n            break;\n          case '\\r':\n            regex.append(\"",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n          case '\\\\':\n            regex.append(\"\\\\\\\\\");\n            wasWhite= false;\n            break;\n          case '?':\n            regex.append(\"\\\\?\");\n            wasWhite= false;\n            break;\n          case '*':\n            regex.append(\"\\\\*\");\n            wasWhite= false;\n            break;\n          case '+':\n            regex.append(\"\\\\+\");\n            wasWhite= false;\n            break;\n          case '|':\n            regex.append(\"\\\\|\");\n            wasWhite= false;\n            break;\n          case '$':\n            regex.append(\"\\\\$\");\n            wasWhite= false;\n            break;\n          case '(':\n            regex.append(\"\\\\(\");\n            wasWhite= false;\n            break;\n          case ')':\n            regex.append(\"\\\\)\");\n            wasWhite= false;\n            break;\n          case '[':\n            regex.append(\"\\\\[\");\n            wasWhite= false;\n            break;\n          case ']':\n            regex.append(\"\\\\]\");\n            wasWhite= false;\n            break;\n          case '{':\n            regex.append(\"\\\\{\");\n            wasWhite= false;\n            break;\n          case '}':\n            regex.append(\"\\\\}\");\n            wasWhite= false;\n            break;\n          case'':\n            regex.append(\"\\\\s\");\n            wasWhite= true;\n            break;\n          case '\\t':\n            regex.append(\"\\\\t\");\n            wasWhite= true;\n            break;\n          case '\\r':\n            regex.append(\"\\\\r\");\n            wasWhite= true;\n            break;\n          case '\\n':\n            regex.append(\"\\\\n\");\n            wasWhite= true;\n            break;\n          case '\\f':\n            regex.append",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n          case '\\\\':\n            regex.append(\"\\\\\\\\\");\n            wasWhite= false;\n            break;\n          case '?':\n            regex.append(\"\\\\?\");\n            wasWhite= false;\n            break;\n          case '*':\n            regex.append(\"\\\\*\");\n            wasWhite= false;\n            break;\n          case '+':\n            regex.append(\"\\\\+\");\n            wasWhite= false;\n            break;\n          case '|':\n            regex.append(\"\\\\|\");\n            wasWhite= false;\n            break;\n          case '$':\n            regex.append(\"\\\\$\");\n            wasWhite= false;\n            break;\n          case '(':\n            regex.append(\"\\\\(\");\n            wasWhite= false;\n            break;\n          case ')':\n            regex.append(\"\\\\)\");\n            wasWhite= false;\n            break;\n          case '[':\n            regex.append(\"\\\\[\");\n            wasWhite= false;\n            break;\n          case ']':\n            regex.append(\"\\\\]\");\n            wasWhite= false;\n            break;\n          case '{':\n            regex.append(\"\\\\{\");\n            wasWhite= false;\n            break;\n          case '}':\n            regex.append(\"\\\\}\");\n            wasWhite= false;\n            break;\n          case'':\n            regex.append(\"\\\\s\");\n            wasWhite= true;\n            break;\n          case '\\t':\n            regex.append(\"\\\\t\");\n            wasWhite= true;\n            break;\n          case '\\n':\n            regex.append(\"\\\\n\");\n            wasWhite= true;\n            break;\n          case '\\r':\n            regex.append(\"\\\\r\");\n            wasWhite= true;\n            break;\n          case '\\f':\n            regex.append",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n          case '\\\\':\n            regex.append(\"\\\\\\\\\");\n            wasWhite= false;\n            break;\n          case '?':\n            regex.append(\"\\\\?\");\n            wasWhite= false;\n            break;\n          case '*':\n            regex.append(\"\\\\*\");\n            wasWhite= false;\n            break;\n          case '+':\n            regex.append(\"\\\\+\");\n            wasWhite= false;\n            break;\n          case '|':\n            regex.append(\"\\\\|\");\n            wasWhite= false;\n            break;\n          case '$':\n            regex.append(\"\\\\$\");\n            wasWhite= false;\n            break;\n          case '(':\n            regex.append(\"\\\\(\");\n            wasWhite= false;\n            break;\n          case ')':\n            regex.append(\"\\\\)\");\n            wasWhite= false;\n            break;\n          case '[':\n            regex.append(\"\\\\[\");\n            wasWhite= false;\n            break;\n          case ']':\n            regex.append(\"\\\\]\");\n            wasWhite= false;\n            break;\n          case '^':\n            regex.append(\"\\\\^\");\n            wasWhite= false;\n            break;\n          case '{':\n            regex.append(\"\\\\{\");\n            wasWhite= false;\n            break;\n          case '}':\n            regex.append(\"\\\\}\");\n            wasWhite= false;\n            break;\n          case'':\n            regex.append(\"\\\\s\");\n            wasWhite= true;\n            break;\n          case '\\t':\n            regex.append(\"\\\\t\");\n            wasWhite= true;\n            break;\n          case '\\r':\n            regex.append(\"\\\\r\");\n            wasWhite= true;\n            break;\n          case '\\n':\n            regex.append(\"",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n          case '\\\\':\n            regex.append(\"\\\\\\\\\");\n            wasWhite= false;\n            break;\n          case '?':\n            regex.append(\"\\\\?\");\n            wasWhite= false;\n            break;\n          case '*':\n            regex.append(\"\\\\*\");\n            wasWhite= false;\n            break;\n          case '+':\n            regex.append(\"\\\\+\");\n            wasWhite= false;\n            break;\n          case '|':\n            regex.append(\"\\\\|\");\n            wasWhite= false;\n            break;\n          case '$':\n            regex.append(\"\\\\$\");\n            wasWhite= false;\n            break;\n          case '(':\n            regex.append(\"\\\\(\");\n            wasWhite= false;\n            break;\n          case ')':\n            regex.append(\"\\\\)\");\n            wasWhite= false;\n            break;\n          case '[':\n            regex.append(\"\\\\[\");\n            wasWhite= false;\n            break;\n          case ']':\n            regex.append(\"\\\\]\");\n            wasWhite= false;\n            break;\n          case '{':\n            regex.append(\"\\\\{\");\n            wasWhite= false;\n            break;\n          case '}':\n            regex.append(\"\\\\}\");\n            wasWhite= false;\n            break;\n          case'':\n            regex.append(\"\\\\s\");\n            wasWhite= true;\n            break;\n          case '\\t':\n            regex.append(\"\\\\t\");\n            wasWhite= true;\n            break;\n          case '\\n':\n            regex.append(\"\\\\n\");\n            wasWhite= true;\n            break;\n          case '\\r':\n            regex.append(\"\\\\r\");\n            wasWhite= true;\n            break;\n          default:\n            if(wasWhite) {\n",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n          case '\\\\':\n            regex.append(\"\\\\\\\\\");\n            wasWhite= false;\n            break;\n          case '?':\n            regex.append(\"\\\\?\");\n            wasWhite= false;\n            break;\n          case '*':\n            regex.append(\"\\\\*\");\n            wasWhite= false;\n            break;\n          case '+':\n            regex.append(\"\\\\+\");\n            wasWhite= false;\n            break;\n          case '|':\n            regex.append(\"\\\\|\");\n            wasWhite= false;\n            break;\n          case '$':\n            regex.append(\"\\\\$\");\n            wasWhite= false;\n            break;\n          case '(':\n            regex.append(\"\\\\(\");\n            wasWhite= false;\n            break;\n          case ')':\n            regex.append(\"\\\\)\");\n            wasWhite= false;\n            break;\n          case '[':\n            regex.append(\"\\\\[\");\n            wasWhite= false;\n            break;\n          case ']':\n            regex.append(\"\\\\]\");\n            wasWhite= false;\n            break;\n          case '{':\n            regex.append(\"\\\\{\");\n            wasWhite= false;\n            break;\n          case '}':\n            regex.append(\"\\\\}\");\n            wasWhite= false;\n            break;\n          case'':\n            regex.append(\"\\\\s\");\n            wasWhite= true;\n            break;\n          case '\\t':\n            regex.append(\"\\\\t\");\n            wasWhite= true;\n            break;\n          case '\\n':\n            regex.append(\"\\\\n\");\n            wasWhite= true;\n            break;\n          case '\\r':\n            regex.append(\"\\\\r\");\n            wasWhite= true;\n            break;\n          default:\n            if(!wasWhite) {",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n          case '\\\\':\n            regex.append(\"\\\\\\\\\");\n            wasWhite= false;\n            break;\n          case '?':\n            regex.append(\"\\\\?\");\n            wasWhite= false;\n            break;\n          case '*':\n            regex.append(\"\\\\*\");\n            wasWhite= false;\n            break;\n          case '+':\n            regex.append(\"\\\\+\");\n            wasWhite= false;\n            break;\n          case '|':\n            regex.append(\"\\\\|\");\n            wasWhite= false;\n            break;\n          case '$':\n            regex.append(\"\\\\$\");\n            wasWhite= false;\n            break;\n          case '(':\n            regex.append(\"\\\\(\");\n            wasWhite= false;\n            break;\n          case ')':\n            regex.append(\"\\\\)\");\n            wasWhite= false;\n            break;\n          case '[':\n            regex.append(\"\\\\[\");\n            wasWhite= false;\n            break;\n          case ']':\n            regex.append(\"\\\\]\");\n            wasWhite= false;\n            break;\n          case '{':\n            regex.append(\"\\\\{\");\n            wasWhite= false;\n            break;\n          case '}':\n            regex.append(\"\\\\}\");\n            wasWhite= false;\n            break;\n          case'':\n            regex.append(\"\\\\s\");\n            wasWhite= true;\n            break;\n          case '\\t':\n            regex.append(\"\\\\t\");\n            wasWhite= true;\n            break;\n          case '\\n':\n            regex.append(\"\\\\n\");\n            wasWhite= true;\n            break;\n          case '\\r':\n            regex.append(\"\\\\r\");\n            wasWhite= true;\n            break;\n          default:\n            if (unquote && (c",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n          case '\\\\':\n            regex.append(\"\\\\\\\\\");\n            wasWhite= false;\n            break;\n          case '?':\n            regex.append(\"\\\\?\");\n            wasWhite= false;\n            break;\n          case '*':\n            regex.append(\"\\\\*\");\n            wasWhite= false;\n            break;\n          case '+':\n            regex.append(\"\\\\+\");\n            wasWhite= false;\n            break;\n          case '|':\n            regex.append(\"\\\\|\");\n            wasWhite= false;\n            break;\n          case '$':\n            regex.append(\"\\\\$\");\n            wasWhite= false;\n            break;\n          case '(':\n            regex.append(\"\\\\(\");\n            wasWhite= false;\n            break;\n          case ')':\n            regex.append(\"\\\\)\");\n            wasWhite= false;\n            break;\n          case '[':\n            regex.append(\"\\\\[\");\n            wasWhite= false;\n            break;\n          case ']':\n            regex.append(\"\\\\]\");\n            wasWhite= false;\n            break;\n          case '{':\n            regex.append(\"\\\\{\");\n            wasWhite= false;\n            break;\n          case '}':\n            regex.append(\"\\\\}\");\n            wasWhite= false;\n            break;\n          case'':\n            regex.append(\"\\\\s\");\n            wasWhite= true;\n            break;\n          case '\\t':\n            regex.append(\"\\\\t\");\n            wasWhite= true;\n            break;\n          case '\\n':\n            regex.append(\"\\\\n\");\n            wasWhite= true;\n            break;\n          case '\\r':\n            regex.append(\"\\\\r\");\n            wasWhite= true;\n            break;\n          default:\n            if(unquote && (c",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n          case '\\\\':\n            regex.append(\"\\\\\\\\\");\n            wasWhite= false;\n            break;\n          case '?':\n            regex.append(\"\\\\?\");\n            wasWhite= false;\n            break;\n          case '*':\n            regex.append(\"\\\\*\");\n            wasWhite= false;\n            break;\n          case '+':\n            regex.append(\"\\\\+\");\n            wasWhite= false;\n            break;\n          case '|':\n            regex.append(\"\\\\|\");\n            wasWhite= false;\n            break;\n          case '$':\n            regex.append(\"\\\\$\");\n            wasWhite= false;\n            break;\n          case '(':\n            regex.append(\"\\\\(\");\n            wasWhite= false;\n            break;\n          case ')':\n            regex.append(\"\\\\)\");\n            wasWhite= false;\n            break;\n          case '[':\n            regex.append(\"\\\\[\");\n            wasWhite= false;\n            break;\n          case ']':\n            regex.append(\"\\\\]\");\n            wasWhite= false;\n            break;\n          case '{':\n            regex.append(\"\\\\{\");\n            wasWhite= false;\n            break;\n          case '}':\n            regex.append(\"\\\\}\");\n            wasWhite= false;\n            break;\n          case'':\n            regex.append(\"\\\\s\");\n            wasWhite= true;\n            break;\n          case '\\t':\n            regex.append(\"\\\\t\");\n            wasWhite= true;\n            break;\n          case '\\n':\n            regex.append(\"\\\\n\");\n            wasWhite= true;\n            break;\n          case '\\r':\n            regex.append(\"\\\\r\");\n            wasWhite= true;\n            break;\n          default:\n            if(!Character.isWh",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n          case '\\\\':\n            regex.append(\"\\\\\\\\\");\n            wasWhite= false;\n            break;\n          case '?':\n            regex.append(\"\\\\?\");\n            wasWhite= false;\n            break;\n          case '*':\n            regex.append(\"\\\\*\");\n            wasWhite= false;\n            break;\n          case '+':\n            regex.append(\"\\\\+\");\n            wasWhite= false;\n            break;\n          case '|':\n            regex.append(\"\\\\|\");\n            wasWhite= false;\n            break;\n          case '$':\n            regex.append(\"\\\\$\");\n            wasWhite= false;\n            break;\n          case '(':\n            regex.append(\"\\\\(\");\n            wasWhite= false;\n            break;\n          case ')':\n            regex.append(\"\\\\)\");\n            wasWhite= false;\n            break;\n          case '[':\n            regex.append(\"\\\\[\");\n            wasWhite= false;\n            break;\n          case ']':\n            regex.append(\"\\\\]\");\n            wasWhite= false;\n            break;\n          case '{':\n            regex.append(\"\\\\{\");\n            wasWhite= false;\n            break;\n          case '}':\n            regex.append(\"\\\\}\");\n            wasWhite= false;\n            break;\n          case'':\n            regex.append(\"\\\\s\");\n            wasWhite= true;\n            break;\n          case '\\t':\n            regex.append(\"\\\\t\");\n            wasWhite= true;\n            break;\n          case '\\r':\n            regex.append(\"\\\\r\");\n            wasWhite= true;\n            break;\n          case '\\n':\n            regex.append(\"\\\\n\");\n            wasWhite= true;\n            break;\n          default:\n            if(!wasWhite) {"
      ],
      "function range": "303,5-343,5"
    },
    "Lang_38_src/java/org/apache/commons/lang3/time/FastDateFormat.java_872-872": {
      "loc": "872-872",
      "input": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {",
      "output": [
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      buf.append(calendar.getTimeZone().getID());\n    } else {\n      buf.append(calendar.getTimeZone().getDisplayName(false, TimeZone.SHORT));\n    }\n    return buf;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      buf.append(calendar.getTimeZone().getID());\n    } else {\n      buf.append(calendar.getTimeZone().getDisplayName(false, TimeZone.SHORT));\n    }\n    return buf;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      buf.append(calendar.getTimeZone().getID());\n    } else {\n      buf.append(calendar.getTimeZone().getDisplayName(false, TimeZone.SHORT));\n    }\n    return buf;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyr",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      buf.append(calendar.getTimeZone().getID());\n    } else {\n      buf.append(calendar.getTimeZone().getDisplayName(false, TimeZone.SHORT));\n    }\n    return buf;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      buf.append(calendar.getTimeZone().getID());\n    } else {\n      buf.append(calendar.getTimeZone().getDisplayName(false, TimeZone.SHORT));\n    }\n    return buf;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      buf.append(calendar.getTimeZone().getID());\n    } else {\n      buf.append(calendar.getTimeZone().getDisplayName(false, TimeZone.SHORT));\n    }\n    return buf;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      buf.append(calendar.getTimeZone().getID());\n    } else {\n      buf.append(calendar.getTimeZone().getDisplayName(false, TimeZone.SHORT));\n    }\n    return buf;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      buf.append(calendar.getTimeZone().getID());\n    } else {\n      buf.append(calendar.getTimeZone().getDisplayName(false, TimeZone.SHORT));\n    }\n    return buf;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      buf.append(calendar.getTimeZone().getID());\n    } else {\n      buf.append(calendar.getTimeZone().getDisplayName(false, TimeZone.SHORT));\n    }\n    return buf;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunction",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      buf.append(calendar.getTimeZone().getID());\n    } else {\n      buf.append(calendar.getTimeZone().getDisplayName(false, TimeZone.SHORT));\n    }\n    return buf;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra."
      ],
      "function range": "870,5-876,5"
    },
    "Math_65_src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java_258-259": {
      "loc": "258-259",
      "input": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];",
      "output": [
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        final double expected = expectedValues[i];\n        chiSquare += residual * residual / expected;\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.alge",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        final double expected = expectedValues[i];\n        chiSquare += residual * residual / expected;\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.oper",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        final double expected = expectedValues[i];\n        chiSquare += residual * residual / expected;\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algeb",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        final double expected = expectedValues[i];\n        chiSquare += residual * residual / expected;\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        final double expected = expectedValues[i];\n        chiSquare += residual * residual / expected;\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        final double expected = expectedValues[i];\n        chiSquare += residual * residual / expected;\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        final double expected = expectedValues[i];\n        chiSquare += residual * residual / expected;\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        final double expected = expectedValues[i];\n        chiSquare += residual * residual / expected;\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.express",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        final double expected = expectedValues[i];\n        chiSquare += residual * residual / expected;\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        final double expected = expectedValues[i];\n        chiSquare += residual * residual / expected;\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks."
      ],
      "function range": "254,5-261,5"
    },
    "Math_79_src/main/java/org/apache/commons/math/util/MathUtils.java_1624-1625": {
      "loc": "1624-1625",
      "input": "public static double distance(int[] p1, int[] p2) {",
      "output": [
        "public static double distance(int[] p1, int[] p2) {\n        int x1 = p1[0];\n        int y1 = p1[1];\n        int x2 = p2[0];\n        int y2 = p2[1];\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.",
        "public static double distance(int[] p1, int[] p2) {\n        int x1 = p1[0];\n        int y1 = p1[1];\n        int x2 = p2[0];\n        int y2 = p2[1];\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.al",
        "public static double distance(int[] p1, int[] p2) {\n        int x1 = p1[0];\n        int y1 = p1[1];\n        int x2 = p2[0];\n        int y2 = p2[1];\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\n",
        "public static double distance(int[] p1, int[] p2) {\n        int x1 = p1[0];\n        int y1 = p1[1];\n        int x2 = p2[0];\n        int y2 = p2[1];\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks",
        "public static double distance(int[] p1, int[] p2) {\n        int x1 = p1[0];\n        int y1 = p1[1];\n        int x2 = p2[0];\n        int y2 = p2[1];\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.al",
        "public static double distance(int[] p1, int[] p2) {\n        int x1 = p1[0];\n        int y1 = p1[1];\n        int x2 = p2[0];\n        int y2 = p2[1];\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag",
        "public static double distance(int[] p1, int[] p2) {\n        int x1 = p1[0];\n        int y1 = p1[1];\n        int x2 = p2[0];\n        int y2 = p2[1];\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;",
        "public static double distance(int[] p1, int[] p2) {\n        int x1 = p1[0];\n        int y1 = p1[1];\n        int x2 = p2[0];\n        int y2 = p2[1];\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.",
        "public static double distance(int[] p1, int[] p2) {\n        int x1 = p1[0];\n        int y1 = p1[1];\n        int x2 = p2[0];\n        int y2 = p2[1];\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.",
        "public static double distance(int[] p1, int[] p2) {\n        int x1 = p1[0];\n        int y1 = p1[1];\n        int x2 = p2[0];\n        int y2 = p2[1];\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.Abstract"
      ],
      "function range": "1623,5-1630,5"
    },
    "Math_98_src/java/org/apache/commons/math/linear/BigMatrixImpl.java_991-992": {
      "loc": "991-992",
      "input": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length != this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();",
      "output": [
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        out[row] = this.getEntry(row, 0).multiply(v[0]);\n        for (int col = 1; col < nCols; col++) {\n            out[row] = out[row].add(this.getEntry(row, col).multiply(v[col]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int col = 0; col < nCols; col++) {\n        out[col] = v[0].multiply(this.getEntry(0, col));\n        for (int row = 1; row < nRows; row++) {\n            out[col] = out[col].add(v[row].multiply(this.getEntry(row, col)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public FieldMatrix<BigDecimal> transpose() {\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final FieldMatrix<BigDecimal> out = new Array2DRowFieldMatrix<BigDecimal",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int i = 0; i < nRows; i++) {\n        out[i] = this.getEntry(i, 0).multiply(v[0]);\n        for (int j = 1; j < nCols; j++) {\n            out[i] = out[i].add(this.getEntry(i, j).multiply(v[j]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int j = 0; j < nCols; j++) {\n        out[j] = v[0].multiply(this.getEntry(0, j));\n        for (int i = 1; i < nRows; i++) {\n            out[j] = out[j].add(v[i].multiply(this.getEntry(i, j)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public FieldMatrix<BigDecimal> transpose() {\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final FieldMatrix<BigDecimal> out = new Array2DRowFieldMatrix<BigDecimal",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        out[row] = this.getEntry(row, 0).multiply(v[0]);\n        for (int col = 1; col < nCols; col++) {\n            out[row] = out[row].add(this.getEntry(row, col).multiply(v[col]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int col = 0; col < nCols; col++) {\n        out[col] = v[0].multiply(this.getEntry(0, col));\n        for (int row = 1; row < nRows; row++) {\n            out[col] = out[col].add(v[row].multiply(this.getEntry(row, col)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[][] preMultiply(BigDecimal[][] v) throws IllegalArgumentException {\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    if (v.length!= n",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int i = 0; i < nRows; i++) {\n        out[i] = this.getEntry(i, 0).multiply(v[0]);\n        for (int j = 1; j < nCols; j++) {\n            out[i] = out[i].add(this.getEntry(i, j).multiply(v[j]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int j = 0; j < nCols; j++) {\n        out[j] = v[0].multiply(this.getEntry(0, j));\n        for (int i = 1; i < nRows; i++) {\n            out[j] = out[j].add(v[i].multiply(this.getEntry(i, j)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[][] preMultiply(BigDecimal[][] v) throws IllegalArgumentException {\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    if (v.length!= n",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        out[row] = this.getEntry(row, 0).multiply(v[0]);\n        for (int col = 1; col < nCols; col++) {\n            out[row] = out[row].add(this.getEntry(row, col).multiply(v[col]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int col = 0; col < nCols; col++) {\n        out[col] = v[0].multiply(this.getEntry(0, col));\n        for (int row = 1; row < nRows; row++) {\n            out[col] = out[col].add(v[row].multiply(this.getEntry(row, col)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public FieldMatrix<BigDecimal> transpose() {\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final FieldMatrix<BigDecimal> out = createMatrix(nCols, nRows);",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int i = 0; i < nRows; i++) {\n        out[i] = this.getEntry(i, 0).multiply(v[0]);\n        for (int j = 1; j < nCols; j++) {\n            out[i] = out[i].add(this.getEntry(i, j).multiply(v[j]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int j = 0; j < nCols; j++) {\n        out[j] = v[0].multiply(this.getEntry(0, j));\n        for (int i = 1; i < nRows; i++) {\n            out[j] = out[j].add(v[i].multiply(this.getEntry(i, j)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public FieldMatrix<BigDecimal> transpose() {\n    final int nRows = getRowDimension();\n    final int nCols = getColumnDimension();\n    final FieldMatrix<BigDecimal> out = new Array2DRowFieldMatrix<BigDecimal>(field, n",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        out[row] = this.getEntry(row, 0).multiply(v[0]);\n        for (int col = 1; col < nCols; col++) {\n            out[row] = out[row].add(this.getEntry(row, col).multiply(v[col]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int col = 0; col < nCols; col++) {\n        out[col] = v[0].multiply(this.getEntry(0, col));\n        for (int row = 1; row < nRows; row++) {\n            out[col] = out[col].add(v[row].multiply(this.getEntry(row, col)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public FieldMatrix<BigDecimal> transpose() {\n    final int nRows = getRowDimension();\n    final int nCols = getColumnDimension();\n    final FieldMatrix<BigDecimal> out = new Array2DRowFieldMatrix<BigDecimal>(field, n",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        out[row] = this.getEntry(row, 0).multiply(v[0]);\n        for (int col = 1; col < nCols; col++) {\n            out[row] = out[row].add(this.getEntry(row, col).multiply(v[col]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int col = 0; col < nCols; col++) {\n        out[col] = v[0].multiply(this.getEntry(0, col));\n        for (int row = 1; row < nRows; row++) {\n            out[col] = out[col].add(v[row].multiply(this.getEntry(row, col)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[][] preMultiply(BigDecimal[][] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    if (v[",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int i = 0; i < nRows; i++) {\n        out[i] = this.getEntry(i, 0).multiply(v[0]);\n        for (int j = 1; j < nCols; j++) {\n            out[i] = out[i].add(this.getEntry(i, j).multiply(v[j]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int j = 0; j < nCols; j++) {\n        out[j] = v[0].multiply(this.getEntry(0, j));\n        for (int i = 1; i < nRows; i++) {\n            out[j] = out[j].add(v[i].multiply(this.getEntry(i, j)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[][] preMultiply(BigDecimal[][] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    if (v[",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        out[row] = this.getEntry(row, 0).multiply(v[0]);\n        for (int col = 1; col < nCols; col++) {\n            out[row] = out[row].add(this.getEntry(row, col).multiply(v[col]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int col = 0; col < nCols; col++) {\n        out[col] = v[0].multiply(this.getEntry(0, col));\n        for (int row = 1; row < nRows; row++) {\n            out[col] = out[col].add(v[row].multiply(this.getEntry(row, col)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[][] operate(BigDecimal[][] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    if (v[0].length"
      ],
      "function range": "985,5-1000,5"
    },
    "Chart_1_/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java_1797-1798": {
      "loc": "1797-1798",
      "input": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);",
      "output": [
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getSeriesCount();\n    for (int i = 0; i < seriesCount; i++) {\n        String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                dataset, i);\n        String description = label;\n        String toolTipText = null;\n        if (this.plot.getLegendItemToolTipGenerator()!= null) {\n            toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                    dataset, i);\n        }\n        String urlText = null;\n        if (this.plot.getLegendItemURLGenerator()!= null) {\n            urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                    dataset, i);\n        }\n        Shape shape = lookupLegendShape(i);\n        Paint paint = lookupSeriesPaint(i);\n        Paint outlinePaint = lookupSeriesOutlinePaint(i);\n        Stroke outlineStroke = lookupSeriesOutlineStroke(i);\n        LegendItem item = new LegendItem(label, description, toolTipText,\n                urlText, shape, paint, outlineStroke, outlinePaint);\n        item.setSeriesKey(dataset.getSeriesKey(i));\n        item.setSeriesIndex(i);\n        item.setDataset(dataset);\n        result.add(item);\n    }\n    return result;\n  }\n\n  /**\n   * Returns a shape used to represent the items in a series.\n   *\n   * @param series  the series (zero-based index).\n   *\n   * @return The shape (never <code>null</code>).\n   */\n  public Shape getSeriesShape(int series) {\n    return lookupSeriesShape(",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getSeriesCount();\n    for (int i = 0; i < seriesCount; i++) {\n        String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                dataset, i);\n        String description = label;\n        String toolTipText = null;\n        if (this.plot.getLegendItemToolTipGenerator()!= null) {\n            toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                    dataset, i);\n        }\n        String urlText = null;\n        if (this.plot.getLegendItemURLGenerator()!= null) {\n            urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                    dataset, i);\n        }\n        Shape shape = lookupLegendShape(i);\n        Paint paint = lookupSeriesPaint(i);\n        Paint outlinePaint = lookupSeriesOutlinePaint(i);\n        Stroke outlineStroke = lookupSeriesOutlineStroke(i);\n        LegendItem item = new LegendItem(label, description, toolTipText,\n                urlText, shape, paint, outlineStroke, outlinePaint);\n        item.setSeriesKey(dataset.getSeriesKey(i));\n        item.setSeriesIndex(i);\n        item.setDataset(dataset);\n        result.add(item);\n    }\n    return result;\n  }\n\n  /**\n   * Returns a shape used to represent the items in a series.\n   *\n   * @param series  the series index (zero-based).\n   *\n   * @return The shape (never <code>null</code>).\n   */\n  public Shape getSeriesShape(int series) {\n    return lookupSeriesShape(",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getSeriesCount();\n    for (int i = 0; i < seriesCount; i++) {\n        String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                dataset, i);\n        String description = label;\n        String toolTipText = null;\n        if (this.plot.getLegendItemToolTipGenerator()!= null) {\n            toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                    dataset, i);\n        }\n        String urlText = null;\n        if (this.plot.getLegendItemURLGenerator()!= null) {\n            urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                    dataset, i);\n        }\n        Shape shape = lookupLegendShape(i);\n        Paint paint = lookupSeriesPaint(i);\n        Paint outlinePaint = lookupSeriesOutlinePaint(i);\n        Stroke outlineStroke = lookupSeriesOutlineStroke(i);\n        LegendItem item = new LegendItem(label, description, toolTipText,\n                urlText, shape, paint, outlineStroke, outlinePaint);\n        item.setDataset(dataset);\n        item.setSeriesKey(dataset.getSeriesKey(i));\n        item.setSeriesIndex(i);\n        item.setDatasetIndex(index);\n        result.add(item);\n    }\n    return result;\n  }\n\n  /**\n   * Tests this <code>LegendTitle</code> for equality with an arbitrary\n   * object.  This method returns <code>true</code> if and only if:\n   * <ul>\n   * <li><code>obj</code> is not <code>null",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getSeriesCount();\n    for (int i = 0; i < seriesCount; i++) {\n        String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                dataset, i);\n        String description = label;\n        String toolTipText = null;\n        if (this.plot.getLegendItemToolTipGenerator()!= null) {\n            toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                    dataset, i);\n        }\n        String urlText = null;\n        if (this.plot.getLegendItemURLGenerator()!= null) {\n            urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                    dataset, i);\n        }\n        Shape shape = lookupLegendShape(i);\n        Paint paint = lookupSeriesPaint(i);\n        Paint outlinePaint = lookupSeriesOutlinePaint(i);\n        Stroke outlineStroke = lookupSeriesOutlineStroke(i);\n        LegendItem item = new LegendItem(label, description, toolTipText,\n                urlText, shape, paint, outlineStroke, outlinePaint);\n        item.setDataset(dataset);\n        item.setSeriesKey(dataset.getSeriesKey(i));\n        item.setSeriesIndex(i);\n        item.setDatasetIndex(index);\n        result.add(item);\n    }\n    return result;\n  }\n\n  /**\n   * Returns a shape used to represent the items in a series.\n   *\n   * @param series  the series (zero-based index).\n   *\n   * @return The shape (never <code>null</code>).\n   */\n  public Shape getSeriesShape",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getSeriesCount();\n    for (int i = 0; i < seriesCount; i++) {\n        String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                dataset, i);\n        String description = label;\n        String toolTipText = null;\n        if (this.plot.getLegendItemToolTipGenerator()!= null) {\n            toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                    dataset, i);\n        }\n        String urlText = null;\n        if (this.plot.getLegendItemURLGenerator()!= null) {\n            urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                    dataset, i);\n        }\n        Shape shape = lookupLegendShape(i);\n        Paint paint = lookupSeriesPaint(i);\n        Paint outlinePaint = lookupSeriesOutlinePaint(i);\n        Stroke outlineStroke = lookupSeriesOutlineStroke(i);\n        LegendItem item = new LegendItem(label, description, toolTipText,\n                urlText, shape, paint, outlineStroke, outlinePaint);\n        item.setDataset(dataset);\n        item.setDatasetIndex(i);\n        item.setSeriesKey(dataset.getSeriesKey(i));\n        item.setSeriesIndex(i);\n        result.add(item);\n    }\n    return result;\n  }\n\n  /**\n   * Returns a shape used to represent the items in a series.\n   *\n   * @param series  the series (zero-based index).\n   *\n   * @return The shape (never <code>null</code>).\n   */\n  public Shape getSeriesShape",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getSeriesCount();\n    for (int i = 0; i < seriesCount; i++) {\n        String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                dataset, i);\n        String description = label;\n        String toolTipText = null;\n        if (this.plot.getLegendItemToolTipGenerator()!= null) {\n            toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                    dataset, i);\n        }\n        String urlText = null;\n        if (this.plot.getLegendItemURLGenerator()!= null) {\n            urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                    dataset, i);\n        }\n        Shape shape = lookupLegendShape(i);\n        Paint paint = lookupSeriesPaint(i);\n        Paint outlinePaint = lookupSeriesOutlinePaint(i);\n        Stroke outlineStroke = lookupSeriesOutlineStroke(i);\n        LegendItem item = new LegendItem(label, description, toolTipText,\n                urlText, shape, paint, outlineStroke, outlinePaint);\n        item.setDataset(dataset);\n        item.setDatasetIndex(i);\n        item.setSeriesKey(dataset.getRowKey(i));\n        item.setSeriesIndex(i);\n        result.add(item);\n    }\n    return result;\n  }\n\n  /**\n   * Returns a shape used to represent the items in a series.\n   *\n   * @param series  the series (zero-based index).\n   *\n   * @return The shape (never <code>null</code>).\n   */\n  public Shape getSeriesShape",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getSeriesCount();\n    for (int i = 0; i < seriesCount; i++) {\n        String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                dataset, i);\n        String description = label;\n        String toolTipText = null;\n        if (this.plot.getLegendItemToolTipGenerator()!= null) {\n            toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                    dataset, i);\n        }\n        String urlText = null;\n        if (this.plot.getLegendItemURLGenerator()!= null) {\n            urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                    dataset, i);\n        }\n        Shape shape = lookupLegendShape(i);\n        Paint paint = lookupSeriesPaint(i);\n        Paint outlinePaint = lookupSeriesOutlinePaint(i);\n        Stroke outlineStroke = lookupSeriesOutlineStroke(i);\n        LegendItem item = new LegendItem(label, description, toolTipText,\n                urlText, shape, paint, outlineStroke, outlinePaint);\n        item.setDataset(dataset);\n        item.setSeriesKey(dataset.getSeriesKey(i));\n        item.setSeriesIndex(i);\n        item.setDatasetIndex(index);\n        result.add(item);\n    }\n    return result;\n  }\n\n  /**\n   * Tests this <code>LegendTitle</code> for equality with an arbitrary\n   * object.  This method returns <code>true</code> if and only if:\n   * <ul>\n   * <li><code>obj</code> is an instance of <code",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getSeriesCount();\n    for (int i = 0; i < seriesCount; i++) {\n        String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                dataset, i);\n        String description = label;\n        String toolTipText = null;\n        if (this.plot.getLegendItemToolTipGenerator()!= null) {\n            toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                    dataset, i);\n        }\n        String urlText = null;\n        if (this.plot.getLegendItemURLGenerator()!= null) {\n            urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                    dataset, i);\n        }\n        Shape shape = lookupLegendShape(i);\n        Paint paint = lookupSeriesPaint(i);\n        Paint outlinePaint = lookupSeriesOutlinePaint(i);\n        Stroke outlineStroke = lookupSeriesOutlineStroke(i);\n        LegendItem item = new LegendItem(label, description, toolTipText,\n                urlText, shape, paint, outlineStroke, outlinePaint);\n        item.setSeriesKey(dataset.getSeriesKey(i));\n        item.setSeriesIndex(i);\n        item.setDataset(dataset);\n        item.setDatasetIndex(index);\n        result.add(item);\n    }\n    return result;\n  }\n\n  /**\n   * Returns a shape used to represent the items in a series.\n   *\n   * @param series  the series (zero-based index).\n   *\n   * @return The shape (never <code>null</code>).\n   */\n  public Shape getSeriesShape",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getSeriesCount();\n    for (int i = 0; i < seriesCount; i++) {\n        String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                dataset, i);\n        String description = label;\n        String toolTipText = null;\n        if (this.plot.getLegendItemToolTipGenerator()!= null) {\n            toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                    dataset, i);\n        }\n        String urlText = null;\n        if (this.plot.getLegendItemURLGenerator()!= null) {\n            urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                    dataset, i);\n        }\n        Shape shape = lookupLegendShape(i);\n        Paint paint = lookupSeriesPaint(i);\n        Paint outlinePaint = lookupSeriesOutlinePaint(i);\n        Stroke outlineStroke = lookupSeriesOutlineStroke(i);\n        LegendItem item = new LegendItem(label, description, toolTipText,\n                urlText, shape, paint, outlineStroke, outlinePaint);\n        item.setDataset(dataset);\n        item.setSeriesKey(dataset.getSeriesKey(i));\n        item.setSeriesIndex(i);\n        item.setDatasetIndex(index);\n        result.add(item);\n    }\n    return result;\n  }\n\n  /**\n   * Returns a shape used to represent the items in a series.\n   *\n   * @param series  the series (zero-based index).\n   *\n   * @return The shape (never <code>null</code>).\n   */\n  public Shape lookupSeriesShape",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getSeriesCount();\n    for (int i = 0; i < seriesCount; i++) {\n        String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                dataset, i);\n        String description = label;\n        String toolTipText = null;\n        if (this.plot.getLegendItemToolTipGenerator()!= null) {\n            toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                    dataset, i);\n        }\n        String urlText = null;\n        if (this.plot.getLegendItemURLGenerator()!= null) {\n            urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                    dataset, i);\n        }\n        Shape shape = lookupLegendShape(i);\n        Paint paint = lookupSeriesPaint(i);\n        Paint outlinePaint = lookupSeriesOutlinePaint(i);\n        Stroke outlineStroke = lookupSeriesOutlineStroke(i);\n        LegendItem item = new LegendItem(label, description, toolTipText,\n                urlText, shape, paint, outlineStroke, outlinePaint);\n        item.setDataset(dataset);\n        item.setDatasetIndex(i);\n        item.setSeriesKey(dataset.getSeriesKey(i));\n        item.setSeriesIndex(i);\n        result.add(item);\n    }\n    return result;\n  }\n\n  /**\n   * Returns a shape used to represent the items in a series.\n   *\n   * @param series  the series (zero-based index).\n   *\n   * @return The shape (never <code>null</code>).\n   */\n  public Shape lookupSeriesShape"
      ],
      "function range": "1790,5-1822,5"
    },
    "Chart_3_/source/org/jfree/data/time/TimeSeries.java_1057-1058": {
      "loc": "1057-1058",
      "input": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();",
      "output": [
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start];\n    System.arraycopy(data, start, copy.data, 0, end - start);\n    return copy;\n    }\n\n    /**\n     * Tests if this time series equals another.\n     *\n     * @param arg0  the other time series.\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object arg0) {\n        if (arg0 == this) {\n            return true;\n        }\n        if (!(arg0 instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries arg = (TimeSeries) arg0;\n        if (getItemCount()!= arg.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < getItemCount(); i++) {\n            if (!ObjectUtilities.equal(getDataItem(i), arg.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return the hashcode\n     */\n    public int hashCode() {\n        int result;\n        result = this.data.hashCode();\n        result = 29 * result + super.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns a clone of the time series.\n     * <P>\n     * Notes:\n     * <ul>\n     *   <li>no need to clone the domain and range descriptions, since String\n     *     object is immutable;</li>\n     *   <li>we pass over to the more general method clone(start, end).</li>\n     * </ul>\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupported",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start];\n    System.arraycopy(data, start, copy.data, 0, end - start);\n    return copy;\n    }\n\n    /**\n     * Tests if this time series equals another.\n     *\n     * @param arg0  the other time series.\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object arg0) {\n        if (arg0 == this) {\n            return true;\n        }\n        if (!(arg0 instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries arg = (TimeSeries) arg0;\n        if (getItemCount()!= arg.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < getItemCount(); i++) {\n            if (!ObjectUtilities.equal(getDataItem(i), arg.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return the hashcode\n     */\n    public int hashCode() {\n        int result;\n        result = this.data.hashCode();\n        result = 29 * result + super.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns a clone of the time series.\n     * <P>\n     * Notes:\n     * <ul>\n     *   <li>no need to clone the domain and range descriptions, since String \n     *     object is immutable;</li>\n     *   <li>we pass over to the more general method clone(start, end).</li>\n     * </ul>\n     *\n     * @return A clone.\n     *\n     * @throws CloneNot",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start];\n    System.arraycopy(data, start, copy.data, 0, end - start);\n    return copy;\n    }\n\n    /**\n     * Tests if this time series equals another.\n     *\n     * @param arg0  the other time series.\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object arg0) {\n        if (arg0 == this) {\n            return true;\n        }\n        if (!(arg0 instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries arg = (TimeSeries) arg0;\n        if (getItemCount()!= arg.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < getItemCount(); i++) {\n            if (!ObjectUtilities.equal(getDataItem(i), arg.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result;\n        result = (this.data!= null? this.data.hashCode() : 0);\n        result = 29 * result + (this.workingCalendar!= null\n               ? this.workingCalendar.hashCode() : 0);\n        return result;\n    }\n\n    /**\n     * Returns a clone of this time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if cloning is not possible.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (double[]) this.data.clone();",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start];\n    System.arraycopy(data, start, copy.data, 0, end - start);\n    return copy;\n    }\n\n    /**\n     * Tests if this time series equals another.\n     *\n     * @param arg0  the other time series.\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object arg0) {\n        if (arg0 == this) {\n            return true;\n        }\n        if (!(arg0 instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries arg = (TimeSeries) arg0;\n        if (getItemCount()!= arg.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < getItemCount(); i++) {\n            if (!ObjectUtilities.equal(getDataItem(i), arg.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return the hashcode\n     */\n    public int hashCode() {\n        int result;\n        result = this.data.hashCode();\n        result = 29 * result + super.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns a clone of the time series.\n     * <P>\n     * Notes:\n     * <ul>\n     *   <li>no need to clone the domain and range descriptions, since String \n     *     object is immutable;</li>\n     *   <li>we pass over to the more general method clone(start, end).</li>\n     * </ul>\n     *\n     * @return A clone.\n     * \n     * @throws Clone",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start];\n    System.arraycopy(data, start, copy.data, 0, end - start);\n    return copy;\n    }\n\n    /**\n     * Tests if this time series equals another.\n     *\n     * @param arg0  the other time series.\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object arg0) {\n        if (arg0 == this) {\n            return true;\n        }\n        if (!(arg0 instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries arg = (TimeSeries) arg0;\n        if (getItemCount()!= arg.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < getItemCount(); i++) {\n            if (!ObjectUtilities.equal(getDataItem(i), arg.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result;\n        result = this.data.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns a clone of this time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if cloning is not possible.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = new double[this.data.length];\n        System.arraycopy(this.data, 0, clone.data, 0, this.data.length);\n        return clone;\n    }\n\n}\n<|java|",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start];\n    System.arraycopy(data, start, copy.data, 0, end - start);\n    return copy;\n    }\n\n    /**\n     * Tests if this time series equals another.\n     *\n     * @param arg0  the other time series.\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object arg0) {\n        if (arg0 == this) {\n            return true;\n        }\n        if (!(arg0 instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries arg = (TimeSeries) arg0;\n        if (getItemCount()!= arg.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < getItemCount(); i++) {\n            if (!ObjectUtilities.equal(getDataItem(i), arg.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result;\n        result = this.data.hashCode();\n        result = 29 * result + (this.workingCalendar!= null\n               ? this.workingCalendar.hashCode() : 0);\n        return result;\n    }\n\n    /**\n     * Returns a clone of this time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if cloning is not possible.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (double[]) this.data.clone();\n        clone.workingCalendar = (Cal",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start];\n    System.arraycopy(data, start, copy.data, 0, end - start);\n    return copy;\n    }\n\n    /**\n     * Tests if this time series equals another.\n     *\n     * @param arg0  the other time series.\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object arg0) {\n        if (arg0 == this) {\n            return true;\n        }\n        if (!(arg0 instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries arg = (TimeSeries) arg0;\n        if (getItemCount()!= arg.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < getItemCount(); i++) {\n            if (!ObjectUtilities.equal(getDataItem(i), arg.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result;\n        result = this.data.hashCode();\n        result = 29 * result + (this.workingCalendar!= null\n               ? this.workingCalendar.hashCode() : 0);\n        return result;\n    }\n\n    /**\n     * Returns a clone of this time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if cloning is not possible.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.workingCalendar = (Calendar) this.workingCalendar.clone();\n        clone.data =",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start];\n    System.arraycopy(data, start, copy.data, 0, end - start);\n    return copy;\n    }\n\n    /**\n     * Tests if this time series equals another.\n     *\n     * @param arg0  the other time series.\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object arg0) {\n        if (arg0 == this) {\n            return true;\n        }\n        if (!(arg0 instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries arg = (TimeSeries) arg0;\n        if (getItemCount()!= arg.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < getItemCount(); i++) {\n            if (!ObjectUtilities.equal(getDataItem(i), arg.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result;\n        result = this.data.hashCode();\n        result = 29 * result + (this.workingCalendar!= null\n               ? this.workingCalendar.hashCode() : 0);\n        return result;\n    }\n\n    /**\n     * Returns a clone of this time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if cloning is not possible.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (double[]) this.data.clone();\n        return clone;\n    }\n\n    ",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start];\n    System.arraycopy(data, start, copy.data, 0, end - start);\n    return copy;\n    }\n\n    /**\n     * Tests if this time series equals another.\n     *\n     * @param arg0  the other time series.\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object arg0) {\n        if (arg0 == this) {\n            return true;\n        }\n        if (!(arg0 instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries arg = (TimeSeries) arg0;\n        if (getItemCount()!= arg.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < getItemCount(); i++) {\n            if (!ObjectUtilities.equal(getDataItem(i), arg.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result;\n        result = this.data.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns a clone of this time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if cloning is not possible.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = new double[this.data.length];\n        System.arraycopy(this.data, 0, clone.data, 0, this.data.length);\n        return clone;\n    }\n\n    /**\n     * Provides serialization",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start];\n    System.arraycopy(data, start, copy.data, 0, end - start);\n    return copy;\n    }\n\n    /**\n     * Tests if this time series equals another.\n     *\n     * @param arg0  the other time series.\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object arg0) {\n        if (arg0 == this) {\n            return true;\n        }\n        if (!(arg0 instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries arg = (TimeSeries) arg0;\n        if (getItemCount()!= arg.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < getItemCount(); i++) {\n            if (!ObjectUtilities.equal(getDataItem(i), arg.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result;\n        result = this.data.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns a clone of this time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if cloning is not possible.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = new double[this.data.length];\n        System.arraycopy(this.data, 0, clone.data, 0, this.data.length);\n        return clone;\n    }\n\n    /**\n     * Returns a new"
      ],
      "function range": "1048,5-1072,5"
    },
    "Chart_6_/source/org/jfree/chart/util/ShapeList.java_111-112": {
      "loc": "111-112",
      "input": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }",
      "output": [
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < size(); i++) {\n        if (!get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 1;\n    for (int i = 0; i < size(); i++) {\n      result = 31 * result + get(i).hashCode();\n    }\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < size(); i++) {\n      builder.append(get(i).toString());\n      if (i < size() - 1) {\n        builder.append(\", \");\n      }\n    }\n    return builder.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < size(); i++) {\n        if (!get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 1;\n    for (int i = 0; i < size(); i++) {\n      result = 31 * result + get(i).hashCode();\n    }\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < size(); i++) {\n      builder.append(get(i).toString());\n      if (i < size() - 1) {\n        builder.append(\", \");\n      }\n    }\n    return builder.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules.subplan;\n\nimport java.util",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (other.size()!= size()) {\n        return false;\n    }\n    for (int i = 0; i < size(); i++) {\n        if (!get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 1;\n    for (int i = 0; i < size(); i++) {\n      result = 31 * result + get(i).hashCode();\n    }\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < size(); i++) {\n      builder.append(get(i).toString());\n      if (i < size() - 1) {\n        builder.append(\", \");\n      }\n    }\n    return builder.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (other.size()!= size()) {\n        return false;\n    }\n    for (int i = 0; i < size(); i++) {\n        if (!get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 1;\n    for (int i = 0; i < size(); i++) {\n      result = 31 * result + get(i).hashCode();\n    }\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < size(); i++) {\n      builder.append(get(i).toString());\n      if (i < size() - 1) {\n        builder.append(\", \");\n      }\n    }\n    return builder.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules.subplan;\n\nimport java.util",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < size(); i++) {\n        if (!get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 1;\n    for (int i = 0; i < size(); i++) {\n      result = 31 * result + get(i).hashCode();\n    }\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < size(); i++) {\n      builder.append(get(i).toString());\n      if (i < size() - 1) {\n        builder.append(\", \");\n      }\n    }\n    return builder.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.*;\nimport org.apache.ign",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < size(); i++) {\n        if (!get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 1;\n    for (int i = 0; i < size(); i++) {\n      result = 31 * result + get(i).hashCode();\n    }\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < size(); i++) {\n      builder.append(get(i).toString());\n      if (i < size() - 1) {\n        builder.append(\", \");\n      }\n    }\n    return builder.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < size(); i++) {\n        if (!get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 1;\n    for (int i = 0; i < size(); i++) {\n      result = 31 * result + get(i).hashCode();\n    }\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < size(); i++) {\n      builder.append(get(i).toString());\n      if (i < size() - 1) {\n        builder.append(\", \");\n      }\n    }\n    return builder.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.Collection;",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < size(); i++) {\n        if (!get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 1;\n    for (int i = 0; i < size(); i++) {\n      result = 31 * result + get(i).hashCode();\n    }\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < size(); i++) {\n      builder.append(get(i).toString());\n      if (i < size() - 1) {\n        builder.append(\", \");\n      }\n    }\n    return builder.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (other.size()!= size()) {\n        return false;\n    }\n    for (int i = 0; i < size(); i++) {\n        if (!get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 1;\n    for (int i = 0; i < size(); i++) {\n      result = 31 * result + get(i).hashCode();\n    }\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < size(); i++) {\n      builder.append(get(i).toString());\n      if (i < size() - 1) {\n        builder.append(\", \");\n      }\n    }\n    return builder.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < size(); i++) {\n        if (!get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 1;\n    for (int i = 0; i < size(); i++) {\n      result = 31 * result + get(i).hashCode();\n    }\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < size(); i++) {\n      builder.append(get(i).toString());\n      if (i < size() - 1) {\n        builder.append(\", \");\n      }\n    }\n    return builder.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.HashSet"
      ],
      "function range": "103,5-113,5"
    },
    "Chart_8_/source/org/jfree/data/time/Week.java_175-176": {
      "loc": "175-176",
      "input": "public Week(Date time, TimeZone zone) {",
      "output": [
        "public Week(Date time, TimeZone zone) {\n        this.time = time;\n        this.zone = zone;\n    }\n\n    public Date getTime() {\n        return time;\n    }\n\n    public void setTime(Date time) {\n        this.time = time;\n    }\n\n    public TimeZone getZone() {\n        return zone;\n    }\n\n    public void setZone(TimeZone zone) {\n        this.zone = zone;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((time == null)? 0 : time.hashCode());\n        result = prime * result + ((zone == null)? 0 : zone.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        Week other = (Week) obj;\n        if (time == null) {\n            if (other.time!= null)\n                return false;\n        } else if (!time.equals(other.time))\n            return false;\n        if (zone == null) {\n            if (other.zone!= null)\n                return false;\n        } else if (!zone.equals(other.zone))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Week [time=\" + time + \", zone=\" + zone + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n",
        "public Week(Date time, TimeZone zone) {\n        this.time = time;\n        this.zone = zone;\n    }\n\n    public Date getTime() {\n        return time;\n    }\n\n    public void setTime(Date time) {\n        this.time = time;\n    }\n\n    public TimeZone getZone() {\n        return zone;\n    }\n\n    public void setZone(TimeZone zone) {\n        this.zone = zone;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((time == null)? 0 : time.hashCode());\n        result = prime * result + ((zone == null)? 0 : zone.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        Week other = (Week) obj;\n        if (time == null) {\n            if (other.time!= null)\n                return false;\n        } else if (!time.equals(other.time))\n            return false;\n        if (zone == null) {\n            if (other.zone!= null)\n                return false;\n        } else if (!zone.equals(other.zone))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Week [time=\" + time + \", zone=\" + zone + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0",
        "public Week(Date time, TimeZone zone) {\n        this.time = time;\n        this.zone = zone;\n    }\n\n    public Date getTime() {\n        return time;\n    }\n\n    public void setTime(Date time) {\n        this.time = time;\n    }\n\n    public TimeZone getZone() {\n        return zone;\n    }\n\n    public void setZone(TimeZone zone) {\n        this.zone = zone;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((time == null)? 0 : time.hashCode());\n        result = prime * result + ((zone == null)? 0 : zone.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        Week other = (Week) obj;\n        if (time == null) {\n            if (other.time!= null)\n                return false;\n        } else if (!time.equals(other.time))\n            return false;\n        if (zone == null) {\n            if (other.zone!= null)\n                return false;\n        } else if (!zone.equals(other.zone))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Week [time=\" + time + \", zone=\" + zone + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0",
        "public Week(Date time, TimeZone zone) {\n        this.time = time;\n        this.zone = zone;\n    }\n\n    public Date getTime() {\n        return time;\n    }\n\n    public void setTime(Date time) {\n        this.time = time;\n    }\n\n    public TimeZone getZone() {\n        return zone;\n    }\n\n    public void setZone(TimeZone zone) {\n        this.zone = zone;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((time == null)? 0 : time.hashCode());\n        result = prime * result + ((zone == null)? 0 : zone.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        Week other = (Week) obj;\n        if (time == null) {\n            if (other.time!= null)\n                return false;\n        } else if (!time.equals(other.time))\n            return false;\n        if (zone == null) {\n            if (other.zone!= null)\n                return false;\n        } else if (!zone.equals(other.zone))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Week [time=\" + time + \", zone=\" + zone + \"]\";\n    }\n\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0",
        "public Week(Date time, TimeZone zone) {\n        this.time = time;\n        this.zone = zone;\n    }\n\n    public Date getTime() {\n        return time;\n    }\n\n    public void setTime(Date time) {\n        this.time = time;\n    }\n\n    public TimeZone getZone() {\n        return zone;\n    }\n\n    public void setZone(TimeZone zone) {\n        this.zone = zone;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((time == null)? 0 : time.hashCode());\n        result = prime * result + ((zone == null)? 0 : zone.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        Week other = (Week) obj;\n        if (time == null) {\n            if (other.time!= null)\n                return false;\n        } else if (!time.equals(other.time))\n            return false;\n        if (zone == null) {\n            if (other.zone!= null)\n                return false;\n        } else if (!zone.equals(other.zone))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Week [time=\" + time + \", zone=\" + zone + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n",
        "public Week(Date time, TimeZone zone) {\n        this.time = time;\n        this.zone = zone;\n    }\n\n    public Date getTime() {\n        return time;\n    }\n\n    public void setTime(Date time) {\n        this.time = time;\n    }\n\n    public TimeZone getZone() {\n        return zone;\n    }\n\n    public void setZone(TimeZone zone) {\n        this.zone = zone;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((time == null)? 0 : time.hashCode());\n        result = prime * result + ((zone == null)? 0 : zone.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass()!= obj.getClass()) {\n            return false;\n        }\n        Week other = (Week) obj;\n        if (time == null) {\n            if (other.time!= null) {\n                return false;\n            }\n        } else if (!time.equals(other.time)) {\n            return false;\n        }\n        if (zone == null) {\n            if (other.zone!= null) {\n                return false;\n            }\n        } else if (!zone.equals(other.zone)) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Week [time=\" + time + \", zone=\" + zone + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the",
        "public Week(Date time, TimeZone zone) {\n        this.time = time;\n        this.zone = zone;\n    }\n\n    public Date getTime() {\n        return time;\n    }\n\n    public void setTime(Date time) {\n        this.time = time;\n    }\n\n    public TimeZone getZone() {\n        return zone;\n    }\n\n    public void setZone(TimeZone zone) {\n        this.zone = zone;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((time == null)? 0 : time.hashCode());\n        result = prime * result + ((zone == null)? 0 : zone.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass()!= obj.getClass()) {\n            return false;\n        }\n        Week other = (Week) obj;\n        if (time == null) {\n            if (other.time!= null) {\n                return false;\n            }\n        } else if (!time.equals(other.time)) {\n            return false;\n        }\n        if (zone == null) {\n            if (other.zone!= null) {\n                return false;\n            }\n        } else if (!zone.equals(other.zone)) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Week [time=\" + time + \", zone=\" + zone + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a",
        "public Week(Date time, TimeZone zone) {\n        this.time = time;\n        this.zone = zone;\n    }\n\n    public Date getTime() {\n        return time;\n    }\n\n    public void setTime(Date time) {\n        this.time = time;\n    }\n\n    public TimeZone getZone() {\n        return zone;\n    }\n\n    public void setZone(TimeZone zone) {\n        this.zone = zone;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((time == null)? 0 : time.hashCode());\n        result = prime * result + ((zone == null)? 0 : zone.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        Week other = (Week) obj;\n        if (time == null) {\n            if (other.time!= null)\n                return false;\n        } else if (!time.equals(other.time))\n            return false;\n        if (zone == null) {\n            if (other.zone!= null)\n                return false;\n        } else if (!zone.equals(other.zone))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Week [time=\" + time + \", zone=\" + zone + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n",
        "public Week(Date time, TimeZone zone) {\n        this.time = time;\n        this.zone = zone;\n    }\n\n    public Date getTime() {\n        return time;\n    }\n\n    public void setTime(Date time) {\n        this.time = time;\n    }\n\n    public TimeZone getZone() {\n        return zone;\n    }\n\n    public void setZone(TimeZone zone) {\n        this.zone = zone;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((time == null)? 0 : time.hashCode());\n        result = prime * result + ((zone == null)? 0 : zone.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        Week other = (Week) obj;\n        if (time == null) {\n            if (other.time!= null)\n                return false;\n        } else if (!time.equals(other.time))\n            return false;\n        if (zone == null) {\n            if (other.zone!= null)\n                return false;\n        } else if (!zone.equals(other.zone))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Week [time=\" + time + \", zone=\" + zone + \"]\";\n    }\n\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0",
        "public Week(Date time, TimeZone zone) {\n        this.time = time;\n        this.zone = zone;\n    }\n\n    public Date getTime() {\n        return time;\n    }\n\n    public void setTime(Date time) {\n        this.time = time;\n    }\n\n    public TimeZone getZone() {\n        return zone;\n    }\n\n    public void setZone(TimeZone zone) {\n        this.zone = zone;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((time == null)? 0 : time.hashCode());\n        result = prime * result + ((zone == null)? 0 : zone.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        Week other = (Week) obj;\n        if (time == null) {\n            if (other.time!= null)\n                return false;\n        } else if (!time.equals(other.time))\n            return false;\n        if (zone == null) {\n            if (other.zone!= null)\n                return false;\n        } else if (!zone.equals(other.zone))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Week [time=\" + time + \", zone=\" + zone + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n"
      ],
      "function range": "173,5-176,5"
    },
    "Chart_9_/source/org/jfree/data/time/TimeSeries.java_944-945": {
      "loc": "944-945",
      "input": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null 'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }",
      "output": [
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex < 0) {\n        emptyRange = true;\n    }\n    else if (endIndex >= this.data.size()) {\n        endIndex = this.data.size() - 1;\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        return new EmptyTimeSeries(start, end);\n    }\n    TimeSeriesDataItem[] copyItems = new TimeSeriesDataItem[endIndex \n            - startIndex + 1];\n    for (int i = startIndex; i <= endIndex; i++) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(i);\n        copyItems[i - startIndex] = new TimeSeriesDataItem(item.getPeriod(), \n                item.getValue());\n    }\n    TimeSeriesDataItem[] result = new TimeSeriesDataItem[copyItems.length];\n    System.arraycopy(copyItems, 0, result, 0, copyItems.length);\n    TimeSeries copy = new TimeSeries(getKey(), getTimePeriodClass(), \n            getValueType(), copyItems.length);\n    copy.data = result;\n    return copy;\n  }",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex < 0) {\n        emptyRange = true;\n    }\n    else if (endIndex >= this.data.size()) {\n        endIndex = this.data.size() - 1;\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        return new EmptyTimeSeries(start, end);\n    }\n    TimeSeriesDataItem[] copyItems = new TimeSeriesDataItem[endIndex \n            - startIndex + 1];\n    for (int i = startIndex; i <= endIndex; i++) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(i);\n        copyItems[i - startIndex] = new TimeSeriesDataItem(item.getPeriod(), \n                item.getValue());\n    }\n    TimeSeriesDataItem[] result = new TimeSeriesDataItem[copyItems.length];\n    System.arraycopy(copyItems, 0, result, 0, copyItems.length);\n    TimeSeries copy = new TimeSeries(getKey(), getTimePeriodClass(), \n            getValueClass());\n    copy.data = result;\n    return copy;\n  }\n\n  /**\n   ",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex < 0) {\n        emptyRange = true;\n    }\n    else if (endIndex >= this.data.size()) {\n        endIndex = this.data.size() - 1;\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        return new EmptyTimeSeries(start, end);\n    }\n    TimeSeriesDataItem[] copyItems = new TimeSeriesDataItem[endIndex \n            - startIndex + 1];\n    for (int i = startIndex; i <= endIndex; i++) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(i);\n        copyItems[i - startIndex] = new TimeSeriesDataItem(item.getPeriod(), \n                item.getValue());\n    }\n    TimeSeriesDataItem[] result = new TimeSeriesDataItem[copyItems.length];\n    System.arraycopy(copyItems, 0, result, 0, copyItems.length);\n    TimeSeries copy = new TimeSeries(getKey(), getDescription(), \n            getDomainBounds(), getRangeBounds(), result);\n    return copy;\n  }\n\n  /**\n   * Tests if",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex < 0) {\n        emptyRange = true;\n    }\n    else if (endIndex >= this.data.size()) {\n        endIndex = this.data.size() - 1;\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        return new EmptyTimeSeries(start, end);\n    }\n    TimeSeriesDataItem[] copyItems = new TimeSeriesDataItem[endIndex \n            - startIndex + 1];\n    for (int i = startIndex; i <= endIndex; i++) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(i);\n        copyItems[i - startIndex] = new TimeSeriesDataItem(item.getPeriod(), \n                item.getValue());\n    }\n    TimeSeriesDataItem[] result = new TimeSeriesDataItem[copyItems.length];\n    System.arraycopy(copyItems, 0, result, 0, copyItems.length);\n    TimeSeries copy = new TimeSeries(this.name, this.timePeriodClass, \n            this.valueClass);\n    copy.data = result;\n    return copy;\n  }\n\n  ",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex < 0) {\n        emptyRange = true;\n    }\n    else if (endIndex >= this.data.size()) {\n        endIndex = this.data.size() - 1;\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        return new EmptyTimeSeries(start, end);\n    }\n    TimeSeriesDataItem[] copyItems = new TimeSeriesDataItem[endIndex \n            - startIndex + 1];\n    for (int i = startIndex; i <= endIndex; i++) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(i);\n        copyItems[i - startIndex] = new TimeSeriesDataItem(item.getPeriod(), \n                item.getValue());\n    }\n    TimeSeriesDataItem[] result = new TimeSeriesDataItem[copyItems.length];\n    System.arraycopy(copyItems, 0, result, 0, copyItems.length);\n    TimeSeries copy = new TimeSeries(getKey(), getTimePeriodClass(), \n            getValueType(), copyItems.length);\n    copy.data = result;\n    return copy;\n  \n",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex < 0) {\n        emptyRange = true;\n    }\n    else if (endIndex >= this.data.size()) {\n        endIndex = this.data.size() - 1;\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        return new EmptyTimeSeries(start, end);\n    }\n    TimeSeriesDataItem[] copyItems = new TimeSeriesDataItem[endIndex \n            - startIndex + 1];\n    for (int i = startIndex; i <= endIndex; i++) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(i);\n        copyItems[i - startIndex] = new TimeSeriesDataItem(item.getPeriod(), \n                item.getValue());\n    }\n    TimeSeriesDataItem[] result = new TimeSeriesDataItem[copyItems.length];\n    System.arraycopy(copyItems, 0, result, 0, copyItems.length);\n    TimeSeries copy = new TimeSeries(this.getKey(), this.getTimePeriodClass(), \n            result);\n    return copy;\n  }\n\n  /**\n   * Tests if this time series",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex < 0) {\n        emptyRange = true;\n    }\n    else if (endIndex >= this.data.size()) {\n        endIndex = this.data.size() - 1;\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        return new EmptyTimeSeries(start, end);\n    }\n    TimeSeriesDataItem[] copyItems = new TimeSeriesDataItem[endIndex \n            - startIndex + 1];\n    for (int i = startIndex; i <= endIndex; i++) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(i);\n        copyItems[i - startIndex] = new TimeSeriesDataItem(item.getPeriod(), \n                item.getValue());\n    }\n    TimeSeriesDataItem[] result = new TimeSeriesDataItem[copyItems.length];\n    System.arraycopy(copyItems, 0, result, 0, copyItems.length);\n    TimeSeries copy = new TimeSeries(this.name, this.timePeriodClass, \n            this.valueClass, result);\n    return copy;\n  }\n\n  /**\n   * Tests if",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex < 0) {\n        emptyRange = true;\n    }\n    else if (endIndex >= this.data.size()) {\n        endIndex = this.data.size() - 1;\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        return new EmptyTimeSeries(start, end);\n    }\n    TimeSeriesDataItem[] copyItems = new TimeSeriesDataItem[endIndex \n            - startIndex + 1];\n    for (int i = startIndex; i <= endIndex; i++) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(i);\n        copyItems[i - startIndex] = new TimeSeriesDataItem(item.getPeriod(), \n                item.getValue());\n    }\n    TimeSeriesDataItem[] result = new TimeSeriesDataItem[copyItems.length];\n    System.arraycopy(copyItems, 0, result, 0, copyItems.length);\n    TimeSeries copy = new TimeSeries(this.name, this.timePeriodClass, \n            this.valueType, result);\n    return copy;\n  }\n\n  /**\n   * Tests if",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex < 0) {\n        emptyRange = true;\n    }\n    else if (endIndex >= this.data.size()) {\n        endIndex = this.data.size() - 1;\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        return new EmptyTimeSeries(start, end);\n    }\n    TimeSeriesDataItem[] copyItems = new TimeSeriesDataItem[endIndex \n            - startIndex + 1];\n    for (int i = startIndex; i <= endIndex; i++) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(i);\n        copyItems[i - startIndex] = new TimeSeriesDataItem(item.getPeriod(), \n                item.getValue());\n    }\n    TimeSeriesDataItem[] result = new TimeSeriesDataItem[copyItems.length];\n    System.arraycopy(copyItems, 0, result, 0, copyItems.length);\n    TimeSeries copy = new TimeSeries(this.name, this.timePeriodClass, \n            result);\n    return copy;\n  }\n\n  /**\n   * Tests if this time series contains the",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex < 0) {\n        emptyRange = true;\n    }\n    else if (endIndex >= this.data.size()) {\n        endIndex = this.data.size() - 1;\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        return new EmptyTimeSeries(start, end);\n    }\n    TimeSeriesDataItem[] copyItems = new TimeSeriesDataItem[endIndex \n            - startIndex + 1];\n    for (int i = startIndex; i <= endIndex; i++) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(i);\n        copyItems[i - startIndex] = new TimeSeriesDataItem(item.getPeriod(), \n                item.getValue());\n    }\n    TimeSeriesDataItem[] result = new TimeSeriesDataItem[copyItems.length];\n    System.arraycopy(copyItems, 0, result, 0, copyItems.length);\n    TimeSeries copy = new TimeSeries(this.name, this.timePeriodClass, \n            result);\n    return copy;\n  }\n\n  /**\n   * Tests if this time series is empty"
      ],
      "function range": "918,5-956,5"
    },
    "Chart_10_/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java_65-66": {
      "loc": "65-66",
      "input": "public String generateToolTipFragment(String toolTipText) {",
      "output": [
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.algebricks.core.al",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport org.apache.hyracks.al",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AggregateOperator;\nimport org",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AggregateOperator;\nimport org.apache.hyracks.algebricks.core.algebra.oper"
      ],
      "function range": "64,5-67,5"
    },
    "Chart_11_/source/org/jfree/chart/util/ShapeUtilities.java_275-276": {
      "loc": "275-276",
      "input": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);",
      "output": [
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (!iterator1.isDone() && iterator2.isDone()) {\n        return false;\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (!iterator1.isDone() && iterator2.isDone()) {\n        return false;\n    }\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (!iterator1.isDone() && iterator2.isDone()) {\n        return false;\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (iterator2.isDone() &&!iterator1.isDone()) {\n        return false;\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (!iterator1.isDone() && iterator2.isDone()) {\n        return false;\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (!iterator1.isDone() && iterator2.isDone()) {\n        return false;\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (!iterator1.isDone() && iterator2.isDone()) {\n        return false;\n    }\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY K",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (!iterator1.isDone() && iterator2.isDone()) {\n        return false;\n    }\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (iterator2.isDone() &&!iterator1.isDone()) {\n        return false;\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY K",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (iterator2.isDone() &&!iterator1.isDone()) {\n        return false;\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
      ],
      "function range": "264,5-296,5"
    },
    "Chart_12_/source/org/jfree/chart/plot/MultiplePiePlot.java_145-146": {
      "loc": "145-146",
      "input": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();",
      "output": [
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    setDataset(dataset);\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset.\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset.\n   */\n  public void setDataset(CategoryDataset dataset) {\n    // if there is an existing dataset, remove the plot from the list of\n    // change listeners...\n    if (this.dataset!= null) {\n      this.dataset.removeChangeListener(this);\n    }\n\n    // set the new dataset, and register the chart as a change listener...\n    this.dataset = dataset;\n    if (dataset!= null) {\n      dataset.addChangeListener(this);\n    }\n\n    // send a dataset change event to self to trigger plot change event\n    DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n    datasetChanged(event);\n  }\n\n  /**\n   * Receives notification of a dataset change event.\n   *\n   * @param event Information about the event.\n   */\n  public void datasetChanged(DatasetChangeEvent event) {\n    PlotChangeEvent e = new PlotChangeEvent(this);\n    e.setType(ChartChangeEventType.DATASET_UPDATED);\n    notifyListeners(e);\n  }\n\n  /**\n   * Receives notification of a plot change event.\n   *\n   * @param event Information about the event.\n   */\n  public void plotChanged(PlotChangeEvent event) {\n    notifyListeners(event);\n  }\n\n  /**\n   * Tests this plot for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return A boolean.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (!(obj instanceof MultiplePie",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    setDataset(dataset);\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset.\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset.\n   */\n  public void setDataset(CategoryDataset dataset) {\n    // if there is an existing dataset, remove the plot from the list of\n    // change listeners...\n    if (this.dataset!= null) {\n      this.dataset.removeChangeListener(this);\n    }\n\n    // set the new dataset, and register the chart as a change listener...\n    this.dataset = dataset;\n    if (dataset!= null) {\n      dataset.addChangeListener(this);\n    }\n\n    // send a dataset change event to self to trigger plot change event\n    DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n    datasetChanged(event);\n  }\n\n  /**\n   * Receives notification of a dataset change event.\n   *\n   * @param event Information about the event.\n   */\n  public void datasetChanged(DatasetChangeEvent event) {\n    PlotChangeEvent newEvent = new PlotChangeEvent(this);\n    newEvent.setType(ChartChangeEventType.DATASET_UPDATED);\n    notifyListeners(newEvent);\n  }\n\n  /**\n   * Receives notification of a plot change event.\n   *\n   * @param event Information about the event.\n   */\n  public void plotChanged(PlotChangeEvent event) {\n    notifyListeners(event);\n  }\n\n  /**\n   * Tests this plot for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return A boolean.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (!(obj instance",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    setDataset(dataset);\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset.\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset.\n   */\n  public void setDataset(CategoryDataset dataset) {\n    // if there is an existing dataset, remove the plot from the list of\n    // change listeners...\n    if (this.dataset!= null) {\n      this.dataset.removeChangeListener(this);\n    }\n\n    // set the new dataset, and register the chart as a change listener...\n    this.dataset = dataset;\n    if (dataset!= null) {\n      dataset.addChangeListener(this);\n    }\n\n    // send a dataset change event to self to trigger plot change event\n    DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n    datasetChanged(event);\n  }\n\n  /**\n   * Receives notification of a dataset change event.\n   *\n   * @param event Information about the event.\n   */\n  public void datasetChanged(DatasetChangeEvent event) {\n    PlotChangeEvent newEvent = new PlotChangeEvent(this);\n    newEvent.setType(ChartChangeEventType.DATASET_UPDATED);\n    notifyListeners(newEvent);\n  }\n\n  /**\n   * Receives notification of a plot change event.\n   *\n   * @param event Information about the event.\n   */\n  public void plotChanged(PlotChangeEvent event) {\n    notifyListeners(event);\n  }\n\n  /**\n   * Tests this plot for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return <code>true</code> or <code>false</code>.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    setDataset(dataset);\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset.\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset.\n   */\n  public void setDataset(CategoryDataset dataset) {\n    // if there is an existing dataset, remove the plot from the list of\n    // change listeners...\n    if (this.dataset!= null) {\n      this.dataset.removeChangeListener(this);\n    }\n\n    // set the new dataset, and register the chart as a change listener...\n    this.dataset = dataset;\n    if (dataset!= null) {\n      dataset.addChangeListener(this);\n    }\n\n    // send a dataset change event to self to trigger plot change event\n    DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n    datasetChanged(event);\n  }\n\n  /**\n   * Receives notification of a dataset change event.\n   *\n   * @param event Information about the event.\n   */\n  public void datasetChanged(DatasetChangeEvent event) {\n    PlotChangeEvent newEvent = new PlotChangeEvent(this);\n    newEvent.setType(ChartChangeEventType.DATASET_UPDATED);\n    notifyListeners(newEvent);\n  }\n\n  /**\n   * Receives notification of a renderer change event.\n   *\n   * @param event Information about the event.\n   */\n  public void rendererChanged(RendererChangeEvent event) {\n    PlotChangeEvent newEvent = new PlotChangeEvent(this);\n    newEvent.setType(ChartChangeEventType.RENDERER_UPDATED);\n    notifyListeners(newEvent);\n  }\n\n  /**\n   * Tests this plot for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    setDataset(dataset);\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset.\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset.\n   */\n  public void setDataset(CategoryDataset dataset) {\n    // if there is an existing dataset, remove the plot from the list of\n    // change listeners...\n    if (this.dataset!= null) {\n      this.dataset.removeChangeListener(this);\n    }\n\n    // set the new dataset, and register the chart as a change listener...\n    this.dataset = dataset;\n    if (dataset!= null) {\n      setDatasetGroup(dataset.getGroup());\n      dataset.addChangeListener(this);\n    }\n\n    // send a dataset change event to self to trigger plot change event\n    DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n    datasetChanged(event);\n  }\n\n  /**\n   * Receives notification of a dataset change event.\n   *\n   * @param event Information about the event.\n   */\n  public void datasetChanged(DatasetChangeEvent event) {\n    PlotChangeEvent newEvent = new PlotChangeEvent(this);\n    newEvent.setType(ChartChangeEventType.DATASET_UPDATED);\n    notifyListeners(newEvent);\n  }\n\n  /**\n   * Receives notification of a plot change event.\n   *\n   * @param event Information about the event.\n   */\n  public void plotChanged(PlotChangeEvent event) {\n    notifyListeners(event);\n  }\n\n  /**\n   * Tests this plot for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return A boolean.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    setDataset(dataset);\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset.\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset.\n   */\n  public void setDataset(CategoryDataset dataset) {\n    // if there is an existing dataset, remove the plot from the list of\n    // change listeners...\n    if (this.dataset!= null) {\n      this.dataset.removeChangeListener(this);\n    }\n\n    // set the new dataset, and register the chart as a change listener...\n    this.dataset = dataset;\n    if (dataset!= null) {\n      setDatasetGroup(dataset.getGroup());\n      dataset.addChangeListener(this);\n    }\n\n    // send a dataset change event to self to trigger plot change event\n    DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n    datasetChanged(event);\n  }\n\n  /**\n   * Receives notification of a dataset change event.\n   *\n   * @param event Information about the event.\n   */\n  public void datasetChanged(DatasetChangeEvent event) {\n    PlotChangeEvent e = new PlotChangeEvent(this);\n    e.setType(ChartChangeEventType.DATASET_UPDATED);\n    notifyListeners(e);\n  }\n\n  /**\n   * Receives notification of a renderer change event.\n   *\n   * @param event Information about the event.\n   */\n  public void rendererChanged(RendererChangeEvent event) {\n    PlotChangeEvent e = new PlotChangeEvent(this);\n    e.setType(ChartChangeEventType.RENDERER_UPDATED);\n    notifyListeners(e);\n  }\n\n  /**\n   * Tests this plot for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code>",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    setDataset(dataset);\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset.\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset.\n   */\n  public void setDataset(CategoryDataset dataset) {\n    // if there is an existing dataset, remove the plot from the list of\n    // change listeners...\n    if (this.dataset!= null) {\n      this.dataset.removeChangeListener(this);\n    }\n\n    // set the new dataset, and register the chart as a change listener...\n    this.dataset = dataset;\n    if (dataset!= null) {\n      dataset.addChangeListener(this);\n    }\n\n    // send a dataset change event to self to trigger plot change event\n    DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n    datasetChanged(event);\n  }\n\n  /**\n   * Receives notification of a dataset change event.\n   *\n   * @param event Information about the event.\n   */\n  public void datasetChanged(DatasetChangeEvent event) {\n    PlotChangeEvent e = new PlotChangeEvent(this);\n    e.setType(ChartChangeEventType.DATASET_UPDATED);\n    notifyListeners(e);\n  }\n\n  /**\n   * Receives notification of a renderer change event.\n   *\n   * @param event Information about the event.\n   */\n  public void rendererChanged(RendererChangeEvent event) {\n    PlotChangeEvent e = new PlotChangeEvent(this);\n    e.setType(ChartChangeEventType.RENDERER_UPDATED);\n    notifyListeners(e);\n  }\n\n  /**\n   * Tests this plot for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return A boolean.\n   ",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    setDataset(dataset);\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset.\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset.\n   */\n  public void setDataset(CategoryDataset dataset) {\n    // if there is an existing dataset, remove the plot from the list of\n    // change listeners...\n    if (this.dataset!= null) {\n      this.dataset.removeChangeListener(this);\n    }\n\n    // set the new dataset, and register the chart as a change listener...\n    this.dataset = dataset;\n    if (dataset!= null) {\n      dataset.addChangeListener(this);\n    }\n\n    // send a dataset change event to self to trigger plot change event\n    DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n    datasetChanged(event);\n  }\n\n  /**\n   * Receives notification of a dataset change event.\n   *\n   * @param event Information about the event.\n   */\n  public void datasetChanged(DatasetChangeEvent event) {\n    PlotChangeEvent newEvent = new PlotChangeEvent(this);\n    newEvent.setType(ChartChangeEventType.DATASET_UPDATED);\n    notifyListeners(newEvent);\n  }\n\n  /**\n   * Receives notification of a plot change event.\n   *\n   * @param event Information about the event.\n   */\n  public void plotChanged(PlotChangeEvent event) {\n    notifyListeners(event);\n  }\n\n  /**\n   * Tests this plot for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return <code>true</code> or <code>false</code>.\n   */\n  public boolean equals(Object obj) {\n\n    if (obj == this) {\n      return",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    setDataset(dataset);\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset.\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset.\n   */\n  public void setDataset(CategoryDataset dataset) {\n    // if there is an existing dataset, remove the plot from the list of\n    // change listeners...\n    if (this.dataset!= null) {\n      this.dataset.removeChangeListener(this);\n    }\n\n    // set the new dataset, and register the chart as a change listener...\n    this.dataset = dataset;\n    if (dataset!= null) {\n      setDatasetGroup(dataset.getGroup());\n      dataset.addChangeListener(this);\n    }\n\n    // send a dataset change event to self to trigger plot change event\n    DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n    datasetChanged(event);\n  }\n\n  /**\n   * Receives notification of a dataset change event.\n   *\n   * @param event Information about the event.\n   */\n  public void datasetChanged(DatasetChangeEvent event) {\n    PlotChangeEvent newEvent = new PlotChangeEvent(this);\n    newEvent.setType(ChartChangeEventType.DATASET_UPDATED);\n    notifyListeners(newEvent);\n  }\n\n  /**\n   * Receives notification of a renderer change event.\n   *\n   * @param event Information about the event.\n   */\n  public void rendererChanged(RendererChangeEvent event) {\n    PlotChangeEvent newEvent = new PlotChangeEvent(this);\n    newEvent.setType(ChartChangeEventType.RENDERER_UPDATED);\n    notifyListeners(newEvent);\n  }\n\n  /**\n   * Tests this plot for equality with an arbitrary object.\n   *\n   * @param obj  the object (<",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    setDataset(dataset);\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset.\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset.\n   */\n  public void setDataset(CategoryDataset dataset) {\n    // if there is an existing dataset, remove the plot from the list of\n    // change listeners...\n    if (this.dataset!= null) {\n      this.dataset.removeChangeListener(this);\n    }\n\n    // set the new dataset, and register the chart as a change listener...\n    this.dataset = dataset;\n    if (dataset!= null) {\n      setDatasetGroup(dataset.getGroup());\n      dataset.addChangeListener(this);\n    }\n\n    // send a dataset change event to self to trigger plot change event\n    DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n    datasetChanged(event);\n  }\n\n  /**\n   * Receives notification of a dataset change event.\n   *\n   * @param event Information about the event.\n   */\n  public void datasetChanged(DatasetChangeEvent event) {\n    PlotChangeEvent newEvent = new PlotChangeEvent(this);\n    newEvent.setType(ChartChangeEventType.DATASET_UPDATED);\n    notifyListeners(newEvent);\n  }\n\n  /**\n   * Receives notification of a renderer change event.\n   *\n   * @param event Information about the event.\n   */\n  public void rendererChanged(RendererChangeEvent event) {\n    PlotChangeEvent newEvent = new PlotChangeEvent(this);\n    newEvent.setType(ChartChangeEventType.RENDERER_UPDATED);\n    notifyListeners(newEvent);\n  }\n\n  /**\n   * Tests this plot for equality with another object.\n   *\n   * @param obj  the object (<code"
      ],
      "function range": "143,5-158,5"
    },
    "Chart_13_/source/org/jfree/chart/block/BorderArrangement.java_455-456": {
      "loc": "455-456",
      "input": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock != null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock != null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock != null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock != null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,",
      "output": [
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth() - w[2]),\n                LengthConstraintType.RANGE, h[2], null,\n",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),\n                LengthConstraintType.",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                new Range(0.0, Math.max(0.0, constraint.getWidth() - w[2])),\n                LengthConstraintType.R",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                new Range(constraint.getWidth() - w[2], constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0,\n                constraint.getWidth() - w[2]), LengthConstraintType.RANGE,\n                h[2], null",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(\n                0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE,\n                h[2], null, Length",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                constraint.getWidth() - w[2], LengthConstraintType.RANGE,\n                h[2], null, LengthConstraintType.",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                new Range(w[2], constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstr",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                new Range(0.0, Math.max(0.0, constraint.getWidth() -\n                w[2])), LengthConstraintType.R",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth() - w[2]),\n                LengthConstraintType.RANGE, h[2],\n                Length"
      ],
      "function range": "422,5-489,5"
    },
    "Chart_17_/source/org/jfree/data/time/TimeSeries.java_857-858": {
      "loc": "857-858",
      "input": "public Object clone() throws CloneNotSupportedException {",
      "output": [
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.al",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.algebricks.core.algebra.oper",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.log",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AggregateOperator;\nimport org.apache.",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyracks.algebricks.core.algebra.express",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.Abstract"
      ],
      "function range": "856,5-859,5"
    },
    "Chart_20_/source/org/jfree/chart/plot/ValueMarker.java_95-96": {
      "loc": "95-96",
      "input": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {",
      "output": [
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint.\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke.\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint.\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke.\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha transparency.\n     *\n     * @return The alpha transparency.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @param value  the value.\n     */\n    public void setValue(double value) {\n        this.value = value;\n    }\n\n    /**\n     * Sets the paint.\n     *\n     * @param paint  the paint.\n     */\n    public void setPaint(Paint paint) {\n        this.paint = paint;\n    }\n\n    /**\n     * Sets the stroke.\n     *\n     * @param stroke  the stroke.\n     */\n    public void setStroke(St",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        super(value);\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint.\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke.\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint.\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke.\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha.\n     *\n     * @return The alpha.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Sets the paint.\n     *\n     * @param paint  the paint.\n     */\n    public void setPaint(Paint paint) {\n        this.paint = paint;\n    }\n\n    /**\n     * Sets the stroke.\n     *\n     * @param stroke  the stroke.\n     */\n    public void setStroke(Stroke stroke) {\n        this.stroke = stroke;\n    }\n\n    /**\n     * Sets the outline paint.\n     *\n     * @param paint  the paint.\n     */\n    public void setOutlinePaint(Paint paint) {\n        this.outlinePaint = paint;\n    }\n\n    /**\n     * Sets the outline stroke.\n     *\n     * @param stroke  the",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint.\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke.\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint.\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke.\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha transparency.\n     *\n     * @return The alpha transparency.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Tests this instance for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof ValueMarker)) {\n            return false;\n        }\n        ValueMarker that = (ValueMarker) obj;\n        if (this.value!= that.value) {\n            return false;\n        }\n",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        super(value);\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint.\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke.\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint.\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke.\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha.\n     *\n     * @return The alpha.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Sets the paint.\n     *\n     * @param paint  the paint.\n     */\n    public void setPaint(Paint paint) {\n        this.paint = paint;\n    }\n\n    /**\n     * Sets the stroke.\n     *\n     * @param stroke  the stroke.\n     */\n    public void setStroke(Stroke stroke) {\n        this.stroke = stroke;\n    }\n\n    /**\n     * Sets the outline paint.\n     *\n     * @param outlinePaint  the outline paint.\n     */\n    public void setOutlinePaint(Paint outlinePaint) {\n        this.outlinePaint = outlinePaint;\n    }\n\n    /**\n     * Sets the outline stroke.\n     *\n",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (possibly <code>null</code>).\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke (possibly <code>null</code>).\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint (possibly <code>null</code>).\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke (possibly <code>null</code>).\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha transparency.\n     *\n     * @return The alpha transparency.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Tests this instance for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof ValueMarker)) {\n            return false;\n        }",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        super(value);\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (never <code>null</code>).\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke (never <code>null</code>).\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint (possibly <code>null</code>).\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke (possibly <code>null</code>).\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha transparency.\n     *\n     * @return The alpha transparency.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Tests this instance for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof ValueMarker)) {\n            return false;\n        }\n        ValueMarker that = (ValueMarker) obj;\n        if (!PaintUtilities.equal(this.paint, that.paint)) {\n            return false;\n        }",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint.\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke.\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint.\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke.\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha transparency.\n     *\n     * @return The alpha transparency.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Sets the value and sends a {@link MarkerChangeEvent} to all registered\n     * listeners.\n     *\n     * @param value  the value.\n     */\n    public void setValue(double value) {\n        this.value = value;\n        notifyListeners(new MarkerChangeEvent(this));\n    }\n\n    /**\n     * Sets the paint and sends a {@link MarkerChangeEvent} to all registered\n     * listeners.\n     *\n     * @param paint  the paint.\n     */\n    public void setPaint(Paint",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        super(value);\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint.\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke.\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint.\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke.\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha.\n     *\n     * @return The alpha.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Sets the paint.\n     *\n     * @param paint  the paint.\n     */\n    public void setPaint(Paint paint) {\n        this.paint = paint;\n    }\n\n    /**\n     * Sets the stroke.\n     *\n     * @param stroke  the stroke.\n     */\n    public void setStroke(Stroke stroke) {\n        this.stroke = stroke;\n    }\n\n    /**\n     * Sets the outline paint.\n     *\n     * @param outlinePaint  the paint.\n     */\n    public void setOutlinePaint(Paint outlinePaint) {\n        this.outlinePaint = outlinePaint;\n    }\n\n    /**\n     * Sets the outline stroke.\n     *\n     ",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint.\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke.\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint.\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke.\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha transparency.\n     *\n     * @return The alpha transparency.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Tests this instance for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof ValueMarker)) {\n            return false;\n        }\n        ValueMarker that = (ValueMarker) obj;\n        if (this.value!= that.value) {\n            return false;",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        super(value);\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (never <code>null</code>).\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke (never <code>null</code>).\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint (possibly <code>null</code>).\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke (possibly <code>null</code>).\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha transparency.\n     *\n     * @return The alpha transparency.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Tests this instance for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof ValueMarker)) {\n            return false;\n        }\n        ValueMarker that = (ValueMarker) obj;\n        if (!PaintUtilities.equal(this.paint, that.paint)) {\n            return false;\n        }"
      ],
      "function range": "93,5-97,5"
    },
    "Chart_24_/source/org/jfree/chart/renderer/GrayPaintScale.java_126-127": {
      "loc": "126-127",
      "input": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);",
      "output": [
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    return this.paintScale.getPaint(v);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class MulticastTest extends ContextTestSupport {\n\n    @Test\n    public void testMulticast() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Hello World\");\n\n        template.sendBody(\"direct:start\", \"Hello World\");",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    return this.paintScale.getPaint(v);\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class MulticastTest extends ContextTestSupport {\n\n    @Test\n    public void testMulticast() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Hello World\");\n\n        template.sendBody(\"direct:start\", \"Hello World",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    return this.paintScale.getPaint(v);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class MulticastTest extends ContextTestSupport {\n\n    @Test\n    public void testMulticast() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Hello World\");\n\n        template.sendBody(\"direct:start\", \"Hello\");\n\n",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    return this.paintScale.getPaint(v);\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class MulticastTest extends ContextTestSupport {\n\n    @Test\n    public void testMulticast() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Hello World\");\n\n        template.sendBody(\"direct:start\", \"Hello\");",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    return this.paintScale.getPaint(v);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class DeadLetterChannelOnPrepareTest extends ContextTestSupport {\n\n    @Test\n    public void testDeadLetterChannelOnPrepare() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:error\");\n        mock.expectedBodiesReceived(\"Hello World\");\n        mock.expectedHeaderReceived",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    return this.paintScale.getPaint(v);\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class DeadLetterChannelOnPrepareTest extends ContextTestSupport {\n\n    @Test\n    public void testDeadLetterChannelOnPrepare() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:error\");\n        mock.expectedBodiesReceived(\"Hello World\");\n        mock.expectedHeaderRe",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    return this.paintScale.getPaint(v);\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class MulticastTest extends ContextTestSupport {\n\n    @Test\n    public void testMulticast() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Hello A\", \"Hello B\", \"Hello C\", \"Hello D\", \"Hello",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    return this.paintScale.getPaint(v);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class MulticastTest extends ContextTestSupport {\n\n    @Test\n    public void testMulticast() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Hello A\", \"Hello B\", \"Hello C\", \"Hello D\", \"Hello E",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    return this.paintScale.getPaint(v);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class DeadLetterChannelOnPrepareTest extends ContextTestSupport {\n\n    @Test\n    public void testDeadLetterChannelOnPrepare() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Hello World\");\n\n        template.sendBody(\"direct:",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    return this.paintScale.getPaint(v);\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class DeadLetterChannelOnPrepareTest extends ContextTestSupport {\n\n    @Test\n    public void testDeadLetterChannelOnPrepare() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Hello World\");\n\n        template.sendBody(\"direct"
      ],
      "function range": "123,5-129,5"
    },
    "Cli_4_/src/java/org/apache/commons/cli/Parser.java_298-299": {
      "loc": "298-299",
      "input": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();",
      "output": [
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            if (getOption(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.h",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            if (getOption(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            if (getOption(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            if (getOption(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            if (getOption(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.Logical",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            if (getOption(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOper",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            if (getOption(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.Logical",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            if (getOption(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.Log",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            if (getOption(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimization",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            if (getOption(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptim"
      ],
      "function range": "290,5-309,5"
    },
    "Cli_8_/src/java/org/apache/commons/cli/HelpFormatter.java_812-813": {
      "loc": "812-813",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();",
      "output": [
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n    }\n}\n\n}\n<|java|",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n    }\n}\n\nprivate String createPadding(int",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        pos = findWrapPos(text, width, next"
      ],
      "function range": "792,5-823,5"
    },
    "Cli_11_/src/java/org/apache/commons/cli/HelpFormatter.java_632-633": {
      "loc": "632-633",
      "input": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt() != null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }",
      "output": [
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.getValue()!= null)\n    {\n        buff.append(\"=\").append(option.getValue());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.h",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.getValue()!= null)\n    {\n        buff.append(\"=\").append(option.getValue());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.getValue()!= null)\n    {\n        buff.append(\"=\").append(option.getValue());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOper",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.getValue()!= null)\n    {\n        buff.append(\"=\").append(option.getValue());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.getValue()!= null)\n    {\n        buff.append(\"=\").append(option.getValue());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimization",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.getValue()!= null)\n    {\n        buff.append(\"=\").append(option.getValue());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.getValue()!= null)\n    {\n        buff.append(\"=\").append(option.getValue());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.getValue()!= null)\n    {\n        buff.append(\"=\").append(option.getValue());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.H",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.getValue()!= null)\n    {\n        buff.append(\"=\").append(option.getValue());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.h",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.getValue()!= null)\n    {\n        buff.append(\"=\").append(option.getValue());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;"
      ],
      "function range": "613,5-642,5"
    },
    "Cli_24_/src/java/org/apache/commons/cli/HelpFormatter.java_825-827": {
      "loc": "825-827",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {",
      "output": [
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.Hive",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.Vectorized",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.Hive",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.alge",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.al",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.h"
      ],
      "function range": "809,5-852,5"
    },
    "Cli_25_/src/java/org/apache/commons/cli/HelpFormatter.java_825-826": {
      "loc": "825-826",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {",
      "output": [
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.Hive",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.Vectorized",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.Hive",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.alge",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.al",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        renderWrappedText(sb, width - nextLineTabStop, nextLineTabStop, \n                          text.substring(pos));\n    }\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.h"
      ],
      "function range": "809,5-851,5"
    },
    "Cli_28_/src/java/org/apache/commons/cli/Parser.java_290-291": {
      "loc": "290-291",
      "input": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {",
      "output": [
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode;\n\nimport java.io.IOException;\n\nimport org.",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode;\n\nimport java.io.IOException;\nimport java.util",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode;\n\nimport static org.junit.Assert.assertEquals",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules.subplan;\n\nimport java.util.ArrayList",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode;\n\nimport java.io.IOException;\nimport java.net",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode;\n\nimport org.apache.hadoop.conf.Configuration;",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.Collection;\nimport java",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode.metrics;\n\nimport org.apache.hadoop.class"
      ],
      "function range": "252,5-296,5"
    },
    "Cli_32_/src/main/java/org/apache/commons/cli/HelpFormatter.java_937-942": {
      "loc": "937-942",
      "input": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n            && (c != '\\n') && (c != '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;",
      "output": [
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    return pos;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.builder.RouteBuilder;\nimport org",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    return pos;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos < text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    return pos;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.builder.RouteBuilder;\nimport",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos < text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    return pos;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    return pos;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.*;\nimport org.apache.ignite.cache.*;\nimport",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    return pos;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.cache.CacheAtomicityMode;\nimport org.apache.ign",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    return pos;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.atomic.At",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos < text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    return pos;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.cache.CacheAtomicityMode;\nimport org.apache.",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    return pos;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos < text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    return pos;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache.distributed.near;\n\nimport org.apache.ignite.cache.CacheAtomicityMode;\n"
      ],
      "function range": "902,5-943,5"
    },
    "Cli_40_/src/main/java/org/apache/commons/cli/TypeHandler.java_103-104": {
      "loc": "103-104",
      "input": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {",
      "output": [
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == null)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == null)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == null)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == null)\n    {\n        return (T) createDate",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createObject(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createNumber(final String str) throws ParseException\n{\n    return createValue(str,",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return (T) createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createObject(final String str) throws ParseException\n{\n    return (T) createValue(str, (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createNumber(final String str) throws ParseException\n{\n    ",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Object obj) throws ParseException\n{\n    return createValue(obj, (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Number num) throws ParseException\n{\n    return createValue(num,",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Object obj) throws ParseException\n{\n    return createValue(obj.toString(), (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Number num) throws ParseException\n{\n    return createValue",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Object obj) throws ParseException\n{\n    return createValue(obj, (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Number number) throws ParseException\n{\n    return createValue(number,",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Object obj) throws ParseException\n{\n    return createValue(obj.toString(), (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Number number) throws ParseException\n{\n    return createValue",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createObject(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createNumber(final String str)\n{\n    return createValue(str, (Class<T",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return (T) createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Object obj) throws ParseException\n{\n    return (T) createValue(obj.toString(), (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Number num) throws ParseException\n",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createObject(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createNumber(final String str) throws ParseException\n{\n    try\n    {\n        "
      ],
      "function range": "62,5-105,5"
    },
    "Closure_1_/src/com/google/javascript/jscomp/RemoveUnusedVars.java_379-380": {
      "loc": "379-380",
      "input": "private void removeUnreferencedFunctionArgs(Scope fnScope) {",
      "output": [
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().get",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().getParent() == next.getParent().getParent());\n      }\n      arg = next;",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().get",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      }\n      arg = next;\n    }",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().getParent() == next.getParent());\n      }\n      arg = next;\n    }",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().get",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent().getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next);\n      }\n      arg = next;\n    }\n  }",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().getParent() == next.getParent().getParent());\n        Preconditions.checkState("
      ],
      "function range": "369,3-406,3"
    },
    "Closure_5_/src/com/google/javascript/jscomp/InlineObjectLiterals.java_176-177": {
      "loc": "176-177",
      "input": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }",
      "output": [
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"setup\"));\n  Preconditions.checkState(validProperties.contains(\"teardown\"));\n  Preconditions.checkState(validProperties.contains(\"before\"));\n  Preconditions.checkState(validProperties.contains(\"after\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  Precond",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"it\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  Preconditions.checkState(validProperties.contains(\"before\"));\n  Preconditions.checkState(validProperties.contains(\"after\"));\n  Preconditions.checkState(validProperties.contains(\"describe\"));\n  Preconditions",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"setup\"));\n  Preconditions.checkState(validProperties.contains(\"teardown\"));\n  Preconditions.checkState(validProperties.contains(\"before\"));\n  Preconditions.checkState(validProperties.contains(\"after\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  return ret",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"runTest\"));\n  Preconditions.checkState(validProperties.contains(\"initialize\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"runTest\"));\n  Preconditions.checkState(validProperties.contains(\"initialize\"));\n",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"it\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  Preconditions.checkState(validProperties.contains(\"beforeAll\"));\n  Preconditions.checkState(validProperties.contains(\"afterAll\"));\n  Preconditions.checkState(validProperties.contains(\"describe\"));\n  Pre",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"it\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  Preconditions.checkState(validProperties.contains(\"before\"));\n  Preconditions.checkState(validProperties.contains(\"after\"));\n  Preconditions.checkState(validProperties.contains(\"beforeAll\"));\n  Preconditions",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"it\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  Preconditions.checkState(validProperties.contains(\"before\"));\n  Preconditions.checkState(validProperties.contains(\"after\"));\n  Preconditions.checkState(validProperties.contains(\"test\"));\n  return ret;\n",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"setup\"));\n  Preconditions.checkState(validProperties.contains(\"teardown\"));\n  Preconditions.checkState(validProperties.contains(\"before\"));\n  Preconditions.checkState(validProperties.contains(\"after\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  return true",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"runTest\"));\n  Preconditions.checkState(validProperties.contains(\"initialize\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"runTest\"));\n  Preconditions.checkState(validProperties.contains(\"shouldRunTests\")",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"it\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  Preconditions.checkState(validProperties.contains(\"beforeAll\"));\n  Preconditions.checkState(validProperties.contains(\"afterAll\"));\n  Preconditions.checkState(validProperties.contains(\"test\"));\n  return ret"
      ],
      "function range": "155,5-253,5"
    },
    "Closure_10_/src/com/google/javascript/jscomp/NodeUtil.java_1417-1418": {
      "loc": "1417-1418",
      "input": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {",
      "output": [
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n      return true;\n    case Token.NAME:\n      return n.getString().equals(\"goog\");\n    case Token.GETPROP:\n      return n.getLastChild().getString().equals(\"goog\")\n          && mayBeString(n.getFirstChild(), false);\n    case Token.GETELEM:\n    case Token.IN:\n      return mayBeString(n.getLastChild(), false);\n    case Token.CALL:\n      return n.getFirstChild().getType() == Token.GETPROP &&\n          n.getLastChild().getString().equals(\"goog\") &&\n          mayBeString(n.getFirstChild().getFirstChild(), false);\n    case Token.NULL:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * @return Whether the node is namespace placeholder.\n */\nstatic boolean isNamespacePlaceholder(Node n) {\n  if (!n.getBooleanProp(Node.IS_NAMESPACE)) {\n    return false;\n  }\n\n  Node value = null;\n  if (n.getType() == Token.EXPR_RESULT) {\n    Node assign = n.getFirstChild();\n    value = assign.getLastChild();\n  } else if (n.getType() == Token.VAR) {\n    Node name = n.getFirstChild();\n    value = name.getFirstChild();\n  }\n\n  return value!= null\n      && value.getType() == Token.OBJECTLIT\n      &&!value.hasChildren();\n}\n\n/**\n * Returns true if the shallow scope contains references to 'this' keyword",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n      return true;\n    case Token.NAME:\n      return n.getString().equals(\"goog\");\n    case Token.GETPROP:\n      return n.getLastChild().getString().equals(\"goog\")\n          && mayBeString(n.getFirstChild(), false);\n    case Token.GETELEM:\n    case Token.IN:\n      return mayBeString(n.getLastChild(), false);\n    case Token.CALL:\n      return n.getFirstChild().getType() == Token.GETPROP &&\n          n.getLastChild().getString().equals(\"goog\") &&\n          mayBeString(n.getFirstChild().getFirstChild(), false);\n    case Token.NULL:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * @return Whether the node is namespace placeholder.\n */\nstatic boolean isNamespacePlaceholder(Node n) {\n  if (!n.getBooleanProp(Node.IS_NAMESPACE)) {\n    return false;\n  }\n\n  Node value = null;\n  if (n.getType() == Token.EXPR_RESULT) {\n    Node assign = n.getFirstChild();\n    value = assign.getLastChild();\n  } else if (n.getType() == Token.VAR) {\n    Node name = n.getFirstChild();\n    value = name.getFirstChild();\n  }\n\n  return value!= null\n      && value.getType() == Token.OBJECTLIT\n      &&!value.hasChildren();\n}\n\n/**\n * The string in {@code n} is a reference name.",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n      return true;\n    case Token.NAME:\n      return n.getString().equals(\"goog\");\n    case Token.GETPROP:\n      return n.getLastChild().getString().equals(\"goog\")\n          && mayBeString(n.getFirstChild(), false);\n    case Token.GETELEM:\n    case Token.IN:\n      return mayBeString(n.getLastChild(), false);\n    case Token.CALL:\n      return n.getFirstChild().getType() == Token.GETPROP &&\n          n.getLastChild().getString().equals(\"goog\") &&\n          mayBeString(n.getFirstChild().getFirstChild(), false);\n    case Token.NULL:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * @return Whether the node is namespace placeholder.\n */\nstatic boolean isNamespacePlaceholder(Node n) {\n  if (!n.getBooleanProp(Node.IS_NAMESPACE)) {\n    return false;\n  }\n\n  Node value = null;\n  if (n.getType() == Token.EXPR_RESULT) {\n    Node assign = n.getFirstChild();\n    value = assign.getLastChild();\n  } else if (n.getType() == Token.VAR) {\n    Node name = n.getFirstChild();\n    value = name.getFirstChild();\n  }\n\n  return value!= null\n      && value.getType() == Token.OBJECTLIT\n      &&!value.hasChildren();\n}\n\n/**\n * The string in {@code n} is a reference name.",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n      return true;\n    case Token.NAME:\n      return n.getString().equals(\"goog\");\n    case Token.GETPROP:\n      return n.getLastChild().getString().equals(\"goog\")\n          && mayBeString(n.getFirstChild(), false);\n    case Token.GETELEM:\n    case Token.IN:\n      return mayBeString(n.getLastChild(), false);\n    case Token.CALL:\n      return n.getFirstChild().getType() == Token.GETPROP &&\n          n.getLastChild().getString().equals(\"goog\") &&\n          mayBeString(n.getFirstChild().getFirstChild(), false);\n    case Token.NULL:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * @return Whether the node is namespace placeholder.\n */\nstatic boolean isNamespacePlaceholder(Node n) {\n  if (!n.getBooleanProp(Node.IS_NAMESPACE)) {\n    return false;\n  }\n\n  Node value = null;\n  if (n.getType() == Token.EXPR_RESULT) {\n    Node assign = n.getFirstChild();\n    value = assign.getLastChild();\n  } else if (n.getType() == Token.VAR) {\n    Node name = n.getFirstChild();\n    value = name.getFirstChild();\n  }\n\n  return value!= null\n      && value.getType() == Token.OBJECTLIT\n      &&!value.hasChildren();\n}\n\n\n/**\n * Returns true if the shallow scope contains references to 'this' keyword",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n      return true;\n    case Token.NAME:\n      return n.getString().equals(\"goog\");\n    case Token.GETPROP:\n      return n.getLastChild().getString().equals(\"goog\")\n          && mayBeString(n.getFirstChild(), false);\n    case Token.GETELEM:\n    case Token.IN:\n      return mayBeString(n.getLastChild(), false);\n    case Token.CALL:\n      return n.getFirstChild().getType() == Token.GETPROP &&\n          n.getLastChild().getString().equals(\"goog\") &&\n          mayBeString(n.getFirstChild().getFirstChild(), false);\n    case Token.NULL:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * @return Whether the node is namespace placeholder.\n */\nstatic boolean isNamespacePlaceholder(Node n) {\n  if (!n.getBooleanProp(Node.IS_NAMESPACE)) {\n    return false;\n  }\n\n  Node value = null;\n  if (n.getType() == Token.EXPR_RESULT) {\n    Node assign = n.getFirstChild();\n    value = assign.getLastChild();\n  } else if (n.getType() == Token.VAR) {\n    Node name = n.getFirstChild();\n    value = name.getFirstChild();\n  }\n\n  return value!= null\n      && value.getType() == Token.OBJECTLIT\n      &&!value.hasChildren();\n}\n\n/**\n * Returns true if the shallow scope contains references to 'this' keyword",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n      return true;\n    case Token.NAME:\n      return n.getString().equals(\"goog\");\n    case Token.GETPROP:\n      return n.getLastChild().getString().equals(\"goog\")\n          && mayBeString(n.getFirstChild(), false);\n    case Token.GETELEM:\n    case Token.IN:\n      return mayBeString(n.getLastChild(), false);\n    case Token.CALL:\n      return n.getFirstChild().getType() == Token.GETPROP &&\n          n.getLastChild().getString().equals(\"goog\") &&\n          mayBeString(n.getFirstChild().getFirstChild(), false);\n    case Token.NULL:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * @return Whether the node is namespace placeholder.\n */\nstatic boolean isNamespacePlaceholder(Node n) {\n  if (!n.getBooleanProp(Node.IS_NAMESPACE)) {\n    return false;\n  }\n\n  Node value = null;\n  if (n.getType() == Token.EXPR_RESULT) {\n    Node assign = n.getFirstChild();\n    value = assign.getLastChild();\n  } else if (n.getType() == Token.VAR) {\n    Node name = n.getFirstChild();\n    if (name.hasChildren()) {\n      value = name.getLastChild();\n    }\n  }\n\n  return value!= null\n      && value.getType() == Token.OBJECTLIT\n      &&!value.hasChildren();\n}\n\n/**\n *",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n      return true;\n    case Token.NAME:\n      return n.getString().equals(\"goog\");\n    case Token.GETPROP:\n      return n.getLastChild().getString().equals(\"goog\")\n          && mayBeString(n.getFirstChild(), false);\n    case Token.GETELEM:\n    case Token.IN:\n      return mayBeString(n.getLastChild(), false);\n    case Token.CALL:\n      return n.getFirstChild().getType() == Token.GETPROP &&\n          n.getLastChild().getString().equals(\"goog\") &&\n          mayBeString(n.getFirstChild().getFirstChild(), false);\n    case Token.NULL:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * @return Whether the node is namespace placeholder.\n */\nstatic boolean isNamespacePlaceholder(Node n) {\n  if (!n.getBooleanProp(Node.IS_NAMESPACE)) {\n    return false;\n  }\n\n  Node value = null;\n  if (n.getType() == Token.EXPR_RESULT) {\n    Node assign = n.getFirstChild();\n    value = assign.getLastChild();\n  } else if (n.getType() == Token.VAR) {\n    Node name = n.getFirstChild();\n    if (name.hasChildren()) {\n      value = name.getLastChild();\n    }\n  }\n\n  return value!= null\n      && value.getType() == Token.OBJECTLIT\n      &&!value.hasChildren();\n}\n\n\n/**\n *",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n      return true;\n    case Token.NAME:\n      return n.getString().equals(\"goog\");\n    case Token.GETPROP:\n      return n.getLastChild().getString().equals(\"goog\")\n          && mayBeString(n.getFirstChild(), false);\n    case Token.GETELEM:\n    case Token.IN:\n      return mayBeString(n.getLastChild(), false);\n    case Token.CALL:\n      return n.getFirstChild().getType() == Token.GETPROP &&\n          n.getLastChild().getString().equals(\"goog\") &&\n          mayBeString(n.getFirstChild().getFirstChild(), false);\n    case Token.NULL:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * @return Whether the node is namespace placeholder.\n */\nstatic boolean isNamespacePlaceholder(Node n) {\n  if (!n.getBooleanProp(Node.IS_NAMESPACE)) {\n    return false;\n  }\n\n  Node value = null;\n  if (n.getType() == Token.EXPR_RESULT) {\n    Node assign = n.getFirstChild();\n    value = assign.getLastChild();\n  } else if (n.getType() == Token.VAR) {\n    Node name = n.getFirstChild();\n    value = name.hasChildren()? name.getLastChild() : null;\n  }\n\n  return value!= null\n      && value.getType() == Token.OBJECTLIT\n      &&!value.hasChildren();\n}\n\n/**\n * Returns true if the",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n      return true;\n    case Token.NAME:\n      return n.getString().equals(\"goog\");\n    case Token.GETPROP:\n      return n.getLastChild().getString().equals(\"goog\")\n          && mayBeString(n.getFirstChild(), false);\n    case Token.GETELEM:\n    case Token.IN:\n      return mayBeString(n.getLastChild(), false);\n    case Token.CALL:\n      return n.getFirstChild().getType() == Token.GETPROP &&\n          n.getLastChild().getString().equals(\"goog\") &&\n          mayBeString(n.getFirstChild().getFirstChild(), false);\n    case Token.NULL:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * @return Whether the node is namespace placeholder.\n */\nstatic boolean isNamespacePlaceholder(Node n) {\n  if (!n.getBooleanProp(Node.IS_NAMESPACE)) {\n    return false;\n  }\n\n  Node value = null;\n  if (n.getType() == Token.EXPR_RESULT) {\n    Node assign = n.getFirstChild();\n    value = assign.getLastChild();\n  } else if (n.getType() == Token.VAR) {\n    Node name = n.getFirstChild();\n    if (name.hasChildren()) {\n      value = name.getLastChild();\n    }\n  }\n\n  return value!= null\n      && value.getType() == Token.OBJECTLIT\n      &&!value.hasChildren();\n}\n\n\n// ------------------------------------------------------------------------",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n      return true;\n    case Token.NAME:\n      return n.getString().equals(\"goog\");\n    case Token.GETPROP:\n      return n.getLastChild().getString().equals(\"goog\")\n          && mayBeString(n.getFirstChild(), false);\n    case Token.GETELEM:\n    case Token.IN:\n      return mayBeString(n.getLastChild(), false);\n    case Token.CALL:\n      return n.getFirstChild().getType() == Token.GETPROP &&\n          n.getLastChild().getString().equals(\"goog\") &&\n          mayBeString(n.getFirstChild().getFirstChild(), false);\n    case Token.NULL:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * @return Whether the node is namespace placeholder.\n */\nstatic boolean isNamespacePlaceholder(Node n) {\n  if (!n.getBooleanProp(Node.IS_NAMESPACE)) {\n    return false;\n  }\n\n  Node value = null;\n  if (n.getType() == Token.EXPR_RESULT) {\n    Node assign = n.getFirstChild();\n    value = assign.getLastChild();\n  } else if (n.getType() == Token.VAR) {\n    Node name = n.getFirstChild();\n    if (name.hasChildren()) {\n      value = name.getLastChild();\n    }\n  }\n\n  return value!= null\n      && value.getType() == Token.OBJECTLIT\n      &&!value.hasChildren();\n}\n\n\n// exports ="
      ],
      "function range": "1415,3-1421,3"
    },
    "Closure_11_/src/com/google/javascript/jscomp/TypeCheck.java_1314-1316": {
      "loc": "1314-1316",
      "input": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");",
      "output": [
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"struct\");\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"enum element\");\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"union\");\n  }\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of n\n */\nvoid visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(t, n, parent);\n  visitGetProp(t, n, parent);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of n\n */\nvoid visitVar(NodeTraversal t, Node n, Node parent) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.getJSDocInfo();\n  if (",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"struct\");\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"enum element\");\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"union\");\n  }\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of n\n */\nvoid visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(\n      t, n, parent, getJSType(n.getFirstChild()), getJSType(n.getLastChild()));\n  ensureTyped(t, n);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nvoid visitVar(NodeTraversal t, Node n) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo =",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"struct\");\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"enum element\");\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"union\");\n  }\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of n\n */\nvoid visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(t, n, parent);\n  visitGetProp(t, n, parent);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nvoid visitVar(NodeTraversal t, Node n) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.getJSDocInfo();\n  if (varInfo!= null && varInfo.getType()!=",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"struct\");\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"enum element\");\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"union\");\n  }\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of <code>n</code>\n */\nvoid visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(t, n, parent);\n  visitGetProp(t, n, parent);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of <code>n</code>\n */\nvoid visitVar(NodeTraversal t, Node n, Node parent) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo =",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"struct\");\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"enum element\");\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"union\");\n  }\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of n\n */\nvoid visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(t, n, parent);\n  visitGetProp(t, n, parent);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nvoid visitVar(NodeTraversal t, Node n) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.hasOneChild()? n.getJSDocInfo() : null;\n  for (Node name",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"struct\");\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"enum element\");\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"union\");\n  }\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of n\n */\nvoid visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(t, n, parent);\n  visitGetProp(t, n, parent);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nvoid visitVar(NodeTraversal t, Node n) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.getJSDocInfo();\n  if (varInfo!= null && varInfo.isExterns",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"struct\");\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"enum element\");\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"union\");\n  }\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of n\n */\nvoid visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(t, n, parent);\n  visitGetProp(t, n, parent);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of n\n */\nvoid visitVar(NodeTraversal t, Node n, Node parent) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varDocInfo = n.getJSDocInfo();\n  if",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"struct\");\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"enum element\");\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"union\");\n  }\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of n\n */\nvoid visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(t, n, parent);\n  visitGetProp(t, n, parent);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of n\n */\nvoid visitVar(NodeTraversal t, Node n, Node parent) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.hasOneChild()? n.getJSD",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"struct\");\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"enum element\");\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"union\");\n  }\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of n\n */\nvoid visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(t, n, parent);\n  visitGetProp(t, n, parent);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nvoid visitVar(NodeTraversal t, Node n) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.getJSDocInfo();\n  if (varInfo!= null) {\n    for (Node name",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"struct\");\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"enum element\");\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"union\");\n  }\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of n\n */\nvoid visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(t, n, parent);\n  visitGetProp(t, n, parent);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nvoid visitVar(NodeTraversal t, Node n) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.getJSDocInfo();\n  if (varInfo!= null && varInfo.isConstructor())"
      ],
      "function range": "1303,3-1321,3"
    },
    "Closure_14_/src/com/google/javascript/jscomp/ControlFlowAnalysis.java_767-768": {
      "loc": "767-768",
      "input": "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa != null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext() != null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa != null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {",
      "output": [
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (finallyNode!= null) {\n",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (finallyNode == node) {\n",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (finallyNode.getLastChild()",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (finallyNode.getNext()!=",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (finallyNode.getType() ==",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (finallyNode.getNext() ==",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (fromNode.isEquivalentTo(",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (finallyNode.isCatch()",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (finallyNode.isNormalExit()",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (finallyNode!= null && finallyNode"
      ],
      "function range": "692,3-789,3"
    },
    "Closure_15_/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java_102-103": {
      "loc": "102-103",
      "input": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }",
      "output": [
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\n",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.al",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyr",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.util.JavaDataModel;\nimport org.apache."
      ],
      "function range": "83,7-109,7"
    },
    "Closure_18_/src/com/google/javascript/jscomp/Compiler.java_1288-1289": {
      "loc": "1288-1289",
      "input": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;",
      "output": [
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      if (staleInputs) {\n        input.clearAst();\n      }\n      jsRoot.addChildToBack(n);\n      staleInputs = true;\n    }\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n  return externAndJsRoot;\n}\n\n/**\n * Hoists inputs with the @externs annotation into the externs list.\n */\nprivate void hoistExterns(Node externsRoot) {\n  boolean staleInputs = false",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      if (staleInputs) {\n        input.clearAst();\n      }\n      jsRoot.addChildToBack(n);\n      staleInputs = true;\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}\n\n/**\n * Hoists inputs with the @externs annotation into the externs list.\n */\nvoid Compiler::hoistEx",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      if (staleInputs) {\n        input.clearAst();\n      }\n      jsRoot.addChildToBack(n);\n      staleInputs = true;\n    }\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n  return externAndJsRoot;\n}\n\n\n/**\n * Hoists inputs with the @externs annotation into the externs list.\n */\nprotected void hoistExterns(Node externsRoot) {\n  boolean staleInputs = false",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      if (staleInputs) {\n        input.clearAst();\n      }\n      jsRoot.addChildToBack(n);\n      staleInputs = true;\n    }\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n  return externAndJsRoot;\n}\n\n\n/**\n * Hoists inputs with the @externs annotation into the externs list.\n */\nprivate void hoistExterns(Node externsRoot) {\n  boolean staleInputs = false",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      if (staleInputs) {\n        input.clearAst();\n      }\n      jsRoot.addChildToBack(n);\n      staleInputs = true;\n    }\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n  return externAndJsRoot;\n}\n\n\n/**\n * Hoists inputs with the @externs annotation into the externs list.\n */\nvoid Compiler::hoistExterns(Node externsRoot) {\n  boolean staleInputs",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      if (staleInputs) {\n        input.clearAst();\n      }\n      jsRoot.addChildToBack(n);\n      staleInputs = true;\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}\n\n/**\n * Hoists inputs with the @externs annotation into the externs list.\n */\nprivate void hoistExterns",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      if (staleInputs) {\n        input.clearAst();\n      }\n      jsRoot.addChildToBack(n);\n      staleInputs = true;\n    }\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n  return externAndJsRoot;\n}\n\n/**\n * Hoists inputs with the @externs annotation into the externs list.\n */\nvoid Compiler::hoistExterns(Node externsRoot) {\n  boolean staleInputs",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      if (staleInputs) {\n        input.clearAst();\n      }\n      jsRoot.addChildToBack(n);\n      staleInputs = true;\n    }\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n  return externAndJsRoot;\n}\n\n\n/**\n * Hoists inputs with the @externs annotation into the externs list.\n */\nvoid Compiler::hoistExterns(Node externsRoot) {\n  if (externs",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      if (staleInputs) {\n        input.clearAst();\n      }\n      jsRoot.addChildToBack(n);\n      staleInputs = true;\n    }\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n  return externAndJsRoot;\n}\n\n/**\n * Hoists inputs with the @externs annotation into the externs list.\n */\nvoid Compiler::hoistExterns(Node externsRoot) {\n  if (externs",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      if (staleInputs) {\n        input.clearAst();\n      }\n      jsRoot.addChildToBack(n);\n      staleInputs = true;\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}\n\n\nfunction processAMDAndCommonJSModules() {\n  for (CompilerInput input : inputs) {\n    input.setCompiler("
      ],
      "function range": "1240,3-1362,3"
    },
    "Closure_20_/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java_220-221": {
      "loc": "220-221",
      "input": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget != null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();",
      "output": [
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString() &&\n        value.getString().length() == 1) {\n      switch (value.getString().charAt(0)) {\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\u0085':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\uFEFF':\n        case '\\u00A0':\n        case '\\u2000':\n        case '\\u2001':\n        case '\\u2002':\n        case '\\u2003':\n        case '\\u2004':\n        case '\\u2005':\n        case '\\u2006':\n        case '\\u2007':\n        case '\\u2008':\n        case '\\u2009':\n        case '\\u200A':\n        case '\\u202F':\n        case '\\u205F':\n        case '\\u2060':\n        case '\\u2061':\n        case '\\u2062':\n        case '\\u2063':\n        case '\\u2064':\n        case '\\u2065':\n        case '\\u2066':\n        case '\\u2067':\n        case '\\u2068':\n        case '\\u2069':\n        case '\\u206A':\n        case '\\u206B':\n        case '\\u206C':\n        case '\\u206D':\n        case '\\u206E':\n        case '\\u206F':\n        case '\\u2070':\n        case '\\u2071':\n        case '\\u2072':\n        case '\\u2073':\n        case '\\u2074':\n        case '\\u2075':\n        case '\\u20",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString() &&\n        value.getString().length() == 1) {\n      switch (value.getString().charAt(0)) {\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\u0085':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\uFEFF':\n        case '\\u00A0':\n        case '\\u2000':\n        case '\\u2001':\n        case '\\u2002':\n        case '\\u2003':\n        case '\\u2004':\n        case '\\u2005':\n        case '\\u2006':\n        case '\\u2007':\n        case '\\u2008':\n        case '\\u2009':\n        case '\\u200A':\n        case '\\u202F':\n        case '\\u205F':\n        case '\\u2060':\n        case '\\u2061':\n        case '\\u2062':\n        case '\\u2063':\n        case '\\u206A':\n        case '\\u206B':\n        case '\\u206C':\n        case '\\u206D':\n        case '\\u206E':\n        case '\\u206F':\n        case '\\uFFF9':\n        case '\\uFFFA':\n        case '\\uFFFB':\n        case '\\uFFFC':\n        case '\\uFFFD':\n        case '\\u2FF0':\n        case '\\u2FF1':\n        case '\\u2FF2':\n        case '\\u2FF3':\n        case '\\u2FF4':\n        case '\\u2FF5':\n        case '\\u2FF6",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString() &&\n        value.getString().length() == 1) {\n      switch (value.getString().charAt(0)) {\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\u0085':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\uFEFF':\n        case '\\u00A0':\n        case '\\u2000':\n        case '\\u2001':\n        case '\\u2002':\n        case '\\u2003':\n        case '\\u2004':\n        case '\\u2005':\n        case '\\u2006':\n        case '\\u2007':\n        case '\\u2008':\n        case '\\u2009':\n        case '\\u200A':\n        case '\\u202F':\n        case '\\u205F':\n        case '\\u2060':\n        case '\\u2061':\n        case '\\u2062':\n        case '\\u2063':\n        case '\\u206A':\n        case '\\u206B':\n        case '\\u206C':\n        case '\\u206D':\n        case '\\u206E':\n        case '\\u206F':\n        case '\\uFEFF':\n        case '\\uFFF9':\n        case '\\uFFFA':\n        case '\\uFFFB':\n        case '\\uFFFC':\n        case '\\uFFFD':\n        case '\\u2FF0':\n        case '\\u2FF1':\n        case '\\u2FF2':\n        case '\\u2FF3':\n        case '\\u2FF4':\n        case '\\u2FF5':",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString() &&\n        value.getString().length() == 1) {\n      switch (value.getString().charAt(0)) {\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\u0085':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\uFEFF':\n        case '\\u00A0':\n        case '\\u2000':\n        case '\\u2001':\n        case '\\u2002':\n        case '\\u2003':\n        case '\\u2004':\n        case '\\u2005':\n        case '\\u2006':\n        case '\\u2007':\n        case '\\u2008':\n        case '\\u2009':\n        case '\\u200A':\n        case '\\u202F':\n        case '\\u205F':\n        case '\\u2060':\n        case '\\u2061':\n        case '\\u2062':\n        case '\\u2063':\n        case '\\u2064':\n        case '\\u2065':\n        case '\\u2066':\n        case '\\u2067':\n        case '\\u2068':\n        case '\\u2069':\n        case '\\u206A':\n        case '\\u206B':\n        case '\\u206C':\n        case '\\u206D':\n        case '\\u206E':\n        case '\\u206F':\n        case '\\uFFF9':\n        case '\\uFFFA':\n        case '\\uFFFB':\n        case '\\uFFFC':\n        case '\\uFFFD':\n        case '\\uFFFE':\n        case '\\u",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString() &&\n        value.getString().length() == 1) {\n      switch (value.getString().charAt(0)) {\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\u0085':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\uFEFF':\n        case '\\u00A0':\n        case '\\u2000':\n        case '\\u2001':\n        case '\\u2002':\n        case '\\u2003':\n        case '\\u2004':\n        case '\\u2005':\n        case '\\u2006':\n        case '\\u2007':\n        case '\\u2008':\n        case '\\u2009':\n        case '\\u200A':\n        case '\\u202F':\n        case '\\u205F':\n        case '\\u2060':\n        case '\\u2061':\n        case '\\u2062':\n        case '\\u2063':\n        case '\\u2064':\n        case '\\u2065':\n        case '\\u2066':\n        case '\\u2067':\n        case '\\u2068':\n        case '\\u2069':\n        case '\\u206A':\n        case '\\u206B':\n        case '\\u206C':\n        case '\\u206D':\n        case '\\u206E':\n        case '\\u206F':\n        case '\\uFFF9':\n        case '\\uFFFA':\n        case '\\uFFFB':\n        case '\\uFFFC':\n        case '\\uFFFD':\n          return n;\n      }\n    }\n  }\n",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString() &&\n        value.getString().length() == 1) {\n      switch (value.getString().charAt(0)) {\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\u0085':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\uFEFF':\n        case '\\u00A0':\n        case '\\u2000':\n        case '\\u2001':\n        case '\\u2002':\n        case '\\u2003':\n        case '\\u2004':\n        case '\\u2005':\n        case '\\u2006':\n        case '\\u2007':\n        case '\\u2008':\n        case '\\u2009':\n        case '\\u200A':\n        case '\\u202F':\n        case '\\u205F':\n        case '\\u2060':\n        case '\\u2061':\n        case '\\u2062':\n        case '\\u2063':\n        case '\\u2064':\n        case '\\u2065':\n        case '\\u2066':\n        case '\\u2067':\n        case '\\u2068':\n        case '\\u2069':\n        case '\\u206A':\n        case '\\u206B':\n        case '\\u206C':\n        case '\\u206D':\n        case '\\u206E':\n        case '\\u206F':\n        case '\\uFFF9':\n        case '\\uFFFA':\n        case '\\uFFFB':\n        case '\\uFFFC':\n        case '\\uFFFD':\n        case '\\u2FF0':\n        case '\\",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString() &&\n        value.getString().length() == 1) {\n      switch (value.getString().charAt(0)) {\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\u0085':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\uFEFF':\n        case '\\u00A0':\n        case '\\u2000':\n        case '\\u2001':\n        case '\\u2002':\n        case '\\u2003':\n        case '\\u2004':\n        case '\\u2005':\n        case '\\u2006':\n        case '\\u2007':\n        case '\\u2008':\n        case '\\u2009':\n        case '\\u200A':\n        case '\\u202F':\n        case '\\u205F':\n        case '\\u2060':\n        case '\\u2061':\n        case '\\u2062':\n        case '\\u2063':\n        case '\\u2064':\n        case '\\u2065':\n        case '\\u2066':\n        case '\\u2067':\n        case '\\u2068':\n        case '\\u2069':\n        case '\\u206A':\n        case '\\u206B':\n        case '\\u206C':\n        case '\\u206D':\n        case '\\u206E':\n        case '\\u206F':\n        case '\\uFEFF':\n        case '\\uFFF9':\n        case '\\uFFFA':\n        case '\\uFFFB':\n        case '\\uFFFC':\n        case '\\uFFFD':\n        case '\\u",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString() &&\n        value.getString().length() == 1) {\n      switch (value.getString().charAt(0)) {\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\u0085':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\uFEFF':\n        case '\\u00A0':\n        case '\\u2000':\n        case '\\u2001':\n        case '\\u2002':\n        case '\\u2003':\n        case '\\u2004':\n        case '\\u2005':\n        case '\\u2006':\n        case '\\u2007':\n        case '\\u2008':\n        case '\\u2009':\n        case '\\u200A':\n        case '\\u202F':\n        case '\\u205F':\n        case '\\u2060':\n        case '\\u2061':\n        case '\\u2062':\n        case '\\u2063':\n        case '\\u2064':\n        case '\\u2065':\n        case '\\u2066':\n        case '\\u2067':\n        case '\\u2068':\n        case '\\u2069':\n        case '\\u206A':\n        case '\\u206B':\n        case '\\u206C':\n        case '\\u206D':\n        case '\\u206E':\n        case '\\u206F':\n        case '\\uFEFF':\n        case '\\uFFF9':\n        case '\\uFFFA':\n        case '\\uFFFB':\n        case '\\uFFFC':\n        case '\\uFFFD':\n          return n;\n",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString() &&\n        value.getString().length() == 1) {\n      switch (value.getString().charAt(0)) {\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\u0085':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\uFEFF':\n        case '\\u00A0':\n        case '\\u2000':\n        case '\\u2001':\n        case '\\u2002':\n        case '\\u2003':\n        case '\\u2004':\n        case '\\u2005':\n        case '\\u2006':\n        case '\\u2007':\n        case '\\u2008':\n        case '\\u2009':\n        case '\\u200A':\n        case '\\u202F':\n        case '\\u205F':\n        case '\\u2060':\n        case '\\u2061':\n        case '\\u2062':\n        case '\\u2063':\n        case '\\u2064':\n        case '\\u2065':\n        case '\\u2066':\n        case '\\u2067':\n        case '\\u2068':\n        case '\\u2069':\n        case '\\u206A':\n        case '\\u206B':\n        case '\\u206C':\n        case '\\u206D':\n        case '\\u206E':\n        case '\\u206F':\n        case '\\uFFF9':\n        case '\\uFFFA':\n        case '\\uFFFB':\n        case '\\uFFFC':\n        case '\\uFFFD':\n        case '\\uFFFE':\n          return n;\n",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString() &&\n        value.getString().length() == 1) {\n      switch (value.getString().charAt(0)) {\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\u0085':\n        case '\\u2028':\n        case '\\u2029':\n        case '\\uFEFF':\n        case '\\u00A0':\n        case '\\u2000':\n        case '\\u2001':\n        case '\\u2002':\n        case '\\u2003':\n        case '\\u2004':\n        case '\\u2005':\n        case '\\u2006':\n        case '\\u2007':\n        case '\\u2008':\n        case '\\u2009':\n        case '\\u200A':\n        case '\\u202F':\n        case '\\u205F':\n        case '\\u2060':\n        case '\\u2061':\n        case '\\u2062':\n        case '\\u2063':\n        case '\\u2064':\n        case '\\u2065':\n        case '\\u2066':\n        case '\\u2067':\n        case '\\u2068':\n        case '\\u2069':\n        case '\\u206A':\n        case '\\u206B':\n        case '\\u206C':\n        case '\\u206D':\n        case '\\u206E':\n        case '\\u206F':\n        case '\\uFFF9':\n        case '\\uFFFA':\n        case '\\uFFFB':\n        case '\\uFFFC':\n          return n;\n      }\n    }\n  }\n  return n;\n}\n<"
      ],
      "function range": "208,3-230,3"
    },
    "Closure_31_/src/com/google/javascript/jscomp/Compiler.java_1285-1286": {
      "loc": "1285-1286",
      "input": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&",
      "output": [
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && js!= null) {\n      for (CompilerInput input : js) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n      }\n    }\n    if (hasErrors()) {\n      return null;\n    }\n    if (options.",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && js!= null) {\n      for (CompilerInput input : js) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n      }\n    }\n    if (hasErrors()) {\n      return null;\n    }\n    return externAnd",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && js!= null) {\n      for (CompilerInput input : js) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    }\n    if (staleInputs) {\n      externAndJsRoot.detachChildren();\n      externsRoot.detachChildren();\n      jsRoot = IR.block();\n      jsRoot.setIsSyntheticBlock(true);\n      externsRoot = IR.block();\n      externsRoot.setIsSyntheticBlock(true);\n      externAndJsRoot = IR.",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && js!= null) {\n      for (CompilerInput input : js) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    }\n    if (hasErrors()) {\n      return null;",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && js!= null) {\n      for (CompilerInput input : js) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    }\n    if (staleInputs) {\n      repart",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && js!= null) {\n      for (CompilerInput input : js) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n      }\n    }\n    if (!jsRoot.hasChildren()) {\n      jsRoot.addChildToBack(IR.",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && js!= null) {\n      for (CompilerInput input : js) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n      }\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAnd",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && js!= null) {\n      for (CompilerInput input : js) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    }\n    if (staleInputs) {\n      extern",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && js!= null) {\n      for (CompilerInput input : js) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n      }\n    }\n    if (hasErrors()) {\n      return null;\n    }\n    jsRoot.set",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && js!= null) {\n      for (CompilerInput input : js) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n      }\n    }\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n"
      ],
      "function range": "1236,3-1387,3"
    },
    "Closure_33_/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java_557-558": {
      "loc": "557-558",
      "input": "@Override\npublic void matchConstraint(ObjectType constraintObj) {",
      "output": [
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyr",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.Abstract",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.al",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyracks.al",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport org.apache.hyracks.algeb",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.Agg",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.In",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AggregateOperator;\nimport org.apache.hyracks.algebricks"
      ],
      "function range": "554,3-580,3"
    },
    "Closure_35_/src/com/google/javascript/jscomp/TypeInference.java_1121-1136": {
      "loc": "1121-1136",
      "input": "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());",
      "output": [
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj == null) {\n    return;\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    for (JSType alt : unionType.getAlternates()) {\n      inferPropertyTypesToMatchConstraint(\n          alt, constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n    }\n  } else if (type.isEnumElementType()) {\n    inferPropertyTypesToMatchConstraint(\n        type.toMaybeEnumElementType().getPrimitiveType(),\n        constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n  } else if (type.isObject()) {\n    ObjectType instanceType = type.toMaybeObjectType();\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      if (instanceType.hasProperty(prop)) {\n        continue;\n      }\n      JSType propType = instanceType.getPropertyType(prop);\n      inferPropertyTypesToMatchConstraint(\n          propType, constraintObj.getPropertyType(prop));\n    }\n  }\n}\n\n\n/**\n * Asserts that\n * <ol>\n * <li>The prototype chain of {@code typeA} is the same as the prototype\n * chain of {@code typeB}, and</li>\n * <li>The type of each prototype object is compatible according to\n * {@link JSType#################################################################################################",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj == null) {\n    return;\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    for (JSType alt : unionType.getAlternates()) {\n      inferPropertyTypesToMatchConstraint(\n          alt, constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n    }\n  } else if (type.isEnumElementType()) {\n    inferPropertyTypesToMatchConstraint(\n        type.toMaybeEnumElementType().getPrimitiveType(),\n        constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n  } else if (type.isObject()) {\n    ObjectType instanceType = type.toMaybeObjectType();\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      if (instanceType.hasProperty(prop)) {\n        continue;\n      }\n      JSType propType = instanceType.getPropertyType(prop);\n      inferPropertyTypesToMatchConstraint(\n          propType, constraintObj.getPropertyType(prop));\n    }\n  }\n}\n\n\n/**\n * Asserts that\n * <ol>\n * <li>The prototype chain of {@code typeA} is the same as the prototype\n * chain of {@code typeB}, and</li>\n * <li>The [[Prototype]] of {@code typeA} equals the [[Prototype]] of\n * {@code typeB}, and</li>\n * <li>The [[Get]] of {@code typeA.prototype} equals the [[Get]] of\n * {@code typeB.prototype}.</li>\n * </ol>\n */\npublic void assertTypeEquals(JSType typeA, JSType typeB) {\n  Asserts.assertTypeEquals(typeA, typeB);\n}",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj == null) {\n    return;\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    for (JSType alt : unionType.getAlternates()) {\n      inferPropertyTypesToMatchConstraint(\n          alt, constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n    }\n  } else if (type.isEnumElementType()) {\n    inferPropertyTypesToMatchConstraint(\n        type.toMaybeEnumElementType().getPrimitiveType(),\n        constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n  } else if (type.isObject()) {\n    ObjectType instanceType = type.toMaybeObjectType();\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      if (instanceType.hasProperty(prop)) {\n        continue;\n      }\n      JSType propType = instanceType.getPropertyType(prop);\n      inferPropertyTypesToMatchConstraint(\n          propType, constraintObj.getPropertyType(prop));\n    }\n  }\n}\n\n\n/**\n * Asserts that\n * <ol>\n * <li>The prototype chain of {@code typeA} is the same as the prototype\n * chain of {@code typeB}, and</li>\n * <li>The [[Prototype]] of {@code typeA} equals the [[Prototype]] of\n * {@code typeB}, and</li>\n * <li>The [[Get]] of {@code typeA.prototype} equals the [[Get]] of\n * {@code typeB.prototype}, and</li>\n * <li>The [[Get]] of {@code typeA.prototype.constructor} equals the\n * [[Get]] of {@code typeB.prototype.constructor}.\n * </ol>\n",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj == null) {\n    return;\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    for (JSType alt : unionType.getAlternates()) {\n      inferPropertyTypesToMatchConstraint(\n          alt, constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n    }\n  } else if (type.isEnumElementType()) {\n    inferPropertyTypesToMatchConstraint(\n        type.toMaybeEnumElementType().getPrimitiveType(),\n        constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n  } else if (type.isObject()) {\n    ObjectType instanceType = type.toMaybeObjectType();\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      if (instanceType.hasProperty(prop)) {\n        continue;\n      }\n      JSType propType = instanceType.getPropertyType(prop);\n      inferPropertyTypesToMatchConstraint(\n          propType, constraintObj.getPropertyType(prop));\n    }\n  }\n}\n\n\n/**\n * Asserts that\n * <ol>\n * <li>The prototype chain of {@code typeA} is the same as the prototype\n * chain of {@code typeB}, and</li>\n * <li>The [[Prototype]] of {@code typeA} equals the [[Prototype]] of\n * {@code typeB}, and</li>\n * <li>The [[Get]] of {@code typeA.prototype} equals the [[Get]] of\n * {@code typeB.prototype}, and</li>\n * <li>The [[Get]] of {@code typeA.prototype.constructor} equals the\n * [[Get]] of {@code typeB.prototype.constructor}, and</li>\n *",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj == null) {\n    return;\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    for (JSType alt : unionType.getAlternates()) {\n      inferPropertyTypesToMatchConstraint(\n          alt, constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n    }\n  } else if (type.isEnumElementType()) {\n    inferPropertyTypesToMatchConstraint(\n        type.toMaybeEnumElementType().getPrimitiveType(),\n        constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n  } else if (type.isObject()) {\n    ObjectType instanceType = type.toMaybeObjectType();\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      if (instanceType.hasProperty(prop)) {\n        continue;\n      }\n      JSType propType = instanceType.getPropertyType(prop);\n      inferPropertyTypesToMatchConstraint(\n          propType, constraintObj.getPropertyType(prop));\n    }\n  }\n}\n\n\n/**\n * Asserts that\n * <ol>\n * <li>The prototype chain of {@code typeA} is the same as the prototype\n * chain of {@code typeB}, and</li>\n * <li>The [[Prototype]] of {@code typeA} equals the [[Prototype]] of\n * {@code typeB}, and</li>\n * <li>The [[Get]] of {@code typeA} equals the [[Get]] of {@code typeB}.</li>\n * </ol>\n */\nprivate void assertTypeEquals(JSType typeA, JSType typeB) {\n  Asserts.assertTypeEquals(typeA, typeB);\n}\n\n\n/**\n * Ass",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj == null) {\n    return;\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    for (JSType alt : unionType.getAlternates()) {\n      inferPropertyTypesToMatchConstraint(\n          alt, constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n    }\n  } else if (type.isEnumElementType()) {\n    inferPropertyTypesToMatchConstraint(\n        type.toMaybeEnumElementType().getPrimitiveType(),\n        constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n  } else if (type.isObject()) {\n    ObjectType instanceType = type.toMaybeObjectType();\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      if (instanceType.hasProperty(prop)) {\n        continue;\n      }\n      JSType propType = instanceType.getPropertyType(prop);\n      inferPropertyTypesToMatchConstraint(\n          propType, constraintObj.getPropertyType(prop));\n    }\n  }\n}\n\n\n/**\n * Asserts that\n * <ol>\n * <li>The prototype chain of {@code typeA} is the same as the prototype\n * chain of {@code typeB}, and</li>\n * <li>The [[Prototype]] of {@code typeA} equals the [[Prototype]] of\n * {@code typeB}, and</li>\n * <li>The [[Get]] of {@code typeA} equals the [[Get]] of {@code typeB},\n * and</li>\n * <li>The [[Set]] of {@code typeA} equals the [[Set]] of {@code typeB},\n * and</li>\n * <li>The [[Enumerable]] of {@code typeA",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj == null) {\n    return;\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    for (JSType alt : unionType.getAlternates()) {\n      inferPropertyTypesToMatchConstraint(\n          alt, constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n    }\n  } else if (type.isEnumElementType()) {\n    inferPropertyTypesToMatchConstraint(\n        type.toMaybeEnumElementType().getPrimitiveType(),\n        constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n  } else if (type.isObject()) {\n    ObjectType instanceType = type.toMaybeObjectType();\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      if (instanceType.hasProperty(prop)) {\n        continue;\n      }\n      JSType propType = instanceType.getPropertyType(prop);\n      inferPropertyTypesToMatchConstraint(\n          propType, constraintObj.getPropertyType(prop));\n    }\n  }\n}\n\n\n/**\n * Asserts that\n * <ol>\n * <li>The prototype chain of {@code typeA} is the same as the prototype\n * chain of {@code typeB}, and</li>\n * <li>The type of each prototype object is compatible according to\n * {@link JSTypeNative################################################################################################",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj == null) {\n    return;\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    for (JSType alt : unionType.getAlternates()) {\n      inferPropertyTypesToMatchConstraint(\n          alt, constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n    }\n  } else if (type.isEnumElementType()) {\n    inferPropertyTypesToMatchConstraint(\n        type.toMaybeEnumElementType().getPrimitiveType(),\n        constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n  } else if (type.isObject()) {\n    ObjectType instanceType = type.toMaybeObjectType();\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      if (instanceType.hasProperty(prop)) {\n        continue;\n      }\n      JSType propType = instanceType.getPropertyType(prop);\n      inferPropertyTypesToMatchConstraint(\n          propType, constraintObj.getPropertyType(prop));\n    }\n  }\n}\n\n\n/**\n * Asserts that\n * <ol>\n * <li>The prototype chain of {@code typeA} is the same as the prototype\n * chain of {@code typeB}, and</li>\n * <li>The [[Prototype]] of {@code typeA} equals the [[Prototype]] of\n * {@code typeB}, and</li>\n * <li>The [[Get]] of {@code typeA.prototype} equals the [[Get]] of\n * {@code typeB.prototype}, and</li>\n * <li>The [[Get]] of {@code typeA.prototype.constructor} equals the\n * [[Get]] of {@code typeB.prototype.constructor}.</li>\n * </",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj == null) {\n    return;\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    for (JSType alt : unionType.getAlternates()) {\n      inferPropertyTypesToMatchConstraint(\n          alt, constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n    }\n  } else if (type.isEnumElementType()) {\n    inferPropertyTypesToMatchConstraint(\n        type.toMaybeEnumElementType().getPrimitiveType(),\n        constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n  } else if (type.isObject()) {\n    ObjectType instanceType = type.toMaybeObjectType();\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      if (instanceType.hasProperty(prop)) {\n        continue;\n      }\n      JSType propType = instanceType.getPropertyType(prop);\n      inferPropertyTypesToMatchConstraint(\n          propType, constraintObj.getPropertyType(prop));\n    }\n  }\n}\n\n\n/**\n * Asserts that\n * <ol>\n * <li>The prototype chain of {@code typeA} is the same as the prototype\n * chain of {@code typeB}, and</li>\n * <li>The [[Prototype]] of {@code typeA} equals the [[Prototype]] of\n * {@code typeB}, and</li>\n * <li>The [[Get]] of {@code typeA} equals the [[Get]] of {@code typeB}.</li>\n * </ol>\n */\nprivate void assertTypeEquals(JSType typeA, JSType typeB) {\n  Asserts.assertTypeEquals(typeA, typeB);\n}\n}\n<|",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj == null) {\n    return;\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    for (JSType alt : unionType.getAlternates()) {\n      inferPropertyTypesToMatchConstraint(\n          alt, constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n    }\n  } else if (type.isEnumElementType()) {\n    inferPropertyTypesToMatchConstraint(\n        type.toMaybeEnumElementType().getPrimitiveType(),\n        constraintObj.getRestrictedTypeGivenToBooleanOutcome(true));\n  } else if (type.isObject()) {\n    ObjectType instanceType = type.toMaybeObjectType();\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      if (instanceType.hasProperty(prop)) {\n        continue;\n      }\n      JSType propType = instanceType.getPropertyType(prop);\n      inferPropertyTypesToMatchConstraint(\n          propType, constraintObj.getPropertyType(prop));\n    }\n  }\n}\n\n\n/**\n * Asserts that\n * <ol>\n * <li>The prototype chain of {@code typeA} is the same as the prototype\n * chain of {@code typeB}, and</li>\n * <li>The [[Prototype]] of {@code typeA} equals the [[Prototype]] of\n * {@code typeB}, and</li>\n * <li>The [[Get]] of {@code typeA} equals the [[Get]] of {@code typeB}.</li>\n * </ol>\n */\nprivate void assertTypeEquals(JSType typeA, JSType typeB) {\n  if (!typeA.isEquivalentTo(typeB)) {\n    return;\n  }\n\n  "
      ],
      "function range": "1113,3-1137,3"
    },
    "Closure_36_/src/com/google/javascript/jscomp/InlineVariables.java_575-576": {
      "loc": "575-576",
      "input": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      || !isValidInitialization(initialization)\n      || !isValidReference(reference)) {\n    return false;\n  }\n  if (declaration != initialization &&\n      !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock() != initialization.getBasicBlock()\n      || declaration.getBasicBlock() != reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value != null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship != null) {\n        return false;\n      }",
      "output": [
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @return Whether the call represents a class definition.\n */\nstatic boolean isClassDefiningCall(Node callNode) {\n  SubclassRelationship relationship =\n      compiler.getCodingConvention().getClassesDefinedByCall(callNode);\n  return relationship!= null;\n}\n\n/**\n * @return Whether the new represents a class definition.\n */\nstatic boolean isClassDefiningNew(Node newNode) {\n  SubclassRelationship relationship =\n      compiler.getCodingConvention().",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(reference.getParent());\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @return Whether the call represents a class definition.\n */\nstatic boolean isClassDefiningCall(Node callNode) {\n  SubclassRelationship relationship =\n      compiler.getCodingConvention().getClassesDefinedByCall(callNode);\n  return relationship!= null;\n}\n\n/**\n * @return Whether the new represents a class definition.\n */\nstatic boolean isClassDefiningNew(Node newNode) {\n  SubclassRelationship relationship =\n      compiler.getCodingCon",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @return Whether the call represents a class definition.\n */\nstatic boolean isClassDefiningCall(Node callNode) {\n  CodingConvention convention = compiler.getCodingConvention();\n  SubclassRelationship relationship =\n      convention.getClassesDefinedByCall(callNode);\n  return relationship!= null;\n}\n\n/**\n * @return Whether the new represents a class definition.\n */\nstatic boolean isClassDefiningNew(Node newNode) {\n  CodingConvention convention = compiler",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @return Whether the call represents a class definition.\n */\nstatic boolean isClassDefiningCall(Node callNode) {\n  CodingConvention convention = compiler.getCodingConvention();\n  SubclassRelationship rel = convention.getClassesDefinedByCall(callNode);\n  return rel!= null;\n}\n\n/**\n * @return Whether the new represents a class definition.\n */\nstatic boolean isClassDefiningNew(Node newNode) {\n  CodingConvention convention = compiler.getC",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @return Whether the call represents a class definition.\n */\nstatic boolean isClassDefiningCall(Node callNode) {\n  SubclassRelationship relationship =\n      compiler.getCodingConvention().getClassesDefinedByCall(callNode);\n  return relationship!= null;\n}\n\n/**\n * @return Whether the new represents a class definition.\n */\nstatic boolean isClassDefiningNew(Node callNode) {\n  SubclassRelationship relationship =\n      compiler.getCodingConvention().",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @return Whether the call represents a class definition.\n */\nstatic boolean isClassDefiningCall(Node callNode) {\n  CodingConvention convention = compiler.getCodingConvention();\n  SubclassRelationship relationship =\n      convention.getClassesDefinedByCall(callNode);\n  return relationship!= null;\n}\n\n/**\n * @return Whether the call represents a call to a class factory.\n */\nstatic boolean isClassFactoryCall(Node callNode) {\n  CodingConvention convention",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @return Whether the call represents a class definition.\n */\nstatic boolean isClassDefiningCall(Node callNode) {\n  SubclassRelationship relationship =\n      compiler.getCodingConvention().getClassesDefinedByCall(callNode);\n  return relationship!= null;\n}\n\n/**\n * @return Whether the call represents a call to a class factory.\n */\nstatic boolean isClassFactoryCall(Node callNode) {\n  return callNode.getFirstChild().isNew();\n}\n\n",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @return Whether the call represents a class definition.\n */\nstatic boolean isClassDefiningCall(Node callNode) {\n  CodingConvention convention = compiler.getCodingConvention();\n  SubclassRelationship relationship =\n      convention.getClassesDefinedByCall(callNode);\n  return relationship!= null;\n}\n\n/**\n * @return Whether the new represents a class definition.\n */\nstatic boolean isClassDefiningNew(Node callNode) {\n  CodingConvention convention = compiler",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @return Whether the call represents a class definition.\n */\nstatic boolean isClassDefiningCall(Node callNode) {\n  CodingConvention convention = compiler.getCodingConvention();\n  SubclassRelationship relationship =\n      convention.getClassesDefinedByCall(callNode);\n  return relationship!= null;\n}\n\n/**\n * @return Whether the call represents a call to a class factory.\n */\nstatic boolean isClassFactoryCall(Node callNode) {\n  if (callNode.",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @return Whether the call represents a class definition.\n */\nstatic boolean isClassDefiningCall(Node callNode) {\n  CodingConvention convention = compiler.getCodingConvention();\n  SubclassRelationship relationship =\n      convention.getClassesDefinedByCall(callNode);\n  return relationship!= null;\n}\n\n/**\n * @return Whether the function is testing for the existence of a class.\n */\nstatic boolean isTestingForClassDefinedness(Node callNode) {\n  C"
      ],
      "function range": "519,5-580,5"
    },
    "Closure_38_/src/com/google/javascript/jscomp/CodeConsumer.java_245-246": {
      "loc": "245-246",
      "input": "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);",
      "output": [
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.log(x);\n  } else {\n    x = Math.log10(x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.exp(x);\n  } else {\n    x = Math.pow(10, x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  addNumber(x);\n}\n\npublic static void main(String[] args) {\n  Scanner in = new Scanner(System.in);\n  int t = in.nextInt();\n  for (int i = 0; i < t; i++) {\n    double x = in.nextDouble();\n    addNumber(x);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.h",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.log(x);\n  } else {\n    x = Math.log10(x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.exp(x);\n  } else {\n    x = Math.pow(10, x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  addNumber(x);\n}\n\npublic static void main(String[] args) {\n  Scanner in = new Scanner(System.in);\n  int t = in.nextInt();\n  for (int i = 0; i < t; i++) {\n    double x = in.nextDouble();\n    addNumber(x);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.log(x);\n  } else {\n    x = Math.log10(x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.exp(x);\n  } else {\n    x = Math.pow(10, x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  addNumber(x);\n}\n\npublic static void main(String[] args) {\n  Scanner in = new Scanner(System.in);\n  int t = in.nextInt();\n  for (int i = 0; i < t; i++) {\n    double x = in.nextDouble();\n    addNumber(x);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.al",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.log(x);\n  } else {\n    x = Math.log10(x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.exp(x);\n  } else {\n    x = Math.pow(10, x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  addNumber(x);\n}\n\npublic static void main(String[] args) {\n  Scanner in = new Scanner(System.in);\n  int t = in.nextInt();\n  for (int i = 0; i < t; i++) {\n    double x = in.nextDouble();\n    addNumber(x);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.h",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.log(x);\n  } else {\n    x = Math.log10(x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.exp(x);\n  } else {\n    x = Math.pow(10, x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  addNumber(x);\n}\n\npublic static void main(String[] args) {\n  Scanner in = new Scanner(System.in);\n  int t = in.nextInt();\n  for (int i = 0; i < t; i++) {\n    double x = in.nextDouble();\n    addNumber(x);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.aggregation.datasketches.theta;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.log(x);\n  } else {\n    x = Math.log10(x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.exp(x);\n  } else {\n    x = Math.pow(10, x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  addNumber(x);\n}\n\npublic static void main(String[] args) {\n  Scanner in = new Scanner(System.in);\n  int t = in.nextInt();\n  for (int i = 0; i < t; i++) {\n    double x = in.nextDouble();\n    addNumber(x);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.log(x);\n  } else {\n    x = Math.log10(x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.exp(x);\n  } else {\n    x = Math.pow(10, x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  addNumber(x);\n}\n\npublic static void main(String[] args) {\n  Scanner in = new Scanner(System.in);\n  int t = in.nextInt();\n  for (int i = 0; i < t; i++) {\n    double x = in.nextDouble();\n    addNumber(x);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.log(x);\n  } else {\n    x = Math.log10(x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.exp(x);\n  } else {\n    x = Math.pow(10, x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  addNumber(x);\n}\n\npublic static void main(String[] args) {\n  Scanner in = new Scanner(System.in);\n  int t = in.nextInt();\n  for (int i = 0; i < t; i++) {\n    double x = in.nextDouble();\n    addNumber(x);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.log(x);\n  } else {\n    x = Math.log10(x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.exp(x);\n  } else {\n    x = Math.pow(10, x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  addNumber(x);\n}\n\npublic static void main(String[] args) {\n  Scanner in = new Scanner(System.in);\n  int t = in.nextInt();\n  for (int i = 0; i < t; i++) {\n    double x = in.nextDouble();\n    addNumber(x);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.Bytes",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.log(x);\n  } else {\n    x = Math.log10(x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  if (prev == 'e' || prev == 'E') {\n    x = Math.exp(x);\n  } else {\n    x = Math.pow(10, x);\n  }\n  if (negativeZero) {\n    x = -x;\n  }\n  addNumber(x);\n}\n\npublic static void main(String[] args) {\n  Scanner scanner = new Scanner(System.in);\n  int t = scanner.nextInt();\n  for (int tItr = 0; tItr < t; tItr++) {\n    int n = scanner.nextInt();\n    double x = scanner.nextDouble();\n    addNumber(x);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.builder.RouteBuilder;\nimport"
      ],
      "function range": "240,3-267,3"
    },
    "Closure_52_/src/com/google/javascript/jscomp/CodeGenerator.java_745-746": {
      "loc": "745-746",
      "input": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }",
      "output": [
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.al",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.al",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.Abstract",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogical",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.al",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.oper"
      ],
      "function range": "737,3-746,3"
    },
    "Closure_55_/src/com/google/javascript/jscomp/FunctionRewriter.java_117-118": {
      "loc": "117-118",
      "input": "private static boolean isReduceableFunctionExpression(Node n) {",
      "output": [
        "private static boolean isReduceableFunctionExpression(Node n) {\n    if (!n.isFunction()) {\n      return false;\n    }\n    if (n.isArrowFunction()) {\n      return false;\n    }\n    Node parent = n.getParent();\n    if (parent.isSetterDef() || parent.isGetterDef()) {\n      return false;\n    }\n    Node paramList = n.getSecondChild();\n    if (paramList == null) {\n      return false;\n    }\n    Node lastParam = paramList.getLastChild();\n    if (lastParam == null ||!lastParam.isRest()) {\n      return false;\n    }\n    Node block = lastParam.getNext();\n    if (block == null ||!block.isBlock()) {\n      return false;\n    }\n    Node lastBlockChild = block.getLastChild();\n    if (lastBlockChild == null ||!lastBlockChild.isReturn()) {\n      return false;\n    }\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    if (!n.isFunction()) {\n      return false;\n    }\n    if (n.isArrowFunction()) {\n      return false;\n    }\n    Node parent = n.getParent();\n    if (parent.isSetterDef() || parent.isGetterDef()) {\n      return false;\n    }\n    Node paramList = n.getSecondChild();\n    if (paramList == null) {\n      return false;\n    }\n    Node lastParam = paramList.getLastChild();\n    if (lastParam == null ||!lastParam.isRest()) {\n      return false;\n    }\n    Node block = lastParam.getNext();\n    if (block == null ||!block.isBlock()) {\n      return false;\n    }\n    Node lastBlockChild = block.getLastChild();\n    if (lastBlockChild == null ||!lastBlockChild.isReturn()) {\n      return false;\n    }\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.junit.Test;\n\n",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    if (!n.isFunction()) {\n      return false;\n    }\n    if (n.isArrowFunction()) {\n      return false;\n    }\n    Node parent = n.getParent();\n    if (parent.isSetterDef() || parent.isGetterDef()) {\n      return false;\n    }\n    Node paramList = n.getSecondChild();\n    if (paramList == null) {\n      return false;\n    }\n    Node lastParam = paramList.getLastChild();\n    if (lastParam == null ||!lastParam.isRest()) {\n      return false;\n    }\n    Node block = lastParam.getNext();\n    if (block == null ||!block.isBlock()) {\n      return false;\n    }\n    Node lastBlockChild = block.getLastChild();\n    if (lastBlockChild == null ||!lastBlockChild.isReturn()) {\n      return false;\n    }\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    if (!n.isFunction()) {\n      return false;\n    }\n    if (n.isArrowFunction()) {\n      return false;\n    }\n    Node parent = n.getParent();\n    if (parent.isSetterDef() || parent.isGetterDef()) {\n      return false;\n    }\n    Node paramList = n.getSecondChild();\n    if (paramList == null) {\n      return false;\n    }\n    Node lastParam = paramList.getLastChild();\n    if (lastParam == null ||!lastParam.isRest()) {\n      return false;\n    }\n    Node block = lastParam.getNext();\n    if (block == null ||!block.isBlock()) {\n      return false;\n    }\n    Node lastBlockChild = block.getLastChild();\n    if (lastBlockChild == null ||!lastBlockChild.isReturn()) {\n      return false;\n    }\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.junit.jupiter.api",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    if (!n.isFunction()) {\n      return false;\n    }\n    if (n.isArrowFunction()) {\n      return false;\n    }\n    Node parent = n.getParent();\n    if (parent.isSetterDef() || parent.isGetterDef()) {\n      return false;\n    }\n    Node paramList = n.getSecondChild();\n    if (paramList == null) {\n      return false;\n    }\n    Node lastParam = paramList.getLastChild();\n    if (lastParam == null ||!lastParam.isRest()) {\n      return false;\n    }\n    Node block = lastParam.getNext();\n    if (block == null ||!block.isBlock()) {\n      return false;\n    }\n    Node lastBlockChild = block.getLastChild();\n    if (lastBlockChild == null ||!lastBlockChild.isReturn()) {\n      return false;\n    }\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\n",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    if (!n.isFunction()) {\n      return false;\n    }\n    if (n.isArrowFunction()) {\n      return false;\n    }\n    Node parent = n.getParent();\n    if (parent.isSetterDef() || parent.isGetterDef()) {\n      return false;\n    }\n    Node paramList = n.getSecondChild();\n    if (paramList == null) {\n      return false;\n    }\n    Node lastParam = paramList.getLastChild();\n    if (lastParam == null ||!lastParam.isRest()) {\n      return false;\n    }\n    Node block = lastParam.getNext();\n    if (block == null ||!block.isBlock()) {\n      return false;\n    }\n    Node lastBlockChild = block.getLastChild();\n    if (lastBlockChild == null ||!lastBlockChild.isReturn()) {\n      return false;\n    }\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEnd",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    if (!n.isFunction()) {\n      return false;\n    }\n    if (n.isArrowFunction()) {\n      return false;\n    }\n    Node parent = n.getParent();\n    if (parent.isSetterDef() || parent.isGetterDef()) {\n      return false;\n    }\n    Node paramList = n.getSecondChild();\n    if (paramList == null) {\n      return false;\n    }\n    Node lastParam = paramList.getLastChild();\n    if (lastParam == null ||!lastParam.isRest()) {\n      return false;\n    }\n    Node block = lastParam.getNext();\n    if (block == null ||!block.isBlock()) {\n      return false;\n    }\n    Node lastBlockChild = block.getLastChild();\n    if (lastBlockChild == null ||!lastBlockChild.isReturn()) {\n      return false;\n    }\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport org.apache.camel.Exchange;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Before",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    if (!n.isFunction()) {\n      return false;\n    }\n    if (n.isArrowFunction()) {\n      return false;\n    }\n    Node parent = n.getParent();\n    if (parent.isSetterDef() || parent.isGetterDef()) {\n      return false;\n    }\n    Node paramList = n.getSecondChild();\n    if (paramList == null) {\n      return false;\n    }\n    Node lastParam = paramList.getLastChild();\n    if (lastParam == null ||!lastParam.isRest()) {\n      return false;\n    }\n    Node block = lastParam.getNext();\n    if (block == null ||!block.isBlock()) {\n      return false;\n    }\n    Node lastBlockChild = block.getLastChild();\n    if (lastBlockChild == null ||!lastBlockChild.isReturn()) {\n      return false;\n    }\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.c",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    if (!n.isFunction()) {\n      return false;\n    }\n    if (n.isArrowFunction()) {\n      return false;\n    }\n    Node parent = n.getParent();\n    if (parent.isSetterDef() || parent.isGetterDef()) {\n      return false;\n    }\n    Node paramList = n.getSecondChild();\n    if (paramList == null) {\n      return false;\n    }\n    Node lastParam = paramList.getLastChild();\n    if (lastParam == null ||!lastParam.isRest()) {\n      return false;\n    }\n    Node block = lastParam.getNext();\n    if (block == null ||!block.isBlock()) {\n      return false;\n    }\n    Node lastBlockChild = block.getLastChild();\n    if (lastBlockChild == null ||!lastBlockChild.isReturn()) {\n      return false;\n    }\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    if (!n.isFunction()) {\n      return false;\n    }\n    if (n.isArrowFunction()) {\n      return false;\n    }\n    Node parent = n.getParent();\n    if (parent.isSetterDef() || parent.isGetterDef()) {\n      return false;\n    }\n    Node paramList = n.getSecondChild();\n    if (paramList == null) {\n      return false;\n    }\n    Node lastParam = paramList.getLastChild();\n    if (lastParam == null ||!lastParam.isRest()) {\n      return false;\n    }\n    Node block = lastParam.getNext();\n    if (block == null ||!block.isBlock()) {\n      return false;\n    }\n    Node lastBlockChild = block.getLastChild();\n    if (lastBlockChild == null ||!lastBlockChild.isReturn()) {\n      return false;\n    }\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport org.apache.camel.Exchange;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test"
      ],
      "function range": "116,3-118,3"
    },
    "Closure_57_/src/com/google/javascript/jscomp/ClosureCodingConvention.java_197-198": {
      "loc": "197-198",
      "input": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee != null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();",
      "output": [
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  } else if (NodeUtil.isName(parent)\n      && node.getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.VAR) {\n      className = gramps.getFirstChild().getString();\n    } else if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node rvalue = lvalue.getNext();\n      if (rvalue.getType() == Token.NAME) {\n        className = rvalue.getString();\n      }\n    }\n  } else if (NodeUtil.isGetProp(parent)\n      && node.getLastChild().getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node rvalue = lvalue.getNext();\n      if (rvalue.getType() == Token.GETPROP) {\n        Node classNameNode = rvalue.getFirstChild();\n        if (classNameNode.getType() == Token.STRING) {\n          className = classNameNode.getString();\n        }\n      }\n    } else if (gramps.getType() == Token.GETPROP) {\n      Node classNameNode = gramps.getFirstChild();\n      if (classNameNode.getType() == Token",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  } else if (NodeUtil.isName(parent)\n      && node.getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.VAR) {\n      className = gramps.getFirstChild().getString();\n    } else if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node rvalue = lvalue.getNext();\n      if (rvalue.getType() == Token.NAME) {\n        className = rvalue.getString();\n      }\n    }\n  } else if (NodeUtil.isGetProp(parent)\n      && node.getLastChild().getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node rvalue = lvalue.getNext();\n      if (rvalue.getType() == Token.GETPROP) {\n        Node classNameNode = rvalue.getFirstChild();\n        if (classNameNode.getType() == Token.STRING) {\n          className = classNameNode.getString();\n        }\n      }\n    } else if (gramps.getType() == Token.VAR) {\n      Node classNameNode = gramps.getFirstChild();\n      if (classNameNode.getType() == Token.",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  } else if (NodeUtil.isName(parent)\n      && node.getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.VAR) {\n      className = gramps.getFirstChild().getString();\n    } else if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node rvalue = lvalue.getNext();\n      if (rvalue.getType() == Token.NAME) {\n        className = rvalue.getString();\n      }\n    }\n  } else if (NodeUtil.isGetProp(parent)\n      && node.getLastChild().getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node rvalue = lvalue.getNext();\n      if (rvalue.getType() == Token.GETPROP) {\n        Node classNameNode = rvalue.getLastChild();\n        if (classNameNode!= null && classNameNode.getType() == Token.STRING) {\n          className = classNameNode.getString();\n        }\n      }\n    } else if (gramps.getType() == Token.GETPROP) {\n      Node classNameNode = gramps.getLastChild();\n      if (classNameNode",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  } else if (NodeUtil.isName(parent)\n      && node.getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.VAR) {\n      className = gramps.getFirstChild().getString();\n    } else if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node rvalue = lvalue.getNext();\n      if (rvalue.getType() == Token.NAME) {\n        className = rvalue.getString();\n      }\n    }\n  } else if (NodeUtil.isGetProp(parent)\n      && node.getLastChild().getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node classNameNode = lvalue.getNext();\n      if (classNameNode.getType() == Token.STRING) {\n        className = classNameNode.getString();\n      }\n    } else if (gramps.getType() == Token.VAR) {\n      Node lvalue = gramps.getFirstChild();\n      if (lvalue.getType() == Token.STRING) {\n        className = lvalue.getString();\n      }\n    }\n  }\n  return className;\n}\n\n/**\n",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  } else if (NodeUtil.isName(parent)\n      && node.getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.VAR) {\n      className = gramps.getFirstChild().getString();\n    } else if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node rvalue = lvalue.getNext();\n      if (rvalue.getType() == Token.NAME) {\n        className = rvalue.getString();\n      }\n    }\n  } else if (NodeUtil.isGetProp(parent)\n      && node.getLastChild().getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node classNameNode = lvalue.getNext();\n      if (classNameNode.getType() == Token.STRING) {\n        className = classNameNode.getString();\n      }\n    } else if (gramps.getType() == Token.VAR) {\n      Node lvalue = gramps.getFirstChild();\n      if (lvalue.getType() == Token.STRING) {\n        className = lvalue.getString();\n      }\n    }\n  }\n  return className;\n}\n}\n",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  } else if (NodeUtil.isName(parent)\n      && node.getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.VAR) {\n      className = gramps.getFirstChild().getString();\n    } else if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node rvalue = lvalue.getNext();\n      if (rvalue.getType() == Token.NAME) {\n        className = rvalue.getString();\n      }\n    }\n  } else if (NodeUtil.isGetProp(parent)\n      && node.getLastChild().getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node classNameNode = lvalue.getNext();\n      if (classNameNode.getType() == Token.STRING) {\n        className = classNameNode.getString();\n      }\n    } else if (gramps.getType() == Token.VAR) {\n      Node lvalue = gramps.getFirstChild();\n      if (lvalue.getType() == Token.STRING) {\n        className = lvalue.getString();\n      }\n    }\n  }\n  return className;\n}\n\n  /**\n",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  } else if (NodeUtil.isName(parent)\n      && node.getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.VAR) {\n      className = gramps.getFirstChild().getString();\n    } else if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node rvalue = lvalue.getNext();\n      if (rvalue.getType() == Token.NAME) {\n        className = rvalue.getString();\n      }\n    }\n  } else if (NodeUtil.isGetProp(parent)\n      && node.getLastChild().getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node classNameNode = lvalue.getNext();\n      if (classNameNode.getType() == Token.STRING) {\n        className = classNameNode.getString();\n      }\n    } else if (gramps.getType() == Token.VAR) {\n      Node lvalue = gramps.getFirstChild();\n      if (lvalue.getType() == Token.STRING) {\n        className = lvalue.getString();\n      }\n    }\n  }\n  return className;\n}\n\n}\n",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  } else if (NodeUtil.isName(parent)\n      && node.getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.VAR) {\n      className = gramps.getFirstChild().getString();\n    } else if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node rvalue = lvalue.getNext();\n      if (rvalue.getType() == Token.NAME) {\n        className = rvalue.getString();\n      }\n    }\n  } else if (NodeUtil.isGetProp(parent)\n      && node.getLastChild().getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node classNameNode = lvalue.getNext();\n      if (classNameNode.getType() == Token.STRING) {\n        className = classNameNode.getString();\n      }\n    } else if (gramps.getType() == Token.VAR) {\n      Node lvalue = gramps.getFirstChild();\n      if (lvalue.getType() == Token.STRING) {\n        className = lvalue.getString();\n      }\n    }\n  } else if (NodeUtil.isName(parent)",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  } else if (NodeUtil.isName(parent)\n      && node.getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.VAR) {\n      className = gramps.getFirstChild().getString();\n    } else if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node rvalue = lvalue.getNext();\n      if (rvalue.getType() == Token.NAME) {\n        className = rvalue.getString();\n      }\n    }\n  } else if (NodeUtil.isGetProp(parent)\n      && node.getLastChild().getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node classNameNode = lvalue.getNext();\n      if (classNameNode.getType() == Token.STRING) {\n        className = classNameNode.getString();\n      }\n    } else if (gramps.getType() == Token.VAR) {\n      Node lvalue = gramps.getFirstChild();\n      if (lvalue.getType() == Token.STRING) {\n        className = lvalue.getString();\n      }\n    }\n  }\n\n  return className;\n}\n\n/**\n",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  } else if (NodeUtil.isName(parent)\n      && node.getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.VAR) {\n      className = gramps.getFirstChild().getString();\n    } else if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node rvalue = lvalue.getNext();\n      if (rvalue.getType() == Token.NAME) {\n        className = rvalue.getString();\n      }\n    }\n  } else if (NodeUtil.isGetProp(parent)\n      && node.getLastChild().getString().equals(functionName)) {\n    Node gramps = parent.getParent();\n    if (gramps.getType() == Token.ASSIGN) {\n      Node lvalue = gramps.getFirstChild();\n      Node rvalue = lvalue.getNext();\n      if (rvalue.getType() == Token.GETPROP) {\n        Node classNameNode = rvalue.getFirstChild();\n        if (classNameNode.getType() == Token.STRING) {\n          className = classNameNode.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n\n  /**\n   * Extracts X from goog.inherits(Y, X), or returns null.\n   */\n  private static Node"
      ],
      "function range": "188,3-204,3"
    },
    "Closure_59_/src/com/google/javascript/jscomp/Compiler.java_255-256": {
      "loc": "255-256",
      "input": "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }",
      "output": [
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.MISSING_PROPERTIES)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES,\n        CheckLevel.WARNING);\n  } else if (options.disables(DiagnosticGroups.MISSING_PROPERTIES)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES,\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.INVALID_CASTS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.INVALID_CASTS,\n        CheckLevel.WARNING);\n  } else if (options.disables(DiagnosticGroups.INVALID_CASTS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.INVALID_CASTS,\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.CONST)) {\n    options.setWarningLevel(\n        DiagnosticGroups.CONST",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n\n  if (options.checkGlobalThisLevel.isOn() &&\n     !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  }\n\n  if (options.checkSuspiciousCode.isOn() &&\n     !options.disables(DiagnosticGroups.SUSPICIOUS_CODE)) {\n    options.setWarningLevel(DiagnosticGroups.SUSPICIOUS_CODE,\n        CheckLevel.WARNING);\n  }\n\n  if (options.checkControlStructures.isOn() &&\n     !options.disables(DiagnosticGroups.CONTROL_STYLE)) {\n    options.setWarningLevel(DiagnosticGroups.CONTROL_STYLE,\n        CheckLevel.WARNING);\n  }\n\n  if (options.checkRequires.isOn() &&\n     !options.disables(DiagnosticGroups.MISSING_REQUIRE)) {\n    options.setWarningLevel(DiagnosticGroups.MISSING_REQUIRE,\n        ",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.MISSING_PROPERTIES)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES,\n        CheckLevel.WARNING);\n  } else if (options.disables(DiagnosticGroups.MISSING_PROPERTIES)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES,\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL)) {\n    options.setWarningLevel(\n        DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL,\n        CheckLevel.WARNING);\n  } else if (options.disables(DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL)) {\n    options.setWarningLevel(\n        DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL,\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.CHECK_",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.MISSING_PROPERTIES)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES,\n        CheckLevel.WARNING);\n  } else if (options.disables(DiagnosticGroups.MISSING_PROPERTIES)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES,\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.INVALID_CASTS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.INVALID_CASTS,\n        CheckLevel.WARNING);\n  } else if (options.disables(DiagnosticGroups.INVALID_CASTS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.INVALID_CASTS,\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.LINT_CHECKS)) {\n    options.setWarningLevel(\n        DiagnosticGroups",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n\n  if (options.checkGlobalThisLevel.isOn() &&\n     !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  }\n\n  if (options.checkSuspiciousCode.isOn() &&\n     !options.disables(DiagnosticGroups.SUSPICIOUS_CODE)) {\n    options.setWarningLevel(\n        DiagnosticGroups.SUSPICIOUS_CODE,\n        CheckLevel.WARNING);\n  }\n\n  if (options.checkControlStructures.isOn() &&\n     !options.disables(DiagnosticGroups.CONTROL_STYLE)) {\n    options.setWarningLevel(\n        DiagnosticGroups.CONTROL_STYLE,\n        CheckLevel.WARNING);\n  }\n\n  if (options.checkRequires.isOn() &&\n     !options.disables(DiagnosticGroups.MISSING_REQUIRE)) {\n    options.setWarningLevel(\n        DiagnosticGroups.M",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n\n  if (options.checkGlobalThisLevel.isOn() &&\n     !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  }\n\n  if (options.checkSuspiciousCode.isOn() &&\n     !options.disables(DiagnosticGroups.SUSPICIOUS_CODE)) {\n    options.setWarningLevel(DiagnosticGroups.SUSPICIOUS_CODE,\n        CheckLevel.WARNING);\n  }\n\n  if (options.checkControlStructures.isOn() &&\n     !options.disables(DiagnosticGroups.CONTROL_DEFINITIONS)) {\n    options.setWarningLevel(DiagnosticGroups.CONTROL_DEFINITIONS,\n        CheckLevel.WARNING);\n  }\n\n  if (options.checkRequires.isOn() &&\n     !options.disables(DiagnosticGroups.MISSING_REQUIRE)) {\n    options.setWarningLevel(DiagnosticGroups.MISSING_REQUIRE,",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.MISSING_PROPERTIES)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES,\n        CheckLevel.WARNING);\n  } else if (options.disables(DiagnosticGroups.MISSING_PROPERTIES)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES,\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL)) {\n    options.setWarningLevel(\n        DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL,\n        CheckLevel.WARNING);\n  } else if (options.disables(\n      DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL)) {\n    options.setWarningLevel(\n        DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL,\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.MISSING_PROPERTIES)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES,\n        CheckLevel.WARNING);\n  } else if (options.disables(DiagnosticGroups.MISSING_PROPERTIES)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES,\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL)) {\n    options.setWarningLevel(\n        DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL,\n        CheckLevel.WARNING);\n  } else if (options.disables(DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL)) {\n    options.setWarningLevel(\n        DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL,\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.ES5",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.MISSING_PROPERTIES)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES,\n        CheckLevel.WARNING);\n  } else if (options.disables(DiagnosticGroups.MISSING_PROPERTIES)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES,\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.INVALID_CASTS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.INVALID_CASTS,\n        CheckLevel.WARNING);\n  } else if (options.disables(DiagnosticGroups.INVALID_CASTS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.INVALID_CASTS,\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL)) {\n    options.setWarningLevel(",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.MISSING_PROPERTIES)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES,\n        CheckLevel.WARNING);\n  } else if (options.disables(DiagnosticGroups.MISSING_PROPERTIES)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES,\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL)) {\n    options.setWarningLevel(\n        DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL,\n        CheckLevel.WARNING);\n  } else if (options.disables(DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL)) {\n    options.setWarningLevel(\n        DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL,\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.STRICT"
      ],
      "function range": "226,3-288,3"
    },
    "Closure_62_/src/com/google/javascript/jscomp/LightweightMessageFormatter.java_98-99": {
      "loc": "98-99",
      "input": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null ? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName != null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt != null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)",
      "output": [
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno == -1) {\n      charno = 0;\n    }\n    if (charno >= 0) {\n      b.append(source.getSourceLine(error.sourceName, error.lineNumber));\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append('^');\n      b.append('\\n');\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno == -1) {\n      charno = 0;\n    }\n    if (charno >= 0) {\n      b.append(source.getSourceLine(error.sourceName, error.lineNumber));\n      b.append('\\n');\n      for (int i = 0; i < charno; ++i) {\n        b.append(' ');\n      }\n      b.append('^');\n      b.append('\\n');\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n *",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno == -1) {\n      charno = 0;\n    }\n    if (charno >= 0) {\n      b.append(source.getSourceLine(error.sourceName, error.lineNumber));\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append('^');\n      b.append('\\n');\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno == -1) {\n      charno = 0;\n    }\n    if (charno >= 0) {\n      b.append(source.getSourceLine(error.sourceName, error.lineNumber));\n      b.append('\\n');\n      for (int i = 0; i < charno; ++i) {\n        b.append(' ');\n      }\n      b.append('^');\n      b.append('\\n');\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno == -1) {\n      charno = 0;\n    }\n    if (charno >= 0) {\n      b.append(source.getSourceLine(error.sourceName, error.lineNumber));\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append('^');\n      b.append('\\n');\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno == -1) {\n      charno = 0;\n    }\n    if (charno >= 0) {\n      b.append(source.getSourceLine(error.sourceName, error.lineNumber));\n      b.append('\\n');\n      for (int i = 0; i < charno; ++i) {\n        b.append(' ');\n      }\n      b.append('^');\n      b.append('\\n');\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno == -1) {\n      charno = 0;\n    }\n    if (charno >= 0) {\n      b.append(source.getSourceLine(error.sourceName, error.lineNumber));\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append('^');\n      b.append('\\n');\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno == -1) {\n      charno = 0;\n    }\n    if (charno >= 0) {\n      b.append(source.getSourceLine(error.sourceName, error.lineNumber));\n      b.append('\\n');\n      for (int i = 0; i < charno; ++i) {\n        b.append(' ');\n      }\n      b.append('^');\n      b.append('\\n');\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n *",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno == -1) {\n      charno = 0;\n    }\n    if (charno >= 0) {\n      b.append(source.getSourceLine(error.sourceName, error.lineNumber));\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append('^');\n      b.append('\\n');\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno == -1) {\n      charno = 0;\n    }\n    if (charno >= 0) {\n      b.append(source.getSourceLine(error.sourceName, error.lineNumber));\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append('^');\n      b.append('\\n');\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n"
      ],
      "function range": "66,3-111,3"
    },
    "Closure_65_/src/com/google/javascript/jscomp/CodeGenerator.java_1015-1016": {
      "loc": "1015-1016",
      "input": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {",
      "output": [
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf###############################################################################################################################################################################################################################",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F') ||\n            (c >= '\\u007F' && c <= '\\u009F') ||\n            (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            sb.append(singlequoteEscape);\n            sb.append(Character.toString(c));\n            sb.append(singlequoteEscape);\n          }\n          else {\n            sb.append(c);\n          }\n        }\n        break;\n    ",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F')\n            || (c >= '\\u007F' && c <= '\\u009F')\n            || (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            sb.append(singlequoteEscape);\n            sb.append(Character.toString(c));\n            sb.append(singlequoteEscape);\n          }\n          else {\n            sb.append(c);\n          }\n        }\n        break;\n    ",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F')\n            || (c >= '\\u007F' && c <= '\\u009F')\n            || (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            sb.append(String.format(\"\\\\u%04x\", (int) c));\n          }\n          else {\n            sb.append(c);\n          }\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  ",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F') ||\n            (c >= '\\u007F' && c <= '\\u009F') ||\n            (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            sb.append(String.format(\"\\\\u%04x\", (int) c));\n          }\n          else {\n            sb.append(c);\n          }\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  ",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F') ||\n            (c >= '\\u007F' && c <= '\\u009F') ||\n            (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            sb.append(singlequoteEscape);\n          }\n          else {\n            sb.append(c);\n          }\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F') ||\n            (c >= '\\u007F' && c <= '\\u009F') ||\n            (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            sb.append(singlequoteEscape);\n          }\n          else {\n            sb.append(c);\n          }\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '/': sb.append(\"\\\\/\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F')\n            || (c >= '\\u007F' && c <= '\\u009F')\n            || (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            sb.append(singlequoteEscape);\n            sb.append(Character.toString(c));\n            sb.append(singlequoteEscape);\n          }\n          else {\n            sb.append",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '/': sb.append(\"\\\\/\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F')\n            || (c >= '\\u007F' && c <= '\\u009F')\n            || (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            sb.append(singlequoteEscape);\n            sb.append(Character.toString((char)c));\n            sb.append(singlequoteEscape);\n          }\n          else {\n            sb",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F')\n            || (c >= '\\u007F' && c <= '\\u009F')\n            || (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            sb.append(singlequoteEscape);\n            sb.append(Character.toString(c));\n            sb.append(singlequoteEscape);\n          }\n          else {\n            sb.append(c);\n          }\n        }\n    }\n  }"
      ],
      "function range": "1005,3-1075,3"
    },
    "Closure_67_/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java_318-319": {
      "loc": "318-319",
      "input": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP",
      "output": [
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node getprop = n.getFirstChild();\n    return getprop.getType() == Token.GETPROP\n        && getprop.isQualifiedName()\n        && getprop.getLastChild().getString().equals(\"prototype\");\n  }\n  return false;\n}\n\n/**\n * @return Whether the node an assignment to a prototype property of\n *     some constructor\n */\npublic static boolean isPrototypePropertyDeclaration(Node n) {\n  Preconditions.checkArgument(n.getType() == Token.VAR);\n  Node parent = n.getParent();\n  return parent.getType() == Token.ASSIGN\n      && parent.getFirstChild().getType() == Token.GETPROP\n      && parent.getFirstChild().isGetProp()\n      && parent.getFirstChild().getLastChild().getString().equals(\"prototype\")\n      && parent.getLastChild().getType() == Token.OBJECTLIT;\n}\n\n/**\n * @return The class name part of a qualified prototype name.\n */\npublic static Node getPrototypeClassName(Node qName) {\n  Node cur = qName;\n  while (cur.getType() == Token.GETPROP) {\n    if (cur.getLastChild().getString().equals(\"prototype\")) {\n      return cur.getFirstChild();\n    } else {\n      cur = cur.getFirstChild();\n    }\n  }\n  return null;\n}\n\n/**\n * @return The string property name part of a qualified prototype name.\n */\npublic static String getPrototypePropertyName(Node qName) {\n  String qNameStr = qName.getQualifiedName();\n  int prototypeIdx = qNameStr.lastIndexOf(\".prototype.\");\n  int memberIndex = prototypeIdx + \".prototype\".length() + 1;\n  return qNameStr.substring(memberIndex);\n}\n\n/**\n * Create a",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node getprop = n.getFirstChild();\n    return getprop.getType() == Token.GETPROP\n        && getprop.isQualifiedName()\n        && getprop.getLastChild().getString().equals(\"prototype\");\n  }\n  return false;\n}\n\n/**\n * @return Whether the node an assignment to a prototype property of\n *     some constructor\n */\npublic static boolean isPrototypePropertyDeclaration(Node n) {\n  Preconditions.checkArgument(n.getType() == Token.VAR);\n  Node parent = n.getParent();\n  return parent.getType() == Token.ASSIGN\n      && parent.getFirstChild().getType() == Token.GETPROP\n      && parent.getFirstChild().isGetProp()\n      && parent.getFirstChild().getLastChild().getString().equals(\"prototype\")\n      && parent.getLastChild().getType() == Token.OBJECTLIT;\n}\n\n/**\n * @return The class name part of a qualified prototype name.\n */\npublic static Node getPrototypeClassName(Node qName) {\n  Node cur = qName;\n  while (cur.getType() == Token.GETPROP) {\n    if (cur.getLastChild().getString().equals(\"prototype\")) {\n      return cur.getFirstChild();\n    } else {\n      cur = cur.getFirstChild();\n    }\n  }\n  return null;\n}\n\n/**\n * @return The string property name part of a qualified prototype name.\n */\npublic static String getPrototypePropertyName(Node qName) {\n  Node cur = qName;\n  while (cur.getType() == Token.GETPROP) {\n    if (cur.getLastChild().getString().equals(\"prototype\")) {\n      return cur.getLastChild().getNext().getString();\n    } else {\n      cur = cur.getFirstChild();",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node getprop = n.getFirstChild();\n    return getprop.getType() == Token.GETPROP\n        && getprop.isQualifiedName()\n        && getprop.getLastChild().getString().equals(\"prototype\");\n  }\n  return false;\n}\n\n/**\n * @return Whether the node an assignment to a prototype property of\n *     some constructor\n */\npublic static boolean isPrototypePropertyDeclaration(Node n) {\n  Preconditions.checkArgument(n.getType() == Token.VAR);\n  Node parent = n.getParent();\n  return parent.getType() == Token.ASSIGN\n      && parent.getFirstChild().getType() == Token.GETPROP\n      && parent.getFirstChild().isGetProp()\n      && parent.getFirstChild().getLastChild().getString().equals(\"prototype\")\n      && parent.getLastChild().getType() == Token.OBJECTLIT;\n}\n\n/**\n * @return The class name part of a qualified prototype name.\n */\npublic static Node getPrototypeClassName(Node qName) {\n  Node cur = qName;\n  while (cur.getType() == Token.GETPROP) {\n    if (cur.getLastChild().getString().equals(\"prototype\")) {\n      return cur.getFirstChild();\n    } else {\n      cur = cur.getFirstChild();\n    }\n  }\n  return null;\n}\n\n/**\n * @return The string property name part of a qualified prototype name.\n */\npublic static String getPrototypePropertyName(Node qName) {\n  Node cur = qName;\n  while (cur.getType() == Token.GETPROP) {\n    if (cur.getLastChild().getString().equals(\"prototype\")) {\n      return cur.getLastChild().getLastChild().getString();\n    } else {\n      cur = cur.getFirstChild",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node getprop = n.getFirstChild();\n    return getprop.getType() == Token.GETPROP\n        && getprop.isQualifiedName()\n        && getprop.getLastChild().getString().equals(\"prototype\");\n  }\n  return false;\n}\n\n/**\n * @return Whether the node an assignment to a prototype property of\n *     some constructor\n */\npublic static boolean isPrototypePropertyDeclaration(Node n) {\n  Preconditions.checkArgument(n.getType() == Token.VAR);\n  Node parent = n.getParent();\n  return parent.getType() == Token.ASSIGN\n      && parent.getFirstChild().getType() == Token.GETPROP\n      && parent.getFirstChild().isGetProp()\n      && parent.getFirstChild().getLastChild().getString().equals(\"prototype\")\n      && parent.getLastChild().getType() == Token.OBJECTLIT;\n}\n\n/**\n * @return The class name part of a qualified prototype name.\n */\npublic static Node getPrototypeClassName(Node qName) {\n  Node cur = qName;\n  while (cur.getType() == Token.GETPROP) {\n    if (cur.getLastChild().getString().equals(\"prototype\")) {\n      return cur.getFirstChild();\n    } else {\n      cur = cur.getFirstChild();\n    }\n  }\n  return null;\n}\n\n/**\n * @return The string property name part of a qualified prototype name.\n */\npublic static String getPrototypePropertyName(Node qName) {\n  Node cur = qName;\n  if (cur.getType() == Token.NAME) {\n    return cur.getString();\n  } else if (cur.getType() == Token.GETPROP) {\n    return cur.getLastChild().getString();\n  }\n  return null;\n}\n\n",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node getprop = n.getFirstChild();\n    return getprop.getType() == Token.GETPROP\n        && getprop.isQualifiedName()\n        && getprop.getLastChild().getString().equals(\"prototype\");\n  }\n  return false;\n}\n\n/**\n * @return Whether the node an assignment to a prototype property of\n *     some constructor\n */\npublic static boolean isPrototypePropertyDeclaration(Node n) {\n  Preconditions.checkArgument(n.getType() == Token.VAR);\n  Node parent = n.getParent();\n  return parent.getType() == Token.ASSIGN\n      && parent.getFirstChild().getType() == Token.GETPROP\n      && parent.getFirstChild().isGetProp()\n      && parent.getFirstChild().getLastChild().getString().equals(\"prototype\")\n      && parent.getLastChild().getType() == Token.OBJECTLIT;\n}\n\n/**\n * @return The class name part of a qualified prototype name.\n */\npublic static Node getPrototypeClassName(Node qName) {\n  Node cur = qName;\n  while (cur.getType() == Token.GETPROP) {\n    if (cur.getLastChild().getString().equals(\"prototype\")) {\n      return cur.getFirstChild();\n    } else {\n      cur = cur.getFirstChild();\n    }\n  }\n  return null;\n}\n\n/**\n * @return The string property name part of a qualified prototype name.\n */\npublic static String getPrototypePropertyName(Node qName) {\n  Node cur = qName;\n  if (cur.getType()!= Token.GETPROP) {\n    return null;\n  }\n  if (cur.getLastChild().getString().equals(\"prototype\")) {\n    return cur.getLastChild().getNext().getString();\n  }\n  return null",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node getprop = n.getFirstChild();\n    return getprop.getType() == Token.GETPROP\n        && getprop.isQualifiedName()\n        && getprop.getLastChild().getString().equals(\"prototype\");\n  }\n  return false;\n}\n\n/**\n * @return Whether the node an assignment to a prototype property of\n *     some constructor\n */\npublic static boolean isPrototypePropertyDeclaration(Node n) {\n  Preconditions.checkArgument(n.getType() == Token.VAR);\n  Node parent = n.getParent();\n  return parent.getType() == Token.ASSIGN\n      && parent.getFirstChild().getType() == Token.GETPROP\n      && parent.getFirstChild().isGetProp()\n      && parent.getFirstChild().getLastChild().getString().equals(\"prototype\")\n      && parent.getLastChild().getType() == Token.OBJECTLIT;\n}\n\n/**\n * @return The class name part of a qualified prototype name.\n */\npublic static Node getPrototypeClassName(Node qName) {\n  Node cur = qName;\n  while (cur.getType() == Token.GETPROP) {\n    if (cur.getLastChild().getString().equals(\"prototype\")) {\n      return cur.getFirstChild();\n    } else {\n      cur = cur.getFirstChild();\n    }\n  }\n  return null;\n}\n\n/**\n * @return The string property name part of a qualified prototype name.\n */\npublic static String getPrototypePropertyName(Node qName) {\n  Node cur = qName;\n  if (cur.getType() == Token.GETPROP) {\n    if (cur.getLastChild().getString().equals(\"prototype\")) {\n      return cur.getLastChild().getNext().getString();\n    }\n  }\n  return null;\n}\n\n",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node getprop = n.getFirstChild();\n    return getprop.getType() == Token.GETPROP\n        && getprop.isQualifiedName()\n        && getprop.getLastChild().getString().equals(\"prototype\");\n  }\n  return false;\n}\n\n/**\n * @return Whether the node an assignment to a prototype property of\n *     some constructor\n */\npublic static boolean isPrototypePropertyDeclaration(Node n) {\n  Preconditions.checkArgument(n.getType() == Token.VAR);\n  Node parent = n.getParent();\n  return parent.getType() == Token.ASSIGN\n      && parent.getFirstChild().getType() == Token.GETPROP\n      && parent.getFirstChild().isGetProp()\n      && parent.getFirstChild().getLastChild().getString().equals(\"prototype\")\n      && parent.getLastChild().getType() == Token.OBJECTLIT;\n}\n\n/**\n * @return The class name part of a qualified prototype name.\n */\npublic static Node getPrototypeClassName(Node qName) {\n  Node cur = qName;\n  while (cur.getType() == Token.GETPROP) {\n    if (cur.getLastChild().getString().equals(\"prototype\")) {\n      return cur.getFirstChild();\n    } else {\n      cur = cur.getFirstChild();\n    }\n  }\n  return null;\n}\n\n/**\n * @return The string property name part of a qualified prototype name.\n */\npublic static String getPrototypePropertyName(Node qName) {\n  String qNameStr = qName.getQualifiedName();\n  int prototypeIdx = qNameStr.lastIndexOf(\".prototype.\");\n  int memberIndex = prototypeIdx + \".prototype\".length() + 1;\n  return qNameStr.substring(memberIndex);\n}\n\n/**\n * @return",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node getprop = n.getFirstChild();\n    return getprop.getType() == Token.GETPROP\n        && getprop.isQualifiedName()\n        && getprop.getLastChild().getString().equals(\"prototype\");\n  }\n  return false;\n}\n\n/**\n * @return Whether the node an assignment to a prototype property of\n *     some constructor\n */\npublic static boolean isPrototypePropertyDeclaration(Node n) {\n  Preconditions.checkArgument(n.getType() == Token.VAR);\n  Node parent = n.getParent();\n  return parent.getType() == Token.ASSIGN\n      && parent.getFirstChild().getType() == Token.GETPROP\n      && parent.getFirstChild().isGetProp()\n      && parent.getFirstChild().getLastChild().getString().equals(\"prototype\")\n      && parent.getLastChild().getType() == Token.OBJECTLIT;\n}\n\n/**\n * @return The class name part of a qualified prototype name.\n */\npublic static Node getPrototypeClassName(Node qName) {\n  Node cur = qName;\n  while (cur.getType() == Token.GETPROP) {\n    if (cur.getLastChild().getString().equals(\"prototype\")) {\n      return cur.getFirstChild();\n    } else {\n      cur = cur.getFirstChild();\n    }\n  }\n  return null;\n}\n\n/**\n * @return The string property name part of a qualified prototype name.\n */\npublic static String getPrototypePropertyName(Node qName) {\n  Node cur = qName;\n  if (cur.getType()!= Token.GETPROP) {\n    return null;\n  } else if (cur.getLastChild().getString().equals(\"prototype\")) {\n    return cur.getLastChild().getNext().getString();\n  } else {\n    return",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node getprop = n.getFirstChild();\n    return getprop.getType() == Token.GETPROP\n        && getprop.isQualifiedName()\n        && getprop.getLastChild().getString().equals(\"prototype\");\n  }\n  return false;\n}\n\n/**\n * @return Whether the node an assignment to a prototype property of\n *     some constructor\n */\npublic static boolean isPrototypePropertyDeclaration(Node n) {\n  Preconditions.checkArgument(n.getType() == Token.VAR);\n  Node parent = n.getParent();\n  return parent.getType() == Token.ASSIGN\n      && parent.getFirstChild().getType() == Token.GETPROP\n      && parent.getFirstChild().isGetProp()\n      && parent.getFirstChild().getLastChild().getString().equals(\"prototype\")\n      && parent.getLastChild().getType() == Token.OBJECTLIT;\n}\n\n/**\n * @return The class name part of a qualified prototype name.\n */\npublic static Node getPrototypeClassName(Node qName) {\n  Node cur = qName;\n  while (cur.getType() == Token.GETPROP) {\n    if (cur.getLastChild().getString().equals(\"prototype\")) {\n      return cur.getFirstChild();\n    } else {\n      cur = cur.getFirstChild();\n    }\n  }\n  return null;\n}\n\n/**\n * @return The string property name part of a qualified prototype name.\n */\npublic static String getPrototypePropertyName(Node qName) {\n  String qNameStr = qName.getQualifiedName();\n  int prototypeIdx = qNameStr.lastIndexOf(\".prototype.\");\n  int memberIndex = prototypeIdx + \".prototype\".length() + 1;\n  return qNameStr.substring(memberIndex);\n}\n}\n<|java",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node getprop = n.getFirstChild();\n    return getprop.getType() == Token.GETPROP\n        && getprop.isQualifiedName()\n        && getprop.getLastChild().getString().equals(\"prototype\");\n  }\n  return false;\n}\n\n/**\n * @return Whether the node an assignment to a prototype property of\n *     some constructor\n */\npublic static boolean isPrototypePropertyDeclaration(Node n) {\n  Preconditions.checkArgument(n.getType() == Token.VAR);\n  Node parent = n.getParent();\n  return parent.getType() == Token.ASSIGN\n      && parent.getFirstChild().getType() == Token.GETPROP\n      && parent.getFirstChild().isGetProp()\n      && parent.getFirstChild().getLastChild().getString().equals(\"prototype\")\n      && parent.getLastChild().getType() == Token.OBJECTLIT;\n}\n\n/**\n * @return The class name part of a qualified prototype name.\n */\npublic static Node getPrototypeClassName(Node qName) {\n  Node cur = qName;\n  while (cur.getType() == Token.GETPROP) {\n    if (cur.getLastChild().getString().equals(\"prototype\")) {\n      return cur.getFirstChild();\n    } else {\n      cur = cur.getFirstChild();\n    }\n  }\n  return null;\n}\n\n/**\n * @return The string property name part of a qualified prototype name.\n */\npublic static String getPrototypePropertyName(Node qName) {\n  String qname = qName.getQualifiedName();\n  int prototypeIdx = qname.lastIndexOf(\".prototype.\");\n  int memberIndex = prototypeIdx + \".prototype\".length() + 1;\n  return qname.substring(memberIndex);\n}\n\n/**\n * Create a node for an"
      ],
      "function range": "314,5-334,5"
    },
    "Closure_70_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1745-1746": {
      "loc": "1745-1746",
      "input": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType != null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters != null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter != null) {\n          defineSlot(astParameter, functionNode,",
      "output": [
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, functionType);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    if (jsDocParameter!= null) {\n      defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n    } else {\n      defineSlot(astParameter, functionNode, null, functionType);\n    }\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    String parameterName = astParameter.getString();\n    JSType type = functionType.getParameterType(parameterName);\n    defineSlot(astParameter, functionNode, jsDocParameter, type);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      JSType type) {\n    if (jsDocParameter!= null) {\n      defineSlot(astParameter, functionNode, jsDocParameter, type);\n    }",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, functionType);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    if (jsDocParameter!= null) {\n      defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n    } else {\n      defineSlot(astParameter, functionNode, null, functionType);\n    }\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    String parameterName = astParameter.getString();\n    JSType type = functionType.getParameterType(parameterName);\n    defineSlot(astParameter, functionNode, jsDocParameter, type);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      JSType type) {\n    if (jsDocParameter!= null) {\n      jsDocParameter.setJSType(type);\n    }\n    functionNode.getFirstChild().addChildTo",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, functionType);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    if (jsDocParameter!= null) {\n      defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n    } else {\n      defineSlot(astParameter, functionNode, null, functionType);\n    }\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    String parameterName = astParameter.getString();\n    JSType type = functionType.getParameterType(parameterName);\n    defineSlot(astParameter, functionNode, jsDocParameter, type);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      JSType type) {\n    if (jsDocParameter!= null) {\n      jsDocParameter.setJSType(type);\n    }\n    functionNode",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, functionType);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    if (jsDocParameter!= null) {\n      defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n    } else {\n      defineSlot(astParameter, functionNode, null, functionType);\n    }\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    String parameterName = astParameter.getString();\n    JSType type = functionType.getParameterType(parameterName);\n    defineSlot(astParameter, functionNode, jsDocParameter, type);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      JSType type) {\n    if (type!= null &&\n        type.isObject() &&\n        type.isSubtypeOf(typeRegistry.getNative",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, functionType);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    if (jsDocParameter!= null) {\n      defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n    } else {\n      defineSlot(astParameter, functionNode, null, functionType);\n    }\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    String parameterName = astParameter.getString();\n    JSType type = functionType.getParameterType(parameterName);\n    defineSlot(astParameter, functionNode, jsDocParameter, type);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      JSType type) {\n    if (jsDocParameter!= null) {\n      if (type!= null) {\n        jsDocParameter.setJSType(",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, functionType);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    if (jsDocParameter!= null) {\n      defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n    } else {\n      defineSlot(astParameter, functionNode, null, functionType);\n    }\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    String parameterName = astParameter.getString();\n    JSType type = functionType.getParameterType(parameterName);\n    defineSlot(astParameter, functionNode, jsDocParameter, type);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      JSType type) {\n    if (jsDocParameter!= null) {\n      jsDocParameter.setJSType(type);\n    }\n    astParameter",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, functionType);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    if (jsDocParameter!= null) {\n      defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n    } else {\n      defineSlot(astParameter, functionNode, null, functionType);\n    }\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    String parameterName = astParameter.getString();\n    JSType type = functionType.getParameterType(parameterName);\n    defineSlot(astParameter, functionNode, jsDocParameter, type);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      JSType type) {\n    if (jsDocParameter!= null) {\n      if (type!= null) {\n        jsDocParameter.setJSType(type);\n      }\n    }",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, functionType);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    if (jsDocParameter!= null) {\n      defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n    } else {\n      defineSlot(astParameter, functionNode, null, functionType);\n    }\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    String parameterName = astParameter.getString();\n    JSType type = functionType.getParameterType(parameterName);\n    defineSlot(astParameter, functionNode, jsDocParameter, type);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      JSType type) {\n    if (jsDocParameter!= null) {\n      jsDocParameter.setJSType(type);\n    }\n    Node paramNameNode = astParameter.getFirst",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, functionType);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    if (jsDocParameter!= null) {\n      defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n    } else {\n      defineSlot(astParameter, functionNode, null, functionType);\n    }\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    String parameterName = astParameter.getString();\n    JSType type = functionType.getParameterType(parameterName);\n    defineSlot(astParameter, functionNode, jsDocParameter, type);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      JSType type) {\n    if (jsDocParameter!= null) {\n      jsDocParameter.setJSType(type);\n    }\n    Node param",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, functionType);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    if (jsDocParameter!= null) {\n      defineSlot(astParameter, functionNode, jsDocParameter, functionType);\n    } else {\n      defineSlot(astParameter, functionNode, null, functionType);\n    }\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      FunctionType functionType) {\n    String parameterName = astParameter.getString();\n    JSType type = functionType.getParameterType(parameterName);\n    defineSlot(astParameter, functionNode, jsDocParameter, type);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node astParameter, Node functionNode, Node jsDocParameter,\n      JSType type) {\n    if (jsDocParameter!= null) {\n      jsDocParameter.setJSType(type);\n    }\n    Node parameter"
      ],
      "function range": "1734,5-1753,5"
    },
    "Closure_71_/src/com/google/javascript/jscomp/CheckAccessControls.java_416-417": {
      "loc": "416-417",
      "input": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType != null) {",
      "output": [
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSType jsType = objectType.getPropertyType(propertyName);\n    if (jsType!= null) {\n      return;\n    }\n  }\n  t.report(getprop, INVALID_PROP_OVERRIDE, propertyName,\n      parent.isGetProp()?\n          \"getter\" :\n          parent.isSetProp()?\n          \"setter\" :\n          \"mutator\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSType jsType = objectType.getPropertyType(propertyName);\n    if (jsType!= null) {\n      return;\n    }\n  }\n  t.report(getprop, INVALID_PROP_OVERRIDE, propertyName,\n      parent.isGetProp()?\n          \"getter\" :\n          parent.isSetProp()?\n          \"setter\" :\n          \"mutator\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSType jsType = objectType.getPropertyType(propertyName);\n    if (jsType!= null) {\n      return;\n    }\n  }\n  t.report(getprop, INVALID_PROP_OVERRIDE, propertyName,\n      parent.isGetProp()?\n          \"getter\" :\n          parent.isSetProp()?\n          \"setter\" :\n          \"mutator\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSType jsType = objectType.getPropertyType(propertyName);\n    if (jsType!= null) {\n      return;\n    }\n  }\n  t.report(getprop, INVALID_PROP_OVERRIDE, propertyName,\n      parent.isGetProp()?\n          \"getter\" :\n          parent.isSetProp()?\n          \"setter\" :\n          \"mutator\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSType jsType = objectType.getPropertyType(propertyName);\n    if (jsType!= null) {\n      return;\n    }\n  }\n  t.report(getprop, INVALID_PROP_OVERRIDE, propertyName,\n      parent.isGetProp()?\n          \"getter\" :\n          parent.isSetProp()?\n          \"setter\" :\n          \"mutator\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSType jsType = objectType.getPropertyType(propertyName);\n    if (jsType!= null) {\n      return;\n    }\n  }\n  t.report(getprop, INVALID_PROP_OVERRIDE, propertyName,\n      parent.isGetProp()?\n          \"getter\" :\n          parent.isSetProp()?\n          \"setter\" :\n          \"mutator\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyr",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSType jsType = objectType.getPropertyType(propertyName);\n    if (jsType!= null) {\n      return;\n    }\n  }\n  t.report(getprop, INVALID_PROP_OVERRIDE, propertyName,\n      parent.isGetProp()?\n          \"getter\" :\n          parent.isSetProp()?\n          \"setter\" :\n          \"mutator\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.h",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSType jsType = objectType.getPropertyType(propertyName);\n    if (jsType!= null) {\n      return;\n    }\n  }\n  t.report(getprop, INVALID_PROP_OVERRIDE, propertyName,\n      parent.isGetProp()?\n          \"getter\" :\n          parent.isSetProp()?\n          \"setter\" :\n          \"mutator\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSType jsType = objectType.getPropertyType(propertyName);\n    if (jsType!= null) {\n      return;\n    }\n  }\n  t.report(getprop, INVALID_PROP_OVERRIDE, propertyName,\n      parent.isGetProp()?\n          \"getter\" :\n          parent.isSetProp()?\n          \"setter\" :\n          \"mutator\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOper",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSType jsType = objectType.getPropertyType(propertyName);\n    if (jsType!= null) {\n      return;\n    }\n  }\n  t.report(getprop, INVALID_PROP_OVERRIDE, propertyName,\n      parent.isGetProp()?\n          \"getter\" :\n          parent.isSetProp()?\n          \"setter\" :\n          \"mutator\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression"
      ],
      "function range": "407,3-500,3"
    },
    "Closure_82_/src/com/google/javascript/rhino/jstype/JSType.java_163-164": {
      "loc": "163-164",
      "input": "public final boolean isEmptyType() {",
      "output": [
        "public final boolean isEmptyType() {\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.",
        "public final boolean isEmptyType() {\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyr",
        "public final boolean isEmptyType() {\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.",
        "public final boolean isEmptyType() {\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.algebricks.core.",
        "public final boolean isEmptyType() {\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AggregateOperator;\nimport org.apache.hyracks.al",
        "public final boolean isEmptyType() {\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogical",
        "public final boolean isEmptyType() {\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;",
        "public final boolean isEmptyType() {\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public final boolean isEmptyType() {\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport org.apache.hyracks.algebricks.core.rewriter",
        "public final boolean isEmptyType() {\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.LeftOut"
      ],
      "function range": "162,3-164,3"
    },
    "Closure_83_/src/com/google/javascript/jscomp/CommandLineRunner.java_334-335": {
      "loc": "334-335",
      "input": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {",
      "output": [
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algeb",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.algebricks.core",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOper",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.h",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport org.apache.hyracks",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport org.apache.hyracks.algebricks.core.al",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AggregateOperator;\n",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.GroupByOperator;\n",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AggregateOperator;\nimport org.apache.hyracks.algebricks.core.algebra"
      ],
      "function range": "332,7-351,7"
    },
    "Closure_86_/src/com/google/javascript/jscomp/NodeUtil.java_2465-2466": {
      "loc": "2465-2466",
      "input": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:",
      "output": [
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.DELPROP:\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x =",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.DELPROP:\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g (x is now an local string)\n      //  ",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.DELPROP:\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force local values:\n      //  x = ''",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g (x is now an local string)\n      //  x -= g (x is now an local number)\n      if (NodeUtil.isAssignmentOp(value) && value.getFirstChild().isName()) {\n        return true;\n      }\n      return false;\n  }\n}\n\n\n/**\n * @return Whether the call has a local result.\n */",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.DELPROP:\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x++;",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g (x is now an local string)\n      //  x -= g (x is now an local number)\n      if (NodeUtil.isAssignmentOp(value)\n          || NodeUtil.isDecrement(value)\n          || NodeUtil.isIncrement(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g (x is now an local string)\n      //  x -= g (x is now an local number)\n      if (NodeUtil.isAssignmentOp(value)\n          || NodeUtil.isDecrement(value)\n          || NodeUtil.isIncrement(value)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      }",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.DELPROP:\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force special evaluation.\n      return false;\n  ",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g (x is now an local string)\n      //  x -= g (x is now an local number)\n      if (NodeUtil.isAssignmentOp(value) && NodeUtil.isAssignmentOpLast(value)) {\n        return true;\n      }\n      return false;\n  }\n}\n\n\n/**\n * @return Whether the call has a local result",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.DELPROP:\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force local values:\n      //  x++;\n"
      ],
      "function range": "2424,3-2489,3"
    },
    "Closure_92_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_789-790": {
      "loc": "789-790",
      "input": "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition != null && explicitNode != null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {",
      "output": [
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      lastNode.getParent().addChildAfter(replacementNode, lastNode);\n    }\n  }\n  if (explicitNode!= null) {\n    explicitNode.detachFromParent();\n  }\n  if (candidateDefinition!= null) {\n    candidateDefinition.detachFromParent();\n  }\n  if (firstNode!= null) {\n    firstNode.detachFromParent();\n  }\n  if (lastNode!= null) {\n    lastNode.detachFromParent();\n  }\n  compiler.reportCodeChange();\n}\n\n/**\n * Create the declaration node for this name, without inserting it\n * into the AST.\n */\nprivate Node",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      lastNode.getParent().addChildAfter(replacementNode, lastNode);\n    }\n  }\n  if (explicitNode!= null) {\n    explicitNode.detachFromParent();\n  }\n  if (candidateDefinition!= null) {\n    candidateDefinition.detachFromParent();\n  }\n  if (firstNode!= null) {\n    firstNode.detachFromParent();\n  }\n  if (lastNode!= null) {\n    lastNode.detachFromParent();\n  }\n  compiler.reportCodeChange();\n}\n\n/**\n * @return The first property in the objlit that matches the key.\n */\nprivate Node getFirstProp",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      lastNode.getParent().addChildAfter(replacementNode, lastNode);\n    }\n  }\n  if (explicitNode!= null) {\n    explicitNode.detachFromParent();\n  }\n  if (candidateDefinition!= null) {\n    candidateDefinition.detachFromParent();\n  }\n  compiler.reportCodeChange();\n}\n\n/**\n * Create the declaration node for this name, without inserting it\n * into the AST.\n */\nprivate Node createDeclarationNode() {\n  if (namespace.indexOf('.') == -1) {\n    return makeVarDeclNode(namespace, firstNode, lastNode);\n  } else {\n",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      lastNode.getParent().addChildAfter(replacementNode, lastNode);\n    }\n  }\n  if (explicitNode!= null) {\n    explicitNode.detachFromParent();\n  }\n  if (candidateDefinition!= null) {\n    candidateDefinition.detachFromParent();\n  }\n  compiler.reportCodeChange();\n}\n\n/**\n * Create the declaration node for this name, without inserting it\n * into the AST.\n */\nprivate Node createDeclarationNode() {\n  if (namespace.indexOf('.') == -1) {\n    return makeVarDeclNode();\n  } else {\n    return makeAssignmentExprNode();",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      lastNode.getParent().addChildAfter(replacementNode, lastNode);\n    }\n  }\n  if (explicitNode!= null) {\n    explicitNode.detachFromParent();\n  }\n  if (candidateDefinition!= null) {\n    candidateDefinition.detachFromParent();\n  }\n  if (firstNode!= null) {\n    firstNode.detachFromParent();\n  }\n  if (lastNode!= null) {\n    lastNode.detachFromParent();\n  }\n  compiler.reportCodeChange();\n}\n\n/**\n * Create the declaration node for this name, without inserting it\n * into the AST.\n */\nNode create",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      lastNode.getParent().addChildAfter(replacementNode, lastNode);\n    }\n  }\n  if (explicitNode!= null) {\n    explicitNode.detachFromParent();\n  }\n  if (candidateDefinition!= null) {\n    candidateDefinition.detachFromParent();\n  }\n  if (firstNode!= null) {\n    firstNode.detachFromParent();\n  }\n  if (lastNode!= null) {\n    lastNode.detachFromParent();\n  }\n  NodeUtil.markFunctionsDeleted(candidateDefinition, compiler);\n  compiler.reportCodeChange();\n  return replacementNode;\n}\n\n/**",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      lastNode.getParent().addChildAfter(replacementNode, lastNode);\n    }\n  }\n  if (explicitNode!= null) {\n    explicitNode.detachFromParent();\n  }\n  if (candidateDefinition!= null) {\n    candidateDefinition.detachFromParent();\n  }\n  if (firstNode!= null) {\n    firstNode.detachFromParent();\n  }\n  if (lastNode!= null) {\n    lastNode.detachFromParent();\n  }\n  compiler.reportCodeChange();\n}\n\n/**\n * Create the declaration node for this name, without inserting it\n * in the AST.\n */\nprivate Node",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      lastNode.getParent().addChildAfter(replacementNode, lastNode);\n    }\n  }\n  if (explicitNode!= null) {\n    explicitNode.detachFromParent();\n  }\n  if (candidateDefinition!= null) {\n    candidateDefinition.detachFromParent();\n  }\n  compiler.reportCodeChange();\n}\n\n/**\n * Create the declaration node for this name, without inserting it\n * into the AST.\n */\nprivate Node createDeclarationNode() {\n  if (namespace.indexOf('.') == -1) {\n    return makeVarDeclNode();\n  } else {\n    Node name = NodeUtil.new",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      lastNode.getParent().addChildAfter(replacementNode, lastNode);\n    }\n  }\n  if (explicitNode!= null) {\n    explicitNode.detachFromParent();\n  }\n  if (candidateDefinition!= null) {\n    candidateDefinition.detachFromParent();\n  }\n  if (firstNode!= null) {\n    firstNode.detachFromParent();\n  }\n  if (lastNode!= null) {\n    lastNode.detachFromParent();\n  }\n  NodeUtil.markFunctionsDeleted(candidateDefinition, compiler);\n  compiler.reportCodeChange();\n}\n\n/**\n * @return The first",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      lastNode.getParent().addChildAfter(replacementNode, lastNode);\n    }\n  }\n  if (explicitNode!= null) {\n    explicitNode.detachFromParent();\n  }\n  if (candidateDefinition!= null) {\n    candidateDefinition.detachFromParent();\n  }\n  if (firstNode!= null) {\n    firstNode.detachFromParent();\n  }\n  if (lastNode!= null) {\n    lastNode.detachFromParent();\n  }\n  compiler.reportCodeChange();\n}\n\n/**\n * @return The first property in the objlit that matches the key.\n */\nprivate Node getFirstMatch"
      ],
      "function range": "747,5-809,5"
    },
    "Closure_97_/src/com/google/javascript/jscomp/PeepholeFoldConstants.java_698-699": {
      "loc": "698-699",
      "input": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt != lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt != rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:",
      "output": [
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        return n;\n    }\n    Node newNumber = IR.number(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode tryFoldComparison(Node n, Node left, Node right) {\n  TernaryValue result = evaluateComparison(n.getType(), left, right);\n  if (result == TernaryValue.UNKNOWN) {\n    return n;\n  }\n  Node newNode = NodeUtil.booleanNode(result.toBoolean(true",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n            Token.name(n.getType()));\n    }\n    Node newNumber = IR.number(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode tryFoldComparison(Node n, Node left, Node right) {\n  TernaryValue result = evaluateComparison(n.getType(), left, right);\n  if (result == TernaryValue.UNKNOWN) {\n    return n;\n  ",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n            Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode tryFoldComparison(Node n, Node left, Node right) {\n  TernaryValue result = evaluateComparison(n.getType(), left, right);\n  if (result == TernaryValue.UNKNOWN) {\n    return n;\n",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        return n;\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode tryFoldComparison(Node n, Node left, Node right) {\n  TernaryValue result = evaluateComparison(n.getType(), left, right);\n  if (result == TernaryValue.UNKNOWN) {\n    return n;\n  }\n  Node newNode = Node.newNode(result.toBoolean(true)?",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \"\n            + Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode tryFoldComparison(Node n, Node left, Node right) {\n  TernaryValue result = evaluateComparison(n.getType(), left, right);\n  if (result == TernaryValue.UNKNOWN) {\n    return n;\n",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator \" +\n            Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode tryFoldComparison(Node n, Node left, Node right) {\n  TernaryValue result = evaluateComparison(n.getType(), left, right);\n  if (result == TernaryValue.UNKNOWN) {\n    return n;\n  ",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        return n;\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode tryFoldComparison(Node n, Node left, Node right) {\n  TernaryValue result = evaluateComparison(n.getType(), left, right);\n  if (result == TernaryValue.UNKNOWN) {\n    return n;\n  }\n  Node newNode = Node.newBoolean(result.toBoolean(true));",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        return n;\n    }\n    Node newNumber = IR.number(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode tryFoldComparison(Node n, Node left, Node right) {\n  TernaryValue result = evaluateComparison(n.getType(), left, right);\n  if (result == TernaryValue.UNKNOWN) {\n    return n;\n  }\n  Node newNode = NodeUtil.booleanNode(result.toBoolean(n",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        return n;\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode tryFoldComparison(Node n, Node left, Node right) {\n  TernaryValue result = evaluateComparison(n.getType(), left, right);\n  if (result == TernaryValue.UNKNOWN) {\n    return n;\n  }\n  Node newNode = Node.newNode(result.toBoolean(n.get",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        return n;\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode tryFoldComparison(Node n, Node left, Node right) {\n  TernaryValue result = evaluateComparison(n.getType(), left, right);\n  if (result == TernaryValue.UNKNOWN) {\n    return n;\n  }\n  Node newNode = NodeUtil.booleanNode(result.toBoolean("
      ],
      "function range": "652,3-713,3"
    },
    "Closure_104_/src/com/google/javascript/rhino/jstype/UnionType.java_291-292": {
      "loc": "291-292",
      "input": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();",
      "output": [
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic BooleanLiteralSet getPossibleToBooleanOutcomes() {\n  BooleanLiteralSet literals = BooleanLiteralSet.EMPTY;\n  for (JSType alternate : alternates) {\n    literals = literals.union(alternate.getPossibleToBooleanOutcomes());\n  }\n  return literals;\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseUnionType(this",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (!otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic BooleanLiteralSet getPossibleToBooleanOutcomes() {\n  BooleanLiteralSet literals = BooleanLiteralSet.EMPTY;\n  for (JSType alternate : alternates) {\n    literals = literals.union(alternate.getPossibleToBooleanOutcomes());\n  }\n  return literals;\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseUnionType(this",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic BooleanLiteralSet getPossibleToBooleanOutcomes() {\n  BooleanLiteralSet literals = BooleanLiteralSet.EMPTY;\n  for (JSType alt : alternates) {\n    literals = literals.union(alt.getPossibleToBooleanOutcomes());\n  }\n  return literals;\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseUnionType(this);",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic BooleanLiteralSet getPossibleToBooleanOutcomes() {\n  BooleanLiteralSet literals = BooleanLiteralSet.EMPTY;\n  for (int i = 0; i < alternates.size(); i++) {\n    JSType alt = alternates.get(i);\n    literals = literals.union(alt.getPossibleToBooleanOutcomes());\n  }\n  return literals;\n}\n\n@Override\npublic <T> T visit",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic BooleanLiteralSet getPossibleToBooleanOutcomes() {\n  BooleanLiteralSet literals = BooleanLiteralSet.EMPTY;\n  for (int i = 0; i < alternates.size(); i++) {\n    literals = literals.union(alternates.get(i).getPossibleToBooleanOutcomes());\n  }\n  return literals;\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic BooleanLiteralSet getPossibleToBooleanOutcomes() {\n  return BooleanLiteralSet.TRUE;\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseUnionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseUnionType(this, that);\n}\n\n@Override\nJSType resolve",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic BooleanLiteralSet getPossibleToBooleanOutcomes() {\n  BooleanLiteralSet literals = BooleanLiteralSet.EMPTY;\n  for (int i = 0; i < alternates.size(); i++) {\n    JSType alt = alternates.get(i);\n    literals = literals.union(alt.getPossibleToBooleanOutcomes());\n  }\n  return literals;\n}\n\n@Override\npublic int hashCode() {",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic BooleanLiteralSet getPossibleToBooleanOutcomes() {\n  BooleanLiteralSet literals = BooleanLiteralSet.EMPTY;\n  for (JSType alternate : alternates) {\n    literals = literals.union(alternate.getPossibleToBooleanOutcomes());\n  }\n  return literals;\n}\n\n@Override\npublic int hashCode() {\n  return this.hashcode;\n}\n\n@Override\npublic boolean isSub",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseUnionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseUnionType(this, that);\n}\n\n@Override\nJSType resolveInternal(ErrorReporter t, StaticTypedScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n\n  UnionTypeBuilder builder",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n@Override\npublic BooleanLiteralSet getPossibleToBooleanOutcomes() {\n  return BooleanLiteralSet.TRUE;\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseUnionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseUnionType(this, that);\n}\n\n/**\n * @return true if"
      ],
      "function range": "273,3-298,3"
    },
    "Closure_109_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_1908-1909": {
      "loc": "1908-1909",
      "input": "private Node parseContextTypeExpression(JsDocToken token) {",
      "output": [
        "private Node parseContextTypeExpression(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LEFT_CURLY);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parse(next());\n\n    int endLineno = stream.getLineno();\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeExpression(typeNode, lineno, startCharno,\n        endLineno, endCharno);\n    return typeNode;\n  }\n\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token) {\n    switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case RIGHT_ANGLE:\n        return \">\";\n\n      case LEFT_SQUARE:\n        return \"[\";\n\n      case LEFT_CURLY:\n        return \"{\";\n\n      case LEFT_PAREN:\n        return \"(\";\n\n      case LEFT_ANGLE:\n        return \"<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RIGHT_SQUARE:\n        return \"]\";\n\n      case RIGHT_CURLY:\n        return \"}\";\n\n      case RIGHT_PAREN:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }\n  }\n\n  /**\n   * Constructs a new {@code JSTypeExpression}.\n   * @param n A node. May be null.\n   */\n  private JSTypeExpression createJSTypeExpression(Node n) {",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LEFT_CURLY);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parse(next());\n\n    int endLineno = stream.getLineno();\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeExpression(typeNode, lineno, startCharno,\n        endLineno, endCharno);\n    return typeNode;\n  }\n\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token) {\n    switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case RIGHT_ANGLE:\n        return \">\";\n\n      case LEFT_SQUARE:\n        return \"[\";\n\n      case LEFT_CURLY:\n        return \"{\";\n\n      case LEFT_PAREN:\n        return \"(\";\n\n      case LEFT_ANGLE:\n        return \"<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RIGHT_SQUARE:\n        return \"]\";\n\n      case RIGHT_CURLY:\n        return \"}\";\n\n      case RIGHT_PAREN:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalArgumentException(token.toString());\n    }\n  }\n\n  /**\n   * Constructs a new {@code JSTypeExpression}.\n   * @param n A node. May be null.\n   */\n  private JSTypeExpression createJSTypeExpression(Node n)",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LEFT_CURLY);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parse(next());\n\n    int endLineno = stream.getLineno();\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeExpression(typeNode, lineno, startCharno,\n        endLineno, endCharno);\n    return typeNode;\n  }\n\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token) {\n    switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case RIGHT_ANGLE:\n        return \"<>\";\n\n      case LEFT_SQUARE:\n        return \"[\";\n\n      case LEFT_CURLY:\n        return \"{\";\n\n      case LEFT_PAREN:\n        return \"(\";\n\n      case LEFT_ANGLE:\n        return \"<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RIGHT_SQUARE:\n        return \"]\";\n\n      case RIGHT_CURLY:\n        return \"}\";\n\n      case RIGHT_PAREN:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }\n  }\n\n  /**\n   * Constructs a new {@code JSTypeExpression}.\n   * @param n A node. May be null.\n   */\n  private JSTypeExpression createJSTypeExpression(Node n) {",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LEFT_CURLY);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parse(next());\n\n    int endLineno = stream.getLineno();\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeExpression(typeNode, lineno, startCharno,\n        endLineno, endCharno);\n    return typeNode;\n  }\n\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken t) {\n    switch (t) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case RIGHT_ANGLE:\n        return \">\";\n\n      case LEFT_SQUARE:\n        return \"[\";\n\n      case LEFT_CURLY:\n        return \"{\";\n\n      case LEFT_PAREN:\n        return \"(\";\n\n      case LEFT_ANGLE:\n        return \"<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RIGHT_SQUARE:\n        return \"]\";\n\n      case RIGHT_CURLY:\n        return \"}\";\n\n      case RIGHT_PAREN:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(t.toString());\n    }\n  }\n\n  /**\n   * Constructs a new {@code JSTypeExpression}.\n   * @param n A node. May be null.\n   */\n  private JSTypeExpression createJSTypeExpression(Node n) {",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LEFT_CURLY);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parse(next());\n\n    int endLineno = stream.getLineno();\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeExpression(typeNode, lineno, startCharno,\n        endLineno, endCharno);\n    return typeNode;\n  }\n\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token) {\n    switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case RIGHT_ANGLE:\n        return \">\";\n\n      case LEFT_SQUARE:\n        return \"[\";\n\n      case LEFT_CURLY:\n        return \"{\";\n\n      case LEFT_PAREN:\n        return \"(\";\n\n      case LEFT_ANGLE:\n        return \"<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RIGHT_SQUARE:\n        return \"]\";\n\n      case RIGHT_CURLY:\n        return \"}\";\n\n      case RIGHT_PAREN:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }\n  }\n\n  /**\n   * Constructs a new {@code JSTypeExpression}.\n   * @param n A node. May be null.\n   */\n  JSTypeExpression createJSTypeExpression(Node n) {\n",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LEFT_CURLY);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parse(next());\n\n    int endLineno = stream.getLineno();\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeExpression(typeNode, lineno, startCharno,\n        endLineno, endCharno);\n    return typeNode;\n  }\n\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token) {\n    switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case RIGHT_ANGLE:\n        return \">\";\n\n      case LEFT_ANGLE:\n        return \"<\";\n\n      case LEFT_CURLY:\n        return \"{\";\n\n      case LEFT_PAREN:\n        return \"(\";\n\n      case LEFT_SQUARE:\n        return \"[\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RIGHT_ANGLE:\n        return \">\";\n\n      case RIGHT_CURLY:\n        return \"}\";\n\n      case RIGHT_PAREN:\n        return \")\";\n\n      case RIGHT_SQUARE:\n        return \"]\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }\n  }\n\n  /**\n   * Constructs a new {@code JSTypeExpression}.\n   * @param n A node. May be null.\n   */\n  private JST",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LEFT_CURLY);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parse(next());\n\n    int endLineno = stream.getLineno();\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeExpression(typeNode, lineno, startCharno,\n        endLineno, endCharno);\n    return typeNode;\n  }\n\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token) {\n    switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case RIGHT_ANGLE:\n        return \">\";\n\n      case LEFT_ANGLE:\n        return \"<\";\n\n      case LEFT_CURLY:\n        return \"{\";\n\n      case LEFT_PAREN:\n        return \"(\";\n\n      case LEFT_SQUARE:\n        return \"[\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RIGHT_ANGLE:\n        return \">\";\n\n      case RIGHT_CURLY:\n        return \"}\";\n\n      case RIGHT_PAREN:\n        return \")\";\n\n      case RIGHT_SQUARE:\n        return \"]\";\n\n      case SLASH:\n        return \"/\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }\n  }\n\n  /**\n   * Constructs a new {@code JSTypeExpression}.\n   * @param n A node. May",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LEFT_CURLY);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parse(next());\n\n    int endLineno = stream.getLineno();\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeExpression(typeNode, lineno, startCharno,\n        endLineno, endCharno);\n    return typeNode;\n  }\n\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token) {\n    switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case RIGHT_ANGLE:\n        return \">\";\n\n      case LEFT_SQUARE:\n        return \"[\";\n\n      case LEFT_CURLY:\n        return \"{\";\n\n      case LEFT_PAREN:\n        return \"(\";\n\n      case LEFT_ANGLE:\n        return \"<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RIGHT_SQUARE:\n        return \"]\";\n\n      case RIGHT_CURLY:\n        return \"}\";\n\n      case RIGHT_PAREN:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalArgumentException(token.toString());\n    }\n  }\n\n  /**\n   * Constructs a new {@code JSTypeExpression}.\n   * @param n A node. May be null.\n   */\n  JSTypeExpression createJSTypeExpression(Node n) {",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LEFT_CURLY);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parse(next());\n\n    int endLineno = stream.getLineno();\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeExpression(typeNode, lineno, startCharno,\n        endLineno, endCharno);\n    return typeNode;\n  }\n\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token) {\n    switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case RIGHT_ANGLE:\n        return \">\";\n\n      case LEFT_ANGLE:\n        return \"<\";\n\n      case LEFT_CURLY:\n        return \"{\";\n\n      case LEFT_PAREN:\n        return \"(\";\n\n      case LEFT_SQUARE:\n        return \"[\";\n\n      case MINUS:\n        return \"-\";\n\n      case PERCENT:\n        return \"%\";\n\n      case PLUS:\n        return \"+\";\n\n      case RIGHT_ANGLE:\n        return \">\";\n\n      case RIGHT_CURLY:\n        return \"}\";\n\n      case RIGHT_PAREN:\n        return \")\";\n\n      case RIGHT_SQUARE:\n        return \"]\";\n\n      case SLASH:\n        return \"/\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }\n  }\n\n  /**\n   * Constructs a new {@code JSTypeExpression}.\n   * @",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LEFT_CURLY);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parse(next());\n\n    int endLineno = stream.getLineno();\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeExpression(typeNode, lineno, startCharno,\n        endLineno, endCharno);\n    return typeNode;\n  }\n\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token) {\n    switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case RIGHT_ANGLE:\n        return \">\";\n\n      case LEFT_ANGLE:\n        return \"<\";\n\n      case LEFT_CURLY:\n        return \"{\";\n\n      case LEFT_PAREN:\n        return \"(\";\n\n      case LEFT_SQUARE:\n        return \"[\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RIGHT_ANGLE:\n        return \">\";\n\n      case RIGHT_CURLY:\n        return \"}\";\n\n      case RIGHT_PAREN:\n        return \")\";\n\n      case RIGHT_SQUARE:\n        return \"]\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }\n  }\n\n  /**\n   * Constructs a new {@code JSTypeExpression}.\n   * @param n A node. May be null.\n   */\n  JSType"
      ],
      "function range": "1907,3-1909,3"
    },
    "Closure_111_/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java_54-55": {
      "loc": "54-55",
      "input": "@Override\nprotected JSType caseTopType(JSType topType) {",
      "output": [
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  protected JSType caseUnknownType() {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoObjectType() {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoType() {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n\n  @Override\n  protected JSType caseBooleanType() {\n    return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNullType() {\n    return getNativeType(JSTypeNative.NULL_TYPE);\n  }\n\n  @Override\n  protected JSType caseNumberType() {\n    return getNativeType(JSTypeNative.NUMBER_TYPE);\n  }\n\n  @Override\n  protected JSType caseStringType() {\n    return getNativeType(JSTypeNative.STRING_TYPE);\n  }\n\n  @Override\n  protected JSType caseVoidType() {\n    return getNativeType(JSTypeNative.VOID_TYPE);\n  }\n\n  @Override\n  protected JSType caseSymbolType() {\n    return getNativeType(JSTypeNative.SYMBOL_TYPE);\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseUnresolvedNamedType(UnresolvedNamedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  protected JSType caseUnknownType() {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoObjectType() {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoType() {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n\n  @Override\n  protected JSType caseBooleanType() {\n    return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNullType() {\n    return getNativeType(JSTypeNative.NULL_TYPE);\n  }\n\n  @Override\n  protected JSType caseNumberType() {\n    return getNativeType(JSTypeNative.NUMBER_TYPE);\n  }\n\n  @Override\n  protected JSType caseStringType() {\n    return getNativeType(JSTypeNative.STRING_TYPE);\n  }\n\n  @Override\n  protected JSType caseVoidType() {\n    return getNativeType(JSTypeNative.VOID_TYPE);\n  }\n\n  @Override\n  protected JSType caseSymbolType() {\n    return getNativeType(JSTypeNative.SYMBOL_TYPE);\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseObjectType(ObjectType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseUnionType(UnionType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType type)",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  protected JSType caseUnknownType() {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoObjectType() {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoType() {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n\n  @Override\n  protected JSType caseBooleanType() {\n    return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNullType() {\n    return getNativeType(JSTypeNative.NULL_TYPE);\n  }\n\n  @Override\n  protected JSType caseNumberType() {\n    return getNativeType(JSTypeNative.NUMBER_TYPE);\n  }\n\n  @Override\n  protected JSType caseStringType() {\n    return getNativeType(JSTypeNative.STRING_TYPE);\n  }\n\n  @Override\n  protected JSType caseVoidType() {\n    return getNativeType(JSTypeNative.VOID_TYPE);\n  }\n\n  @Override\n  protected JSType caseSymbolType() {\n    return getNativeType(JSTypeNative.SYMBOL_TYPE);\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(Proxy",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  protected JSType caseUnknownType() {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoObjectType() {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoType() {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n\n  @Override\n  protected JSType caseBooleanType() {\n    return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNullType() {\n    return getNativeType(JSTypeNative.NULL_TYPE);\n  }\n\n  @Override\n  protected JSType caseNumberType() {\n    return getNativeType(JSTypeNative.NUMBER_TYPE);\n  }\n\n  @Override\n  protected JSType caseStringType() {\n    return getNativeType(JSTypeNative.STRING_TYPE);\n  }\n\n  @Override\n  protected JSType caseVoidType() {\n    return getNativeType(JSTypeNative.VOID_TYPE);\n  }\n\n  @Override\n  protected JSType caseSymbolType() {\n    return getNativeType(JSTypeNative.SYMBOL_TYPE);\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseUnresolvedNamedType() {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }\n\n  @Override\n  ",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  protected JSType caseUnknownType() {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoObjectType() {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoType() {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n\n  @Override\n  protected JSType caseBooleanType() {\n    return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNullType() {\n    return getNativeType(JSTypeNative.NULL_TYPE);\n  }\n\n  @Override\n  protected JSType caseNumberType() {\n    return getNativeType(JSTypeNative.NUMBER_TYPE);\n  }\n\n  @Override\n  protected JSType caseStringType() {\n    return getNativeType(JSTypeNative.STRING_TYPE);\n  }\n\n  @Override\n  protected JSType caseVoidType() {\n    return getNativeType(JSTypeNative.VOID_TYPE);\n  }\n\n  @Override\n  protected JSType caseSymbolType() {\n    return getNativeType(JSTypeNative.SYMBOL_TYPE);\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseUnknown(JSType",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  protected JSType caseUnknownType() {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoObjectType() {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoType() {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n\n  @Override\n  protected JSType caseBooleanType() {\n    return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNullType() {\n    return getNativeType(JSTypeNative.NULL_TYPE);\n  }\n\n  @Override\n  protected JSType caseNumberType() {\n    return getNativeType(JSTypeNative.NUMBER_TYPE);\n  }\n\n  @Override\n  protected JSType caseStringType() {\n    return getNativeType(JSTypeNative.STRING_TYPE);\n  }\n\n  @Override\n  protected JSType caseVoidType() {\n    return getNativeType(JSTypeNative.VOID_TYPE);\n  }\n\n  @Override\n  protected JSType caseSymbolType() {\n    return getNativeType(JSTypeNative.SYMBOL_TYPE);\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseEnumElementType(EnumElementType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseUnionType(",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  protected JSType caseUnknownType() {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoObjectType() {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoType() {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n\n  @Override\n  protected JSType caseBooleanType() {\n    return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNullType() {\n    return getNativeType(JSTypeNative.NULL_TYPE);\n  }\n\n  @Override\n  protected JSType caseNumberType() {\n    return getNativeType(JSTypeNative.NUMBER_TYPE);\n  }\n\n  @Override\n  protected JSType caseStringType() {\n    return getNativeType(JSTypeNative.STRING_TYPE);\n  }\n\n  @Override\n  protected JSType caseVoidType() {\n    return getNativeType(JSTypeNative.VOID_TYPE);\n  }\n\n  @Override\n  protected JSType caseSymbolType() {\n    return getNativeType(JSTypeNative.SYMBOL_TYPE);\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseEnumElementType(EnumElementType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseObjectType(",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  protected JSType caseUnknownType() {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoObjectType() {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoType() {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n\n  @Override\n  protected JSType caseBooleanType() {\n    return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNullType() {\n    return getNativeType(JSTypeNative.NULL_TYPE);\n  }\n\n  @Override\n  protected JSType caseNumberType() {\n    return getNativeType(JSTypeNative.NUMBER_TYPE);\n  }\n\n  @Override\n  protected JSType caseStringType() {\n    return getNativeType(JSTypeNative.STRING_TYPE);\n  }\n\n  @Override\n  protected JSType caseVoidType() {\n    return getNativeType(JSTypeNative.VOID_TYPE);\n  }\n\n  @Override\n  protected JSType caseSymbolType() {\n    return getNativeType(JSTypeNative.SYMBOL_TYPE);\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseObjectType(ObjectType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseUnresolvedNamedType()",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  protected JSType caseUnknownType() {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoObjectType() {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoType() {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n\n  @Override\n  protected JSType caseBooleanType() {\n    return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNullType() {\n    return getNativeType(JSTypeNative.NULL_TYPE);\n  }\n\n  @Override\n  protected JSType caseNumberType() {\n    return getNativeType(JSTypeNative.NUMBER_TYPE);\n  }\n\n  @Override\n  protected JSType caseStringType() {\n    return getNativeType(JSTypeNative.STRING_TYPE);\n  }\n\n  @Override\n  protected JSType caseVoidType() {\n    return getNativeType(JSTypeNative.VOID_TYPE);\n  }\n\n  @Override\n  protected JSType caseSymbolType() {\n    return getNativeType(JSTypeNative.SYMBOL_TYPE);\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseObjectType(ObjectType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseUnresolvedNamedType(",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  protected JSType caseUnknownType() {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoObjectType() {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n\n  @Override\n  protected JSType caseNoType() {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n\n  @Override\n  protected JSType caseBooleanType() {\n    return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n  }\n\n  @Override\n  protected JSType caseNullType() {\n    return getNativeType(JSTypeNative.NULL_TYPE);\n  }\n\n  @Override\n  protected JSType caseNumberType() {\n    return getNativeType(JSTypeNative.NUMBER_TYPE);\n  }\n\n  @Override\n  protected JSType caseStringType() {\n    return getNativeType(JSTypeNative.STRING_TYPE);\n  }\n\n  @Override\n  protected JSType caseVoidType() {\n    return getNativeType(JSTypeNative.VOID_TYPE);\n  }\n\n  @Override\n  protected JSType caseSymbolType() {\n    return getNativeType(JSTypeNative.SYMBOL_TYPE);\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseUnresolvedNamedType() {\n    return null;\n  }\n\n  @Override\n  protected JSType caseObjectType(ObjectType type)"
      ],
      "function range": "52,9-55,9"
    },
    "Closure_113_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_329-330": {
      "loc": "329-330",
      "input": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null || !provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph != null &&\n          module != providedModule &&\n          !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);",
      "output": [
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  }\n}\n\n  /**\n   * Verify that the last argument to a goog.require() is a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (!verifyArgument(t, arg)) {\n      return false;\n    }\n\n    Node lastArg = arg;\n    while (arg.getNext()!= null) {\n      arg = arg.getNext();\n    }\n\n    String lastArgStringValue = null;\n    if (arg.isString()) {\n      lastArgStringValue = arg.getString();\n    } else if (arg.isGetProp()) {\n      Node child = arg.getFirstChild();\n      if (child.isString()) {\n        lastArgStringValue = child.getString();\n      }\n    }\n\n    if (lastArgStringValue == null) {\n      compiler.report(\n          t.makeError(n, REQUIRE_NOT_LAST_AR",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  }\n}\n\n  /**\n   * Verify that the last argument to a goog.require() is a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (!verifyArgument(t, arg)) {\n      return false;\n    }\n\n    Node lastArg = arg;\n    while (arg.getNext()!= null) {\n      arg = arg.getNext();\n    }\n\n    String lastArgStringValue = null;\n    if (arg.isString()) {\n      lastArgStringValue = arg.getString();\n    } else if (arg.isNumber()) {\n      lastArgStringValue = arg.getString();\n    }\n\n    if (lastArgStringValue == null) {\n      compiler.report(\n          t.makeError(n, INVALID_MODULE_IDENTIFIER_ERROR,\n              lastArgStringValue));\n      return false;\n    }\n    return true;\n",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  }\n}\n\n  /**\n   * Verify that the last argument to a goog.require() is a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (!verifyArgument(t, arg)) {\n      return false;\n    }\n\n    Node lastArg = arg;\n    while (arg.getNext()!= null) {\n      arg = arg.getNext();\n    }\n\n    String lastArgStringValue = null;\n    if (arg.isString()) {\n      lastArgStringValue = arg.getString();\n    } else if (arg.isNumber()) {\n      lastArgStringValue = arg.getString();\n    }\n\n    if (lastArgStringValue == null) {\n      compiler.report(\n          t.makeError(n, INVALID_MODULE_ARGUMENT_ERROR,\n              lastArgStringValue));\n      return false;\n    }\n    return true;",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  }\n}\n\n  /**\n   * Verify that the last argument to a goog.require() is a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (!verifyArgument(t, arg)) {\n      return false;\n    }\n\n    Node lastArg = arg;\n    while (arg.getNext()!= null) {\n      arg = arg.getNext();\n    }\n\n    String lastArgStringValue = null;\n    if (arg.isString()) {\n      lastArgStringValue = arg.getString();\n    } else if (arg.isNumber()) {\n      lastArgStringValue = arg.getDouble() + \"\";\n    }\n\n    if (lastArgStringValue == null) {\n      compiler.report(\n          t.makeError(n, INVALID_MODULE_ARGUMENT_ERROR,\n              lastArgStringValue));\n      return false;\n    }\n    ",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  }\n}\n\n  /**\n   * Verify that the last argument to a goog.require() is a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (!verifyArgument(t, arg)) {\n      return false;\n    }\n\n    Node lastArg = arg;\n    while (arg.getNext()!= null) {\n      arg = arg.getNext();\n    }\n\n    String lastArgStringValue = null;\n    if (arg.isString()) {\n      lastArgStringValue = arg.getString();\n    } else if (arg.isGetProp()) {\n      Node child = arg.getFirstChild();\n      if (child.isString()) {\n        lastArgStringValue = child.getString();\n      }\n    }\n\n    if (lastArgStringValue == null) {\n      compiler.report(\n          t.makeError(n, INVALID_MODULE_IDENTIF",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  }\n}\n\n  /**\n   * Verify that the last argument to a goog.require() is a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (!verifyArgument(t, arg)) {\n      return false;\n    }\n\n    Node lastArg = arg;\n    while (arg.getNext()!= null) {\n      arg = arg.getNext();\n    }\n\n    String lastArgStringValue = null;\n    if (arg.isString()) {\n      lastArgStringValue = arg.getString();\n    } else if (arg.isGetProp()) {\n      Node child = arg.getFirstChild();\n      if (child.isString()) {\n        lastArgStringValue = child.getString();\n      }\n    }\n\n    if (lastArgStringValue == null) {\n      compiler.report(\n          t.makeError(n, EXPECTED_MODULE_ARG",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  }\n}\n\n  /**\n   * Verify that the last argument to a goog.require() is a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (!verifyArgument(t, arg)) {\n      return false;\n    }\n\n    Node lastArg = arg;\n    while (arg.getNext()!= null) {\n      arg = arg.getNext();\n    }\n\n    String lastArgStringValue = null;\n    if (arg.isString()) {\n      lastArgStringValue = arg.getString();\n    } else if (arg.isGetProp()) {\n      Node child = arg.getFirstChild();\n      if (child.isString()) {\n        lastArgStringValue = child.getString();\n      }\n    }\n\n    if (lastArgStringValue == null) {\n      compiler.report(\n          t.makeError(n, INVALID_MODULE_ARG",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  }\n}\n\n  /**\n   * Verify that the last argument to a goog.require() is a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (!verifyArgument(t, arg)) {\n      return false;\n    }\n\n    Node lastArg = arg;\n    while (arg.getNext()!= null) {\n      arg = arg.getNext();\n    }\n\n    String lastArgStringValue = null;\n    if (arg.isString()) {\n      lastArgStringValue = arg.getString();\n    } else if (arg.isNumber()) {\n      lastArgStringValue = arg.getString();\n    }\n\n    if (lastArgStringValue == null) {\n      compiler.report(\n          t.makeError(n, INVALID_MODULE_ARGUMENT,\n              lastArgStringValue == null? \"null\" : lastArgStringValue));\n      return false",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  }\n}\n\n  /**\n   * Verify that the last argument to a goog.require() is a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (!verifyArgument(t, arg)) {\n      return false;\n    }\n\n    Node lastArg = arg;\n    while (arg.getNext()!= null) {\n      arg = arg.getNext();\n    }\n\n    String lastArgStringValue = null;\n    if (arg.isString()) {\n      lastArgStringValue = arg.getString();\n    } else if (arg.isGetProp()) {\n      Node child = arg.getFirstChild();\n      if (child.isString()) {\n        lastArgStringValue = child.getString();\n      }\n    }\n\n    if (lastArgStringValue == null) {\n      compiler.report(\n          t.makeError(n, INVALID_MODULE_NAME_",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  }\n}\n\n  /**\n   * Verify that the last argument to a goog.require() is a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (!verifyArgument(t, arg)) {\n      return false;\n    }\n\n    Node lastArg = arg;\n    while (arg.getNext()!= null) {\n      arg = arg.getNext();\n    }\n\n    String lastArgStringValue = null;\n    if (arg.isString()) {\n      lastArgStringValue = arg.getString();\n    } else if (arg.isNumber()) {\n      lastArgStringValue = arg.getString();\n    }\n\n    if (lastArgStringValue == null) {\n      compiler.report(\n          t.makeError(n, INVALID_MODULE_IDENTIFIER_ERROR,\n              lastArgStringValue));\n      return false;\n    } else {\n      return true"
      ],
      "function range": "295,3-334,3"
    },
    "Closure_114_/src/com/google/javascript/jscomp/NameAnalyzer.java_578-579": {
      "loc": "578-579",
      "input": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns != null) {\n    if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext() != n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }",
      "output": [
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isFunction()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isComputedProp()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild()!= n) {\n      recordDepScope(recordNode, ns);\n    } else if (NodeUtil.isCall(parent) && parent.getFirstChild()!= n) {\n      recordDep",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isFunction()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() || parent.isGetElem()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isComputedProp()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isCall() && parent.getFirstChild()!= n) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isDelProp()) {\n      recordDepScope(recordNode, ns);\n    } else",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isFunction()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() || parent.isGetElem()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isComputedProp()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isCall() && parent.getFirstChild()!= n) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isDelProp()) {\n      recordDepScope(recordNode, ns);\n    }\n",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isFunction()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() || parent.isGetElem()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isComputedProp()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isCall() && parent.getFirstChild()!= n) {\n      recordDepScope(recordNode, ns);\n    } else if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild()!= n) {",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isFunction()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() || parent.isGetElem()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isComputedProp()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isCall() || parent.isNew()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isDelProp()) {\n      recordDepScope(recordNode, ns);\n    }\n  }\n}",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isFunction()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() || parent.isGetElem()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isComputedProp()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isCall() || parent.isNew()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isDelProp()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isFunction()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() || parent.isGetElem()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isComputedProp()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isCall() && parent.getFirstChild()!= n) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isBlock()) {\n      recordDepScope(recordNode, ns);\n    } else if",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isFunction()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isComputedProp()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild()!= n) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isCatch()) {\n      recordDepScope(recordNode, ns);\n    } else if (",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isFunction()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() || parent.isGetElem()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isCatch()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isBlock()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isScript() || parent.isModuleBody()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.is",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isFunction()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() || parent.isGetElem()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isComputedProp()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isCall() || parent.isNew()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isDelProp()) {\n      recordDepScope(recordNode, ns);\n    } else if (NodeUt"
      ],
      "function range": "558,5-588,5"
    },
    "Closure_118_/src/com/google/javascript/jscomp/DisambiguateProperties.java_495-496": {
      "loc": "495-496",
      "input": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child != null;\n      child = child.getNext()) {",
      "output": [
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isVoid()) {\n      handleVoid(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isGoto()) {\n      handleGoto(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.isWith()) {\n      handleWith(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isCase()) {\n      handleCase(t, child);\n    } else if (child.isDefault",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isVoid()) {\n      handleVoid(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isGoto()) {\n      handleGoto(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.isWith()) {\n      handleWith(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isTry",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isVar()) {\n      handleVar(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isForIn()) {\n      handleForIn(t, child);\n    } else if (child.isForOf()) {\n      handleForOf(t, child);\n    } else if (child.isDebugger()) {\n      handleDebugger(t, child);\n    } else if (child.",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isVar()) {\n      handleVar(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isForIn()) {\n      handleForIn(t, child);\n    } else if (child.isDebugger()) {\n      handleDebugger(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.isWith",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isForIn()) {\n      handleForIn(t, child);\n    } else if (child.isForOf()) {\n      handleForOf(t, child);\n    } else if (child.isDebugger()) {\n      handleDebugger(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isGoto()) {\n      handleGoto(t, child);\n    } else if (child.isVar()) {\n      handleVar(t, child);\n    } else if (child.isFunction()) {\n      handleFunction(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.isWith()) {",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isVar()) {\n      handleVar(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isForIn()) {\n      handleForIn(t, child);\n    } else if (child.isDebugger()) {\n      handleDebugger(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.isWith",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isForIn()) {\n      handleForIn(t, child);\n    } else if (child.isDebugger()) {\n      handleDebugger(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.isWith()) {\n      handleWith(t, child);\n    } else if (child.isV",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isVar()) {\n      handleVar(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isForIn()) {\n      handleForIn(t, child);\n    } else if (child.isForOf()) {\n      handleForOf(t, child);\n    } else if (child.isDebugger()) {\n      handleDebugger(t, child);\n    } else {\n      handle",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isVoid()) {\n      handleVoid(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isGoto()) {\n      handleGoto(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.isWith()) {\n      handleWith(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isCase"
      ],
      "function range": "490,5-513,5"
    },
    "Closure_120_/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java_431-432": {
      "loc": "431-432",
      "input": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block != null; block = block.getParent()) {\n    if (block.isFunction) {",
      "output": [
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n/**\n * Gets the one and only assignment.\n *\n * @return the one and only assignment, or {@code null} if there are none\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAndOnly();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one and only reference.\n *\n * @return the one and only reference, or {@code null} if there are none\n */\npublic Reference getOneAndOnly() {\n  Reference ref = getOne();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one reference.\n *\n * @return the one reference, or {@code null} if there are none\n */\npublic Reference getOne() {\n  Reference ref = getFirst();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the first reference.\n *\n * @return the first reference, or {@code null} if there are none\n */\npublic Reference getFirst() {",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n/**\n * Gets the one and only assignment.\n *\n * @return the one and only assignment, or {@code null} if there are none\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAndOnly();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one and only reference.\n *\n * @return the one and only reference, or {@code null} if there are none\n */\npublic Reference getOneAndOnly() {\n  Reference ref = getOne();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one reference.\n *\n * @return the one reference, or {@code null} if there are none\n */\npublic Reference getOne() {\n  Reference ref = getFirst();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the last reference.\n *\n * @return the last reference, or {@code null} if there are none\n */\npublic Reference getLast() {",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n/**\n * Gets the one and only assignment.\n *\n * @return the one and only assignment, or {@code null} if there are none\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAndOnly();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one and only reference.\n *\n * @return the one and only reference, or {@code null} if there are none\n */\npublic Reference getOneAndOnly() {\n  Reference ref = getOne();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one reference.\n *\n * @return the one reference, or {@code null} if there are none\n */\npublic Reference getOne() {\n  Reference ref = getFirst();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n/**\n * Gets the one and only assignment.\n *\n * @return the one and only assignment, or {@code null} if there are none\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAndOnly();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one and only reference.\n *\n * @return the one and only reference, or {@code null} if there are none\n */\npublic Reference getOneAndOnly() {\n  Reference ref = getOne();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one reference.\n *\n * @return the one reference, or {@code null} if there are none\n */\npublic Reference getOne() {\n  Reference ref = getFirst();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n *",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n/**\n * Gets the one and only assignment.\n *\n * @return the one and only assignment, or {@code null} if there are none\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAndOnly();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one and only reference.\n *\n * @return the one and only reference, or {@code null} if there are none\n */\npublic Reference getOneAndOnly() {\n  Reference ref = getOne();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one reference.\n *\n * @return the one reference, or {@code null} if there are none\n */\npublic Reference getOne() {\n  Reference ref = getFirst();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the first reference.\n *\n * @return the first reference, or {@code null} if none\n */\npublic Reference getFirst() {\n  ",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n/**\n * Gets the one and only assignment.\n *\n * @return the one and only assignment, or {@code null} if there are none\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAndOnly();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one and only reference.\n *\n * @return the one and only reference, or {@code null} if there are none\n */\npublic Reference getOneAndOnly() {\n  Reference ref = getOne();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one reference.\n *\n * @return the one reference, or {@code null} if there are none\n */\npublic Reference getOne() {\n  Reference ref = getFirst();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the first reference in the list.\n *\n * @return the first reference, or {@code null} if there are none\n */\npublic Reference get",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n/**\n * Gets the one and only assignment.\n *\n * @return the one and only assignment, or {@code null} if there are none\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAndOnly();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one and only reference.\n *\n * @return the one and only reference, or {@code null} if there are none\n */\npublic Reference getOneAndOnly() {\n  Reference ref = getOne();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one reference.\n *\n * @return the one reference, or {@code null} if there are none\n */\npublic Reference getOne() {\n  Reference ref = getFirst();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the list of references.\n *\n * @return the list of references, or {@code null} if there are none\n */\npublic List<Reference",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n/**\n * Gets the one and only assignment.\n *\n * @return the one and only assignment, or {@code null} if there are none\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAndOnly();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one and only reference.\n *\n * @return the one and only reference, or {@code null} if there are none\n */\npublic Reference getOneAndOnly() {\n  Reference ref = getOne();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one reference.\n *\n * @return the one reference, or {@code null} if there are none\n */\npublic Reference getOne() {\n  Reference ref = getFirst();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the list of references.\n *\n * @return the list of references\n */\npublic List<Reference> getReferences() {\n  return new ArrayList",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n/**\n * Gets the one and only assignment.\n *\n * @return the one and only assignment, or {@code null} if there are none\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAndOnly();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one and only reference.\n *\n * @return the one and only reference, or {@code null} if there are none\n */\npublic Reference getOneAndOnly() {\n  Reference ref = getOne();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one reference.\n *\n * @return the one reference, or {@code null} if there are none\n */\npublic Reference getOne() {\n  Reference ref = getFirst();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the list of references.\n *\n * @return the list of references\n */\npublic List<Reference> getReferences() {\n  return Collections.un",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n/**\n * Gets the one and only assignment.\n *\n * @return the one and only assignment, or {@code null} if there are none\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAndOnly();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one and only reference.\n *\n * @return the one and only reference, or {@code null} if there are none\n */\npublic Reference getOneAndOnly() {\n  Reference ref = getOne();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the one reference.\n *\n * @return the one reference, or {@code null} if there are none\n */\npublic Reference getOne() {\n  Reference ref = getFirst();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return null;\n    }\n  }\n  return ref;\n}\n\n\n/**\n * Gets the first reference.\n *\n * @return the first reference, or {@code null} if there are none\n */\npublic BasicBlock getFirst()"
      ],
      "function range": "421,5-438,5"
    },
    "Closure_122_/src/com/google/javascript/jscomp/parsing/IRFactory.java_252-253": {
      "loc": "252-253",
      "input": "private void handleBlockComment(Comment comment) {",
      "output": [
        "private void handleBlockComment(Comment comment) {\n        if (comment == null) {\n            return;\n        }\n        String commentText = comment.getText();\n        if (commentText == null) {\n            return;\n        }\n        commentText = commentText.trim();\n        if (commentText.length() == 0) {\n            return;\n        }\n        if (commentText.startsWith(\"//\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim",
        "private void handleBlockComment(Comment comment) {\n        if (comment == null) {\n            return;\n        }\n        String commentText = comment.getText();\n        if (commentText == null) {\n            return;\n        }\n        commentText = commentText.trim();\n        if (commentText.length() == 0) {\n            return;\n        }\n        if (commentText.startsWith(\"//\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n",
        "private void handleBlockComment(Comment comment) {\n        if (comment == null) {\n            return;\n        }\n        String commentText = comment.getText();\n        if (commentText == null) {\n            return;\n        }\n        commentText = commentText.trim();\n        if (commentText.length() == 0) {\n            return;\n        }\n        if (commentText.startsWith(\"//\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"/*\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"/*\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n",
        "private void handleBlockComment(Comment comment) {\n        if (comment == null) {\n            return;\n        }\n        String commentText = comment.getText();\n        if (commentText == null) {\n            return;\n        }\n        commentText = commentText.trim();\n        if (commentText.length() == 0) {\n            return;\n        }\n        if (commentText.startsWith(\"//\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"//\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim",
        "private void handleBlockComment(Comment comment) {\n        if (comment == null) {\n            return;\n        }\n        String commentText = comment.getText();\n        if (commentText == null) {\n            return;\n        }\n        commentText = commentText.trim();\n        if (commentText.length() == 0) {\n            return;\n        }\n        if (commentText.startsWith(\"//\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"/*\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"/*\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"/*\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"/*\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n",
        "private void handleBlockComment(Comment comment) {\n        if (comment == null) {\n            return;\n        }\n        String commentText = comment.getText();\n        if (commentText == null) {\n            return;\n        }\n        commentText = commentText.trim();\n        if (commentText.length() == 0) {\n            return;\n        }\n        if (commentText.startsWith(\"//\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"/*\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"/*\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"/*\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n",
        "private void handleBlockComment(Comment comment) {\n        if (comment == null) {\n            return;\n        }\n        String commentText = comment.getText();\n        if (commentText == null) {\n            return;\n        }\n        commentText = commentText.trim();\n        if (commentText.length() == 0) {\n            return;\n        }\n        if (commentText.startsWith(\"//\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"//\")) {\n            commentText = commentText.substring(2).trim",
        "private void handleBlockComment(Comment comment) {\n        if (comment == null) {\n            return;\n        }\n        String commentText = comment.getText();\n        if (commentText == null) {\n            return;\n        }\n        commentText = commentText.trim();\n        if (commentText.length() == 0) {\n            return;\n        }\n        if (commentText.startsWith(\"//\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"--\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n\n",
        "private void handleBlockComment(Comment comment) {\n        if (comment == null) {\n            return;\n        }\n        String commentText = comment.getText();\n        if (commentText == null) {\n            return;\n        }\n        commentText = commentText.trim();\n        if (commentText.length() == 0) {\n            return;\n        }\n        if (commentText.startsWith(\"//\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2);\n        ",
        "private void handleBlockComment(Comment comment) {\n        if (comment == null) {\n            return;\n        }\n        String commentText = comment.getText();\n        if (commentText == null) {\n            return;\n        }\n        commentText = commentText.trim();\n        if (commentText.length() == 0) {\n            return;\n        }\n        if (commentText.startsWith(\"//\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.startsWith(\"/*\")) {\n            commentText = commentText.substring(2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"/*\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"/*\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n        if (commentText.endsWith(\"*/\")) {\n            commentText = commentText.substring(0, commentText.length() - 2).trim();\n        }\n\n"
      ],
      "function range": "251,3-258,3"
    },
    "Closure_125_/src/com/google/javascript/jscomp/TypeCheck.java_1661-1662": {
      "loc": "1661-1662",
      "input": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();",
      "output": [
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n/**\n * Visits a GETPROP node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetProp(t, n) {\n  JSType type = getJSType(n.getFirstChild());\n  visitExpression(t, n.getLastChild());\n  ensureTyped(t, n, type);\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetElem(t, n) {\n  visitExpression(t, n.getLastChild());\n  ensureTyped(t, n);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitVar(t, n) {\n  for (var i = 0; i < n.getChildCount(); i++) {\n    visit(t, n.",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n/**\n * Visits a GETPROP node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetProp(t, n) {\n  JSType type = getJSType(n.getFirstChild());\n  visitExpression(t, n.getLastChild());\n  ensureTyped(t, n, type);\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetElem(t, n) {\n  JSType type = getJSType(n.getLastChild());\n  visitExpression(t, n.getFirstChild());\n  ensureTyped(t, n, type);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitVar(t, n) {\n  // TODO(nicksant",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n/**\n * Visits a GETPROP node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetProp(t, n) {\n  JSType type = getJSType(n.getFirstChild());\n  visitExpression(t, n.getLastChild());\n  ensureTyped(t, n, type);\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetElem(t, n) {\n  visitExpression(t, n.getLastChild());\n  ensureTyped(t, n);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitVar(t, n) {\n  for (var i = 0; i < n.getChildCount(); i++) {\n    if (n.getChildAt",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n/**\n * Visits a GETPROP node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetProp(t, n) {\n  JSType type = getJSType(n.getFirstChild());\n  visitExpression(t, n.getLastChild());\n  ensureTyped(t, n, type);\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetElem(t, n) {\n  JSType type = getJSType(n.getLastChild());\n  visitExpression(t, n.getFirstChild());\n  ensureTyped(t, n, type);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitVar(t, n) {\n  JSType type = n.",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n/**\n * Visits a RETURN node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nvoid TypeCheck::visitReturn(NodeTraversal t, Node n) {\n  JSType jsType = getJSType(t.getEnclosingFunction());\n\n  if (jsType.isFunctionType()) {\n    FunctionType functionType = jsType.toMaybeFunctionType();\n\n    JSType returnType = functionType.getReturnType();\n\n    // if no return type is specified, undefined must be returned\n    // (it's a void function)\n    if (returnType == null) {\n      returnType = getNativeType(VOID_TYPE);\n    }\n\n    // fetching the returned value's type\n    Node valueNode = n.getFirstChild();\n    JSType actualReturnType;\n    if (valueNode == null) {\n      actualReturnType = getNativeType(VOID_TYPE);\n      valueNode = n;\n    } else {\n      actualReturnType = getJSType(valueNode);\n    }\n\n    // verifying\n    validator.expectCanAssignTo(t, valueNode, actualReturnType, returnType,\n        \"inconsistent return type\");\n  } else",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n/**\n * Visits a GETPROP node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetProp(t, n) {\n  JSType type = getJSType(n.getFirstChild());\n  visitExpression(t, n.getLastChild());\n  ensureTyped(t, n, type);\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetElem(t, n) {\n  JSType type = getJSType(n.getFirstChild());\n  visitExpression(t, n.getLastChild());\n  ensureTyped(t, n, type);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitVar(t, n) {\n  // TODO(nicksant",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n/**\n * Visits a GETPROP node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetProp(t, n) {\n  JSType type = getJSType(n.getFirstChild());\n  visitExpression(t, n.getLastChild());\n  ensureTyped(t, n, type);\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetElem(t, n) {\n  visitExpression(t, n.getLastChild());\n  ensureTyped(t, n);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitVar(t, n) {\n  for (var i = 0; i < n.getChildCount(); i++) {\n    var child = n.getChild",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n/**\n * Visits a GETPROP node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetProp(t, n) {\n  JSType type = getJSType(n.getFirstChild());\n  visitExpression(t, n.getLastChild());\n  ensureTyped(t, n, type);\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetElem(t, n) {\n  visitExpression(t, n.getLastChild());\n  ensureTyped(t, n);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitVar(t, n) {\n  for (var x = n.getFirstChild(); x; x = x.getNext()) {\n    if (x.",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n/**\n * Visits a GETPROP node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetProp(t, n) {\n  JSType type = getJSType(n.getFirstChild());\n  visitExpression(t, n.getLastChild());\n  ensureTyped(t, n, type);\n}\n\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitGetElem(t, n) {\n  JSType type = getJSType(n.getLastChild());\n  visitExpression(t, n.getFirstChild());\n  ensureTyped(t, n, type);\n}\n\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nfunction visitVar(t, n) {\n  for (var i = 0;",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n/**\n * Visits a RETURN node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nvoid TypeCheck::visitReturn(NodeTraversal t, Node n) {\n  JSType jsType = getJSType(t.getEnclosingFunction());\n\n  if (jsType.isFunctionType()) {\n    FunctionType functionType = jsType.toMaybeFunctionType();\n\n    JSType returnType = functionType.getReturnType();\n\n    // if no return type is specified, undefined must be returned\n    // (it's a void function)\n    if (returnType == null) {\n      returnType = getNativeType(VOID_TYPE);\n    }\n\n    // fetching the returned value's type\n    Node valueNode = n.getFirstChild();\n    JSType actualReturnType;\n    if (valueNode == null) {\n      actualReturnType = getNativeType(VOID_TYPE);\n      valueNode = n;\n    } else {\n      actualReturnType = getJSType(valueNode);\n    }\n\n    // verifying\n    validator.expectCanAssignTo(t, valueNode, actualReturnType, returnType,\n        \"inconsistent return type\");\n  }\n"
      ],
      "function range": "1656,3-1671,3"
    },
    "Closure_126_/src/com/google/javascript/jscomp/MinimizeExitPoints.java_141-145": {
      "loc": "141-145",
      "input": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock != null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }",
      "output": [
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    tryMinimizeDoExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isCase()) {\n    tryMinimizeCaseExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isDefaultCase()) {\n    tryMinimizeCaseExits(n, exitType, label",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExit(n, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    tryMinimizeDoExit(n, exitType, labelName);\n    return;\n  }\n  if (n.isFor()) {\n    tryMinimizeForExit(n, exitType, labelName);\n    return;\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExit(n, exitType, labelName);\n    return;\n  }\n  if (n.isCase()) {\n    tryMinimizeCaseExit(n, exitType, labelName);\n    return;\n  }\n  if (n.isDefaultCase()) {\n    tryMinimizeCaseExit(n, exitType, labelName);\n    return;",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    tryMinimizeDoWhileExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isCase()) {\n    tryMinimizeCaseExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isDefaultCase()) {\n    tryMinimizeCaseExits(n, exitType,",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    tryMinimizeDoExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isCase()) {\n    tryMinimizeCaseExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isBlock()) {\n    tryMinimizeExits(n.getLastChild(), exitType",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    tryMinimizeDoWhileExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isCase()) {\n    tryMinimizeCaseExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isBlock()) {\n    tryMinimizeExits(n.getLastChild(), exit",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n  }\n  if (n.isDo()) {\n    tryMinimizeDoExits(n, exitType, labelName);\n  }\n  if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n  }\n  if (n.isCase()) {\n    tryMinimizeCaseExits(n, exitType, labelName);\n  }\n  if (n.isDefaultCase()) {\n    tryMinimizeCaseExits(n, exitType, labelName);\n  }\n  if (n.isWith()) {\n    tryMinimize",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n  }\n  if (n.isDo()) {\n    tryMinimizeDoExits(n, exitType, labelName);\n  }\n  if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n  }\n  if (n.isCase()) {\n    tryMinimizeCaseExits(n, exitType, labelName);\n  }\n  if (n.isDefaultCase()) {\n    tryMinimizeCaseExits(n, exitType, labelName);\n  }\n  if (n.isGoto()) {\n    tryMin",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    tryMinimizeDoWhileExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isCase()) {\n    tryMinimizeCaseExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isBlock()) {\n    tryMinimizeExits(n, exitType, labelName",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n  }\n  if (n.isDo()) {\n    tryMinimizeDoExits(n, exitType, labelName);\n  }\n  if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n  }\n  if (n.isCase()) {\n    tryMinimizeCaseExits(n, exitType, labelName);\n  }\n  if (n.isDefaultCase()) {\n    tryMinimizeCaseExits(n, exitType, labelName);\n  }\n  if (n.isGoto()) {\n    Node label",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n  }\n  if (n.isDo()) {\n    tryMinimizeDoExits(n, exitType, labelName);\n  }\n  if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n  }\n  if (n.isCase()) {\n    tryMinimizeCaseExits(n, exitType, labelName);\n  }\n  if (n.isDefaultCase()) {\n    tryMinimizeCaseExits(n, exitType, labelName);\n  }\n}\n\n/**\n * @return Whether the node is an exit"
      ],
      "function range": "106,3-201,3"
    },
    "Closure_129_/src/com/google/javascript/jscomp/PrepareAst.java_166-167": {
      "loc": "166-167",
      "input": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();",
      "output": [
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().getParent().isAssign());\n    n.getGrandparent().getParent().putBooleanProp",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().getParent().getParent().isAssign());\n    n.getParent().getParent().getParent().",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().getParent().isAssign());\n    n.getParent().getParent().putBooleanProp(",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isAssign());\n    n.getParent().getParent().getParent().putBooleanProp(",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isAssign());\n    n.getGrandparent().getParent().putBooleanProp(Node.",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().getParent().isAssign());\n    n.getParent().getParent().getParent().putBoo",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isAssign());\n  }\n}\n\n}\n<|java|>/*\n *",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isAssign());\n  }\n}\n\n}\n<|java|>package com."
      ],
      "function range": "158,5-177,5"
    },
    "Closure_130_/src/com/google/javascript/jscomp/CollapseProperties.java_172-173": {
      "loc": "172-173",
      "input": "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }",
      "output": [
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.aliases!= null) {\n      for (Name alias : name.aliases) {\n        workList.push(alias);\n      }\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.aliases!= null) {\n      for (Name alias : name.aliases) {\n        workList.push(alias);\n      }\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.aliases!= null) {\n      for (Name alias : name.aliases) {\n        workList.push(alias);\n      }\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.aliases!= null) {\n      for (Name alias : name.aliases) {\n        workList.push(alias);\n      }\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.aliases!= null) {\n      for (Name alias : name.aliases) {\n        workList.push(alias);\n      }\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.aliases!= null) {\n      for (Name alias : name.aliases) {\n        workList.push(alias);\n      }\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.aliases!= null) {\n      for (Name alias : name.aliases) {\n        workList.push(alias);\n      }\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.al",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.aliases!= null) {\n      for (Name alias : name.aliases) {\n        workList.push(alias);\n      }\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyr",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.aliases!= null) {\n      for (Name alias : name.aliases) {\n        workList.push(alias);\n      }\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.aliases!= null) {\n      for (Name alias : name.aliases) {\n        workList.push(alias);\n      }\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalExpressionTag"
      ],
      "function range": "161,3-197,3"
    },
    "Closure_133_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_2401-2402": {
      "loc": "2401-2402",
      "input": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();",
      "output": [
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algeb",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.Abstract",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMap",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalExpressionTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AggregateOperator;",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractBinaryJoinOperator;\nimport org.apache.hyracks.alge",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.al"
      ],
      "function range": "2399,3-2402,3"
    },
    "Closure_146_/src/com/google/javascript/rhino/jstype/JSType.java_706-707": {
      "loc": "706-707",
      "input": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:",
      "output": [
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(this, null);\n    default:\n      return new TypePair(null, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(this, null);\n    default:\n      return new TypePair(null, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n    case FALSE:\n      return",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(this, null);\n    default:\n      return new TypePair(null, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case FALSE:\n      return new TypePair(",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(this, null);\n    default:\n      return new TypePair(null, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseUnionType(this);\n}\n\n@Override\npublic <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseUnionType(this, that);\n}\n\n@Override\npublic BooleanLiteralSet getPossibleToBooleanOutcomes",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(this, null);\n    default:\n      return new TypePair(null, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseUnionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseUnionType(this, that);\n}\n\n@Override\npublic BooleanLiteralSet getPossibleToBooleanOutcomes() {",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(this, null);\n    default:\n      return new TypePair(null, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n    case UNKNOWN:\n      ",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(this, null);\n    default:\n      return new TypePair(null, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseUnionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseUnionType(this, that);\n}\n\n@Override\npublic String toDebugHashCodeString() {\n  return \"{union:\" +",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(this, null);\n    default:\n      return new TypePair(null, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      if (this.isSub",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(this, null);\n    default:\n      return new TypePair(null, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE: return new TypePair(this,",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(this, null);\n    default:\n      return new TypePair(null, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(this, null);\n    case FALSE:\n      return new TypePair(null, that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n    case FALSE:\n    case"
      ],
      "function range": "696,3-715,3"
    },
    "Closure_150_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1451-1466": {
      "loc": "1451-1466",
      "input": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }",
      "output": [
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.BLOCK && parent == scope.getRootNode()) {\n    handleBlockInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FUNCTION && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CATCH && parent == scope.getRootNode()) {\n    handleCatchInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.IF && parent == scope.getRootNode()) {\n    handleIfInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.WHILE && parent == scope.getRootNode()) {\n    handleWhileInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.DO && parent == scope.getRootNode()) {\n    handleDoInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FOR && parent == scope.getRootNode()) {\n    handleForInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.SWITCH && parent == scope.getRootNode()) {\n    handleSwitchInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.VAR && parent == scope.getRootNode()) {\n    handleVarInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CASE && parent == scope.getRootNode()) {\n    handleCaseInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.RETURN && parent == scope.getRootNode()) {\n    handleReturnInputs(parent);\n    return;\n  }\n",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.BLOCK && parent == scope.getRootNode()) {\n    handleBlockInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FUNCTION && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CATCH && parent == scope.getRootNode()) {\n    handleCatchInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.IF && parent == scope.getRootNode()) {\n    handleIfInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.WHILE && parent == scope.getRootNode()) {\n    handleWhileInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.DO && parent == scope.getRootNode()) {\n    handleDoInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FOR && parent == scope.getRootNode()) {\n    handleForInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.SWITCH && parent == scope.getRootNode()) {\n    handleSwitchInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.VAR && parent == scope.getRootNode()) {\n    handleVarInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CASE && parent == scope.getRootNode()) {\n    handleCaseInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.WITH && parent == scope.getRootNode()) {\n    handleWithInputs(parent);\n    return;\n  }\n",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.BLOCK && parent == scope.getRootNode()) {\n    handleBlockInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FUNCTION && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CATCH && parent == scope.getRootNode()) {\n    handleCatchInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.IF && parent == scope.getRootNode()) {\n    handleIfInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.WHILE && parent == scope.getRootNode()) {\n    handleWhileInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.DO && parent == scope.getRootNode()) {\n    handleDoInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FOR && parent == scope.getRootNode()) {\n    handleForInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.SWITCH && parent == scope.getRootNode()) {\n    handleSwitchInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.VAR && parent == scope.getRootNode()) {\n    handleVarInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CASE && parent == scope.getRootNode()) {\n    handleCaseInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CLASS && parent == scope.getRootNode()) {\n    handleClassInputs(parent);\n    return;\n  }\n  ",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.BLOCK && parent == scope.getRootNode()) {\n    handleBlockInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FUNCTION && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CATCH && parent == scope.getRootNode()) {\n    handleCatchInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.IF && parent == scope.getRootNode()) {\n    handleIfInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.WHILE && parent == scope.getRootNode()) {\n    handleWhileInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.DO && parent == scope.getRootNode()) {\n    handleDoInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FOR && parent == scope.getRootNode()) {\n    handleForInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.SWITCH && parent == scope.getRootNode()) {\n    handleSwitchInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.VAR && parent == scope.getRootNode()) {\n    handleVarInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.RETURN && parent == scope.getRootNode()) {\n    handleReturnInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CASE && parent == scope.getRootNode()) {\n    handleCaseInputs(parent);\n    return;\n  }\n",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.BLOCK && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FUNCTION && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CATCH && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.IF && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FOR && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.WHILE && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.DO && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CASE && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.SWITCH && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.RETURN && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.VAR && parent == scope.getRootNode()) {\n    for (Node c = n.getFirstChild(); c!= null; c",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.BLOCK && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FUNCTION && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CATCH && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.IF && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FOR && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.WHILE && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.DO && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CASE && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.SWITCH && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.RETURN && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.VAR && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  ",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.BLOCK && parent == scope.getRootNode()) {\n    handleBlockInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FUNCTION && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CATCH && parent == scope.getRootNode()) {\n    handleCatchInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.IF && parent == scope.getRootNode()) {\n    handleIfInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.DO && parent == scope.getRootNode()) {\n    handleDoInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FOR && parent == scope.getRootNode()) {\n    handleForInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.WHILE && parent == scope.getRootNode()) {\n    handleWhileInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.SWITCH && parent == scope.getRootNode()) {\n    handleSwitchInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.VAR && parent == scope.getRootNode()) {\n    handleVarInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CASE && parent == scope.getRootNode()) {\n    handleCaseInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CLASS && parent == scope.getRootNode()) {\n    handleClassInputs(parent);\n    return;\n  }\n  ",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.BLOCK && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FUNCTION && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CATCH && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.IF && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.WHILE && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.DO && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FOR && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.SWITCH && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CASE && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.DEFAULT && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.RETURN && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  ",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.BLOCK && parent == scope.getRootNode()) {\n    handleBlockInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FUNCTION && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CATCH && parent == scope.getRootNode()) {\n    handleCatchInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.IF && parent == scope.getRootNode()) {\n    handleIfInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.WHILE && parent == scope.getRootNode()) {\n    handleWhileInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.DO && parent == scope.getRootNode()) {\n    handleDoInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FOR && parent == scope.getRootNode()) {\n    handleForInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.SWITCH && parent == scope.getRootNode()) {\n    handleSwitchInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.VAR && parent == scope.getRootNode()) {\n    handleVarInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CASE && parent == scope.getRootNode()) {\n    handleCaseInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.DEFAULT_CASE && parent == scope.getRootNode()) {\n    handleCaseInputs(parent);\n    return;\n",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.BLOCK && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FUNCTION && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CATCH && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.IF && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.WHILE && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.DO && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.FOR && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.SWITCH && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CASE && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.DEFAULT && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if (n.getType() == Token.CLASS && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  if"
      ],
      "function range": "1443,5-1466,5"
    },
    "Closure_152_/src/com/google/javascript/rhino/jstype/FunctionType.java_871-872": {
      "loc": "871-872",
      "input": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);",
      "output": [
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType toMaybeObjectType() {\n  return toObjectType();\n}\n\n@Override\npublic FunctionType toMaybeFunctionType() {\n  return toObjectType().toMaybeFunctionType();\n}\n\n@Override\npublic NamedType toMaybeNamedType() {\n  return toObjectType().toMaybeNamedType();\n}\n\n@Override\npublic JSType getPropertyType(String propertyName) {\n  return toObjectType().getPropertyType(propertyName);\n}\n\n@Override\npublic boolean hasProperty(String propertyName) {\n  return toObjectType().hasProperty(propertyName);\n}\n\n@Override\npublic boolean hasOwnProperty(String propertyName) {\n  return toObjectType().hasOwnProperty(propertyName);\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return toObjectType().getConstructor();\n}\n\n@Override\npublic JSType autoboxesTo() {\n  return toObjectType().autoboxesTo();\n}\n\n@Override\npublic boolean matchesObjectContext() {\n  return toObjectType().matchesObjectContext();\n}\n\n@Override\npublic boolean matchesNumberContext() {\n  return toObjectType().matchesNumberContext();\n}\n\n@Override\npublic boolean matchesStringContext() {\n  return toObjectType().matchesStringContext();\n}\n\n@Override\npublic boolean matchesObjectContext(String typeName) {\n  return toObjectType().matchesObjectContext(typeName);\n}\n\n@Override\npublic boolean matchesNumberContext(String typeName) {\n  return toObjectType().matchesNumberContext(typeName);\n}\n\n@Override\npublic boolean matchesStringContext(String typeName) {\n  return toObjectType().matchesStringContext(typeName);\n}",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType toMaybeObjectType() {\n  return toObjectType();\n}\n\n@Override\npublic FunctionType toMaybeFunctionType() {\n  return toObjectType().toMaybeFunctionType();\n}\n\n@Override\npublic NamedType toMaybeNamedType() {\n  return toObjectType().toMaybeNamedType();\n}\n\n@Override\npublic JSType getPropertyType(String propertyName) {\n  return toObjectType().getPropertyType(propertyName);\n}\n\n@Override\npublic boolean hasProperty(String propertyName) {\n  return toObjectType().hasProperty(propertyName);\n}\n\n@Override\npublic boolean hasOwnProperty(String propertyName) {\n  return toObjectType().hasOwnProperty(propertyName);\n}\n\n@Override\npublic JSType getIndexType() {\n  return toObjectType().getIndexType();\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return toObjectType().getConstructor();\n}\n\n@Override\npublic JSType autoboxesTo() {\n  return toObjectType().autoboxesTo();\n}\n\n@Override\npublic boolean matchesObjectContext() {\n  return toObjectType().matchesObjectContext();\n}\n\n@Override\npublic boolean matchesNumberContext() {\n  return toObjectType().matchesNumberContext();\n}\n\n@Override\npublic boolean matchesStringContext() {\n  return toObjectType().matchesStringContext();\n}\n\n@Override\npublic boolean matchesObjectContext(String typeName) {\n  return toObjectType().matchesObjectContext(typeName);\n}\n\n@Override\npublic boolean matchesNumberContext(String typeName) {\n  return toObjectType().matchesNumberContext(typeName);\n}\n\n@Override\npublic",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType toMaybeObjectType() {\n  return toObjectType();\n}\n\n@Override\npublic FunctionType toMaybeFunctionType() {\n  return toObjectType().toMaybeFunctionType();\n}\n\n@Override\npublic NamedType toMaybeNamedType() {\n  return toObjectType().toMaybeNamedType();\n}\n\n@Override\npublic JSType getPropertyType(String propertyName) {\n  return toObjectType().getPropertyType(propertyName);\n}\n\n@Override\npublic boolean hasProperty(String propertyName) {\n  return toObjectType().hasProperty(propertyName);\n}\n\n@Override\npublic boolean hasOwnProperty(String propertyName) {\n  return toObjectType().hasOwnProperty(propertyName);\n}\n\n@Override\npublic JSType getIndexType() {\n  return toObjectType().getIndexType();\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return toObjectType().getConstructor();\n}\n\n@Override\npublic JSType autoboxesTo() {\n  return toObjectType().autoboxesTo();\n}\n\n@Override\npublic boolean matchesObjectContext() {\n  return toObjectType().matchesObjectContext();\n}\n\n@Override\npublic boolean matchesNumberContext() {\n  return toObjectType().matchesNumberContext();\n}\n\n@Override\npublic boolean matchesStringContext() {\n  return toObjectType().matchesStringContext();\n}\n\n@Override\npublic boolean matchesSymbolContext() {\n  return toObjectType().matchesSymbolContext();\n}\n\n@Override\npublic boolean canBeCalled() {\n  return toObjectType().canBeCalled();\n}\n\n@Override\npublic boolean isStructuralInterface() {\n  return to",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType toMaybeObjectType() {\n  return toObjectType();\n}\n\n@Override\npublic FunctionType toMaybeFunctionType() {\n  return toObjectType().toMaybeFunctionType();\n}\n\n@Override\npublic NamedType toMaybeNamedType() {\n  return toObjectType().toMaybeNamedType();\n}\n\n@Override\npublic JSType getPropertyType(String propertyName) {\n  return toObjectType().getPropertyType(propertyName);\n}\n\n@Override\npublic boolean hasProperty(String propertyName) {\n  return toObjectType().hasProperty(propertyName);\n}\n\n@Override\npublic boolean hasOwnProperty(String propertyName) {\n  return toObjectType().hasOwnProperty(propertyName);\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return toObjectType().getConstructor();\n}\n\n@Override\npublic JSType autoboxesTo() {\n  return toObjectType().autoboxesTo();\n}\n\n@Override\npublic boolean matchesObjectContext() {\n  return toObjectType().matchesObjectContext();\n}\n\n@Override\npublic boolean matchesNumberContext() {\n  return toObjectType().matchesNumberContext();\n}\n\n@Override\npublic boolean matchesStringContext() {\n  return toObjectType().matchesStringContext();\n}\n\n@Override\npublic boolean matchesSymbolContext() {\n  return toObjectType().matchesSymbolContext();\n}\n\n@Override\npublic boolean canBeCalled() {\n  return toObjectType().canBeCalled();\n}\n\n@Override\npublic boolean isStructuralInterface() {\n  return toObjectType().isStructuralInterface();\n}\n\n@Override\npublic boolean isStructuralType() {\n  return to",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType toMaybeObjectType() {\n  return toObjectType();\n}\n\n@Override\npublic FunctionType toMaybeFunctionType() {\n  return toObjectType().toMaybeFunctionType();\n}\n\n@Override\npublic NamedType toMaybeNamedType() {\n  return toObjectType().toMaybeNamedType();\n}\n\n@Override\npublic JSType getPropertyType(String propertyName) {\n  return toObjectType().getPropertyType(propertyName);\n}\n\n@Override\npublic boolean hasProperty(String propertyName) {\n  return toObjectType().hasProperty(propertyName);\n}\n\n@Override\npublic boolean hasOwnProperty(String propertyName) {\n  return toObjectType().hasOwnProperty(propertyName);\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return toObjectType().getConstructor();\n}\n\n@Override\npublic JSType autoboxesTo() {\n  return toObjectType().autoboxesTo();\n}\n\n@Override\npublic boolean matchesObjectContext() {\n  return toObjectType().matchesObjectContext();\n}\n\n@Override\npublic boolean matchesNumberContext() {\n  return toObjectType().matchesNumberContext();\n}\n\n@Override\npublic boolean matchesStringContext() {\n  return toObjectType().matchesStringContext();\n}\n\n@Override\npublic boolean matchesSymbolContext() {\n  return toObjectType().matchesSymbolContext();\n}\n\n@Override\npublic boolean canBeCalled() {\n  return toObjectType().canBeCalled();\n}\n\n@Override\npublic boolean isStructuralInterface() {\n  return toObjectType().isStructuralInterface();\n}\n\n@Override\npublic Iterable<ObjectType> getCtorImple",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType toMaybeObjectType() {\n  return toObjectType();\n}\n\n@Override\npublic FunctionType toMaybeFunctionType() {\n  return toObjectType().toMaybeFunctionType();\n}\n\n@Override\npublic NamedType toMaybeNamedType() {\n  return toObjectType().toMaybeNamedType();\n}\n\n@Override\npublic JSType getPropertyType(String propertyName) {\n  return toObjectType().getPropertyType(propertyName);\n}\n\n@Override\npublic boolean hasProperty(String propertyName) {\n  return toObjectType().hasProperty(propertyName);\n}\n\n@Override\npublic boolean hasOwnProperty(String propertyName) {\n  return toObjectType().hasOwnProperty(propertyName);\n}\n\n@Override\npublic TernaryValue testForEquality(JSType that) {\n  return toObjectType().testForEquality(that);\n}\n\n@Override\npublic boolean isSubtype(JSType that) {\n  return isSubtype(that, ImplCache.create(), SubtypingMode.NORMAL);\n}\n\n@Override\nprotected boolean isSubtype(JSType that,\n    ImplCache implicitImplCache, SubtypingMode subtypingMode) {\n  return toObjectType().isSubtype(that, implicitImplCache, subtypingMode);\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return null;\n}\n\n@Override\npublic JSType findPropertyType(String propertyName) {\n  return toObjectType().findPropertyType(propertyName);\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n\n@Override <T> T visit(Relations",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType toMaybeObjectType() {\n  return toObjectType();\n}\n\n@Override\npublic FunctionType toMaybeFunctionType() {\n  return toObjectType().toMaybeFunctionType();\n}\n\n@Override\npublic NamedType toMaybeNamedType() {\n  return toObjectType().toMaybeNamedType();\n}\n\n@Override\npublic JSType getPropertyType(String propertyName) {\n  return toObjectType().getPropertyType(propertyName);\n}\n\n@Override\npublic boolean hasProperty(String propertyName) {\n  return toObjectType().hasProperty(propertyName);\n}\n\n@Override\npublic boolean hasOwnProperty(String propertyName) {\n  return toObjectType().hasOwnProperty(propertyName);\n}\n\n@Override\npublic JSType getIndexType() {\n  return toObjectType().getIndexType();\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return toObjectType().getConstructor();\n}\n\n@Override\npublic JSType autoboxesTo() {\n  return toObjectType().autoboxesTo();\n}\n\n@Override\npublic boolean matchesObjectContext() {\n  return toObjectType().matchesObjectContext();\n}\n\n@Override\npublic boolean matchesNumberContext() {\n  return toObjectType().matchesNumberContext();\n}\n\n@Override\npublic boolean matchesStringContext() {\n  return toObjectType().matchesStringContext();\n}\n\n@Override\npublic boolean matchesSymbolContext() {\n  return toObjectType().matchesSymbolContext();\n}\n\n@Override\npublic boolean canBeCalled() {\n  return toObjectType().canBeCalled();\n}\n\n@Override\npublic boolean isRegexpType() {\n  return",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType toMaybeObjectType() {\n  return toObjectType();\n}\n\n@Override\npublic FunctionType toMaybeFunctionType() {\n  return toObjectType().toMaybeFunctionType();\n}\n\n@Override\npublic NamedType toMaybeNamedType() {\n  return toObjectType().toMaybeNamedType();\n}\n\n@Override\npublic JSType getPropertyType(String propertyName) {\n  return toObjectType().getPropertyType(propertyName);\n}\n\n@Override\npublic boolean hasProperty(String propertyName) {\n  return toObjectType().hasProperty(propertyName);\n}\n\n@Override\npublic boolean hasOwnProperty(String propertyName) {\n  return toObjectType().hasOwnProperty(propertyName);\n}\n\n@Override\npublic JSType getIndexType() {\n  return toObjectType().getIndexType();\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return toObjectType().getConstructor();\n}\n\n@Override\npublic JSType autoboxesTo() {\n  return toObjectType().autoboxesTo();\n}\n\n@Override\npublic boolean matchesObjectContext() {\n  return toObjectType().matchesObjectContext();\n}\n\n@Override\npublic boolean matchesNumberContext() {\n  return toObjectType().matchesNumberContext();\n}\n\n@Override\npublic boolean matchesStringContext() {\n  return toObjectType().matchesStringContext();\n}\n\n@Override\npublic boolean matchesSymbolContext() {\n  return toObjectType().matchesSymbolContext();\n}\n\n@Override\npublic boolean canBeCalled() {\n  return toObjectType().canBeCalled();\n}\n\n@Override\npublic boolean isStructuralType() {\n  return to",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType toMaybeObjectType() {\n  return toObjectType();\n}\n\n@Override\npublic FunctionType toMaybeFunctionType() {\n  return toObjectType().toMaybeFunctionType();\n}\n\n@Override\npublic NamedType toMaybeNamedType() {\n  return toObjectType().toMaybeNamedType();\n}\n\n@Override\npublic JSType getPropertyType(String propertyName) {\n  return toObjectType().getPropertyType(propertyName);\n}\n\n@Override\npublic boolean hasProperty(String propertyName) {\n  return toObjectType().hasProperty(propertyName);\n}\n\n@Override\npublic boolean hasOwnProperty(String propertyName) {\n  return toObjectType().hasOwnProperty(propertyName);\n}\n\n@Override\npublic TernaryValue testForEquality(JSType that) {\n  return toObjectType().testForEquality(that);\n}\n\n@Override\npublic boolean isSubtype(JSType that) {\n  return isSubtype(that, ImplCache.create(), SubtypingMode.NORMAL);\n}\n\n@Override\nprotected boolean isSubtype(JSType that,\n    ImplCache implicitImplCache, SubtypingMode subtypingMode) {\n  return toObjectType().isSubtype(that, implicitImplCache, subtypingMode);\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseFunctionType(this, that);\n}\n\n@Override\nString toStringHelper(boolean forAnnotations) {\n  return getReferenceName() +",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType toMaybeObjectType() {\n  return toObjectType();\n}\n\n@Override\npublic FunctionType toMaybeFunctionType() {\n  return toObjectType().toMaybeFunctionType();\n}\n\n@Override\npublic NamedType toMaybeNamedType() {\n  return toObjectType().toMaybeNamedType();\n}\n\n@Override\npublic JSType getPropertyType(String propertyName) {\n  return toObjectType().getPropertyType(propertyName);\n}\n\n@Override\npublic boolean hasProperty(String propertyName) {\n  return toObjectType().hasProperty(propertyName);\n}\n\n@Override\npublic boolean hasOwnProperty(String propertyName) {\n  return toObjectType().hasOwnProperty(propertyName);\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return toObjectType().getConstructor();\n}\n\n@Override\npublic JSType autoboxesTo() {\n  return toObjectType().autoboxesTo();\n}\n\n@Override\npublic boolean matchesObjectContext() {\n  return toObjectType().matchesObjectContext();\n}\n\n@Override\npublic boolean matchesNumberContext() {\n  return toObjectType().matchesNumberContext();\n}\n\n@Override\npublic boolean matchesStringContext() {\n  return toObjectType().matchesStringContext();\n}\n\n@Override\npublic boolean matchesSymbolContext() {\n  return toObjectType().matchesSymbolContext();\n}\n\n@Override\npublic boolean canBeCalled() {\n  return toObjectType().canBeCalled();\n}\n\n@Override\npublic boolean isStructuralInterface() {\n  return toObjectType().isStructuralInterface();\n}\n\n@Override\npublic Collection<JSType> getCtorImple"
      ],
      "function range": "861,3-892,3"
    },
    "Closure_159_/src/com/google/javascript/jscomp/InlineFunctions.java_777-781": {
      "loc": "777-781",
      "input": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed != null);",
      "output": [
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (NodeUtil.isFunction(node)) {\n    String name = node.getFirstChild().getString();\n    if (!changed.contains(name)) {\n      changed.add(name);\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (NodeUtil.isFunction(node)) {\n    String name = node.getFirstChild().getString();\n    if (!changed.contains(name)) {\n      changed.add(name);\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (NodeUtil.isFunction(node)) {\n    String name = node.getFirstChild().getString();\n    if (!changed.contains(name)) {\n      changed.add(name);\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.Log",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (NodeUtil.isFunction(node)) {\n    String name = node.getFirstChild().getString();\n    if (!changed.contains(name)) {\n      changed.add(name);\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (NodeUtil.isFunction(node)) {\n    String name = node.getFirstChild().getString();\n    if (!changed.contains(name)) {\n      changed.add(name);\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.alge",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (NodeUtil.isFunction(node)) {\n    String name = node.getFirstChild().getString();\n    if (!changed.contains(name)) {\n      changed.add(name);\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IO",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (NodeUtil.isFunction(node)) {\n    String name = node.getFirstChild().getString();\n    if (!changed.contains(name)) {\n      changed.add(name);\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (NodeUtil.isFunction(node)) {\n    String name = node.getFirstChild().getString();\n    if (!changed.contains(name)) {\n      changed.add(name);\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IO",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (NodeUtil.isFunction(node)) {\n    String name = node.getFirstChild().getString();\n    if (!changed.contains(name)) {\n      changed.add(name);\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IL",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (NodeUtil.isFunction(node)) {\n    String name = node.getFirstChild().getString();\n    if (!changed.contains(name)) {\n      changed.add(name);\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.serde2.io.HiveDecimalWritable;\nimport org.apache.hadoop.hive."
      ],
      "function range": "773,3-787,3"
    },
    "Closure_168_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1996-1997": {
      "loc": "1996-1997",
      "input": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild() != null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }",
      "output": [
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLog",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.al",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExp",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUn"
      ],
      "function range": "1987,5-2038,5"
    },
    "Codec_2_/src/java/org/apache/commons/codec/binary/Base64.java_446-447": {
      "loc": "446-447",
      "input": "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }",
      "output": [
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        return;\n    }\n    if (buf == null || buf.length - pos < encodeSize) {\n        resizeBuf();\n    }\n    switch (modulus) {\n        case 1:\n            buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n            buf[pos++] = PAD;\n            buf[pos++] = PAD;\n            break;\n        case 2:\n            buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n            buf[pos++] = PAD;\n            ",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        return;\n    }\n    for (int i = 0; i < inAvail; i++) {\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        modulus = (++modulus) % 3;\n        int b = in[inPos++];\n        if (b < 0) {\n            b += 256;\n        }\n        x = (x << 8) + b;\n        if (0 == modulus) {\n            buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n            buf[pos++] = encodeTable[x & MASK_6BITS];\n            if",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        return;\n    }\n    // inAvail < 0 is how we're informed of EOF in the underlying data we're\n    // encoding.\n    if (buf == null || buf.length - pos < encodeSize) {\n        resizeBuf();\n    }\n    switch (modulus) {\n        case 1:\n            buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n            buf[pos++] = PAD;\n            buf[pos++] = PAD;\n            break;\n        case 2:\n            buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n            buf[pos++] = encodeTable",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        return;\n    }\n    for (int i = 0; i < inAvail; i++) {\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        modulus = (++modulus) % 3;\n        int b = in[inPos++];\n        if (b < 0) {\n            b += 256;\n        }\n        x = (x << 8) + b;\n        if (0 == modulus) {\n            buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n            buf[pos++] = encodeTable[x & MASK_6BITS];\n            current",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        return;\n    }\n\n    for (int i = 0; i < inAvail; i++) {\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        modulus = (++modulus) % 3;\n        int b = in[inPos++];\n        if (b < 0) {\n            b += 256;\n        }\n        x = (x << 8) + b;\n        if (0 == modulus) {\n            buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n            buf[pos++] = encodeTable[x & MASK_6BITS];\n            if",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        return;\n    }\n\n    for (int i = 0; i < inAvail; i++) {\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        modulus = (++modulus) % 3;\n        int b = in[inPos++];\n        if (b < 0) {\n            b += 256;\n        }\n        x = (x << 8) + b;\n        if (0 == modulus) {\n            buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n            buf[pos++] = encodeTable[x & MASK_6BITS];\n            current",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        return;\n    }\n\n    // inAvail < 0 is how we're informed of EOF in the underlying data we're\n    // encoding.\n    if (buf == null || buf.length - pos < encodeSize) {\n        resizeBuf();\n    }\n\n    switch (modulus) {\n        case 1:\n            buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n            buf[pos++] = PAD;\n            buf[pos++] = PAD;\n            break;\n        case 2:\n            buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n            buf[pos++] = encodeTable",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        return;\n    }\n    for (int i = 0; i < inAvail; i++) {\n        if (buffer == null || buffer.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        modulus = (++modulus) % 3;\n        int b = in[inPos++];\n        if (b < 0) {\n            b += 256;\n        }\n        x = (x << 8) + b;\n        if (0 == modulus) {\n            buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n            buf[pos++] = encodeTable[x & MASK_6BITS];\n            current",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        return;\n    }\n    for (int i = 0; i < inAvail; i++) {\n        if (buffer == null || buffer.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        modulus = (++modulus) % 3;\n        int b = in[inPos++];\n        if (b < 0) {\n            b += 256;\n        }\n        x = (x << 8) + b;\n        if (0 == modulus) {\n            buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n            buf[pos++] = encodeTable[x & MASK_6BITS];\n            if",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        return;\n    }\n\n    for (int i = 0; i < inAvail; i++) {\n        if (buffer == null || buffer.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        modulus = (++modulus) % 3;\n        int b = in[inPos++];\n        if (b < 0) {\n            b += 256;\n        }\n        x = (x << 8) + b;\n        if (0 == modulus) {\n            buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n            buf[pos++] = encodeTable[x & MASK_6BITS];\n            current"
      ],
      "function range": "414,5-473,5"
    },
    "Codec_4_/src/java/org/apache/commons/codec/binary/Base64.java_225-226": {
      "loc": "225-226",
      "input": "public Base64() {",
      "output": [
        "public Base64() {\n    }\n\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this.lineLength = lineLength;\n        this.lineSeparator = lineSeparator;\n    }\n\n    public int getLineLength() {\n        return lineLength;\n    }\n\n    public void setLineLength(int lineLength) {\n        this.lineLength = lineLength;\n    }\n\n    public byte[] getLineSeparator() {\n        return lineSeparator;\n    }\n\n    public void setLineSeparator(byte[] lineSeparator) {\n        this.lineSeparator = lineSeparator;\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @return The Base64-encoded data as a String.\n     * @throws NullPointerException if source array is null.\n     * @throws IllegalArgumentException if source array, offset, or length are invalid.\n     */\n    public String encodeToString(byte[] source) {\n        return encodeToString(source, 0, source.length);\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @param off Offset in array where conversion should begin.\n     * @param len Length of data to convert.\n     * @return The Base64-encoded data as a String.\n     * @throws NullPointerException if source array is null.\n     * @throws IllegalArgumentException if source array, offset, or length are invalid.\n     */\n    public String encodeToString(byte[] source, int off, int len) {\n        return encodeToString(source, off, len, NO_OPTIONS);\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @param off Offset in array where conversion should begin.\n     * @param len Length of data to convert.\n     * @param options Specified options.\n     * @return The Base64-encoded data as a String.\n     *",
        "public Base64() {\n    }\n\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this.lineLength = lineLength;\n        this.lineSeparator = lineSeparator;\n    }\n\n    public int getLineLength() {\n        return lineLength;\n    }\n\n    public void setLineLength(int lineLength) {\n        this.lineLength = lineLength;\n    }\n\n    public byte[] getLineSeparator() {\n        return lineSeparator;\n    }\n\n    public void setLineSeparator(byte[] lineSeparator) {\n        this.lineSeparator = lineSeparator;\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @return The Base64-encoded data as a String.\n     * @throws NullPointerException if source array is null.\n     * @throws IllegalArgumentException if source array, offset, or length are invalid.\n     */\n    public String encodeToString(byte[] source) {\n        return encodeToString(source, 0, source.length);\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @param off Offset in array where conversion should begin.\n     * @param len Length of data to convert.\n     * @return The Base64-encoded data as a String.\n     * @throws NullPointerException if source array is null.\n     * @throws IllegalArgumentException if source array, offset, or length are invalid.\n     */\n    public String encodeToString(byte[] source, int off, int len) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, off, len, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n",
        "public Base64() {\n    }\n\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this.lineLength = lineLength;\n        this.lineSeparator = lineSeparator;\n    }\n\n    public int getLineLength() {\n        return lineLength;\n    }\n\n    public void setLineLength(int lineLength) {\n        this.lineLength = lineLength;\n    }\n\n    public byte[] getLineSeparator() {\n        return lineSeparator;\n    }\n\n    public void setLineSeparator(byte[] lineSeparator) {\n        this.lineSeparator = lineSeparator;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     *\n     * @param binaryData Array containing binary data to encode.\n     * @return Base64-encoded data.\n     */\n    public byte[] encode(byte[] binaryData) {\n        return encode(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData Array containing binary data to encode.\n     * @return Base64-encoded data.\n     */\n    public byte[] encodeAndChunk(byte[] binaryData) {\n        return encode(binaryData, true);\n    }\n\n    private byte[] encode(byte[] binaryData, boolean isChunked) {\n        int lengthDataBits = binaryData.length * EIGHTBIT;\n        int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;\n        byte encodedData[] = null;\n        int encodedDataLength = 0;\n        int nbrChunks = 0;\n\n        if (fewerThan24bits!= 0) {\n            //data not divisible by 24 bit\n            encodedDataLength = (numberTriplets + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLength = numberTriplets * 4;\n        }\n\n        encodedData = new byte[encodedDataLength];\n\n        byte",
        "public Base64() {\n    }\n\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this.lineLength = lineLength;\n        this.lineSeparator = lineSeparator;\n    }\n\n    public int getLineLength() {\n        return lineLength;\n    }\n\n    public void setLineLength(int lineLength) {\n        this.lineLength = lineLength;\n    }\n\n    public byte[] getLineSeparator() {\n        return lineSeparator;\n    }\n\n    public void setLineSeparator(byte[] lineSeparator) {\n        this.lineSeparator = lineSeparator;\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @return The Base64-encoded data as a String.\n     * @throws NullPointerException if source array is null.\n     * @throws IllegalArgumentException if source array, offset, or length are invalid.\n     */\n    public String encodeToString(byte[] source) {\n        return encodeToString(source, 0, source.length);\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @param off Offset in array where conversion should begin.\n     * @param len Length of data to convert.\n     * @return The Base64-encoded data as a String.\n     * @throws NullPointerException if source array is null.\n     * @throws IllegalArgumentException if source array, offset, or length are invalid.\n     */\n    public String encodeToString(byte[] source, int off, int len) {\n        if (source == null) {\n            throw new NullPointerException(\"Cannot serialize a null array.\");\n        }\n        if (off < 0) {\n            throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n        }\n        if (len < 0) {\n            throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n        }\n        if (off + len > source.length) {\n            throw",
        "public Base64() {\n    }\n\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this.lineLength = lineLength;\n        this.lineSeparator = lineSeparator;\n    }\n\n    public int getLineLength() {\n        return lineLength;\n    }\n\n    public void setLineLength(int lineLength) {\n        this.lineLength = lineLength;\n    }\n\n    public byte[] getLineSeparator() {\n        return lineSeparator;\n    }\n\n    public void setLineSeparator(byte[] lineSeparator) {\n        this.lineSeparator = lineSeparator;\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decode(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public byte[] decode(byte[] base64Data) {\n        return decode(base64Data, 0, base64Data.length);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @param off\n     *            Offset of where to begin decoding\n     * @param len\n     *            Length of characters to decode\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public byte[] decode(byte[] base64Data, int off, int len) {\n        return decode(base64Data, off, len, DECODABET);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @param off\n     *            Offset of where to begin decoding\n     * @param len",
        "public Base64() {\n    }\n\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this.lineLength = lineLength;\n        this.lineSeparator = lineSeparator;\n    }\n\n    public int getLineLength() {\n        return lineLength;\n    }\n\n    public void setLineLength(int lineLength) {\n        this.lineLength = lineLength;\n    }\n\n    public byte[] getLineSeparator() {\n        return lineSeparator;\n    }\n\n    public void setLineSeparator(byte[] lineSeparator) {\n        this.lineSeparator = lineSeparator;\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @return The Base64-encoded data as a String.\n     * @throws NullPointerException if source array is null.\n     * @throws IllegalArgumentException if source array, offset, or length are invalid.\n     */\n    public String encodeToString(byte[] source) {\n        return encodeToString(source, 0, source.length);\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @param off Offset in array where conversion should begin.\n     * @param len Length of data to convert.\n     * @return The Base64-encoded data as a String.\n     * @throws NullPointerException if source array is null.\n     * @throws IllegalArgumentException if source array, offset, or length are invalid.\n     */\n    public String encodeToString(byte[] source, int off, int len) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeToString(source, off, len, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();",
        "public Base64() {\n    }\n\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this.lineLength = lineLength;\n        this.lineSeparator = lineSeparator;\n    }\n\n    public int getLineLength() {\n        return lineLength;\n    }\n\n    public void setLineLength(int lineLength) {\n        this.lineLength = lineLength;\n    }\n\n    public byte[] getLineSeparator() {\n        return lineSeparator;\n    }\n\n    public void setLineSeparator(byte[] lineSeparator) {\n        this.lineSeparator = lineSeparator;\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @return The Base64-encoded data as a String.\n     * @throws NullPointerException if source array is null.\n     * @throws IllegalArgumentException if source array, offset, or length are invalid.\n     */\n    public String encodeToString(byte[] source) {\n        return encodeToString(source, 0, source.length);\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @param off Offset in array where conversion should begin.\n     * @param len Length of data to convert.\n     * @return The Base64-encoded data as a String.\n     * @throws NullPointerException if source array is null.\n     * @throws IllegalArgumentException if source array, offset, or length are invalid.\n     */\n    public String encodeToString(byte[] source, int off, int len) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, off, len, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : \"IOExceptions only come",
        "public Base64() {\n    }\n\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this.lineLength = lineLength;\n        this.lineSeparator = lineSeparator;\n    }\n\n    public int getLineLength() {\n        return lineLength;\n    }\n\n    public void setLineLength(int lineLength) {\n        this.lineLength = lineLength;\n    }\n\n    public byte[] getLineSeparator() {\n        return lineSeparator;\n    }\n\n    public void setLineSeparator(byte[] lineSeparator) {\n        this.lineSeparator = lineSeparator;\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @return The Base64-encoded data as a String.\n     * @throws NullPointerException if source array is null.\n     * @throws IllegalArgumentException if source array, offset, or length are invalid.\n     */\n    public String encodeToString(byte[] source) {\n        return encodeToString(source, 0, source.length);\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @param off Offset in array where conversion should begin.\n     * @param len Length of data to convert.\n     * @return The Base64-encoded data as a String.\n     * @throws NullPointerException if source array is null.\n     * @throws IllegalArgumentException if source array, offset, or length are invalid.\n     */\n    public String encodeToString(byte[] source, int off, int len) {\n        return encodeToString(source, off, len, lineSeparator);\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @param off Offset in array where conversion should begin.\n     * @param len Length of data to convert.\n     * @param lineSeparator The line separator to use.\n     * @return The Base64-encoded data as a",
        "public Base64() {\n    }\n\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this.lineLength = lineLength;\n        this.lineSeparator = lineSeparator;\n    }\n\n    public int getLineLength() {\n        return lineLength;\n    }\n\n    public void setLineLength(int lineLength) {\n        this.lineLength = lineLength;\n    }\n\n    public byte[] getLineSeparator() {\n        return lineSeparator;\n    }\n\n    public void setLineSeparator(byte[] lineSeparator) {\n        this.lineSeparator = lineSeparator;\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @return The Base64-encoded data as a String.\n     * @throws NullPointerException if source array is null.\n     * @throws IllegalArgumentException if source array, offset, or length are invalid.\n     */\n    public String encodeToString(byte[] source) {\n        return encodeToString(source, 0, source.length);\n    }\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     *\n     * @param source The data to convert.\n     * @param off Offset in array where conversion should begin.\n     * @param len Length of data to convert.\n     * @return The Base64-encoded data as a String.\n     * @throws NullPointerException if source array is null.\n     * @throws IllegalArgumentException if source array, offset, or length are invalid.\n     */\n    public String encodeToString(byte[] source, int off, int len) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, off, len);\n        } catch (IOException ex) {\n            assert false : ex.getMessage();\n        } // end catch\n        assert encoded!=",
        "public Base64() {\n    }\n\n    public Base64(int lineLength, byte[] lineSeparator) {\n        this.lineLength = lineLength;\n        this.lineSeparator = lineSeparator;\n    }\n\n    public int getLineLength() {\n        return lineLength;\n    }\n\n    public void setLineLength(int lineLength) {\n        this.lineLength = lineLength;\n    }\n\n    public byte[] getLineSeparator() {\n        return lineSeparator;\n    }\n\n    public void setLineSeparator(byte[] lineSeparator) {\n        this.lineSeparator = lineSeparator;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     *\n     * @param binaryData Array containing binary data to encode.\n     * @return Base64-encoded data.\n     */\n    public byte[] encode(byte[] binaryData) {\n        return encode(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData Array containing binary data to encode.\n     * @return Base64-encoded data.\n     */\n    public byte[] encodeAndChunk(byte[] binaryData) {\n        return encode(binaryData, true);\n    }\n\n    private byte[] encode(byte[] binaryData, boolean isChunked) {\n        int lengthDataBits = binaryData.length * EIGHTBIT;\n        int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;\n        byte encodedData[] = null;\n        int encodedDataLength = 0;\n        int nbrChunks = 0;\n\n        if (fewerThan24bits!= 0) {\n            //data not divisible by 24 bit\n            encodedDataLength = (numberTriplets + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLength = numberTriplets * 4;\n        }\n\n        if (isChunked) {\n            nbrChunks ="
      ],
      "function range": "224,5-226,5"
    },
    "Codec_7_/src/java/org/apache/commons/codec/binary/Base64.java_670-671": {
      "loc": "670-671",
      "input": "public static String encodeBase64String(byte[] binaryData) {",
      "output": [
        "public static String encodeBase64String(byte[] binaryData) {\n        return Base64.encodeToString(binaryData, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return Base64.decode(base64String, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String, int offset, int length) {\n        return Base64.decode(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return Base64.decode(base64Data, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int offset, int length) {\n        return Base64.decode(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(String base64String) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(String base64String, int offset, int length) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(byte[] base64Data) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(byte[] base64Data, int offset, int length) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP, offset, length);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at",
        "public static String encodeBase64String(byte[] binaryData) {\n        return Base64.encodeToString(binaryData, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return Base64.decode(base64String, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String, int offset, int length) {\n        return Base64.decode(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(String base64String) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(String base64String, int offset, int length) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return Base64.decode(base64Data, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int offset, int length) {\n        return Base64.decode(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(byte[] base64Data) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(byte[] base64Data, int offset, int length) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP, offset, length);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at",
        "public static String encodeBase64String(byte[] binaryData) {\n        return Base64.encodeToString(binaryData, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return Base64.decode(base64String, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String, int offset, int length) {\n        return Base64.decode(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return Base64.decode(base64Data, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int offset, int length) {\n        return Base64.decode(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(String base64String) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(String base64String, int offset, int length) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(byte[] base64Data) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(byte[] base64Data, int offset, int length) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP, offset, length);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of",
        "public static String encodeBase64String(byte[] binaryData) {\n        return Base64.encodeToString(binaryData, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return Base64.decode(base64String, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String, int offset, int length) {\n        return Base64.decode(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(String base64String) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(String base64String, int offset, int length) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return Base64.decode(base64Data, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int offset, int length) {\n        return Base64.decode(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(byte[] base64Data) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(byte[] base64Data, int offset, int length) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP, offset, length);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of",
        "public static String encodeBase64String(byte[] binaryData) {\n        return Base64.encodeToString(binaryData, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return Base64.decode(base64String, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String, int offset, int length) {\n        return Base64.decode(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(String base64String) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(String base64String, int offset, int length) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return Base64.decode(base64Data, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int offset, int length) {\n        return Base64.decode(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(byte[] base64Data) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(byte[] base64Data, int offset, int length) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decodeBase64(String base64String, int offset, int length) {\n        return Base64.decode(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int offset, int length) {\n        return Base64.decode(base64Data, Base64.NO_WRAP, offset, length);\n    }",
        "public static String encodeBase64String(byte[] binaryData) {\n        return Base64.encodeToString(binaryData, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return Base64.decode(base64String, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String, int offset, int length) {\n        return Base64.decode(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(String base64String) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(String base64String, int offset, int length) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return Base64.decode(base64Data, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int offset, int length) {\n        return Base64.decode(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(byte[] base64Data) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(byte[] base64Data, int offset, int length) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(String base64Data) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(String base64Data, int offset, int length) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP, offset, length);\n    }\n}\n<|java",
        "public static String encodeBase64String(byte[] binaryData) {\n        return Base64.encodeToString(binaryData, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return Base64.decode(base64String, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String, int offset, int length) {\n        return Base64.decode(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(String base64String) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(String base64String, int offset, int length) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return Base64.decode(base64Data, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int offset, int length) {\n        return Base64.decode(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(byte[] base64Data) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(byte[] base64Data, int offset, int length) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(String base64Data) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(String base64Data, int offset, int length) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decode",
        "public static String encodeBase64String(byte[] binaryData) {\n        return Base64.encodeToString(binaryData, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return Base64.decode(base64String, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String, int offset, int length) {\n        return Base64.decode(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(String base64String) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(String base64String, int offset, int length) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return Base64.decode(base64Data, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int offset, int length) {\n        return Base64.decode(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(byte[] base64Data) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(byte[] base64Data, int offset, int length) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(String base64String, int offset, int length) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decodeBase64(String base64String, int offset, int length) {\n        return Base64.decode(base64String, Base64.NO_WRAP, offset, length);\n    ",
        "public static String encodeBase64String(byte[] binaryData) {\n        return Base64.encodeToString(binaryData, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return Base64.decode(base64String, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String, int offset, int length) {\n        return Base64.decode(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(String base64String) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(String base64String, int offset, int length) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return Base64.decode(base64Data, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int offset, int length) {\n        return Base64.decode(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(byte[] base64Data) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(byte[] base64Data, int offset, int length) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(String base64Data) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(String base64Data, int offset, int length) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase",
        "public static String encodeBase64String(byte[] binaryData) {\n        return Base64.encodeToString(binaryData, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return Base64.decode(base64String, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(String base64String, int offset, int length) {\n        return Base64.decode(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(String base64String) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(String base64String, int offset, int length) {\n        return Base64.decodeToString(base64String, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return Base64.decode(base64Data, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int offset, int length) {\n        return Base64.decode(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static String decodeBase64String(byte[] base64Data) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP);\n    }\n\n    public static String decodeBase64String(byte[] base64Data, int offset, int length) {\n        return Base64.decodeToString(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decodeBase64(String base64Data, int offset, int length) {\n        return Base64.decode(base64Data, Base64.NO_WRAP, offset, length);\n    }\n\n    public static byte[] decodeBase64(String base64Data) {\n        return Base64.decode(base64Data, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeBase64(byte"
      ],
      "function range": "669,5-671,5"
    },
    "Codec_9_/src/java/org/apache/commons/codec/binary/Base64.java_827-828": {
      "loc": "827-828",
      "input": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }",
      "output": [
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n\n    long len = getEncodedLength(binaryData, isChunked, urlSafe);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len + \") than the specified max size of \" + maxResultSize);\n    }\n\n    return encode(binaryData, isChunked, urlSafe);\n  }\n\n  /**\n   * Decodes a Base64 String into octets\n   *\n   * @param base64String\n   *            String containing Base64 data\n   * @return Array containing decoded data.\n   * @since 1.4\n   */\n  public static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n  }\n\n  /**\n   * Decodes Base64 data into octets\n   *\n   * @param base64Data\n   *            Byte array containing Base64 data\n   * @return Array containing decoded data.\n   */\n  public static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n  }\n\n  /**\n   * Checks if a byte value is whitespace or not.\n   *\n   * @param byteToCheck\n   *            the byte to check\n   * @return true if byte is whitespace, false otherwise\n   */\n  private static boolean isWhiteSpace(byte byteToCheck) {\n    switch (byteToCheck) {\n      case'' :\n      case '\\n' :\n      case '\\r' :\n      case '\\t' :\n        return true;\n      default :\n        return false;\n    }\n  }\n\n  // Implementation of the Encoder Interface\n\n  /**\n   * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n   *\n   * @param pArray\n   *            a byte array containing binary data\n   * @return A String containing",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n\n    long len = getEncodedLength(binaryData, isChunked, urlSafe);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len + \") than the specified max size of \" + maxResultSize);\n    }\n\n    return encode(binaryData, isChunked, urlSafe);\n  }\n\n  /**\n   * Decodes a Base64 String into octets\n   *\n   * @param base64String\n   *            String containing Base64 data\n   * @return Array containing decoded data.\n   * @since 1.4\n   */\n  public static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n  }\n\n  /**\n   * Decodes Base64 data into octets\n   *\n   * @param base64Data\n   *            Byte array containing Base64 data\n   * @return Array containing decoded data.\n   */\n  public static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n  }\n\n  /**\n   * Checks if a byte value is whitespace or not.\n   *\n   * @param byteToCheck\n   *            the byte to check\n   * @return true if byte is whitespace, false otherwise\n   */\n  private static boolean isWhiteSpace(byte byteToCheck) {\n    switch (byteToCheck) {\n      case'' :\n      case '\\n' :\n      case '\\r' :\n      case '\\t' :\n        return true;\n      default :\n        return false;\n    }\n  }\n\n  // Implementation of the Encoder Interface\n\n  /**\n   * Encodes a byte[] containing binary data, into a String\n   * containing characters in the Base64 alphabet.\n   *\n   * @param pArray\n   *            a byte array containing binary data\n   * @return",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n\n    long len = getEncodedLength(binaryData, isChunked, urlSafe);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len + \") than the specified max size of \" + maxResultSize);\n    }\n\n    return encode(binaryData, isChunked, urlSafe);\n  }\n\n  /**\n   * Decodes a Base64 String into octets\n   *\n   * @param base64String\n   *            String containing Base64 data\n   * @return Array containing decoded data.\n   * @since 1.4\n   */\n  public static byte[] decodeBase64(String base64String) {\n    return new sun.misc.BASE64Decoder().decodeBuffer(base64String);\n  }\n\n  /**\n   * Decodes Base64 data into octets\n   *\n   * @param base64Data\n   *            Byte array containing Base64 data\n   * @return Array containing decoded data.\n   */\n  public static byte[] decodeBase64(byte[] base64Data) {\n    return new sun.misc.BASE64Decoder().decodeBuffer(base64Data);\n  }\n\n  /**\n   * Checks if a byte value is whitespace or not.\n   *\n   * @param byteToCheck\n   *            the byte to check\n   * @return true if byte is whitespace, false otherwise\n   */\n  private static boolean isWhiteSpace(byte byteToCheck) {\n    switch (byteToCheck) {\n      case'' :\n      case '\\n' :\n      case '\\r' :\n      case '\\t' :\n        return true;\n      default :\n        return false;\n    }\n  }\n\n  // Implementation of the Encoder Interface\n\n  /**\n   * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n   *\n   * @param pArray\n   ",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n\n    long len = getEncodedLength(binaryData, isChunked, urlSafe);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len + \") than the specified max size of \" + maxResultSize);\n    }\n\n    return encode(binaryData, isChunked, urlSafe);\n  }\n\n  /**\n   * Decodes a Base64 String into octets\n   *\n   * @param base64String\n   *            String containing Base64 data\n   * @return Array containing decoded data.\n   * @since 1.4\n   */\n  public static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n  }\n\n  /**\n   * Decodes Base64 data into octets\n   *\n   * @param base64Data\n   *            Byte array containing Base64 data\n   * @return Array containing decoded data.\n   */\n  public static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n  }\n\n  /**\n   * Checks if a byte value is whitespace or not.\n   *\n   * @param byteToCheck\n   *            the byte to check\n   * @return true if byte is whitespace, false otherwise\n   */\n  private static boolean isWhiteSpace(byte byteToCheck) {\n    switch (byteToCheck) {\n      case'' :\n      case '\\n' :\n      case '\\r' :\n      case '\\t' :\n        return true;\n      default :\n        return false;\n    }\n  }\n\n  // Implementation of the Encoder Interface\n\n  /**\n   * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n   *\n   * @param pArray\n   *            a byte array containing binary data\n   * @return A String containing",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n\n    long len = getEncodedLength(binaryData, isChunked, urlSafe);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len + \") than the specified max size of \" + maxResultSize);\n    }\n\n    return encode(binaryData, isChunked, urlSafe);\n  }\n\n  /**\n   * Decodes a Base64 String into octets\n   *\n   * @param base64String\n   *            String containing Base64 data\n   * @return Array containing decoded data.\n   * @since 1.4\n   */\n  public static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n  }\n\n  /**\n   * Decodes Base64 data into octets\n   *\n   * @param base64Data\n   *            Byte array containing Base64 data\n   * @return Array containing decoded data.\n   */\n  public static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n  }\n\n  /**\n   * Checks if a byte value is whitespace or not.\n   *\n   * @param byteToCheck\n   *            the byte to check\n   * @return true if byte is whitespace, false otherwise\n   */\n  private static boolean isWhiteSpace(byte byteToCheck) {\n    switch (byteToCheck) {\n    case'' :\n    case '\\n' :\n    case '\\r' :\n    case '\\t' :\n      return true;\n    default :\n      return false;\n    }\n  }\n\n  // Implementation of the Encoder Interface\n\n  /**\n   * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n   *\n   * @param pArray\n   *            a byte array containing binary data\n   * @return A String containing",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n\n    long len = getEncodedLength(binaryData, isChunked, urlSafe);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len + \") than the specified max size of \" + maxResultSize);\n    }\n\n    return encode(binaryData, isChunked, urlSafe);\n  }\n\n  /**\n   * Decodes a Base64 String into octets\n   *\n   * @param base64String\n   *            String containing Base64 data\n   * @return Array containing decoded data.\n   * @since 1.4\n   */\n  public static byte[] decodeBase64(String base64String) {\n    return new sun.misc.BASE64Decoder().decodeBuffer(base64String);\n  }\n\n  /**\n   * Decodes Base64 data into octets\n   *\n   * @param base64Data\n   *            Byte array containing Base64 data\n   * @return Array containing decoded data.\n   */\n  public static byte[] decodeBase64(byte[] base64Data) {\n    return new sun.misc.BASE64Decoder().decodeBuffer(base64Data);\n  }\n\n  /**\n   * Checks if a byte value is whitespace or not\n   *\n   * @param byteToCheck\n   *            the byte to check\n   * @return true if byte is whitespace, false otherwise\n   */\n  private static boolean isWhiteSpace(byte byteToCheck) {\n    switch (byteToCheck) {\n      case'' :\n      case '\\n' :\n      case '\\r' :\n      case '\\t' :\n        return true;\n      default :\n        return false;\n    }\n  }\n\n  // Implementation of the Encoder Interface\n\n  /**\n   * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n   *\n   * @param pArray\n   *",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n\n    long len = getEncodedLength(binaryData, isChunked, urlSafe);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len + \") than the specified max size of \" + maxResultSize);\n    }\n\n    return encode(binaryData, isChunked, urlSafe);\n  }\n\n  /**\n   * Decodes a Base64 String into octets\n   *\n   * @param base64String\n   *            String containing Base64 data\n   * @return Array containing decoded data.\n   * @since 1.4\n   */\n  public static byte[] decodeBase64(String base64String) {\n    return new sun.misc.BASE64Decoder().decodeBuffer(base64String);\n  }\n\n  /**\n   * Decodes Base64 data into octets\n   *\n   * @param base64Data\n   *            Byte array containing Base64 data\n   * @return Array containing decoded data.\n   */\n  public static byte[] decodeBase64(byte[] base64Data) {\n    return new sun.misc.BASE64Decoder().decodeBuffer(base64Data);\n  }\n\n  /**\n   * Checks if a byte value is whitespace or not.\n   *\n   * @param byteToCheck\n   *            the byte to check\n   * @return true if byte is whitespace, false otherwise\n   */\n  private static boolean isWhiteSpace(byte byteToCheck) {\n    switch (byteToCheck) {\n    case'' :\n    case '\\n' :\n    case '\\r' :\n    case '\\t' :\n      return true;\n    default :\n      return false;\n    }\n  }\n\n  // Implementation of the Encoder Interface\n\n  /**\n   * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n   *\n   * @param pArray\n   ",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n\n    long len = getEncodedLength(binaryData, isChunked, urlSafe);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len + \") than the specified max size of \" + maxResultSize);\n    }\n\n    return encode(binaryData, isChunked, urlSafe);\n  }\n\n  /**\n   * Decodes a Base64 String into octets\n   *\n   * @param base64String\n   *            String containing Base64 data\n   * @return Array containing decoded data.\n   * @since 1.4\n   */\n  public static byte[] decodeBase64(String base64String) {\n    return new sun.misc.BASE64Decoder().decodeBuffer(base64String);\n  }\n\n  /**\n   * Decodes Base64 data into octets\n   *\n   * @param base64Data\n   *            Byte array containing Base64 data\n   * @return Array containing decoded data.\n   */\n  public static byte[] decodeBase64(byte[] base64Data) {\n    return new sun.misc.BASE64Decoder().decodeBuffer(base64Data);\n  }\n\n  /**\n   * Checks if a byte value is whitespace or not.\n   *\n   * @param byteToCheck\n   *            the byte to check\n   * @return true if byte is whitespace, false otherwise\n   */\n  private static boolean isWhiteSpace(byte byteToCheck) {\n    switch (byteToCheck) {\n      case'' :\n      case '\\n' :\n      case '\\r' :\n      case '\\t' :\n        return true;\n      default :\n        return false;\n    }\n  }\n\n  // Implementation of the Encoder Interface\n\n  /**\n   * Encodes a byte[] containing binary data, into a String\n   * containing characters in the Base64 alphabet.\n   *\n   * @param p",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n\n    long len = getEncodedLength(binaryData, isChunked, urlSafe);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len + \") than the specified max size of \" + maxResultSize);\n    }\n\n    return encode(binaryData, isChunked, urlSafe);\n  }\n\n  /**\n   * Decodes a Base64 String into octets\n   *\n   * @param base64String\n   *            String containing Base64 data\n   * @return Array containing decoded data.\n   * @since 1.4\n   */\n  public static byte[] decodeBase64(String base64String) {\n    return new sun.misc.BASE64Decoder().decodeBuffer(base64String);\n  }\n\n  /**\n   * Decodes Base64 data into octets\n   *\n   * @param base64Data\n   *            Byte array containing Base64 data\n   * @return Array containing decoded data.\n   */\n  public static byte[] decodeBase64(byte[] base64Data) {\n    return new sun.misc.BASE64Decoder().decodeBuffer(base64Data);\n  }\n\n  /**\n   * Checks if a byte value is whitespace or not.\n   *\n   * @param byteToCheck\n   *            the byte to check\n   * @return true if byte is whitespace, false otherwise\n   */\n  private static boolean isWhiteSpace(byte byteToCheck) {\n    switch (byteToCheck) {\n    case'' :\n    case '\\n' :\n    case '\\r' :\n    case '\\t' :\n      return true;\n    default :\n      return false;\n    }\n  }\n\n  // Implementation of the Encoder Interface\n\n  /**\n   * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n   *\n   * @param pArray\n   ",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n\n    long len = getEncodedLength(binaryData, isChunked, urlSafe);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len + \") than the specified max size of \" + maxResultSize);\n    }\n\n    return encode(binaryData, isChunked, urlSafe);\n  }\n\n  /**\n   * Decodes a Base64 String into octets\n   *\n   * @param base64String\n   *            String containing Base64 data\n   * @return Array containing decoded data.\n   * @since 1.4\n   */\n  public static byte[] decodeBase64(String base64String) {\n    return new sun.misc.BASE64Decoder().decodeBuffer(base64String);\n  }\n\n  /**\n   * Decodes Base64 data into octets\n   *\n   * @param base64Data\n   *            Byte array containing Base64 data\n   * @return Array containing decoded data.\n   */\n  public static byte[] decodeBase64(byte[] base64Data) {\n    return new sun.misc.BASE64Decoder().decodeBuffer(base64Data);\n  }\n\n  /**\n   * Checks if a byte value is whitespace or not.\n   *\n   * @param byteToCheck\n   *            the byte to check\n   * @return true if byte is whitespace, false otherwise\n   */\n  private static boolean isWhiteSpace(byte byteToCheck) {\n    switch (byteToCheck) {\n      case'' :\n      case '\\n' :\n      case '\\r' :\n      case '\\t' :\n        return true;\n      default :\n        return false;\n    }\n  }\n\n  // Implementation of the Encoder Interface\n\n  /**\n   * Encodes a byte[] containing binary data, into a String containing the\n   * Base64 encoded data.\n   *\n   * @param pArray"
      ],
      "function range": "822,5-837,5"
    },
    "Codec_10_/src/java/org/apache/commons/codec/language/Caverphone.java_76-77": {
      "loc": "76-77",
      "input": "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");",
      "output": [
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\",",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^trough\", \"trou2f\");\n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^enough\",",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^enough\",",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ch\", \"2h\");\n    txt = txt.replaceAll(\"^sh\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\"^th\", \"2h\");\n    txt = txt.replaceAll(\"^ph\", \"2h\");\n    txt = txt.replaceAll(\""
      ],
      "function range": "50,5-142,5"
    },
    "Codec_17_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_339-340": {
      "loc": "339-340",
      "input": "public static String newStringIso8859_1(final byte[] bytes) {",
      "output": [
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf32(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_32);\n    }\n\n    public static String newStringUtf32Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_32BE);\n    }\n\n    public static String newStringUtf32Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_32LE);\n    }\n\n    public static byte[] newBytesIso8859_1(final String string) {\n        return string.getBytes(Charsets.ISO_8859_1);\n    }\n\n    public static byte[] newBytesUtf8(final String string) {\n        return string.getBytes(Charsets.UTF_8);\n    }\n\n    public static byte[] newBytesUtf16(final String string) {\n        return string.getBytes(Charsets.UTF_16);\n    }\n\n    public static byte[] newBytesUtf16Be(final String string) {\n        return string.getBytes(Charsets.UTF_16BE);\n    }\n\n    public static byte[] newBytesUtf16Le(final String string) {\n        return string.getBytes(Charsets.UTF_16LE);\n    }\n\n    public static byte[] newBytesUtf32(final String string) {\n        return string.",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return newStringUtf8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return newStringUtf16(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-16\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return newStringUtf16Be(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-16BE\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return newStringUtf16Le(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf16Le",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return newStringUtf8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesIso8859_1(final String string) {\n        return newBytesIso8859_1(string, 0, string.length());\n    }\n\n    public static byte[] newBytesIso8859_1(final String string, final int offset, final int length) {\n        try {\n            return string.getBytes(\"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesUtf8(final String string) {\n        return newBytesUtf8(string, 0, string.length());\n    }\n\n    public static byte[] newBytesUtf8(final String string, final int offset, final int length) {\n        try {\n            return string.getBytes(\"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesIso8859_1(final byte[] bytes) {\n        return newBytesIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static byte[] newBytes",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return newStringUtf8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesIso8859_1(final String string) {\n        return newBytesIso8859_1(string, 0, string.length());\n    }\n\n    public static byte[] newBytesIso8859_1(final String string, final int offset, final int length) {\n        try {\n            return string.getBytes(\"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesUtf8(final String string) {\n        return newBytesUtf8(string, 0, string.length());\n    }\n\n    public static byte[] newBytesUtf8(final String string, final int offset, final int length) {\n        try {\n            return string.getBytes(\"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n *",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return newStringUtf8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesIso8859_1(final String string) {\n        return newBytesIso8859_1(string, 0, string.length());\n    }\n\n    public static byte[] newBytesIso8859_1(final String string, final int offset, final int length) {\n        try {\n            return string.getBytes(\"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesUtf8(final String string) {\n        return newBytesUtf8(string, 0, string.length());\n    }\n\n    public static byte[] newBytesUtf8(final String string, final int offset, final int length) {\n        try {\n            return string.getBytes(\"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return newStringUtf8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesIso8859_1(final String string) {\n        return newBytesIso8859_1(string, 0, string.length());\n    }\n\n    public static byte[] newBytesIso8859_1(final String string, final int offset, final int length) {\n        try {\n            return string.getBytes(\"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesUtf8(final String string) {\n        return newBytesUtf8(string, 0, string.length());\n    }\n\n    public static byte[] newBytesUtf8(final String string, final int offset, final int length) {\n        try {\n            return string.getBytes(\"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return newStringUtf8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesIso8859_1(final String string) {\n        return newBytesIso8859_1(string, 0, string.length());\n    }\n\n    public static byte[] newBytesIso8859_1(final String string, final int offset, final int length) {\n        try {\n            return string.getBytes(\"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesUtf8(final String string) {\n        return newBytesUtf8(string, 0, string.length());\n    }\n\n    public static byte[] newBytesUtf8(final String string, final int offset, final int length) {\n        try {\n            return string.getBytes(\"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return newStringUtf8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesIso8859_1(final String string) {\n        return newBytesIso8859_1(string, 0, string.length());\n    }\n\n    public static byte[] newBytesIso8859_1(final String string, final int offset, final int length) {\n        try {\n            return string.getBytes(\"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesUtf8(final String string) {\n        return newBytesUtf8(string, 0, string.length());\n    }\n\n    public static byte[] newBytesUtf8(final String string, final int offset, final int length) {\n        try {\n            return string.getBytes(\"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n<|java|>/**\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for\n * license information.\n *\n * Code generated by",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return newStringUtf8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesIso8859_1(final String string) {\n        return newBytesIso8859_1(string, 0, string.length());\n    }\n\n    public static byte[] newBytesIso8859_1(final String string, final int offset, final int length) {\n        try {\n            return string.getBytes(\"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesUtf8(final String string) {\n        return newBytesUtf8(string, 0, string.length());\n    }\n\n    public static byte[] newBytesUtf8(final String string, final int offset, final int length) {\n        try {\n            return string.getBytes(\"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] newBytesIso8859_1(final char[] chars) {\n        return newBytesIso8859_1(chars, 0, chars.length);\n    }\n\n    public static byte[] new",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf32(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_32);\n    }\n\n    public static String newStringUtf32Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_32BE);\n    }\n\n    public static String newStringUtf32Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_32LE);\n    }\n\n    public static byte[] newBytesIso8859_1(final String string) {\n        return string.getBytes(Charsets.ISO_8859_1);\n    }\n\n    public static byte[] newBytesUtf8(final String string) {\n        return string.getBytes(Charsets.UTF_8);\n    }\n\n    public static byte[] newBytesUtf16(final String string) {\n        return string.getBytes(Charsets.UTF_16);\n    }\n\n    public static byte[] newBytesUtf16Be(final String string) {\n        return string.getBytes(Charsets.UTF_16BE);\n    }\n\n    public static byte[] newBytesUtf16Le(final String string) {\n        return string.getBytes(Charsets.UTF_16LE);\n    }\n\n    public static byte[] newBytesIso8859_1(final byte[] bytes) {\n"
      ],
      "function range": "338,5-340,5"
    },
    "Codec_18_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_81-82": {
      "loc": "81-82",
      "input": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }",
      "output": [
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    final int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n    final int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (Character.toLowerCase(cs1.charAt(i))!= Character.toLowerCase(cs2.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final char[] cs1, final char[] cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1.length!= cs2.length) {\n        return false;\n    }\n    if (cs1.length",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n    int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (Character.toLowerCase(cs1.charAt(i))!= Character.toLowerCase(cs2.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final char[] cs1, final char[] cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    int length = cs1.length;\n    if (length!= cs2.length) {\n        return false;\n    }\n    if",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    final int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n    final int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (Character.toLowerCase(cs1.charAt(i))!= Character.toLowerCase(cs2.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final char[] cs1, final char[] cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    final int length = cs1.length;\n    if (length!= cs2.length) {\n        return false;\n    }",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n    int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (Character.toLowerCase(cs1.charAt(i))!= Character.toLowerCase(cs2.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final char[] cs1, final char[] cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1.length!= cs2.length) {\n        return false;\n    }\n    if (cs1.length == 0",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n    int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (Character.toLowerCase(cs1.charAt(i))!= Character.toLowerCase(cs2.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final char[] cs1, final char[] cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1.length!= cs2.length) {\n        return false;\n    }\n    for (int i = 0; i",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    final int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n    final int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (Character.toLowerCase(cs1.charAt(i))!= Character.toLowerCase(cs2.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final char[] cs1, final char[] cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1.length!= cs2.length) {\n        return false;\n    }\n    for (int i = 0",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    final int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n    final int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (Character.toUpperCase(cs1.charAt(i))!= Character.toUpperCase(cs2.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final char[] cs1, final char[] cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1.length!= cs2.length) {\n        return false;\n    }\n    if (cs1",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    final int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n    final int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (Character.toUpperCase(cs1.charAt(i))!= Character.toUpperCase(cs2.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final char[] cs1, final char[] cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    final int length = cs1.length;\n    if (length!= cs2.length) {\n        return false;\n",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    final int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n    final int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (Character.toLowerCase(cs1.charAt(i))!= Character.toLowerCase(cs2.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final char[] cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    final int length = cs1.length();\n    if (length!= cs2.length) {\n        return false;\n    ",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n    int length = cs1.length();\n    if (length!= cs2.length()) {\n        return false;\n    }\n    if (length == 0) {\n        return true;\n    }\n    for (int i = 0; i < length; i++) {\n        if (Character.toLowerCase(cs1.charAt(i))!= Character.toLowerCase(cs2.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final char[] cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    int length = cs1.length();\n    if (length!= cs2.length) {\n        return false;\n    }\n    "
      ],
      "function range": "71,5-82,5"
    },
    "Compress_5_/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java_239-241": {
      "loc": "239-241",
      "input": "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n                ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }",
      "output": [
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            crc.update(buffer, start, read);\n        }\n        return read;\n    }\n    return -1;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (closed) {\n        return;\n    ",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            crc.update(buffer, start, read);\n            readBytesOfEntry += read;\n        }\n        return read;\n    }\n    return -1;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            crc.update(buffer, start, read);\n            readBytesOfEntry += read;\n        }\n        return read;\n    }\n    return -1;\n  }\n\n  @Override\n  public int available() throws IOException {\n    if (",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read!= -1) {\n            crc.update(buffer, start, read);\n            readBytesOfEntry += read;\n        }\n        return read;\n    }\n    return -1;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read!= -1) {\n            crc.update(buffer, start, read);\n            readBytesOfEntry += read;\n        }\n        return read;\n    }\n    return -1;\n  }\n\n  public void close() throws IOException {\n    if (closed) {",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read!= -1) {\n            crc.update(buffer, start, read);\n            readBytesOfEntry += read;\n        }\n        return read;\n    }\n    return -1;\n  }\n\n  @Override\n  public int available() throws IOException {\n    if",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            crc.update(buffer, start, read);\n        }\n        return read;\n    }\n    return -1;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (closed) {\n      return;\n    ",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            crc.update(buffer, start, read);\n        }\n        return read;\n    }\n    throw new ArrayIndexOutOfBoundsException();\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (closed) {",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            crc.update(buffer, start, read);\n            readBytesOfEntry += read;\n        }\n        return read;\n    }\n    throw new ArrayIndexOutOfBoundsException();\n  }\n\n  public long skip(long n) throws IOException",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            crc.update(buffer, start, read);\n            readBytesOfEntry += read;\n        }\n        return read;\n    }\n    return -1;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (!"
      ],
      "function range": "191,5-246,5"
    },
    "Compress_12_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java_198-199": {
      "loc": "198-199",
      "input": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }",
      "output": [
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entrySize = currEntry.getSize();\n    entryOffset = 0;\n    return currEntry;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (in!= null) {\n      in.close();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    return currEntry;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (in!= null) {\n      in.close();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entrySize = currEntry.getSize();\n    entryOffset = 0;\n    return currEntry;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (in!= null) {\n      in.close();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entrySize = currEntry.getSize();\n    entryOffset = 0;\n    return currEntry;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (in!= null) {\n      in.close();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entrySize = currEntry.getSize();\n    entryOffset = 0;\n    return currEntry;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (in!= null) {\n      in.close();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.h",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entrySize = currEntry.getSize();\n    entryOffset = 0;\n    return currEntry;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (in!= null) {\n      in.close();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    return currEntry;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (in!= null) {\n      in.close();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    return currEntry;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (in!= null) {\n      in.close();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.h",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entrySize = currEntry.getSize();\n    entryOffset = 0;\n    return currEntry;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (in!= null) {\n      in.close();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.aggregation;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.common.base.Pre",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    return currEntry;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (in!= null) {\n      in.close();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;"
      ],
      "function range": "172,5-238,5"
    },
    "Compress_14_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_65-73": {
      "loc": "65-73",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }",
      "output": [
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '7'){\n            result = (result << 3) | (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9'){\n            result = (result << 3) | (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f'){\n            result = (result << 3) | (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F'){\n            result = (result << 3) | (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + buffer[i]);\n        }\n    }\n    return result;\n  }\n\n  public static long parseHex(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '9'){\n            result = (result << 4) | (buffer[i] - '0');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f'){\n            result = (result << 4) | (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <=",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '7'){\n            result = (result << 3) + (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9'){\n            result = (result << 3) + (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f'){\n            result = (result << 3) + (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F'){\n            result = (result << 3) + (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + buffer[i]);\n        }\n    }\n    return result;\n  }\n\n  public static long parseHex(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '9'){\n            result = (result << 4) + (buffer[i] - '0');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f'){\n            result = (result << 4) + (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <=",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '7'){\n            result = (result << 3) | (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9'){\n            result = (result << 3) | (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f'){\n            result = (result << 3) | (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F'){\n            result = (result << 3) | (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + buffer[i]);\n        }\n    }\n    return result;\n  }\n\n  public static long parseHex(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '9'){\n            result = (result << 4) | (buffer[i] - '0');\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F'){\n            result = (result << 4) | (buffer[i] - 'A' + 10);\n        } else if (buffer[i] >= 'a' && buffer[i] <=",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '7'){\n            result = (result << 3) + (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9'){\n            result = (result << 3) + (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f'){\n            result = (result << 3) + (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F'){\n            result = (result << 3) + (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + buffer[i]);\n        }\n    }\n    return result;\n  }\n\n  public static long parseHex(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '9'){\n            result = (result << 4) + (buffer[i] - '0');\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F'){\n            result = (result << 4) + (buffer[i] - 'A' + 10);\n        } else if (buffer[i] >= 'a' && buffer[i] <=",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '7'){\n            result = (result << 3) | (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9'){\n            result = (result << 3) | (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f'){\n            result = (result << 3) | (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F'){\n            result = (result << 3) | (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + buffer[i]);\n        }\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '7'){\n            result = (result << 3) | (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9'){\n            result = (result << 3) | (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f'){\n            result = (result << 3) | (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F'){\n            result = (result << 3) | (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character '\"+buffer[i]+\"'\");\n        }\n    }\n    return result;\n  }\n\n  public static long parseHex(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '9'){\n            result = (result << 4) | (buffer[i] - '0');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f'){\n            result = (result << 4) | (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '7'){\n            result = (result << 3) | (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9'){\n            result = (result << 3) | (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f'){\n            result = (result << 3) | (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F'){\n            result = (result << 3) | (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + buffer[i]);\n        }\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '7'){\n            result = (result << 3) | (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9'){\n            result = (result << 3) | (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f'){\n            result = (result << 3) | (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F'){\n            result = (result << 3) | (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character '\"+buffer[i]+\"'\");\n        }\n    }\n    return result;\n  }\n\n  public static long parseHex(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '9'){\n            result = (result << 4) | (buffer[i] - '0');\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F'){\n            result = (result << 4) | (buffer[i] - 'A' + 10);\n        } else if (buffer[i] >= 'a' && buffer[i",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '7'){\n            result = (result << 3) | (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9'){\n            result = (result << 3) | (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f'){\n            result = (result << 3) | (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F'){\n            result = (result << 3) | (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + buffer[i]);\n        }\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    for (int i = offset; i < end; i++){\n        if (buffer[i] >= '0' && buffer[i] <= '7'){\n            result = (result << 3) | (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9'){\n            result = (result << 3) | (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f'){\n            result = (result << 3) | (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F'){\n            result = (result << 3) | (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + buffer[i]);\n        }\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache"
      ],
      "function range": "56,5-112,5"
    },
    "Compress_19_/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java_259-260": {
      "loc": "259-260",
      "input": "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData != null) {\n        int expectedLength = (hasUncompressedSize ? DWORD : 0)\n            + (hasCompressedSize ? DWORD : 0)\n            + (hasRelativeHeaderOffset ? DWORD : 0)\n            + (hasDiskStart ? WORD : 0);",
      "output": [
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Corrupt Central Directory: \"\n                                   + \"expected length = \" + expectedLength\n                                   + \", actual length = \"\n                                   + rawCentralDirectoryData.length);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Corrupt Central Directory: \"\n                                   + \"expected length = \" + expectedLength\n                                   + \", actual length = \"\n                                   + rawCentralDirectoryData.length);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Corrupt Central Directory: \"\n                                   + \"expected length = \" + expectedLength\n                                   + \", actual length = \"\n                                   + rawCentralDirectoryData.length);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Corrupt Central Directory: \"\n                                   + \"expected length = \" + expectedLength\n                                   + \", actual length = \"\n                                   + rawCentralDirectoryData.length);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Corrupt Central Directory: \"\n                                   + \"expected length = \" + expectedLength\n                                   + \", actual length = \"\n                                   + rawCentralDirectoryData.length);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Corrupt Central Directory: \"\n                                   + \"expected length = \" + expectedLength\n                                   + \", actual length = \"\n                                   + rawCentralDirectoryData.length);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Corrupt Central Directory: \"\n                                   + \"expected length = \" + expectedLength\n                                   + \", actual length = \"\n                                   + rawCentralDirectoryData.length);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Corrupt Central Directory: \"\n                                   + \"expected length = \" + expectedLength\n                                   + \", actual length = \"\n                                   + rawCentralDirectoryData.length);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\n",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Corrupt Central Directory: \"\n                                   + \"expected length = \" + expectedLength\n                                   + \", actual length = \"\n                                   + rawCentralDirectoryData.length);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Corrupt Central Directory: \"\n                                   + \"expected length = \" + expectedLength\n                                   + \", actual length = \"\n                                   + rawCentralDirectoryData.length);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra"
      ],
      "function range": "249,5-287,5"
    },
    "Compress_23_/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java_112-113": {
      "loc": "112-113",
      "input": "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {",
      "output": [
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n      coder.properties[i - 1] = coder.properties[i];\n    }\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] =",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n      coder.properties[i - 1] = coder.properties[i];\n    }\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = (byte) ((dictSize >> 24) & 0xFF);\n    coder.properties[2] = (byte) ((dictSize >> 32) & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 40) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 48) & 0xFF);\n    coder.properties[3] = (byte) ((dictSize >> 56) & 0xFF);\n    coder.properties[2] = (byte) ((dictSize >> 64) & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 72) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 80) & 0xFF);\n    coder.properties[3] = (byte) ((dictSize >> 88) & 0xFF);\n    coder.properties[2] = (byte) ((dictSize >> 96) & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 104) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 112) & 0xFF);\n    coder.properties[3] = (byte) ((dictSize >> 120) & 0xFF);\n    coder.properties[2] = (byte) ((dictSize >> 128) & 0xFF);\n    ",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n      coder.properties[i - 1] = coder.properties[i];\n    }\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    return in;\n  }\n\n  ",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n      coder.properties[i - 1] = coder.properties[i];\n    }\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    return in;\n  }\n}",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n      coder.properties[i - 1] = coder.properties[i];\n    }\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    return in;\n  }\n\n",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n      coder.properties[i - 1] = coder.properties[i];\n    }\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    return coder.decode(in",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n      coder.properties[i - 1] = coder.properties[i];\n    }\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    return new ByteArrayInputStream(c",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n      coder.properties[i - 1] = coder.properties[i];\n    }\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[1] =",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n      coder.properties[i - 1] = coder.properties[i];\n    }\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.decode(in,",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n      coder.properties[i - 1] = coder.properties[i];\n    }\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[3] = propsByte;\n    coder.properties[2] = (byte) (dictSize & 0xFF);\n    coder.properties[1] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[0] = (byte) ((dictSize >> 16) & 0xFF);\n    return new CipherInputStream(in,"
      ],
      "function range": "106,9-118,9"
    },
    "Compress_27_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_133-137": {
      "loc": "133-137",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }",
      "output": [
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        result =",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    while (start < end){\n        if (",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end) {\n        result",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        result <<",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    for (int i = start; i < end",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end) {\n        if",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    while (start < end){\n        result =",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    start++;\n    while (start < end){",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    if (start < end){\n        result ="
      ],
      "function range": "102,5-150,5"
    },
    "Compress_31_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_135-138": {
      "loc": "135-138",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];",
      "output": [
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte >= '0' && currentByte <= '7') {\n            result <<= 3;\n            result |= currentByte - '0';\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result <<= 3;\n            result |= currentByte - '7';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result <<= 3;\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result <<= 3;\n            result |= currentByte - 'A' + 10;\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + currentByte);\n        }\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte >= '0' && currentByte <= '7') {\n            result <<= 3;\n            result |= currentByte - '0';\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result <<= 3;\n            result |= currentByte - '7';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result <<= 3;\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result <<= 3;\n            result |= currentByte - 'A' + 10;\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + currentByte);\n        }\n    }\n    return result;\n  }\n\n  public static long parseHex(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start <",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte >= '0' && currentByte <= '7') {\n            result <<= 3;\n            result |= currentByte - '0';\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result <<= 3;\n            result |= currentByte - '7';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result <<= 3;\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result <<= 3;\n            result |= currentByte - 'A' + 10;\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + currentByte);\n        }\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte >= '0' && currentByte <= '7') {\n            result <<= 3;\n            result |= currentByte - '0';\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result <<= 3;\n            result |= currentByte - '7';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result <<= 3;\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result <<= 3;\n            result |= currentByte - 'A' + 10;\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + currentByte);\n        }\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte >= '0' && currentByte <= '7') {\n            result <<= 3;\n            result |= currentByte - '0';\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result <<= 3;\n            result |= currentByte - '7';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result <<= 3;\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result <<= 3;\n            result |= currentByte - 'A' + 10;\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal value: \" + new String(buffer, offset, length));\n        }\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte >= '0' && currentByte <= '7') {\n            result <<= 3;\n            result |= currentByte - '0';\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result <<= 3;\n            result |= currentByte - '7';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result <<= 3;\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result <<= 3;\n            result |= currentByte - 'A' + 10;\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal value: \" + new String(buffer, offset, length));\n        }\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte >= '0' && currentByte <= '7') {\n            result <<= 3;\n            result |= currentByte - '0';\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result <<= 3;\n            result |= currentByte - '7';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result <<= 3;\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result <<= 3;\n            result |= currentByte - 'A' + 10;\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal value: \" + new String(buffer, offset, length));\n        }\n    }\n    return result;\n  }\n\n  public static long parseHex(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte >= '0' && currentByte <= '7') {\n            result <<= 3;\n            result |= currentByte - '0';\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result <<= 3;\n            result |= currentByte - '7';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result <<= 3;\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result <<= 3;\n            result |= currentByte - 'A' + 10;\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + currentByte);\n        }\n    }\n    return result;\n  }\n\n  public static long parseHex(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 4){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 4\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start <",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte >= '0' && currentByte <= '7') {\n            result <<= 3;\n            result |= currentByte - '0';\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result <<= 3;\n            result |= currentByte - '7';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result <<= 3;\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result <<= 3;\n            result |= currentByte - 'A' + 10;\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + currentByte);\n        }\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte >= '0' && currentByte <= '7') {\n            result <<= 3;\n            result |= currentByte - '0';\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result <<= 3;\n            result |= currentByte - '7';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result <<= 3;\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result <<= 3;\n            result |= currentByte - 'A' + 10;\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + currentByte);\n        }\n    }\n    return result;\n  }\n\n  public static long parseHex(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        }"
      ],
      "function range": "101,5-148,5"
    },
    "Compress_38_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java_859-860": {
      "loc": "859-860",
      "input": "@Override\npublic boolean isDirectory() {\n    if (file != null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }",
      "output": [
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return null;\n}\n\n@Override\npublic boolean mkdir() {\n    if (file!= null) {\n        return file.mkdir();\n    }\n    return false;\n}\n\n@Override\npublic boolean mkdirs() {\n    if (file!= null) {\n        return file.mkdirs();\n    }\n    return false;\n}\n\n@Override\npublic boolean setLastModified(long time) {\n    if (file!= null) {\n        return",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return null;\n}\n\n@Override\npublic String[] list(FilenameFilter filter) {\n    if (file!= null) {\n        return file.list(filter);\n    }\n    return null;\n}\n\n@Override\npublic File[] listFiles() {\n    if (file!= null) {\n        return file.listFiles();\n    }\n    return null;\n}\n\n@Override\npublic File[] listFiles(FilenameFilter filter) {\n    if (file!= null)",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return new String[0];\n}\n\n@Override\npublic boolean mkdir() {\n    if (file!= null) {\n        return file.mkdir();\n    }\n    return false;\n}\n\n@Override\npublic boolean mkdirs() {\n    if (file!= null) {\n        return file.mkdirs();\n    }\n    return false;\n}\n\n@Override\npublic boolean setLastModified(long time) {\n    if (file!= null) {",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return new String[0];\n}\n\n@Override\npublic String[] list(FilenameFilter filter) {\n    if (file!= null) {\n        return file.list(filter);\n    }\n    return new String[0];\n}\n\n@Override\npublic File[] listFiles() {\n    if (file!= null) {\n        return file.listFiles();\n    }\n    return new File[0];\n}\n\n@Override\npublic File[] listFiles(FilenameFilter filter)",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return null;\n}\n\n@Override\npublic String[] list(FilenameFilter filter) {\n    if (file!= null) {\n        return file.list(filter);\n    }\n    return null;\n}\n\n@Override\npublic boolean mkdir() {\n    if (file!= null) {\n        return file.mkdir();\n    }\n    return false;\n}\n\n@Override\npublic boolean mkdirs() {\n    if (file!= null) {\n        return file",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return null;\n}\n\n@Override\npublic boolean mkdir() {\n    if (file!= null) {\n        return file.mkdir();\n    }\n    return false;\n}\n\n@Override\npublic boolean mkdirs() {\n    if (file!= null) {\n        return file.mkdirs();\n    }\n    return false;\n}\n\n@Override\npublic boolean renameTo(File dest) {\n    if (file!= null) {\n        return file.",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return new String[0];\n}\n\n@Override\npublic String[] list(FilenameFilter filter) {\n    if (file!= null) {\n        return file.list(filter);\n    }\n    return new String[0];\n}\n\n@Override\npublic boolean mkdir() {\n    if (file!= null) {\n        return file.mkdir();\n    }\n    return false;\n}\n\n@Override\npublic boolean mkdirs() {\n    if (file!= null",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return null;\n}\n\n@Override\npublic boolean mkdir() {\n    if (file!= null) {\n        return file.mkdir();\n    }\n    return false;\n}\n\n@Override\npublic boolean mkdirs() {\n    if (file!= null) {\n        return file.mkdirs();\n    }\n    return false;\n}\n\n@Override\npublic boolean setExecutable(boolean executable) {\n    if (file!= null) {\n        return",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return new String[0];\n}\n\n@Override\npublic boolean mkdir() {\n    if (file!= null) {\n        return file.mkdir();\n    }\n    return false;\n}\n\n@Override\npublic boolean mkdirs() {\n    if (file!= null) {\n        return file.mkdirs();\n    }\n    return false;\n}\n\n@Override\npublic boolean renameTo(File dest) {\n    if (file!= null) {\n        ",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return new String[0];\n}\n\n@Override\npublic boolean mkdir() {\n    if (file!= null) {\n        return file.mkdir();\n    }\n    return false;\n}\n\n@Override\npublic boolean mkdirs() {\n    if (file!= null) {\n        return file.mkdirs();\n    }\n    return false;\n}\n\n@Override\npublic boolean setExecutable(boolean executable) {\n    if (file!= null) {"
      ],
      "function range": "849,5-864,5"
    },
    "Compress_46_/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java_529-531": {
      "loc": "529-531",
      "input": "private static ZipLong unixTimeToZipLong(long l) {",
      "output": [
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.alge",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.algebricks.",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyracks.algebricks",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMap",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport org.apache.hyracks.algebricks.core.",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AggregateOperator;",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport org.apache.hyr",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AggregateOperator;\nimport org.apache.hyracks.algebricks.core.al"
      ],
      "function range": "528,5-534,5"
    },
    "Csv_1_/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java_58-59": {
      "loc": "58-59",
      "input": "@Override\npublic int read() throws IOException {\n    int current = super.read();",
      "output": [
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    int current = super.available();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    int current = super.available();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    int current = super.available();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    int current = super.available();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    int current = super.available();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    int current = super.available();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n *",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    int current = super.available();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    int current = super.available();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n *",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    int current = super.available();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n *",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    int current = super.available();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required"
      ],
      "function range": "55,5-63,5"
    },
    "Csv_4_/src/main/java/org/apache/commons/csv/CSVParser.java_288-289": {
      "loc": "288-289",
      "input": "public Map<String, Integer> getHeaderMap() {",
      "output": [
        "public Map<String, Integer> getHeaderMap() {\r\n        return headerMap;\r\n    }\r\n\r\n    public void setHeaderMap(Map<String, Integer> headerMap) {\r\n        this.headerMap = headerMap;\r\n    }\r\n}\r\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.",
        "public Map<String, Integer> getHeaderMap() {\r\n        return headerMap;\r\n    }\r\n\r\n    public void setHeaderMap(Map<String, Integer> headerMap) {\r\n        this.headerMap = headerMap;\r\n    }\r\n}\r\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogical",
        "public Map<String, Integer> getHeaderMap() {\r\n        return headerMap;\r\n    }\r\n\r\n    public void setHeaderMap(Map<String, Integer> headerMap) {\r\n        this.headerMap = headerMap;\r\n    }\r\n}\r\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.",
        "public Map<String, Integer> getHeaderMap() {\r\n\t\treturn headerMap;\r\n\t}\r\n\r\n\tpublic void setHeaderMap(Map<String, Integer> headerMap) {\r\n\t\tthis.headerMap = headerMap;\r\n\t}\r\n\r\n}\r\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.Abstract",
        "public Map<String, Integer> getHeaderMap() {\r\n        return headerMap;\r\n    }\r\n\r\n    public void setHeaderMap(Map<String, Integer> headerMap) {\r\n        this.headerMap = headerMap;\r\n    }\r\n}\r\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.",
        "public Map<String, Integer> getHeaderMap() {\r\n        return headerMap;\r\n    }\r\n\r\n    public void setHeaderMap(Map<String, Integer> headerMap) {\r\n        this.headerMap = headerMap;\r\n    }\r\n}\r\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.",
        "public Map<String, Integer> getHeaderMap() {\r\n        return headerMap;\r\n    }\r\n\r\n    public void setHeaderMap(Map<String, Integer> headerMap) {\r\n        this.headerMap = headerMap;\r\n    }\r\n}\r\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.",
        "public Map<String, Integer> getHeaderMap() {\r\n        return headerMap;\r\n    }\r\n\r\n    public void setHeaderMap(Map<String, Integer> headerMap) {\r\n        this.headerMap = headerMap;\r\n    }\r\n}\r\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.",
        "public Map<String, Integer> getHeaderMap() {\r\n\t\treturn headerMap;\r\n\t}\r\n\r\n\tpublic void setHeaderMap(Map<String, Integer> headerMap) {\r\n\t\tthis.headerMap = headerMap;\r\n\t}\r\n\r\n}\r\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyr",
        "public Map<String, Integer> getHeaderMap() {\r\n        return headerMap;\r\n    }\r\n\r\n    public void setHeaderMap(Map<String, Integer> headerMap) {\r\n        this.headerMap = headerMap;\r\n    }\r\n}\r\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnn"
      ],
      "function range": "287,5-289,5"
    },
    "Csv_11_/src/main/java/org/apache/commons/csv/CSVParser.java_384-385": {
      "loc": "384-385",
      "input": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);",
      "output": [
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, hdrMap.get(header) + 1);\n                } else {\n                    hdrMap.put(header, 1);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, hdrMap.get(header) + 1);\n                } else {\n                    hdrMap.put(header, 1);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.aggregation.",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, hdrMap.get(header) + 1);\n                } else {\n                    hdrMap.put(header, 1);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rew",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, hdrMap.get(header) + 1);\n                } else {\n                    hdrMap.put(header, 1);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.datanode",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, hdrMap.get(header) + 1);\n                } else {\n                    hdrMap.put(header, 1);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, hdrMap.get(header) + 1);\n                } else {\n                    hdrMap.put(header, 1);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs;\n\nimport java.",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, hdrMap.get(header) + 1);\n                } else {\n                    hdrMap.put(header, 1);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.indexing.common.",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, hdrMap.get(header) + 1);\n                } else {\n                    hdrMap.put(header, 1);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.ddl",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, hdrMap.get(header) + 1);\n                } else {\n                    hdrMap.put(header, 1);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.storage.am.lsm",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, hdrMap.get(header) + 1);\n                } else {\n                    hdrMap.put(header, 1);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.aggregation;"
      ],
      "function range": "359,5-394,5"
    },
    "Csv_14_/src/main/java/org/apache/commons/csv/CSVFormat.java_1039-1040": {
      "loc": "1039-1040",
      "input": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);",
      "output": [
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      switch (c) {\n      case '\\n':\n        out.append(\"\\\\n\");\n        break;\n      case '\\r':\n        out.append(\"\\\\r\");\n        break;\n      case '\\t':\n        out.",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == quoteChar) {\n        out.append(quoteChar);\n      }\n      out.append(c);\n      if (c == quoteChar) {\n        out.append(quoteChar);\n      }\n    }\n  }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int pos = offset; pos < end; ++pos) {\n      final char c = value.charAt(pos);\n      if (c == quoteChar) {\n        out.append(quoteChar);\n      }\n      out.append(c);\n      if (c == quoteChar) {\n        out.append(quoteChar);\n      }\n    }\n  ",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == quoteChar) {\n        out.append(quoteChar);\n        out.append(c);\n        out.append(quoteChar);\n      } else if (c == delimChar) {\n        out.append(c);\n        ",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == quoteChar) {\n        out.append(quoteChar);\n        out.append(c);\n        out.append(quoteChar);\n      } else {\n        out.append(c);\n      }\n    }\n  }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == getDelimiter()) {\n        out.append(getDelimiter());\n      } else if (c == getQuoteCharacter()) {\n        out.append(getQuoteCharacter());\n      } else if (c == getEscapeCharacter",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == quoteChar) {\n        out.append(quoteChar);\n      }\n      out.append(c);\n      if (c == delimChar) {\n        out.append(delimChar);\n      }\n    }\n  ",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == getDelimiter()) {\n        out.append(getDelimiter());\n      } else if (c == getQuoteCharacter()) {\n        out.append(getQuoteCharacter());\n      }\n      out.append(c);\n",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == quoteChar) {\n        out.append(quoteChar);\n        out.append(c);\n        out.append(quoteChar);\n      } else if (c == delimChar) {\n        out.append(c);\n      ",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == getDelimiter() || c == getQuoteCharacter().charValue()) {\n        out.append(getEscapeCharacter().charValue());\n      }\n      out.append(c);\n    }\n  }\n}\n<"
      ],
      "function range": "1001,5-1106,5"
    },
    "Csv_15_/src/main/java/org/apache/commons/csv/CSVFormat.java_1189-1192": {
      "loc": "1189-1192",
      "input": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);",
      "output": [
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      switch (c) {\n      case '\\n':\n        out.append(\"\\\\n\");\n        break;\n      case '\\r':\n        out.append(\"\\\\r\");\n        break;\n",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == quoteChar) {\n        out.append(quoteChar);\n      }\n      out.append(c);\n      if (c == quoteChar) {\n        out.append(quoteChar",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; ++i) {\n      final char c = value.charAt(i);\n      switch (c) {\n      case '\\n':\n        out.append(\"\\\\n\");\n        break;\n      case '\\r':\n        out.append(\"\\\\r\");\n        break;",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == getDelimiter() || c == getQuoteCharacter().charValue()) {\n        out.append(getEscapeCharacter().charValue());\n      }\n      out.append(c);\n",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == quoteChar) {\n        out.append(quoteChar);\n        out.append(c);\n        out.append(quoteChar);\n      } else if (c == delimChar) {",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == getDelimiter()) {\n        out.append(getDelimiter());\n      } else if (c == getQuoteCharacter()) {\n        out.append(getQuoteCharacter());\n      ",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == getQuoteCharacter().charValue()) {\n        out.append(c);\n      }\n      out.append(c);\n    }\n  }\n}\n<|java|>",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == getDelimiter() || c == getQuoteCharacter().charValue()) {\n        out.append(c);\n      }\n      out.append(c);\n    }\n  }\n\n",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == getDelimiter() || c == getQuoteCharacter().charValue()) {\n        out.append(c);\n      }\n      out.append(c);\n    }\n  }\n",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    final int end = offset + len;\n    for (int i = offset; i < end; i++) {\n      final char c = value.charAt(i);\n      if (c == quoteChar) {\n        out.append(quoteChar);\n        out.append(c);\n        out.append(quoteChar);\n      } else if (c == escapeChar) {"
      ],
      "function range": "1151,5-1256,5"
    },
    "Gson_10_/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java_122-124": {
      "loc": "122-124",
      "input": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);",
      "output": [
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue == null) {\n    writer.nullValue();\n  } else if (fieldValue instanceof Boolean) {\n    writer.value((Boolean) fieldValue);\n  } else if (fieldValue instanceof Byte) {\n    writer.value((Byte) fieldValue);\n  } else if (fieldValue instanceof Character) {\n    writer.value((Character) fieldValue);\n  } else if (fieldValue instanceof Double) {\n    writer.value((Double) fieldValue);\n  } else if (fieldValue instanceof Float) {\n    writer.value((Float) fieldValue);\n  } else if (fieldValue instanceof Integer) {\n    writer.value((Integer) fieldValue);\n  } else if (fieldValue instanceof Long) {\n    writer.value((Long) fieldValue);\n  } else if (fieldValue instanceof Short) {\n    writer.value((Short) fieldValue);\n  } else if (fieldValue instanceof String) {\n    writer.value((String) fieldValue);\n  } else if (fieldValue instanceof BigDecimal) {\n    writer.value((BigDecimal) fieldValue);\n  } else if (fieldValue instanceof BigInteger) {\n    writer.value((BigInteger) fieldValue);\n  } else if (fieldValue instanceof Date) {\n    writer.value((Date) fieldValue);\n  } else if (fieldValue instanceof java.sql.Date) {\n    writer.value((java.sql.Date) fieldValue);\n  } else if (fieldValue instanceof Time) {\n    writer.value((Time) fieldValue);\n  } else if (fieldValue instanceof java.sql.Time) {\n    writer.value((java.sql.Time) fieldValue);\n  } else if (fieldValue instanceof Timestamp) {\n    writer.value((Timestamp) fieldValue);\n  } else if (fieldValue instanceof java.sql.Timestamp) {\n    writer.value((java.sql.Timestamp) field",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue == null) {\n    writer.nullValue();\n  } else if (fieldValue instanceof Boolean) {\n    writer.value((Boolean) fieldValue);\n  } else if (fieldValue instanceof Byte) {\n    writer.value((Byte) fieldValue);\n  } else if (fieldValue instanceof Character) {\n    writer.value((Character) fieldValue);\n  } else if (fieldValue instanceof Double) {\n    writer.value((Double) fieldValue);\n  } else if (fieldValue instanceof Float) {\n    writer.value((Float) fieldValue);\n  } else if (fieldValue instanceof Integer) {\n    writer.value((Integer) fieldValue);\n  } else if (fieldValue instanceof Long) {\n    writer.value((Long) fieldValue);\n  } else if (fieldValue instanceof Short) {\n    writer.value((Short) fieldValue);\n  } else if (fieldValue instanceof String) {\n    writer.value((String) fieldValue);\n  } else if (fieldValue instanceof BigDecimal) {\n    writer.value((BigDecimal) fieldValue);\n  } else if (fieldValue instanceof BigInteger) {\n    writer.value((BigInteger) fieldValue);\n  } else if (fieldValue instanceof Date) {\n    writer.value((Date) fieldValue);\n  } else if (fieldValue instanceof java.sql.Date) {\n    writer.value((java.sql.Date) fieldValue);\n  } else if (fieldValue instanceof Time) {\n    writer.value((Time) fieldValue);\n  } else if (fieldValue instanceof Timestamp) {\n    writer.value((Timestamp) fieldValue);\n  } else if (fieldValue instanceof java.util.Date) {\n    writer.value((java.util.Date) fieldValue);\n  } else if (fieldValue instanceof byte[]) {\n    writer.value((byte[]) fieldValue);\n  } else if (",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue == null) {\n    writer.nullValue();\n  } else if (fieldValue instanceof Boolean) {\n    writer.value((Boolean) fieldValue);\n  } else if (fieldValue instanceof Byte) {\n    writer.value((Byte) fieldValue);\n  } else if (fieldValue instanceof Character) {\n    writer.value((Character) fieldValue);\n  } else if (fieldValue instanceof Double) {\n    writer.value((Double) fieldValue);\n  } else if (fieldValue instanceof Float) {\n    writer.value((Float) fieldValue);\n  } else if (fieldValue instanceof Integer) {\n    writer.value((Integer) fieldValue);\n  } else if (fieldValue instanceof Long) {\n    writer.value((Long) fieldValue);\n  } else if (fieldValue instanceof Short) {\n    writer.value((Short) fieldValue);\n  } else if (fieldValue instanceof String) {\n    writer.value((String) fieldValue);\n  } else if (fieldValue instanceof BigDecimal) {\n    writer.value((BigDecimal) fieldValue);\n  } else if (fieldValue instanceof BigInteger) {\n    writer.value((BigInteger) fieldValue);\n  } else if (fieldValue instanceof Date) {\n    writer.value((Date) fieldValue);\n  } else if (fieldValue instanceof Object[]) {\n    writer.beginArray();\n    for (Object item : (Object[]) fieldValue) {\n      write(writer, item);\n    }\n    writer.endArray();\n  } else if (fieldValue instanceof Collection) {\n    writer.beginArray();\n    for (Object item : (Collection) fieldValue) {\n      write(writer, item);\n    }\n    writer.endArray();\n  } else if (fieldValue instanceof Map) {\n    writer.beginObject();\n    for (Map.Entry<?,?> entry : ((Map<?,?>) field",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue == null) {\n    writer.nullValue();\n  } else if (fieldValue instanceof Boolean) {\n    writer.value((Boolean) fieldValue);\n  } else if (fieldValue instanceof Byte) {\n    writer.value((Byte) fieldValue);\n  } else if (fieldValue instanceof Character) {\n    writer.value((Character) fieldValue);\n  } else if (fieldValue instanceof Double) {\n    writer.value((Double) fieldValue);\n  } else if (fieldValue instanceof Float) {\n    writer.value((Float) fieldValue);\n  } else if (fieldValue instanceof Integer) {\n    writer.value((Integer) fieldValue);\n  } else if (fieldValue instanceof Long) {\n    writer.value((Long) fieldValue);\n  } else if (fieldValue instanceof Short) {\n    writer.value((Short) fieldValue);\n  } else if (fieldValue instanceof String) {\n    writer.value((String) fieldValue);\n  } else if (fieldValue instanceof BigDecimal) {\n    writer.value((BigDecimal) fieldValue);\n  } else if (fieldValue instanceof BigInteger) {\n    writer.value((BigInteger) fieldValue);\n  } else if (fieldValue instanceof Date) {\n    writer.value((Date) fieldValue);\n  } else if (fieldValue instanceof java.sql.Date) {\n    writer.value((java.sql.Date) fieldValue);\n  } else if (fieldValue instanceof Time) {\n    writer.value((Time) fieldValue);\n  } else if (fieldValue instanceof Timestamp) {\n    writer.value((Timestamp) fieldValue);\n  } else if (fieldValue instanceof java.sql.Timestamp) {\n    writer.value((java.sql.Timestamp) fieldValue);\n  } else if (fieldValue instanceof URL) {\n    writer.value((URL) fieldValue);\n  } else if (",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue == null) {\n    writer.nullValue();\n  } else if (fieldValue instanceof Boolean) {\n    writer.value((Boolean) fieldValue);\n  } else if (fieldValue instanceof Byte) {\n    writer.value((Byte) fieldValue);\n  } else if (fieldValue instanceof Character) {\n    writer.value((Character) fieldValue);\n  } else if (fieldValue instanceof Double) {\n    writer.value((Double) fieldValue);\n  } else if (fieldValue instanceof Float) {\n    writer.value((Float) fieldValue);\n  } else if (fieldValue instanceof Integer) {\n    writer.value((Integer) fieldValue);\n  } else if (fieldValue instanceof Long) {\n    writer.value((Long) fieldValue);\n  } else if (fieldValue instanceof Short) {\n    writer.value((Short) fieldValue);\n  } else if (fieldValue instanceof String) {\n    writer.value((String) fieldValue);\n  } else if (fieldValue instanceof BigDecimal) {\n    writer.value((BigDecimal) fieldValue);\n  } else if (fieldValue instanceof BigInteger) {\n    writer.value((BigInteger) fieldValue);\n  } else if (fieldValue instanceof Date) {\n    writer.value((Date) fieldValue);\n  } else if (fieldValue instanceof Object[]) {\n    writer.beginArray();\n    for (Object item : (Object[]) fieldValue) {\n      write(writer, item);\n    }\n    writer.endArray();\n  } else if (fieldValue instanceof Collection) {\n    writer.beginArray();\n    for (Object item : (Collection) fieldValue) {\n      write(writer, item);\n    }\n    writer.endArray();\n  } else if (fieldValue instanceof Map) {\n    writer.beginObject();\n    for (Map.Entry<Object, Object> entry : ((Map<Object, Object",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue == null) {\n    writer.nullValue();\n  } else if (fieldValue instanceof Boolean) {\n    writer.value((Boolean) fieldValue);\n  } else if (fieldValue instanceof Byte) {\n    writer.value((Byte) fieldValue);\n  } else if (fieldValue instanceof Character) {\n    writer.value((Character) fieldValue);\n  } else if (fieldValue instanceof Double) {\n    writer.value((Double) fieldValue);\n  } else if (fieldValue instanceof Float) {\n    writer.value((Float) fieldValue);\n  } else if (fieldValue instanceof Integer) {\n    writer.value((Integer) fieldValue);\n  } else if (fieldValue instanceof Long) {\n    writer.value((Long) fieldValue);\n  } else if (fieldValue instanceof Short) {\n    writer.value((Short) fieldValue);\n  } else if (fieldValue instanceof String) {\n    writer.value((String) fieldValue);\n  } else if (fieldValue instanceof BigDecimal) {\n    writer.value((BigDecimal) fieldValue);\n  } else if (fieldValue instanceof BigInteger) {\n    writer.value((BigInteger) fieldValue);\n  } else if (fieldValue instanceof Date) {\n    writer.value((Date) fieldValue);\n  } else if (fieldValue instanceof java.sql.Date) {\n    writer.value((java.sql.Date) fieldValue);\n  } else if (fieldValue instanceof Time) {\n    writer.value((Time) fieldValue);\n  } else if (fieldValue instanceof Timestamp) {\n    writer.value((Timestamp) fieldValue);\n  } else if (fieldValue instanceof UUID) {\n    writer.value((UUID) fieldValue);\n  } else if (fieldValue instanceof URL) {\n    writer.value((URL) fieldValue);\n  } else if (fieldValue instanceof URI) {\n",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue == null) {\n    writer.nullValue();\n  } else if (fieldValue instanceof Boolean) {\n    writer.value((Boolean) fieldValue);\n  } else if (fieldValue instanceof Byte) {\n    writer.value((Byte) fieldValue);\n  } else if (fieldValue instanceof Character) {\n    writer.value((Character) fieldValue);\n  } else if (fieldValue instanceof Double) {\n    writer.value((Double) fieldValue);\n  } else if (fieldValue instanceof Float) {\n    writer.value((Float) fieldValue);\n  } else if (fieldValue instanceof Integer) {\n    writer.value((Integer) fieldValue);\n  } else if (fieldValue instanceof Long) {\n    writer.value((Long) fieldValue);\n  } else if (fieldValue instanceof Short) {\n    writer.value((Short) fieldValue);\n  } else if (fieldValue instanceof String) {\n    writer.value((String) fieldValue);\n  } else if (fieldValue instanceof BigDecimal) {\n    writer.value((BigDecimal) fieldValue);\n  } else if (fieldValue instanceof BigInteger) {\n    writer.value((BigInteger) fieldValue);\n  } else if (fieldValue instanceof Date) {\n    writer.value((Date) fieldValue);\n  } else if (fieldValue instanceof java.sql.Date) {\n    writer.value((java.sql.Date) fieldValue);\n  } else if (fieldValue instanceof Time) {\n    writer.value((Time) fieldValue);\n  } else if (fieldValue instanceof Timestamp) {\n    writer.value((Timestamp) fieldValue);\n  } else if (fieldValue instanceof URL) {\n    writer.value((URL) fieldValue);\n  } else if (fieldValue instanceof UUID) {\n    writer.value((UUID) fieldValue);\n  } else if (fieldValue.getClass().isArray",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue == null) {\n    writer.nullValue();\n  } else if (fieldValue instanceof Boolean) {\n    writer.value((Boolean) fieldValue);\n  } else if (fieldValue instanceof Byte) {\n    writer.value((Byte) fieldValue);\n  } else if (fieldValue instanceof Character) {\n    writer.value((Character) fieldValue);\n  } else if (fieldValue instanceof Double) {\n    writer.value((Double) fieldValue);\n  } else if (fieldValue instanceof Float) {\n    writer.value((Float) fieldValue);\n  } else if (fieldValue instanceof Integer) {\n    writer.value((Integer) fieldValue);\n  } else if (fieldValue instanceof Long) {\n    writer.value((Long) fieldValue);\n  } else if (fieldValue instanceof Short) {\n    writer.value((Short) fieldValue);\n  } else if (fieldValue instanceof String) {\n    writer.value((String) fieldValue);\n  } else if (fieldValue instanceof BigDecimal) {\n    writer.value((BigDecimal) fieldValue);\n  } else if (fieldValue instanceof BigInteger) {\n    writer.value((BigInteger) fieldValue);\n  } else if (fieldValue instanceof Date) {\n    writer.value((Date) fieldValue);\n  } else if (fieldValue instanceof java.sql.Date) {\n    writer.value((java.sql.Date) fieldValue);\n  } else if (fieldValue instanceof Time) {\n    writer.value((Time) fieldValue);\n  } else if (fieldValue instanceof Timestamp) {\n    writer.value((Timestamp) fieldValue);\n  } else if (fieldValue instanceof URL) {\n    writer.value((URL) fieldValue);\n  } else if (fieldValue instanceof UUID) {\n    writer.value((UUID) fieldValue);\n  } else if (fieldValue instanceof byte[]) {",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue == null) {\n    writer.nullValue();\n  } else if (fieldValue instanceof Boolean) {\n    writer.value((Boolean) fieldValue);\n  } else if (fieldValue instanceof Byte) {\n    writer.value((Byte) fieldValue);\n  } else if (fieldValue instanceof Character) {\n    writer.value((Character) fieldValue);\n  } else if (fieldValue instanceof Double) {\n    writer.value((Double) fieldValue);\n  } else if (fieldValue instanceof Float) {\n    writer.value((Float) fieldValue);\n  } else if (fieldValue instanceof Integer) {\n    writer.value((Integer) fieldValue);\n  } else if (fieldValue instanceof Long) {\n    writer.value((Long) fieldValue);\n  } else if (fieldValue instanceof Short) {\n    writer.value((Short) fieldValue);\n  } else if (fieldValue instanceof String) {\n    writer.value((String) fieldValue);\n  } else if (fieldValue instanceof BigDecimal) {\n    writer.value((BigDecimal) fieldValue);\n  } else if (fieldValue instanceof BigInteger) {\n    writer.value((BigInteger) fieldValue);\n  } else if (fieldValue instanceof Date) {\n    writer.value((Date) fieldValue);\n  } else if (fieldValue instanceof java.sql.Date) {\n    writer.value((java.sql.Date) fieldValue);\n  } else if (fieldValue instanceof Time) {\n    writer.value((Time) fieldValue);\n  } else if (fieldValue instanceof Timestamp) {\n    writer.value((Timestamp) fieldValue);\n  } else if (fieldValue instanceof URL) {\n    writer.value((URL) fieldValue);\n  } else if (fieldValue instanceof UUID) {\n    writer.value((UUID) fieldValue);\n  } else if (fieldValue instanceof URI) {\n",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue == null) {\n    writer.nullValue();\n  } else if (fieldValue instanceof Boolean) {\n    writer.value((Boolean) fieldValue);\n  } else if (fieldValue instanceof Byte) {\n    writer.value((Byte) fieldValue);\n  } else if (fieldValue instanceof Character) {\n    writer.value((Character) fieldValue);\n  } else if (fieldValue instanceof Double) {\n    writer.value((Double) fieldValue);\n  } else if (fieldValue instanceof Float) {\n    writer.value((Float) fieldValue);\n  } else if (fieldValue instanceof Integer) {\n    writer.value((Integer) fieldValue);\n  } else if (fieldValue instanceof Long) {\n    writer.value((Long) fieldValue);\n  } else if (fieldValue instanceof Short) {\n    writer.value((Short) fieldValue);\n  } else if (fieldValue instanceof String) {\n    writer.value((String) fieldValue);\n  } else if (fieldValue instanceof BigDecimal) {\n    writer.value((BigDecimal) fieldValue);\n  } else if (fieldValue instanceof BigInteger) {\n    writer.value((BigInteger) fieldValue);\n  } else if (fieldValue instanceof Date) {\n    writer.value((Date) fieldValue);\n  } else if (fieldValue instanceof java.sql.Date) {\n    writer.value((java.sql.Date) fieldValue);\n  } else if (fieldValue instanceof Time) {\n    writer.value((Time) fieldValue);\n  } else if (fieldValue instanceof Timestamp) {\n    writer.value((Timestamp) fieldValue);\n  } else if (fieldValue instanceof URL) {\n    writer.value((URL) fieldValue);\n  } else if (fieldValue instanceof UUID) {\n    writer.value((UUID) fieldValue);\n  } else if (fieldValue.getClass().isEn"
      ],
      "function range": "118,7-125,7"
    },
    "Gson_15_/gson/src/main/java/com/google/gson/stream/JsonWriter.java_495-496": {
      "loc": "495-496",
      "input": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();",
      "output": [
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeBoolean(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter valueNull() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNull();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter object() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeStartObject();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter endObject() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeEndObject();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter array() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeStartArray();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter endArray() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeBoolean(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNull();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter name(String name) throws IOException {\n  writeDeferredName();\n  beforeName();\n  try {\n    out.writeFieldName(name);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter object() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeStartObject();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter endObject() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeEndObject();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter array() throws IOException {\n  writeDeferredName();\n  beforeValue();\n",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeBoolean(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNull();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeString(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonObject value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    value.writeTo(this);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonArray value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    value.writeTo(this);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter object() throws IOException {\n  if",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeBoolean(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNull();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeString(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonObject value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    value.writeTo(this);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonArray value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    value.writeTo(this);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(BigDecimal value) throws IO",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeBoolean(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNull();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeString(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonObject value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    value.write(this);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonArray value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    value.write(this);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(BigDecimal value) throws IOException {",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeBoolean(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNull();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeString(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonObject value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    value.writeTo(this);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonArray value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    value.writeTo(this);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonPrimitive value) throws",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeBoolean(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNull();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeString(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonObject value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    value.write(this);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonArray value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    value.write(this);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonPrimitive value) throws IOException",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeBoolean(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNull();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeString(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonObject value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    value.write(this);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonArray value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    value.write(this);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter object() throws IOException {\n  if (def",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeBoolean(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNull();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeString(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonObject value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    value.write(this);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(JsonArray value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    value.write(this);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter object() throws IOException {\n  if (this",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNumber(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeBoolean(value);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeNull();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter name(String name) throws IOException {\n  writeDeferredName();\n  beforeName();\n  try {\n    out.writeFieldName(name);\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter object() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeStartObject();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter array() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  try {\n    out.writeStartArray();\n  } catch (IOException e) {\n    throw new JsonException(e);\n  }\n  return this;\n  }\n\n  public JsonWriter endObject() throws IOException {\n  writeDeferredName();\n  beforeValue();\n"
      ],
      "function range": "493,3-501,3"
    },
    "Gson_17_/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java_99-101": {
      "loc": "99-101",
      "input": "@Override\npublic Date read(JsonReader in) throws IOException {",
      "output": [
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.log",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\n",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.al",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.al",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.base.Operator",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.IV"
      ],
      "function range": "97,3-113,3"
    },
    "JacksonCore_5_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-194": {
      "loc": "193-194",
      "input": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {",
      "output": [
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.Logical",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.Log",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.util.JavaDataModel;\nimport org.apache.hadoop.",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.serde2.io.HiveDecimalWritable;\nimport org.apache"
      ],
      "function range": "185,5-205,5"
    },
    "JacksonCore_6_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-195": {
      "loc": "193-195",
      "input": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }",
      "output": [
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    if (str.charAt(0) < '0' || str.charAt(0) > '9') {\n        return -1;\n    }\n    if (str.charAt(len - 1) < '0' || str.charAt(len - 1) > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len - 1; i++) {\n        if (str.charAt(i) < '0' || str.charAt(i) > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    if (str.charAt(0) < '0' || str.charAt(0) > '9') {\n        return -1;\n    }\n    if (str.charAt(len - 1) < '0' || str.charAt(len - 1) > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len - 1; i++) {\n        if (str.charAt(i) < '0' || str.charAt(i) > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    if (str.charAt(0) < '0' || str.charAt(0) > '9') {\n        return -1;\n    }\n    if (str.charAt(len - 1) < '0' || str.charAt(len - 1) > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len - 1; ++i) {\n        if (str.charAt(i) < '0' || str.charAt(i) > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    if (str.charAt(0) < '0' || str.charAt(0) > '9') {\n        return -1;\n    }\n    if (str.charAt(len - 1) < '0' || str.charAt(len - 1) > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len - 1; ++i) {\n        if (str.charAt(i) < '0' || str.charAt(i) > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRow",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    if (str.charAt(0) < '0' || str.charAt(0) > '9') {\n        return -1;\n    }\n    if (str.charAt(len - 1) < '0' || str.charAt(len - 1) > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len - 1; ++i) {\n        if (str.charAt(i) < '0' || str.charAt(i) > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRow",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    if (str.charAt(0) < '0' || str.charAt(0) > '9') {\n        return -1;\n    }\n    if (str.charAt(len - 1) < '0' || str.charAt(len - 1) > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len - 1; i++) {\n        if (str.charAt(i) < '0' || str.charAt(i) > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    if (str.charAt(0) < '0' || str.charAt(0) > '9') {\n        return -1;\n    }\n    if (str.charAt(len - 1) < '0' || str.charAt(len - 1) > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len - 1; i++) {\n        if (str.charAt(i) < '0' || str.charAt(i) > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    if (str.charAt(0) < '0' || str.charAt(0) > '9') {\n        return -1;\n    }\n    if (str.charAt(len - 1) < '0' || str.charAt(len - 1) > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len - 1; i++) {\n        if (str.charAt(i) < '0' || str.charAt(i) > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\n",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    if (str.charAt(0) < '0' || str.charAt(0) > '9') {\n        return -1;\n    }\n    if (str.charAt(len - 1) < '0' || str.charAt(len - 1) > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len - 1; i++) {\n        if (str.charAt(i) < '0' || str.charAt(i) > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    if (str.charAt(0) < '0' || str.charAt(0) > '9') {\n        return -1;\n    }\n    if (str.charAt(len - 1) < '0' || str.charAt(len - 1) > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len - 1; i++) {\n        if (str.charAt(i) < '0' || str.charAt(i) > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.aggregation.datasketches.theta;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.common.base.Preconditions;\nimport com.google.common.primitives.Doubles;\nimport org."
      ],
      "function range": "185,5-206,5"
    },
    "JacksonCore_8_/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java_307-308": {
      "loc": "307-308",
      "input": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray != null)  return _resultArray;\n    if (_resultString != null) {\n        return (_resultArray = _resultString.toCharArray());\n    }",
      "output": [
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.Logical",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.al",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoin",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnn",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnn"
      ],
      "function range": "298,5-310,5"
    },
    "JacksonCore_20_/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java_1330-1331": {
      "loc": "1330-1331",
      "input": "public void writeEmbeddedObject(Object object) throws IOException {",
      "output": [
        "public void writeEmbeddedObject(Object object) throws IOException {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void close() throws IOException {\n        throw new UnsupportedOperationException();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void close() throws IOException {\n        throw new UnsupportedOperationException();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void close() throws IOException {\n        throw new UnsupportedOperationException();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void close() throws IOException {\n        throw new UnsupportedOperationException();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.h",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void close() throws IOException {\n        throw new UnsupportedOperationException();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.al",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void close() throws IOException {\n        throw new UnsupportedOperationException();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void close() throws IOException {\n        throw new UnsupportedOperationException();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void close() throws IOException {\n        throw new UnsupportedOperationException();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.al",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void close() throws IOException {\n        throw new UnsupportedOperationException();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyr",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void close() throws IOException {\n        throw new UnsupportedOperationException();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOper"
      ],
      "function range": "1328,5-1332,5"
    },
    "JacksonCore_25_/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java_1963-1964": {
      "loc": "1963-1964",
      "input": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;",
      "output": [
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7F);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7FF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (0xC0 | (c >> 6));\n            outBuf[outPtr++] = (char) (0x80 | (c & 0x3F));\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0xFFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (0xE0 | (c >> 12));\n            outBuf[outPtr++] = (char) (0x80 | ((c >> 6) & 0x3F));\n            outBuf[outPtr++] = (char) (0x80 | (c & 0x3F",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7F);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (c & 0x7F);\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7FF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (c & 0x7FF);\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0xFFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (c & 0xFFFF);\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x1FFFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (c & 0x1FFFFF);",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7F);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7FF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0xFFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x1FFFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x3FFFFFF);\n        if (i < max",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7F);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (c & 0x7F);\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7FF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (c & 0x7FF);\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0xFFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (c & 0x7FFF);\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x1FFFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (c & 0x7FFFF",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7F);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) i;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7FF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) i;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0xFFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) i;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x1FFFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) i;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7F);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7FF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0xFFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x1FFFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7F);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7FF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (0xC0 | (c >> 6));\n            outBuf[outPtr++] = (char) (0x80 | (c & 0x3F));\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0xFFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (0xE0 | (c >> 12));\n            outBuf[outPtr++] = (char) (0x80 | ((c >> 6) & 0x3F));\n            outBuf[outPtr++] = (char) (0x80 | ((c ) & 0x3",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7F);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7FF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (0xC0 | (c >> 6));\n            outBuf[outPtr++] = (char) (0x80 | (c & 0x3F));\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0xFFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (0xE0 | (c >> 12));\n            outBuf[outPtr++] = (char) (0x80 | ((c >> 6) & 0x3F));\n            outBuf[outPtr++] = (char) (0x80 | ((c) & 0x3",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7F);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7FF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (0xC0 | (c >> 6));\n            outBuf[outPtr++] = (char) (0x80 | (c & 0x3F));\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0xFFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = (char) (0xE0 | (c >> 12));\n            outBuf[outPtr++] = (char) (0x80 | ((c >> 6) & 0x3F));\n            outBuf[outPtr++] = (char) (0x80 | ((c >> 0) & 0",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7F);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7FF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7FFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7FFFFFF);\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            outBuf[outPtr++] = c;\n            _inputPtr++;\n            continue;\n        }\n        i = (int) (c & 0x7FFFFFFFF);\n        if (i <"
      ],
      "function range": "1948,5-1990,5"
    },
    "JacksonDatabind_12_/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java_303-304": {
      "loc": "303-304",
      "input": "@Override\npublic boolean isCachable() {",
      "output": [
        "@Override\npublic boolean isCachable() {\n\treturn true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators",
        "@Override\npublic boolean isCachable() {\n\treturn true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.h",
        "@Override\npublic boolean isCachable() {\n\treturn true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical",
        "@Override\npublic boolean isCachable() {\n\treturn true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.algebricks.core",
        "@Override\npublic boolean isCachable() {\n\treturn true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.Abstract",
        "@Override\npublic boolean isCachable() {\n\treturn true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLog",
        "@Override\npublic boolean isCachable() {\n\treturn true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression",
        "@Override\npublic boolean isCachable() {\n\treturn true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExp",
        "@Override\npublic boolean isCachable() {\n\treturn true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.VariableReference",
        "@Override\npublic boolean isCachable() {\n\treturn true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.Variable"
      ],
      "function range": "298,5-305,5"
    },
    "JacksonDatabind_16_/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java_112-113": {
      "loc": "112-113",
      "input": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);",
      "output": [
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        if (previous.equals(ann)) {\n            return false;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.equals(ann)) {\n            return true;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(annType);\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.equals(annType)) {\n            return true;\n        } else {\n            _annotations.put(annType, previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final boolean _contains(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(annType);\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return null;\n",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        if (previous.equals(ann)) {\n            return false;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.equals(ann)) {\n            return true;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(annType);\n    if (previous == null) {\n        return false;\n    } else {\n        return true;\n    }\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final boolean _contains(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(annType);\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return null;\n    }\n    return _annotations.get(annType);\n  }\n\n  protected final Annotation _get(Annotation ann) {\n    if (_annotations == null)",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        if (previous.equals(ann)) {\n            return false;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.equals(ann)) {\n            return true;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(annType);\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.equals(annType)) {\n            return true;\n        } else {\n            _annotations.put(annType, previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final boolean _contains(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(annType);\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annType) {\n    return _annotations.get(annType);\n  }\n\n",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        if (previous.equals(ann)) {\n            return false;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.equals(ann)) {\n            return true;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(annType);\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.annotationType().equals(annType)) {\n            return true;\n        } else {\n            _annotations.put(annType, previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final boolean _contains(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(annType);\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        ",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        if (previous.equals(ann)) {\n            return false;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.equals(ann)) {\n            return true;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(annType);\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.equals(annType)) {\n            return true;\n        } else {\n            _annotations.put(annType, previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final boolean _contains(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(annType);\n  }\n\n  protected final boolean _containsAll(Annotation[] anns) {\n    if (_annotations == null) {\n        return false;\n    }",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        if (previous.equals(ann)) {\n            return false;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.equals(ann)) {\n            return true;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(annType);\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.equals(annType)) {\n            return true;\n        } else {\n            _annotations.put(annType, previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final boolean _contains(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(annType);\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annType) {\n    return _annotations == null? null : _annotations.get",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        if (previous.equals(ann)) {\n            return false;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.equals(ann)) {\n            return true;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(annType);\n    if (previous == null) {\n        return false;\n    } else {\n        return true;\n    }\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final boolean _contains(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(annType);\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return null;\n    }\n    return _annotations.get(annType);\n  }\n\n  protected final Annotation[] _getAnnotations() {\n    if (_annotations == null) {",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        if (previous.equals(ann)) {\n            return false;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.equals(ann)) {\n            return true;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(annType);\n    if (previous == null) {\n        return false;\n    } else {\n        return true;\n    }\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final boolean _contains(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(annType);\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return null;\n    }\n    return _annotations.get(annType);\n  }\n\n  protected final Map<Class<? extends Annotation>,Annotation> _annotations() {\n    return",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        if (previous.equals(ann)) {\n            return false;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.equals(ann)) {\n            return true;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(annType);\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.annotationType().equals(annType)) {\n            return true;\n        } else {\n            _annotations.put(annType, previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final boolean _contains(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(annType);\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annType) {\n    return _annotations.get(annType);",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        if (previous.equals(ann)) {\n            return false;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.equals(ann)) {\n            return true;\n        } else {\n            _annotations.put(ann.annotationType(), previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _remove(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    Annotation previous = _annotations.remove(annType);\n    if (previous == null) {\n        return false;\n    } else {\n        if (previous.equals(annType)) {\n            return true;\n        } else {\n            _annotations.put(annType, previous);\n        }\n    }\n    return true;\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final boolean _contains(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n        return false;\n    }\n    return _annotations.containsKey(annType);\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annType) {\n    return _annotations.get(annType);\n  }\n"
      ],
      "function range": "107,5-113,5"
    },
    "JacksonDatabind_17_/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java_180-181": {
      "loc": "180-181",
      "input": "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()",
      "output": [
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyr",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyr",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.h",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.al",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core."
      ],
      "function range": "167,9-193,9"
    },
    "JacksonDatabind_27_/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java_794-795": {
      "loc": "794-795",
      "input": "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {",
      "output": [
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"expected JSON Object\");\n    }\n    t = p.nextToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"expected JSON Object\");\n    }\n    t = p.nextToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"expected JSON Object\");\n    }\n    t = p.nextToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    if (t!= JsonToken.END_OBJECT) {\n        throw c",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"expected JSON Object\");\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_ARRAY, \"expected JSON Array\");\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_ARRAY) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.VALUE_STRING) {\n        throw ctxt.wrongTokenException(p, JsonToken.VALUE_STRING, \"expected JSON String\");",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"expected JSON Object\");\n    }\n    t = p.nextToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    if (t == JsonToken.END_OBJECT) {\n        t =",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"expected JSON Object\");\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_ARRAY, \"expected JSON Array\");\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_ARRAY) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.VALUE_EMBEDDED_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.VALUE_EMB",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"expected JSON Object\");\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_ARRAY, \"expected JSON Array\");\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_ARRAY) {\n        t = p.nextToken();\n    }\n    if (t!= null) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \"expected end of JSON Array\");\n    }\n    ",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"expected JSON Object\");\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_ARRAY, \"expected JSON Array\");\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_ARRAY) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.VALUE_NUMBER_INT) {\n        throw ctxt.wrongTokenException(p, JsonToken.VALUE_NUMBER_INT, \"",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"expected JSON Object\");\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_ARRAY, \"expected JSON Array\");\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_ARRAY) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.VALUE_STRING) {\n        throw ctxt.wrongTokenException(p, JsonToken.VALUE_STRING,\n                \"expected JSON",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"expected JSON Object\");\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_OBJECT) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.START_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.START_ARRAY, \"expected JSON Array\");\n    }\n    t = p.nextToken();\n    if (t == JsonToken.END_ARRAY) {\n        t = p.nextToken();\n    }\n    if (t!= JsonToken.VALUE_STRING) {\n        throw ctxt.wrongTokenException(p, JsonToken.VALUE_STRING, \"expected JSON String value"
      ],
      "function range": "773,5-857,5"
    },
    "JacksonDatabind_33_/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java_748-749": {
      "loc": "748-749",
      "input": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg != null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann != null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)",
      "output": [
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForMerge(Annotated a)\n{\n    String name = null;\n    JsonMerge merge = _findAnnotation(a, JsonMerge.class);\n    if (merge!= null) {\n        name = merge.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForMerging(Annotated a)\n{\n    String name = null;\n    JsonMerge merge = _findAnnotation(a, JsonMerge.class);\n    if (merge!= null) {\n        name = merge.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonDeserialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForMerging(Annotated a)\n{\n    String name = null;\n    JsonMerge merge = _findAnnotation(a, JsonMerge.class);\n    if (merge!= null) {\n        name = merge.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForMerge(Annotated a)\n{\n    String name = null;\n    JsonMerge merger = _findAnnotation(a, JsonMerge.class);\n    if (merger!= null) {\n        name = merger.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonDeserialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForMerge(Annotated a)\n{\n    String name = null;\n    JsonMerge merge = _findAnnotation(a, JsonMerge.class);\n    if (merge!= null) {\n        name = merge.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonDeserialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForMerge(Annotated a)\n{\n    String name = null;\n    JsonMerge merger = _findAnnotation(a, JsonMerge.class);\n    if (merger!= null) {\n        name = merger.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForMerge(Annotated a)\n{\n    String name = null;\n    JsonMerge merge = _findAnnotation(a, JsonMerge.class);\n    if (merge!= null) {\n        name = merge.value();\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForCreation(Annotated a)\n{",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonDeserialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForMerging(Annotated a)\n{\n    String name = null;\n    JsonMerge merge = _findAnnotation(a, JsonMerge.class);\n    if (merge!= null) {\n        name = merge.value();\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForTypeId(Annotated a)\n",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForMerging(Annotated a)\n{\n    String name = null;\n    JsonMerge merge = _findAnnotation(a, JsonMerge.class);\n    if (merge!= null) {\n        name = merge.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.name",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonFormat.class)) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForMerge(Annotated a)\n{\n    String name = null;\n    JsonMerge merge = _findAnnotation(a, JsonMerge.class);\n    if (merge!= null) {\n        name = merge.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.name"
      ],
      "function range": "730,5-755,5"
    },
    "JacksonDatabind_34_/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java_81-82": {
      "loc": "81-82",
      "input": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {",
      "output": [
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == Double.TYPE) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.TYPE) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.TYPE) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        ",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == Double.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        ",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == BigDecimal.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.FL",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == BigDecimal.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Double.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == AtomicInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == AtomicLong.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == BigDecimal.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIM",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == Double.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        }",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == Double.TYPE) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.TYPE) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.TYPE) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        }",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == BigDecimal.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            visitor.unknownFormat(typeHint);\n        }\n    }\n}\n}\n<|",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == BigDecimal.class) {\n            visitDecimalFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            visitor.unknownFormat(typeHint);\n        }\n    }\n}\n\n@Override\npublic"
      ],
      "function range": "73,5-87,5"
    },
    "JacksonDatabind_37_/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java_135-136": {
      "loc": "135-136",
      "input": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }",
      "output": [
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    } else {\n        return super._narrow(subclass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentType);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentType);\n    }\n}\n\n@Override\npublic int hashCode()\n{\n    return _class.hashCode();\n}\n\n@Override\npublic boolean equals(Object o)\n{\n    if (o == this) {\n        return true;\n    }\n    if (o == null) {\n        return false;\n    }\n    if (o.getClass()!= getClass()) {\n        return false;\n    }\n    JavaType other = (JavaType) o;\n    return _class.equals(other._class);\n}\n\n@Override\npublic String toString()\n{\n    return _class.getName();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    } else {\n        return super._narrow(subclass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentType);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentType);\n    }\n}\n\n@Override\npublic int hashCode()\n{\n    return _class.hashCode();\n}\n\n@Override\npublic boolean equals(Object o)\n{\n    if (o == this) {\n        return true;\n    }\n    if (o == null) {\n        return false;\n    }\n    if (o.getClass()!= getClass()) {\n        return false;\n    }\n    JavaType other = (JavaType) o;\n    return _class.equals(other._class);\n}\n\n@Override\npublic String toString()\n{\n    return _class.getName();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    } else {\n        return super._narrow(subclass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentType);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentType);\n    }\n}\n\n@Override\npublic int hashCode()\n{\n    return _class.hashCode();\n}\n\n@Override\npublic boolean equals(Object o)\n{\n    if (o == this) {\n        return true;\n    }\n    if (o == null) {\n        return false;\n    }\n    if (o.getClass()!= getClass()) {\n        return false;\n    }\n    JavaType other = (JavaType) o;\n    return _class.equals(other._class);\n}\n\n@Override\npublic String toString()\n{\n    return _class.getName();\n}\n\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    } else {\n        return super._narrow(subclass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentType);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentType);\n    }\n}\n\n@Override\npublic int hashCode()\n{\n    return _class.hashCode();\n}\n\n@Override\npublic boolean equals(Object o)\n{\n    if (o == this) {\n        return true;\n    }\n    if (o == null) {\n        return false;\n    }\n    if (o.getClass()!= getClass()) {\n        return false;\n    }\n    JavaType other = (JavaType) o;\n    return _class.equals(other._class);\n}\n\n@Override\npublic String toString()\n{\n    return _class.getName();\n}\n\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    } else {\n        return super._narrow(subclass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentType);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentType);\n    }\n}\n\n@Override\npublic int hashCode()\n{\n    return _class.hashCode();\n}\n\n@Override\npublic boolean equals(Object o)\n{\n    if (o == this) {\n        return true;\n    }\n    if (o == null) {\n        return false;\n    }\n    if (o.getClass()!= getClass()) {\n        return false;\n    }\n    JavaType other = (JavaType) o;\n    return _class == other._class;\n}\n\n@Override\npublic String toString()\n{\n    return \"[JavaType \" + _class.getName() + \"]\";\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    } else {\n        return super._narrow(subclass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentType);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentType);\n    }\n}\n\n@Override\npublic int hashCode()\n{\n    return _class.hashCode();\n}\n\n@Override\npublic boolean equals(Object o)\n{\n    if (o == this) {\n        return true;\n    }\n    if (o == null) {\n        return false;\n    }\n    if (o.getClass()!= getClass()) {\n        return false;\n    }\n    JavaType other = (JavaType) o;\n    return _class == other._class;\n}\n\n@Override\npublic String toString()\n{\n    return \"[JavaType \" + _class.getName() + \"]\";\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    } else {\n        return super._narrow(subclass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentType);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentType);\n    }\n}\n\n@Override\npublic int hashCode()\n{\n    return _class.hashCode();\n}\n\n@Override\npublic boolean equals(Object o)\n{\n    if (o == this) {\n        return true;\n    }\n    if (o == null) {\n        return false;\n    }\n    if (o.getClass()!= getClass()) {\n        return false;\n    }\n    JavaType other = (JavaType) o;\n    return _class.equals(other._class);\n}\n\n@Override\npublic String toString()\n{\n    return \"[JavaType \" + _class.getName() + \"]\";\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    } else {\n        return super._narrow(subclass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentType);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentType);\n    }\n}\n\n@Override\npublic int hashCode()\n{\n    return _class.hashCode();\n}\n\n@Override\npublic boolean equals(Object o)\n{\n    if (o == this) {\n        return true;\n    }\n    if (o == null) {\n        return false;\n    }\n    if (o.getClass()!= getClass()) {\n        return false;\n    }\n    JavaType other = (JavaType) o;\n    return _class.equals(other._class);\n}\n\n@Override\npublic String toString()\n{\n    return \"[JavaType \" + _class.getName() + \"]\";\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    } else {\n        return super._narrow(subclass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentType);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentType);\n    }\n}\n\n@Override\npublic int hashCode()\n{\n    return _class.hashCode();\n}\n\n@Override\npublic boolean equals(Object o)\n{\n    if (o == this) {\n        return true;\n    }\n    if (o == null) {\n        return false;\n    }\n    if (o.getClass()!= getClass()) {\n        return false;\n    }\n    JavaType other = (JavaType) o;\n    return _class.equals(other._class);\n}\n\n@Override\npublic String toString()\n{\n    return _class.getName();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    } else {\n        return super._narrow(subclass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.narrowContentsBy(contentType);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(Class<?> contentClass)\n{\n    if (_class == contentClass) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentClass);\n    }\n}\n\n@Override\npublic JavaType widenContentsBy(JavaType contentType)\n{\n    if (_class == contentType.getRawClass()) {\n        return this;\n    } else {\n        return super.widenContentsBy(contentType);\n    }\n}\n\n@Override\npublic int hashCode()\n{\n    return _class.hashCode();\n}\n\n@Override\npublic boolean equals(Object o)\n{\n    if (o == this) {\n        return true;\n    }\n    if (o == null) {\n        return false;\n    }\n    if (o.getClass()!= getClass()) {\n        return false;\n    }\n    JavaType other = (JavaType) o;\n    return _class.equals(other._class);\n}\n\n@Override\npublic String toString()\n{\n    return _class.getName();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this"
      ],
      "function range": "119,5-137,5"
    },
    "JacksonDatabind_45_/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java_63-64": {
      "loc": "63-64",
      "input": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property != null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format != null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }",
      "output": [
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algeb",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.al",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.Log",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algeb",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks"
      ],
      "function range": "49,5-81,5"
    },
    "JacksonDatabind_46_/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java_156-157": {
      "loc": "156-157",
      "input": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);",
      "output": [
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getGenericSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic String toString()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.toString(sb);\n    sb.append(\">;\");\n    return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getGenericSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic String toString()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.toString(sb);\n    sb.append(\">;\");\n    return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/L",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getGenericSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic String toString()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.toString(sb);\n    sb.append(\">;\");\n    return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/L",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getGenericSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic String toString()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.toString(sb);\n    sb.append(\">;\");\n    return sb.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getGenericSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic String toString()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.toString(sb);\n    sb.append(\">;\");\n    return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getGenericSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic String toString()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.toString(sb);\n    sb.append(\">;\");\n    return sb.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LIC",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getGenericSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic String toString()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.toString(sb);\n    sb.append(\">;\");\n    return sb.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LIC",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getGenericSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic String toString()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.toString(sb);\n    sb.append(\">;\");\n    return sb.toString();\n}\n\n@Override\npublic int hashCode()\n{\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((_class == null)? 0 : _class.hashCode());\n    result = prime * result + ((_referencedType == null)? 0 : _referencedType.hashCode());\n    return result;\n}\n\n@Override\npublic boolean equals(Object obj)\n{\n    if (this == obj)\n    {\n        return true;\n    }\n    if",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getGenericSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic String toString()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.toString(sb);\n    sb.append(\">;\");\n    return sb.toString();\n}\n\n@Override\npublic int hashCode()\n{\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((_class == null)? 0 : _class.hashCode());\n    result = prime * result + ((_referencedType == null)? 0 : _referencedType.hashCode());\n    return result;\n}\n\n@Override\npublic boolean equals(Object obj)\n{\n    if (this == obj)\n        return true;\n    if (obj == null)\n",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getGenericSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic StringBuilder getSignature()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.getSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}\n\n@Override\npublic String toString()\n{\n    StringBuilder sb = new StringBuilder();\n    _classSignature(_class, sb, true);\n    sb.append('<');\n    sb = _referencedType.toString(sb);\n    sb.append(\">;\");\n    return sb.toString();\n}\n\n@Override\npublic int hashCode()\n{\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((_class == null)? 0 : _class.hashCode());\n    result = prime * result + ((_referencedType == null)? 0 : _referencedType.hashCode());\n    return result;\n}\n\n@Override\npublic boolean equals(Object obj)\n{\n    if (this == obj) {\n        return true;\n    }\n    if (obj"
      ],
      "function range": "150,5-158,5"
    },
    "JacksonDatabind_57_/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java_1441-1442": {
      "loc": "1441-1442",
      "input": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders != null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }",
      "output": [
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(InputStream src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(InputStream src, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, length), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Reader src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Reader src, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, length), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(String src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return super.readValues(src, offset, length);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(byte[] src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(InputStream src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Reader src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(char[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return super.readValues(src, offset, length);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(String src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormat",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(InputStream src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(InputStream src, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, length), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Reader src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Reader src, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, length), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(JsonParser p)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(p), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return super.readValues(src, offset, length);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(byte[] src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(InputStream src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Reader src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(String src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(JsonParser p)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(p), false);\n    }",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return super.readValues(src, offset, length);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(byte[] src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(InputStream src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Reader src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(char[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return super.readValues(src, offset, length);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(char[] src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_data",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return super.readValues(src, offset, length);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(InputStream src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Reader src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(char[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return super.readValues(src, offset, length);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(String src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(JsonParser p)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_data",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(InputStream src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(InputStream src, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, length), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Reader src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Reader src, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, length), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(byte[] src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return super.readValues(src, offset, length);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(InputStream src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Reader src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(char[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return super.readValues(src, offset, length);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(String src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(String src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAnd",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(InputStream src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(InputStream src, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, length), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Reader src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Reader src, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, length), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Object src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return null;\n}\n\n@Override\npublic <T> MappingIterator<T",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return super.readValues(src, offset, length);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(InputStream src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Reader src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(char[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return super.readValues(src, offset, length);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(String src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n    return super.readValues(src);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(String src, Charset encoding)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndRead"
      ],
      "function range": "1435,5-1443,5"
    },
    "JacksonDatabind_70_/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java_440-441": {
      "loc": "440-441",
      "input": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {",
      "output": [
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(getPropertyName(prop))) {\n                props.add(prop);\n                found = true;\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    if (found) {\n        _size -= props.size();\n        for (int i = 0, end = props.size(); i < end; i++) {\n            SettableBeanProperty prop = props.get(i);\n            _hashArea[prop.getIndex()] = null;\n        }\n    }\n}\n\nprivate String getPropertyName(SettableBeanProperty prop)\n{\n    return prop.getName();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.dru",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(getPropertyName(prop))) {\n                props.add(prop);\n                found = true;\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    if (found) {\n        _size -= props.size();\n        for (int i = 0, end = props.size(); i < end; i++) {\n            SettableBeanProperty prop = props.get(i);\n            _hashArea[prop.getIndex()] = null;\n        }\n    }\n}\n\nprivate String getPropertyName(SettableBeanProperty prop)\n{\n    return prop.getName();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(getPropertyName(prop))) {\n                props.add(prop);\n                found = true;\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    if (found) {\n        _size -= props.size();\n        for (int i = 0, end = props.size(); i < end; i++) {\n            SettableBeanProperty prop = props.get(i);\n            _hashArea[prop.getIndex()] = null;\n        }\n    }\n}\n\nprivate String getPropertyName(SettableBeanProperty prop)\n{\n    return prop.getName();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(getPropertyName(prop))) {\n                props.add(prop);\n                found = true;\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    if (found) {\n        _size -= props.size();\n        for (int i = 0, end = props.size(); i < end; i++) {\n            SettableBeanProperty prop = props.get(i);\n            _hashArea[prop.getIndex()] = null;\n        }\n    }\n}\n\nprivate String getPropertyName(SettableBeanProperty prop)\n{\n    return prop.getName();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.h",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(getPropertyName(prop))) {\n                props.add(prop);\n                found = true;\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    if (found) {\n        _size -= props.size();\n        for (int i = 0, end = props.size(); i < end; i++) {\n            SettableBeanProperty prop = props.get(i);\n            _hashArea[prop.getIndex()] = null;\n        }\n    }\n}\n\nprivate String getPropertyName(SettableBeanProperty prop)\n{\n    return prop.getName();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.flink.runtime.",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(getPropertyName(prop))) {\n                props.add(prop);\n                found = true;\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    if (found) {\n        _size -= props.size();\n        for (int i = 0, end = props.size(); i < end; ++i) {\n            SettableBeanProperty prop = props.get(i);\n            _hashArea[prop.getIndex()] = null;\n        }\n    }\n}\n\nprivate String getPropertyName(SettableBeanProperty prop)\n{\n    return prop.getName();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(getPropertyName(prop))) {\n                props.add(prop);\n                found = true;\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    if (found) {\n        _size -= props.size();\n        for (int i = 0, end = props.size(); i < end; i++) {\n            SettableBeanProperty prop = props.get(i);\n            _hashArea[prop.getIndex()] = null;\n        }\n    }\n}\n\nprivate String getPropertyName(SettableBeanProperty prop)\n{\n    return prop.getName();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.sling.",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(getPropertyName(prop))) {\n                props.add(prop);\n                found = true;\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    if (found) {\n        _size -= props.size();\n        for (int i = 0, end = props.size(); i < end; ++i) {\n            SettableBeanProperty prop = props.get(i);\n            _hashArea[prop.getIndex()] = null;\n        }\n    }\n}\n\nprivate String getPropertyName(SettableBeanProperty prop)\n{\n    return prop.getName();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyr",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(getPropertyName(prop))) {\n                props.add(prop);\n                found = true;\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    if (found) {\n        _size -= props.size();\n        for (int i = 0, end = props.size(); i < end; ++i) {\n            SettableBeanProperty prop = props.get(i);\n            _hashArea[prop.getIndex()] = null;\n        }\n    }\n}\n\nprivate String getPropertyName(SettableBeanProperty prop)\n{\n    return prop.getName();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.flink.runtime",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(getPropertyName(prop))) {\n                props.add(prop);\n                found = true;\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    if (found) {\n        _size -= props.size();\n        for (int i = 0, end = props.size(); i < end; ++i) {\n            SettableBeanProperty prop = props.get(i);\n            _hashArea[prop.getIndex()] = null;\n        }\n    }\n}\n\nprivate String getPropertyName(SettableBeanProperty prop)\n{\n    return prop.getName();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.sling"
      ],
      "function range": "426,5-453,5"
    },
    "JacksonDatabind_71_/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java_75-76": {
      "loc": "75-76",
      "input": "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;",
      "output": [
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHAR;\n    } else if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == UUID.class) {\n        kind = StdKeyDeserializer.UUID;\n    } else if (raw == InetAddress.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = StdKeyDeserializer.INET_SOCKET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = StdKeyDeserializer.INET_4_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = StdKeyDeserializer.INET_6_ADDRESS;\n    } else if (raw == Inet",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHAR;\n    } else if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == UUID.class) {\n        kind = StdKeyDeserializer.UUID;\n    } else if (raw == InetAddress.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = StdKeyDeserializer.INET_SOCKET_ADDRESS;\n    } else if (raw == File.class) {\n        kind = StdKeyDeserializer.FILE;\n    } else if (raw == URI.class) {\n        kind = StdKeyDeserializer.URI;\n    } else if (raw == URL.class) {\n        kind = StdKeyDeserializer.URL;\n    } else",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHAR;\n    } else if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == UUID.class) {\n        kind = StdKeyDeserializer.UUID;\n    } else if (raw == InetAddress.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = StdKeyDeserializer.INET_SOCKET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHAR;\n    } else if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == UUID.class) {\n        kind = StdKeyDeserializer.UUID;\n    } else if (raw == InetAddress.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = StdKeyDeserializer.INET_SOCKET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = StdKeyDeserializer.INET4_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = StdKeyDeserializer.INET6_ADDRESS;\n    } else if (raw == InetSocketAddress",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHAR;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == Date.class) {\n        kind = StdKeyDeserializer.DATE;\n    } else if (raw == UUID.class) {\n        kind = StdKeyDeserializer.UUID;\n    } else if (raw == InetAddress.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = StdKeyDeserializer.INET_SOCKET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = St",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHAR;\n    } else if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == Date.class) {\n        kind = StdKeyDeserializer.DATE;\n    } else if (raw == UUID.class) {\n        kind = StdKeyDeserializer.UUID;\n    } else if (raw == InetAddress.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = StdKeyDeserializer.INET_SOCKET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = St",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHAR;\n    } else if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == Date.class) {\n        kind = StdKeyDeserializer.DATE;\n    } else if (raw == UUID.class) {\n        kind = StdKeyDeserializer.UUID;\n    } else if (raw == InetAddress.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = StdKeyDeserializer.INET_SOCKET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = St",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INTEGER;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHARACTER;\n    } else if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == Date.class) {\n        kind = StdKeyDeserializer.DATE;\n    } else if (raw == UUID.class) {\n        kind = StdKeyDeserializer.UUID;\n    } else if (raw == InetAddress.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = StdKeyDeserializer.INET_SOCKET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHAR;\n    } else if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == UUID.class) {\n        kind = StdKeyDeserializer.UUID;\n    } else if (raw == InetAddress.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = StdKeyDeserializer.INET_SOCKET_ADDRESS;\n    } else if (raw == File.class) {\n",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHAR;\n    } else if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == UUID.class) {\n        kind = StdKeyDeserializer.UUID;\n    } else if (raw == InetAddress.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = StdKeyDeserializer.INET_SOCKET_ADDRESS;\n    } else if (raw == InetSocketAddress.class"
      ],
      "function range": "70,5-116,5"
    },
    "JacksonDatabind_76_/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java_583-604": {
      "loc": "583-604",
      "input": "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {",
      "output": [
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            // [databind#################################################################################################################################################################################################################################################################################################################",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            buffer.assignParameter(propName, deserialize(p, ctxt));\n        }\n        t = p.nextToken();\n        if (t!= JsonToken.END_OBJECT) {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            t = p.nextToken();\n        }\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.getResult();\n}\n\n@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithWrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.next",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            buffer.assignParameter(propName, deserialize(p, ctxt));\n        }\n        t = p.nextToken();\n        if (t!= JsonToken.END_OBJECT) {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            t = p.nextToken();\n        }\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.getResult();\n}\n\n@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithWrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.nextToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            buffer.assignParameter(propName, deserialize(p, ctxt));\n        }\n        t = p.nextToken();\n        if (t!= JsonToken.END_OBJECT) {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            t = p.nextToken();\n        }\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.getResult();\n}\n\n@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithWrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartArray();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.next",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            buffer.assignParameter(propName, deserialize(p, ctxt));\n        }\n        t = p.nextToken();\n        if (t!= JsonToken.END_OBJECT) {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            t = p.nextToken();\n        }\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.getResult();\n}\n\n@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithWrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        t = p",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            buffer.assignParameter(propName, deserialize(p, ctxt));\n        }\n        t = p.nextToken();\n        if (t!= JsonToken.END_OBJECT) {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            t = p.nextToken();\n        }\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.getResult();\n}\n\n@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithWrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            buffer.assignParameter(propName, deserialize(p, ctxt));\n        }\n        t = p.nextToken();\n        if (t!= JsonToken.END_OBJECT) {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            t = p.nextToken();\n        }\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.getResult();\n}\n\n@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithWrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        Settable",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            buffer.assignParameter(propName, deserialize(p, ctxt));\n        }\n        t = p.nextToken();\n        if (t!= JsonToken.END_OBJECT) {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            t = p.nextToken();\n        }\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.getResult();\n}\n\n@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithWrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        tokens",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            buffer.assignParameter(propName, deserialize(p, ctxt));\n        }\n        t = p.nextToken();\n        if (t!= JsonToken.END_OBJECT) {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            t = p.nextToken();\n        }\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.getResult();\n}\n\n@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithWrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(prop",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n        } else {\n            buffer.assignParameter(propName, deserialize(p, ctxt));\n        }\n        t = p.nextToken();\n        if (t!= JsonToken.END_OBJECT) {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            t = p.nextToken();\n        }\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.getResult();\n}\n\n@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithWrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME || t == JsonToken.END_OBJECT; t = p.nextToken()) {\n        String propName ="
      ],
      "function range": "565,5-637,5"
    },
    "JacksonDatabind_82_/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java_495-496": {
      "loc": "495-496",
      "input": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n            ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n            .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);",
      "output": [
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // [databind###################################################################################################################################################################################################################################################################################################",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getIgnored();\n        } else {\n            ignored = Collections.emptySet();\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    JsonIncludeProperties.Value inclVals = ctxt.getConfig()\n           .getDefaultPropertyInclusion(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    if (inclVals!= null) {\n        builder.setInclude(inclVals.getInclude());\n        builder.setExclude(inclVals.getExclude());\n    } else {\n        builder.setInclude(JsonInclude.Include.USE_DEFAULTS);\n        builder.setExclude(JsonInclude.Include.USE_DEFAULTS);\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            final SettableBeanProperty prop = creatorProps[i];\n            if (ignored.contains(prop.getName())) {\n                continue;\n            }\n            builder.addProperty(prop);\n        }\n    }\n}\n}\n<",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getIgnored();\n        } else {\n            ignored = Collections.emptySet();\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    JsonIncludeProperties.Value inclVals = ctxt.getConfig()\n           .getDefaultPropertyInclusion(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    if (inclVals!= null) {\n        builder.setInclude(inclVals.getInclude());\n        builder.setExclude(inclVals.getExclude());\n    } else {\n        builder.setInclude(JsonInclude.Include.USE_DEFAULTS);\n        builder.setExclude(JsonInclude.Include.USE_DEFAULTS);\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            final SettableBeanProperty prop = creatorProps[i];\n            if (ignored.contains(prop.getName())) {\n                continue;\n            }\n            builder.addCreatorProperty(prop);\n        }\n    }\n}\n}\n",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getIgnored();\n        } else {\n            ignored = Collections.emptySet();\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    JsonIncludeProperties.Value inclVals = ctxt.getConfig()\n           .getDefaultPropertyInclusion(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    if (inclVals!= null) {\n        builder.setInclude(inclVals.getInclude());\n        builder.setExclude(inclVals.getExclude());\n    } else {\n        builder.setInclude(JsonInclude.Include.USE_DEFAULTS);\n        builder.setExclude(JsonInclude.Include.USE_DEFAULTS);\n    }\n    if (hasCreatorProps) {\n        for (SettableBeanProperty prop : creatorProps) {\n            if (ignored.contains(prop.getName())) {\n                continue;\n            }\n            builder.addCreatorProperty(prop);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getIgnored();\n        } else {\n            ignored = Collections.emptySet();\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    JsonIncludeProperties.Value inclVals = ctxt.getConfig()\n           .getDefaultPropertyInclusion(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    if (inclVals!= null) {\n        builder.setInclude(inclVals.getInclude());\n        builder.setExclude(inclVals.getExclude());\n    } else {\n        builder.setInclude(JsonInclude.Include.USE_DEFAULTS);\n        builder.setExclude(JsonInclude.Include.USE_DEFAULTS);\n    }\n    if (hasCreatorProps) {\n        for (SettableBeanProperty prop : creatorProps) {\n            if (ignored.contains(prop.getName())) {\n                continue;\n            }\n            builder.addCreatorProperty(prop);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getIgnored();\n        } else {\n            ignored = Collections.emptySet();\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    JsonIncludeProperties.Value inclVals = ctxt.getConfig()\n           .getDefaultPropertyInclusion(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    if (inclVals!= null) {\n        builder.setInclude(inclVals.getInclude());\n        builder.setExclude(inclVals.getExclude());\n    } else {\n        builder.setInclude(JsonInclude.Include.USE_DEFAULTS);\n        builder.setExclude(JsonInclude.Include.USE_DEFAULTS);\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            final SettableBeanProperty prop = creatorProps[i];\n            if (ignored.contains(prop.getName())) {\n                continue;\n            }\n            builder.addProperty(prop);\n        }\n    } else {\n        for (S",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getIgnored();\n        } else {\n            ignored = Collections.emptySet();\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    JsonIncludeProperties.Value inclVals = ctxt.getConfig()\n           .getDefaultPropertyInclusion(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    if (inclVals!= null) {\n        builder.setInclude(inclVals.getInclude());\n        builder.setExclude(inclVals.getExclude());\n    } else {\n        builder.setInclude(JsonInclude.Include.USE_DEFAULTS);\n        builder.setExclude(JsonInclude.Include.USE_DEFAULTS);\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            final SettableBeanProperty prop = creatorProps[i];\n            if (ignored.contains(prop.getName())) {\n                continue;\n            }\n            builder.addProperty(prop);\n        }\n    } else {\n        for (Be",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getIgnored();\n        } else {\n            ignored = Collections.emptySet();\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    JsonIncludeProperties.Value inclVals = ctxt.getConfig()\n           .getDefaultPropertyInclusion(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    if (inclVals!= null) {\n        builder.setInclude(inclVals.getInclude());\n        builder.setExclude(inclVals.getExclude());\n    } else {\n        builder.setInclude(JsonInclude.Include.USE_DEFAULTS);\n        builder.setExclude(JsonInclude.Include.USE_DEFAULTS);\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            final SettableBeanProperty prop = creatorProps[i];\n            if (ignored.contains(prop.getName())) {\n                continue;\n            }\n            builder.addProperty(prop);\n        }\n    } else {\n        for (Property",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getIgnored();\n        } else {\n            ignored = Collections.emptySet();\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    JsonIncludeProperties.Value inclVals = ctxt.getConfig()\n           .getDefaultPropertyInclusion(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    if (inclVals!= null) {\n        builder.setInclude(inclVals.getInclude());\n        builder.setExclude(inclVals.getExclude());\n    } else {\n        builder.setInclude(JsonInclude.Include.USE_DEFAULTS);\n        builder.setExclude(JsonInclude.Include.USE_DEFAULTS);\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            final SettableBeanProperty prop = creatorProps[i];\n            if (ignored.contains(prop.getName())) {\n                continue;\n            }\n            prop.deserializeAndSet(ctxt, builder);\n        }\n    }\n",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getIgnored();\n        } else {\n            ignored = Collections.emptySet();\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    JsonIncludeProperties.Value inclVals = ctxt.getConfig()\n           .getDefaultPropertyInclusion(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    if (inclVals!= null) {\n        builder.setInclude(inclVals.getInclude());\n        builder.setExclude(inclVals.getExclude());\n    } else {\n        builder.setInclude(JsonInclude.Include.USE_DEFAULTS);\n        builder.setExclude(JsonInclude.Include.USE_DEFAULTS);\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            final SettableBeanProperty prop = creatorProps[i];\n            if (ignored.contains(prop.getName())) {\n                continue;\n            }\n            builder.addCreatorProperty(prop);\n        }\n    }\n}\n\n}"
      ],
      "function range": "472,5-615,5"
    },
    "JacksonDatabind_93_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java_83-85": {
      "loc": "83-85",
      "input": "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }",
      "output": [
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        for (int i = 0, len = _cfgIllegalClassNames.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames2.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames2.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames3.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames3.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames4.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames4.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames5.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames5.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames6.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames6.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames7.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames7.get(",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        for (int i = 0, len = _cfgIllegalClassNames.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames2.size(); i < len; ++i) {\n            if (full.endsWith(_cfgIllegalClassNames2.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames3.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames3.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames4.size(); i < len; ++i) {\n            if (full.endsWith(_cfgIllegalClassNames4.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames5.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames5.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames6.size(); i < len; ++i) {\n            if (full.endsWith(_cfgIllegalClassNames6.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames7.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames7.get(i))) {",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        for (int i = 0, len = _cfgIllegalClassNames.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames2.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames2.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames3.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames3.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames4.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames4.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames5.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames5.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames6.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames6.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalPackageNames.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalPackageNames.get(i)))",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        for (int i = 0, len = _cfgIllegalClassNames.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames2.size(); i < len; ++i) {\n            if (full.endsWith(_cfgIllegalClassNames2.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames3.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames3.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames4.size(); i < len; ++i) {\n            if (full.endsWith(_cfgIllegalClassNames4.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames5.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames5.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames6.size(); i < len; ++i) {\n            if (full.endsWith(_cfgIllegalClassNames6.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames7.size(); i < len; ++i) {\n            if (full.contains(_cfgIllegalClassNames7.get(i))) {\n",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        for (int i = 0, len = _cfgIllegalClassNames.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames2.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames2.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames3.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames3.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames4.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames4.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames5.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames5.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames6.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames6.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames7.size(); i < len; ++i) {\n            if (full.equals(_cfgIllegalClassNames7.get(i",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        for (int i = 0, len = _cfgIllegalClassNames.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames2.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames2.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames3.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames3.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames4.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames4.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames5.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames5.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames6.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames6.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames7.size(); i < len; ++i) {\n            if (full.endsWith(_cfgIllegalClassNames7.get(i",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        for (int i = 0, len = _cfgIllegalClassNames.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames2.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames2.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames3.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames3.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames4.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames4.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames5.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames5.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames6.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames6.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames7.size(); i < len; ++i) {\n            if (full.contains(_cfgIllegalClassNames7.get(i",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        for (int i = 0, len = _cfgIllegalClassNames.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames2.size(); i < len; ++i) {\n            if (full.endsWith(_cfgIllegalClassNames2.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames3.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames3.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames4.size(); i < len; ++i) {\n            if (full.endsWith(_cfgIllegalClassNames4.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames5.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames5.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames6.size(); i < len; ++i) {\n            if (full.endsWith(_cfgIllegalClassNames6.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames7.size(); i < len; ++i) {\n            if (full.endsWith(_cfgIllegalClassNames7.get(i))) {\n",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        for (int i = 0, len = _cfgIllegalClassNames.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames2.size(); i < len; ++i) {\n            if (full.endsWith(_cfgIllegalClassNames2.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames3.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames3.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames4.size(); i < len; ++i) {\n            if (full.endsWith(_cfgIllegalClassNames4.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames5.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames5.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames6.size(); i < len; ++i) {\n            if (full.endsWith(_cfgIllegalClassNames6.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames7.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames7.get(i))\n",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        for (int i = 0, len = _cfgIllegalClassNames.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames2.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames2.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames3.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames3.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames4.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames4.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames5.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames5.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalClassNames6.size(); i < len; ++i) {\n            if (full.startsWith(_cfgIllegalClassNames6.get(i))) {\n                break main_check;\n            }\n        }\n        for (int i = 0, len = _cfgIllegalPackageNames.size(); i < len; ++i) {\n            String pkg = _cfgIllegalPackageNames.get(i);\n            if"
      ],
      "function range": "67,5-99,5"
    },
    "JacksonDatabind_96_/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java_735-736": {
      "loc": "735-736",
      "input": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1 != candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName != null) || (injectId != null);\n    if (!useProps && (paramDef != null)) {",
      "output": [
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        // [databind############################################################################################################################################################################################################################################",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) { // [databind##############################################################################################################################################################################################################################################",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        // [databind###################################################################################",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n        boolean useProps = (paramName!= null) || (injectId!= null);\n        if (!",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n        boolean useProps = (paramName!= null) || (injectId!= null);\n        \n        ",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n        boolean useProps = (paramName!= null) || (injectId!= null);\n        if (",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n        boolean useProps = (paramName!= null) || (injectId!= null);\n        boolean",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition propDef = candidate.propertyDef(0);\n        boolean useProps = (paramName!= null) || (injectId!= null);\n        if (!",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter delegateParam = candidate.parameter(0);\n        JacksonInject.Value delegateId = candidate.injection(0);\n        PropertyName delegateName = candidate.explicitParamName(0);\n        BeanPropertyDefinition delegateDef = candidate.propertyDef(0);\n        boolean useProps = (delegateName!= null) || (delegateId!= null);\n        ",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition propDef = candidate.propertyDef(0);\n        boolean useProps = (paramName!= null) || (injectId!= null);\n        \n        "
      ],
      "function range": "701,5-752,5"
    },
    "JacksonDatabind_97_/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java_114-115": {
      "loc": "114-115",
      "input": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {",
      "output": [
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException, JsonProcessingException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForScalar(this, gen);\n        gen.writeString(_value.toString());\n        typeSer.writeTypeSuffixForScalar(this, gen);\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n    throws JsonMappingException\n{\n    visitor.expectStringFormat(typeHint);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException, JsonProcessingException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForScalar(this, gen);\n        gen.writeString(_value.toString());\n        typeSer.writeTypeSuffixForScalar(this, gen);\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n    throws JsonMappingException\n{\n    visitor.expectStringFormat(typeHint);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForScalar(this, gen);\n        gen.writeString(_value.toString());\n        typeSer.writeTypeSuffixForScalar(this, gen);\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n{\n    JsonStringFormatVisitor v2 = visitor.expectStringFormat(typeHint);\n    if (v2!= null) {\n        v2.format(_value);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForScalar(this, gen);\n        gen.writeString(_value.toString());\n        typeSer.writeTypeSuffixForScalar(this, gen);\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n{\n    JsonStringFormatVisitor v2 = visitor.expectStringFormat(typeHint);\n    if (v2!= null) {\n        v2.format(_value);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException, JsonProcessingException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForScalar(this, gen);\n        gen.writeString(_value.toString());\n        typeSer.writeTypeSuffixForScalar(this, gen);\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n    throws JsonMappingException\n{\n    visitor.expectStringFormat(typeHint);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForScalar(this, gen);\n        gen.writeString(_value.toString());\n        typeSer.writeTypeSuffixForScalar(this, gen);\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n{\n    JsonStringFormatVisitor v2 = visitor.expectStringFormat(typeHint);\n    if (v2!= null) {\n        v2.format(_value);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForScalar(this, gen);\n        gen.writeString(_value.toString());\n        typeSer.writeTypeSuffixForScalar(this, gen);\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n{\n    JsonStringFormatVisitor v2 = visitor.expectStringFormat(typeHint);\n    if (v2!= null) {\n        v2.format(_value);\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForScalar(this, gen);\n        gen.writeString(_value.toString());\n        typeSer.writeTypeSuffixForScalar(this, gen);\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n{\n    JsonStringFormatVisitor v2 = visitor.expectStringFormat(typeHint);\n    if (v2!= null) {\n        v2.format(_value);\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForScalar(this, gen);\n        gen.writeString(_value.toString());\n        typeSer.writeTypeSuffixForScalar(this, gen);\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n{\n    JsonStringFormatVisitor v2 = visitor.expectStringFormat(typeHint);\n    if (v2!= null) {\n        v2.format(_value);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException, JsonProcessingException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForScalar(this, gen);\n        gen.writeString(_value.toString());\n        typeSer.writeTypeSuffixForScalar(this, gen);\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n    throws JsonMappingException\n{\n    visitor.expectStringFormat(typeHint);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n"
      ],
      "function range": "104,5-116,5"
    },
    "JacksonDatabind_98_/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java_298-299": {
      "loc": "298-299",
      "input": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {",
      "output": [
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\");",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.createUsingDelegate(values);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\");",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.createUsingDelegate(values);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n *",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file"
      ],
      "function range": "255,5-311,5"
    },
    "JacksonDatabind_102_/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java_67-70": {
      "loc": "67-70",
      "input": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{",
      "output": [
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonSerializer<?> ser = property.getSerializer();\n        if (ser!= null) {\n            return ser;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.oper",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonSerializer<?> ser = property.getSerializer();\n        if (ser!= null) {\n            return ser;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.alge",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonSerializer<?> ser = property.getSerializer();\n        if (ser!= null) {\n            return ser;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonSerializer<?> ser = property.getSerializer();\n        if (ser!= null) {\n            return ser;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonSerializer<?> ser = property.getSerializer();\n        if (ser!= null) {\n            return ser;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonSerializer<?> ser = property.getSerializer();\n        if (ser!= null) {\n            return ser;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonSerializer<?> ser = property.getSerializer();\n        if (ser!= null) {\n            return ser;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogical",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonSerializer<?> ser = property.getSerializer();\n        if (ser!= null) {\n            return ser;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonSerializer<?> ser = property.getSerializer();\n        if (ser!= null) {\n            return ser;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalExpressionTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.al",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonSerializer<?> ser = property.getSerializer();\n        if (ser!= null) {\n            return ser;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.express"
      ],
      "function range": "61,5-136,5"
    },
    "JacksonDatabind_107_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java_165-166": {
      "loc": "165-166",
      "input": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { ",
      "output": [
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    return null;\n                }\n                deser = _createImplDeserializer(ctxt, actual);\n            }\n        } else {\n            deser = _createImplDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n    \n    protected JsonDeserializer<Object> _createImplDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.findContextualValueDeserializer(type);\n        if (deser!= null) {\n            return deser;\n        }\n        return ctxt.handleSecondaryContextualization(deser, type);\n    }\n    \n    protected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.getDefaultImplDeserializer(Object.class);\n        if (deser!= null) {\n            return deser;\n        }\n        return ctxt.handleSecondaryContextualization(deser, Object.class);\n    }\n    \n    protected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws IOException\n    {\n        ",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    return null;\n                }\n                deser = _createImplDeserializer(ctxt, actual);\n            }\n        } else {\n            deser = _createImplDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n    \n    protected JsonDeserializer<Object> _createImplDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.findContextualValueDeserializer(type);\n        if (deser!= null) {\n            return deser;\n        }\n        return ctxt.handleSecondaryContextualization(deser, type);\n    }\n    \n    protected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.getDefaultImplDeserializer(Object.class);\n        if (deser!= null) {\n            return deser;\n        }\n        return ctxt.handleSecondaryContextualization(deser, Object.class);\n    }\n    \n    protected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws JsonMappingException\n    ",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    return null;\n                }\n                deser = _createImplDeserializer(ctxt, actual);\n            }\n        } else {\n            deser = _createImplDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n    \n    protected JsonDeserializer<Object> _createImplDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.findContextualValueDeserializer(type);\n        if (deser!= null) {\n            return deser;\n        }\n        return ctxt.handleSecondaryContextualization(deser, type);\n    }\n    \n    protected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.getDefaultImplDeserializer(Object.class);\n        if (deser!= null) {\n            return deser;\n        }\n        return ctxt.handleSecondaryContextualization(deser, Object.class);\n    }\n    \n    protected JsonDeserializer<Object> _handleUnknownTypeId(DeserializationContext ctxt,\n            String typeId)\n        th",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    return null;\n                }\n                deser = _createImplDeserializer(ctxt, actual);\n            }\n        } else {\n            deser = _createImplDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n    \n    protected JsonDeserializer<Object> _createImplDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.findContextualValueDeserializer(type);\n        if (deser!= null) {\n            return deser;\n        }\n        return ctxt.handleSecondaryContextualization(deser, type);\n    }\n    \n    protected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.getDefaultImplDeserializer(Object.class);\n        if (deser!= null) {\n            return deser;\n        }\n        return ctxt.handleSecondaryContextualization(deser, Object.class);\n    }\n    \n    protected JavaType _handleUnknownTypeId(DeserializationContext ctxt,\n            String typeId)\n        throws IOException\n    {",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    return null;\n                }\n                deser = _createImplDeserializer(ctxt, actual);\n            }\n        } else {\n            deser = _createImplDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n    \n    protected JsonDeserializer<Object> _createImplDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.findContextualValueDeserializer(type);\n        if (deser!= null) {\n            return deser;\n        }\n        return ctxt.handleSecondaryContextualization(deser, type);\n    }\n    \n    protected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.getDefaultImplDeserializer(Object.class);\n        if (deser!= null) {\n            return deser;\n        }\n        return ctxt.handleSecondaryContextualization(deser, Object.class);\n    }\n\n    protected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws JsonMappingException\n    {\n",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    return null;\n                }\n                deser = _createImplDeserializer(ctxt, actual);\n            }\n        } else {\n            deser = _createImplDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n    \n    protected JsonDeserializer<Object> _createImplDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.findContextualValueDeserializer(type);\n        if (deser!= null) {\n            return deser;\n        }\n        return ctxt.handleSecondaryContextualization(deser, type);\n    }\n    \n    protected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.getDefaultImplDeserializer(Object.class);\n        if (deser!= null) {\n            return deser;\n        }\n        return ctxt.handleSecondaryContextualization(deser, Object.class);\n    }\n    \n    protected JavaType _handleUnknownTypeId(DeserializationContext ctxt,\n            String typeId)\n        throws JsonMappingException",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    return null;\n                }\n                deser = _createImplDeserializer(ctxt, actual);\n            }\n        } else {\n            deser = _createImplDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n    \n    protected JsonDeserializer<Object> _createImplDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.findContextualValueDeserializer(type);\n        if (deser == null) {\n            deser = ctxt.handleSecondaryContextualization(deser, type);\n        }\n        return deser;\n    }\n    \n    protected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.getDefaultImplDeserializer(Object.class);\n        if (deser == null) {\n            deser = ctxt.handleSecondaryContextualization(deser, Object.class);\n        }\n        return deser;\n    }\n    \n    protected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws IOException\n",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    return null;\n                }\n                deser = _createImplDeserializer(ctxt, actual);\n            }\n        } else {\n            deser = _createImplDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected JsonDeserializer<Object> _createImplDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.findContextualValueDeserializer(type);\n        if (deser == null) {\n            deser = ctxt.handleSecondaryContextualization(deser, type);\n        }\n        return deser;\n    }\n    \n    protected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.getDefaultImplDeserializer(Object.class);\n        if (deser == null) {\n            deser = ctxt.handleSecondaryContextualization(deser, Object.class);\n        }\n        return deser;\n    }\n    \n    protected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws IOException\n    {",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    return null;\n                }\n                deser = _createImplDeserializer(ctxt, actual);\n            }\n        } else {\n            deser = _createImplDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n    \n    protected JsonDeserializer<Object> _createImplDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.findContextualValueDeserializer(type);\n        if (deser == null) {\n            deser = ctxt.handleSecondaryContextualization(deser, type);\n        }\n        return deser;\n    }\n    \n    protected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.getDefaultImplDeserializer(Object.class);\n        if (deser == null) {\n            deser = ctxt.handleSecondaryContextualization(deser, Object.class);\n        }\n        return deser;\n    }\n    \n    protected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws JsonM",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    return null;\n                }\n                deser = _createImplDeserializer(ctxt, actual);\n            }\n        } else {\n            deser = _createImplDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n    \n    protected JsonDeserializer<Object> _createImplDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.findContextualValueDeserializer(type);\n        if (deser!= null) {\n            return deser;\n        }\n        return ctxt.handleSecondaryContextualization(deser, type);\n    }\n    \n    protected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = ctxt.getDefaultImplDeserializer(Object.class);\n        if (deser!= null) {\n            return deser;\n        }\n        return ctxt.handleSecondaryContextualization(deser, Object.class);\n    }\n\n    protected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws IOException\n    {\n        // ["
      ],
      "function range": "146,5-199,5"
    },
    "JacksonXml_5_/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java_59-60": {
      "loc": "59-60",
      "input": "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);",
      "output": [
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n\n  @Override\n  public XmlSerializerProvider clone() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n\n  @Override\n  public XmlSerializerProvider copy() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n\n  @Override\n  public XmlSerializerProvider clone() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n\n  @Override\n  public XmlSerializerProvider copy() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n\n  @Override\n  public XmlSerializerProvider clone() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n\n  @Override\n  public XmlSerializerProvider clone() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.al",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n\n  @Override\n  public XmlSerializerProvider clone() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n\n  @Override\n  public XmlSerializerProvider clone() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n\n  @Override\n  public XmlSerializerProvider clone() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractBinaryJoinOperator;\nimport org",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n\n  @Override\n  public XmlSerializerProvider clone() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.Con"
      ],
      "function range": "55,5-60,5"
    },
    "Jsoup_1_/src/main/java/org/jsoup/nodes/Document.java_125-127": {
      "loc": "125-127",
      "input": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);",
      "output": [
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n    }\n    for (Node node: toMove) {\n        element.appendChild(node);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperator",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n    }\n    for (Node node: toMove) {\n        element.appendChild(node);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyr",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n    }\n    for (Node node: toMove) {\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.h",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n    }\n    for (Node node: toMove) {\n        element.appendChild(node);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n    }\n    for (Node node: toMove) {\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n    }\n    for (Node node: toMove) {\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n    }\n    for (Node node: toMove) {\n        element.appendChild(node);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n    }\n    for (Node node: toMove) {\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n    }\n    for (Node node: toMove) {\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.util.JavaDataModel;\nimport org.apache.hadoop.io.",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n    }\n    for (Node node: toMove) {\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.serde2.io.HiveDecimalWritable;\nimport org.apache.h"
      ],
      "function range": "113,5-128,5"
    },
    "Jsoup_15_/src/main/java/org/jsoup/parser/TreeBuilderState.java_283-284": {
      "loc": "283-284",
      "input": "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }",
      "output": [
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (name.equals(\"head\")) {\n                tb.error(this);\n                Element head = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!head.hasAttr(attribute.getKey()))\n                        head.attributes().put(attribute);\n                }\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                Element body = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!body.hasAttr(attribute.getKey()))\n                        body.attributes().put(attribute);\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                Element frameset = tb.getStack().getFirst();",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (name.equals(\"body\")) {\n                tb.framesetOk(false);\n                Element body = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!body.hasAttr(attribute.getKey()))\n                        body.attributes().put(attribute);\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.framesetOk(false);\n                Element frameset = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!frameset.hasAttr(attribute.getKey()))\n                        frameset.attributes().put(attribute);\n                }\n            } else if (name.equals(\"frame\")) {\n                tb.framesetOk(false);\n                Element frame = t",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (name.equals(\"body\")) {\n                tb.framesetOk(false);\n                Element body = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!body.hasAttr(attribute.getKey()))\n                        body.attributes().put(attribute);\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.framesetOk(false);\n                Element frameset = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!frameset.hasAttr(attribute.getKey()))\n                        frameset.attributes().put(attribute);\n                }\n            } else if (name.equals(\"frame\")) {\n                tb.framesetOk(false);\n            } else if (",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (name.equals(\"body\")) {\n                tb.framesetOk(false);\n                Element body = new Element(Tag.valueOf(\"body\"), \"\");\n                body.attributes().putAll(startTag.attributes());\n                tb.getStack().push(body);\n            } else if (name.equals(\"frameset\")) {\n                tb.framesetOk(false);\n                Element frameset = new Element(Tag.valueOf(\"frameset\"), \"\");\n                frameset.attributes().putAll(startTag.attributes());\n                tb.getStack().push(frameset);\n            } else if (name.equals(\"frame\")) {\n                tb.framesetOk(false);\n                Element frame = new Element(Tag.valueOf(\"frame\"), \"\");\n                frame.attributes().putAll(startTag.att",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (name.equals(\"body\")) {\n                tb.framesetOk(false);\n                Element body = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!body.hasAttr(attribute.getKey()))\n                        body.attributes().put(attribute);\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.framesetOk(false);\n                Element frameset = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!frameset.hasAttr(attribute.getKey()))\n                        frameset.attributes().put(attribute);\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.framesetOk(false);\n                Element frameset",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (name.equals(\"head\")) {\n                tb.error(this);\n                Element head = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!head.hasAttr(attribute.getKey()))\n                        head.attributes().put(attribute);\n                }\n            } else if (name.equals(\"body\")) {\n                tb.framesetOk(false);\n                Element body = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!body.hasAttr(attribute.getKey()))\n                        body.attributes().put(attribute);\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.framesetOk(false);\n                Element frameset = tb.getStack",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (name.equals(\"body\")) {\n                tb.framesetOk(false);\n                Element body = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!body.hasAttr(attribute.getKey()))\n                        body.attributes().put(attribute);\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.framesetOk(false);\n                Element frameset = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!frameset.hasAttr(attribute.getKey()))\n                        frameset.attributes().put(attribute);\n                }\n            } else if (name.equals(\"frame\")) {\n                tb.framesetOk(false);\n                tb.insert",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (name.equals(\"head\")) {\n                tb.error(this);\n                Element head = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!head.hasAttr(attribute.getKey()))\n                        head.attributes().put(attribute);\n                }\n            } else if (name.equals(\"body\")) {\n                tb.framesetOk(false);\n                Element body = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!body.hasAttr(attribute.getKey()))\n                        body.attributes().put(attribute);\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                Element frameset = tb.getStack().get",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (name.equals(\"head\")) {\n                tb.error(this);\n                Element head = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!head.hasAttr(attribute.getKey()))\n                        head.attributes().put(attribute);\n                }\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                Element body = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!body.hasAttr(attribute.getKey()))\n                        body.attributes().put(attribute);\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                Element fs = tb.getStack().getFirst();\n",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (name.equals(\"body\")) {\n                tb.framesetOk(false);\n                Element body = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!body.hasAttr(attribute.getKey()))\n                        body.attributes().put(attribute);\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.framesetOk(false);\n                Element frameset = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!frameset.hasAttr(attribute.getKey()))\n                        frameset.attributes().put(attribute);\n                }\n            } else if (name.equals(\"base\")) {\n                Element base = tb.getStack().getFirst();\n                for"
      ],
      "function range": "246,9-761,9"
    },
    "Jsoup_24_/src/main/java/org/jsoup/parser/TokeniserState.java_558-559": {
      "loc": "558-559",
      "input": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);",
      "output": [
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            if (t.isAppropriateEndTagToken())\n                t.transition(BeforeAttributeNameState);\n            else\n                anythingElse(t, r);\n            break;\n        case '/':\n            if (t.matches(\"</\")) {\n                t.transition(SelfClosingStartTagState);\n            } else if (t.isAppropriateEndTagToken()) {\n                t.transition(BeforeAttributeNameState);\n            } else {\n                anythingElse(t, r);\n            }\n            break;\n        case '>':\n            if (t.isAppropriateEndTagToken()) {\n                t.emitTagPending();\n                t.transition(DataState);\n            } else {\n                t.anythingElse();\n            }\n            break;\n        default:\n            anythingElse(t, r);\n            break;\n    }\n}\n\n    private void anythingElse(Tokeniser t, CharacterReader r) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case'':\n                break;\n            case '/':\n                if (t.matches(\"</\")) {\n                    t.emitTagPending();\n                    t.transition(SelfClosingStartTagState);\n                } else if (t.isAppropriateEndTagToken()) {\n                    t.transition(BeforeAttributeNameState);\n                } else {\n                    t.transition(BogusCommentState);\n                }\n                break;\n            case '>':\n                t.emitTagPending();\n                ",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            if (t.isAppropriateEndTagToken())\n                t.transition(BeforeAttributeNameState);\n            else\n                anythingElse(t, r);\n            break;\n        case '/':\n            if (t.matches(\"</\")) {\n                t.transition(SelfClosingStartTagState);\n            } else if (t.isAppropriateEndTagToken()) {\n                t.transition(BeforeAttributeNameState);\n            } else {\n                anythingElse(t, r);\n            }\n            break;\n        case '>':\n            if (t.isAppropriateEndTagToken()) {\n                t.emitTagPending();\n                t.transition(DataState);\n            } else {\n                t.anythingElse();\n            }\n            break;\n        default:\n            anythingElse(t, r);\n            break;\n    }\n}\n\n    private void anythingElse(Tokeniser t, CharacterReader r) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case'':\n                break;\n            case '/':\n                if (t.matches(\"</\")) {\n                    t.transition(SelfClosingStartTagState);\n                } else if (t.isAppropriateEndTagToken()) {\n                    t.transition(BeforeAttributeNameState);\n                } else {\n                    t.transition(BogusCommentState);\n                }\n                break;\n            case '>':\n                t.emitParseError();\n                t.transition(DataState);\n                ",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            if (t.isAppropriateEndTagToken())\n                t.transition(BeforeAttributeName);\n            else\n                anythingElse(t, r);\n            break;\n        case '/':\n            if (t.matches(\"</\")) {\n                t.transition(EndTagOpen);\n            } else if (t.isAppropriateEndTagToken()) {\n                t.transition(BeforeAttributeName);\n            } else {\n                anythingElse(t, r);\n            }\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case nullChar:\n            t.error(this);\n            r.advance();\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case eof:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            anythingElse(t, r);\n            break;\n    }\n}\n\n    private void anythingElse(Tokeniser t, CharacterReader r) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case'':\n                break;\n            case '/':\n                if (t.isAppropriateEndTagToken()) {\n                    t.transition(EndTagOpen);\n                } else {\n                    t.transition(BogusComment);\n                }\n                break;\n            case '>':\n                t.emitTagPending();\n                t.trans",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            if (t.isAppropriateEndTagToken())\n                t.transition(BeforeAttributeName);\n            else\n                anythingElse(t, r);\n            break;\n        case '/':\n            if (t.matches(\"</\")) {\n                t.transition(EndTagOpen);\n            } else if (t.isAppropriateEndTagToken()) {\n                t.transition(BeforeAttributeName);\n            } else {\n                anythingElse(t, r);\n            }\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case nullChar:\n            t.error(this);\n            r.advance();\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case eof:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            anythingElse(t, r);\n            break;\n    }\n}\n\n    private void anythingElse(Tokeniser t, CharacterReader r) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case'':\n                break;\n            case '/':\n                if (t.matches(\"</\")) {\n                    t.transition(EndTagOpen);\n                } else {\n                    t.transition(BogusComment);\n                }\n                break;\n            case '>':\n                t.emitTagPending();\n                t.transition(Data",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            if (t.isAppropriateEndTagToken())\n                t.transition(BeforeAttributeName);\n            else\n                anythingElse(t, r);\n            break;\n        case '/':\n            if (t.matches(\"</\")) {\n                t.transition(EndTagOpen);\n            } else if (t.isAppropriateEndTagToken()) {\n                t.transition(BeforeAttributeName);\n            } else {\n                anythingElse(t, r);\n            }\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case nullChar:\n            t.error(this);\n            r.advance();\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case eof:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            anythingElse(t, r);\n            break;\n    }\n}\n\n    private void anythingElse(Tokeniser t, CharacterReader r) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case'':\n                break;\n            case '/':\n                if (t.matches(\"</\")) {\n                    t.transition(EndTagOpen);\n                } else {\n                    t.transition(BeforeAttributeName);\n                }\n                break;\n            case '>':\n                t.emitTagPending();\n                t.transition(Data);",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            if (t.isAppropriateEndTagToken())\n                t.transition(BeforeAttributeName);\n            else\n                anythingElse(t, r);\n            break;\n        case '/':\n            if (t.matches(\"</\")) {\n                t.transition(EndTagOpen);\n            } else if (t.isAppropriateEndTagToken()) {\n                t.transition(BeforeAttributeName);\n            } else {\n                anythingElse(t, r);\n            }\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case nullChar:\n            t.error(this);\n            r.advance();\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case eof:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            anythingElse(t, r);\n            break;\n    }\n}\n\n    private void anythingElse(Tokeniser t, CharacterReader r) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case'':\n                break;\n            case '>':\n                t.emitTagPending();\n                t.transition(Data);\n                break;\n            case nullChar:\n                t.error(this);\n                r.advance();\n                t.emitTagPending();\n                t.transition(Data);\n                break;\n            case",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            if (t.isAppropriateEndTagToken())\n                t.transition(BeforeAttributeNameState);\n            else\n                anythingElse(t, r);\n            break;\n        case '/':\n            if (t.matches(\"</\")) {\n                t.transition(SelfClosingStartTagState);\n            } else if (t.isAppropriateEndTagToken()) {\n                t.transition(BeforeAttributeNameState);\n            } else {\n                anythingElse(t, r);\n            }\n            break;\n        case '>':\n            if (t.isAppropriateEndTagToken()) {\n                t.emitTagPending();\n                t.transition(DataState);\n            } else {\n                t.anythingElse();\n            }\n            break;\n        default:\n            anythingElse(t, r);\n            break;\n    }\n}\n\n    private void anythingElse(Tokeniser t, CharacterReader r) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case'':\n                break;\n            case '/':\n                if (t.matches(\"</\")) {\n                    t.transition(SelfClosingStartTagState);\n                } else if (t.isAppropriateEndTagToken()) {\n                    t.transition(BeforeAttributeNameState);\n                } else {\n                    t.transition(BogusCommentState);\n                }\n                break;\n            case '>':\n                t.emitTagPending();\n                t.transition(DataState);\n                ",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            if (t.isAppropriateEndTagToken())\n                t.transition(BeforeAttributeNameState);\n            else\n                anythingElse(t, r);\n            break;\n        case '/':\n            if (t.matches(\"</\")) {\n                t.transition(SelfClosingStartTagState);\n            } else if (t.isAppropriateEndTagToken()) {\n                t.transition(BeforeAttributeNameState);\n            } else {\n                anythingElse(t, r);\n            }\n            break;\n        case '>':\n            if (t.isAppropriateEndTagToken()) {\n                t.emitTagPending();\n                t.transition(DataState);\n            } else {\n                t.anythingElse();\n            }\n            break;\n        default:\n            anythingElse(t, r);\n            break;\n    }\n}\n\n    private void anythingElse(Tokeniser t, CharacterReader r) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case'':\n                break;\n            case '/':\n                if (t.matches(\"</\")) {\n                    t.transition(SelfClosingStartTagState);\n                } else if (t.isAppropriateEndTagToken()) {\n                    t.transition(BeforeAttributeNameState);\n                } else {\n                    t.emitTagPending();\n                    t.transition(DataState);\n                }\n                break;\n            case '>':\n                t.emitTagPending();\n                t.trans",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            if (t.isAppropriateEndTagToken())\n                t.transition(BeforeAttributeName);\n            else\n                anythingElse(t, r);\n            break;\n        case '/':\n            if (t.matches(\"</\")) {\n                t.transition(EndTagOpen);\n            } else if (t.isAppropriateEndTagToken()) {\n                t.transition(BeforeAttributeName);\n            } else {\n                anythingElse(t, r);\n            }\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case nullChar:\n            t.error(this);\n            r.advance();\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case eof:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            anythingElse(t, r);\n            break;\n    }\n}\n\n    private void anythingElse(Tokeniser t, CharacterReader r) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case'':\n                break;\n            case '/':\n                if (t.matches(\"</\")) {\n                    t.transition(EndTagOpen);\n                } else if (t.isAppropriateEndTagToken()) {\n                    t.transition(BeforeAttributeName);\n                } else {\n                    t.transition(BogusComment);\n                }",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            if (t.isAppropriateEndTagToken())\n                t.transition(BeforeAttributeNameState);\n            else\n                anythingElse(t, r);\n            break;\n        case '/':\n            if (t.matches(\"</\")) {\n                t.transition(SelfClosingStartTagState);\n            } else if (t.isAppropriateEndTagToken()) {\n                t.transition(BeforeAttributeNameState);\n            } else {\n                anythingElse(t, r);\n            }\n            break;\n        case '>':\n            if (t.isAppropriateEndTagToken()) {\n                t.emitTagPending();\n                t.transition(DataState);\n            } else {\n                t.anythingElse();\n            }\n            break;\n        default:\n            anythingElse(t, r);\n            break;\n    }\n}\n\n    private void anythingElse(Tokeniser t, CharacterReader r) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case'':\n                break;\n            case '/':\n                if (t.matches(\"</\")) {\n                    t.emitTagPending();\n                    t.transition(SelfClosingStartTagState);\n                } else {\n                    t.transition(BeforeAttributeNameState);\n                }\n                break;\n            case '>':\n                t.emitTagPending();\n                t.transition(DataState);\n                break;\n            default:\n                t.dataBuffer.append(c);\n                t"
      ],
      "function range": "553,9-586,9"
    },
    "Jsoup_34_/src/main/java/org/jsoup/parser/CharacterReader.java_91-92": {
      "loc": "91-92",
      "input": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;",
      "output": [
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n        if (i == last)\n            return offset;\n    }\n    return -1;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n        if (i == last)\n            return offset;\n    }\n    return -1;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimization",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n        if (i == last)\n            return offset;\n    }\n    return -1;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n        if (i == last)\n            return offset;\n    }\n    return -1;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n        if (i == last)\n            return offset;\n    }\n    return -1;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.Logical",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n        if (i == last)\n            return offset;\n    }\n    return -1;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.h",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n        if (i == last)\n            return offset;\n    }\n    return -1;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n        if (i == last)\n            return offset;\n    }\n    return -1;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.util.JavaDataModel;\nimport org",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n        if (i == last)\n            return offset;\n    }\n    return -1;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.serde2.io.HiveDecimalWrit",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n        if (i == last)\n            return offset;\n    }\n    return -1;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ser"
      ],
      "function range": "82,5-98,5"
    },
    "Jsoup_37_/src/main/java/org/jsoup/nodes/Element.java_1101-1102": {
      "loc": "1101-1102",
      "input": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);",
      "output": [
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algeb",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.al",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.alge",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\n\n"
      ],
      "function range": "1098,5-1102,5"
    },
    "Jsoup_40_/src/main/java/org/jsoup/nodes/DocumentType.java_22-23": {
      "loc": "22-23",
      "input": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);",
      "output": [
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass()!= obj.getClass()) {\n      return false;\n    }\n    DocumentType other = (DocumentType) obj;\n    if (name == null) {\n      if (other.name!= null) {\n        return false;\n      }\n    } else if (!name.equals(other.name)) {\n      return false;\n    }\n    if (publicId == null) {\n      if (other.publicId!= null) {\n        return false;\n      }\n    } else if (!publicId.equals(other.publicId)) {\n      return false;\n    }\n    if (systemId == null) {\n      if (other.systemId!= null) {\n        return false;\n      }\n    } else",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass()!= obj.getClass())\n      return false;\n    DocumentType other = (DocumentType) obj;\n    if (name == null) {\n      if (other.name!= null)\n        return false;\n    } else if (!name.equals(other.name))\n      return false;\n    if (publicId == null) {\n      if (other.publicId!= null)\n        return false;\n    } else if (!publicId.equals(other.publicId))\n      return false;\n    if (systemId == null) {\n      if (other.systemId!= null)\n        return false;\n    } else if (!systemId.equals(other.systemId))\n      return false;\n    return true;\n  }\n\n  @Override\n  ",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((baseUri == null)? 0 : baseUri.hashCode());\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass()!= obj.getClass())\n      return false;\n    DocumentType other = (DocumentType) obj;\n    if (baseUri == null) {\n      if (other.baseUri!= null)\n        return false;\n    } else if (!baseUri.equals(other.baseUri))\n      return false;\n    if (name == null) {\n      if (other.name!= null)\n        return false;\n    } else if (!name.equals(other.name))\n      return false;\n    if (publicId == null) {\n      if (other.publicId!= null)\n        return false;\n    } else if (!public",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((baseUri == null)? 0 : baseUri.hashCode());\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass()!= obj.getClass()) {\n      return false;\n    }\n    DocumentType other = (DocumentType) obj;\n    if (baseUri == null) {\n      if (other.baseUri!= null) {\n        return false;\n      }\n    } else if (!baseUri.equals(other.baseUri)) {\n      return false;\n    }\n    if (name == null) {\n      if (other.name!= null) {\n        return false;\n      }\n    } else if (!name.equals(other.name)) {\n      return false;\n    }\n    if (public",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass()!= obj.getClass())\n      return false;\n    DocumentType other = (DocumentType) obj;\n    if (name == null) {\n      if (other.name!= null)\n        return false;\n    } else if (!name.equals(other.name))\n      return false;\n    if (publicId == null) {\n      if (other.publicId!= null)\n        return false;\n    } else if (!publicId.equals(other.publicId))\n      return false;\n    if (systemId == null) {\n      if (other.systemId!= null)\n        return false;\n    } else if (!systemId.equals(other.systemId))\n      return false;\n    return true;\n  }\n\n}\n<",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (!(obj instanceof DocumentType)) {\n      return false;\n    }\n    DocumentType other = (DocumentType) obj;\n    if (name == null) {\n      if (other.name!= null) {\n        return false;\n      }\n    } else if (!name.equals(other.name)) {\n      return false;\n    }\n    if (publicId == null) {\n      if (other.publicId!= null) {\n        return false;\n      }\n    } else if (!publicId.equals(other.publicId)) {\n      return false;\n    }\n    if (systemId == null) {\n      if (other.systemId!= null) {\n        return false;\n      }\n    } else if (!",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((baseUri == null)? 0 : baseUri.hashCode());\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) return true;\n    if (obj == null) return false;\n    if (getClass()!= obj.getClass()) return false;\n    DocumentType other = (DocumentType) obj;\n    if (baseUri == null) {\n      if (other.baseUri!= null) return false;\n    } else if (!baseUri.equals(other.baseUri)) return false;\n    if (name == null) {\n      if (other.name!= null) return false;\n    } else if (!name.equals(other.name)) return false;\n    if (publicId == null) {\n      if (other.publicId!= null) return false;\n    } else if (!publicId.equals(other.publicId)) return false;\n    if",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass()!= obj.getClass())\n      return false;\n    DocumentType other = (DocumentType) obj;\n    if (name == null) {\n      if (other.name!= null)\n        return false;\n    } else if (!name.equals(other.name))\n      return false;\n    if (publicId == null) {\n      if (other.publicId!= null)\n        return false;\n    } else if (!publicId.equals(other.publicId))\n      return false;\n    if (systemId == null) {\n      if (other.systemId!= null)\n        return false;\n    } else if (!systemId.equals(other.systemId))\n      return false;\n    return true;\n  }\n}\n<|",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) return true;\n    if (obj == null) return false;\n    if (getClass()!= obj.getClass()) return false;\n    DocumentType other = (DocumentType) obj;\n    if (name == null) {\n      if (other.name!= null) return false;\n    } else if (!name.equals(other.name)) return false;\n    if (publicId == null) {\n      if (other.publicId!= null) return false;\n    } else if (!publicId.equals(other.publicId)) return false;\n    if (systemId == null) {\n      if (other.systemId!= null) return false;\n    } else if (!systemId.equals(other.systemId)) return false;\n    return true;\n  }\n\n  @Override\n  public String toString() {\n    return \"DocumentType [name=\" + name +",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n\n    DocumentType that = (DocumentType) o;\n\n    if (name!= null?!name.equals(that.name) : that.name!= null) return false;\n    if (publicId!= null?!publicId.equals(that.publicId) : that.publicId!= null) return false;\n    if (systemId!= null?!systemId.equals(that.systemId) : that.systemId!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (name!= null? name.hashCode() : 0);\n    result = 31 * result + (publicId!= null? publicId.hashCode() : 0);\n    result = 31 * result + (systemId!= null? systemId.hashCode() : 0);\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    return \"DocumentType{\" +\n        \"name='\" + name + '\\'' +\n        \", publicId='\" + publicId + '\\'' +\n        \", systemId='\" + systemId"
      ],
      "function range": "19,5-26,5"
    },
    "Jsoup_41_/src/main/java/org/jsoup/nodes/Element.java_1175-1176": {
      "loc": "1175-1176",
      "input": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;",
      "output": [
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name!= null? name.equals(element.name) : element.name == null;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (name!= null? name.hashCode() : 0);\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assert",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name!= null? name.equals(element.name) : element.name == null;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (name!= null? name.hashCode() : 0);\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name!= null? name.equals(element.name) : element.name == null;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (name!= null? name.hashCode() : 0);\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\npublic class DeadLetterChannelOnPrepareTest extends Context",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name!= null? name.equals(element.name) : element.name == null;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (name!= null? name.hashCode() : 0);\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\npublic class DeadLetterChannelTest extends ContextTestSupport {",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name!= null? name.equals(element.name) : element.name == null;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (name!= null? name.hashCode() : 0);\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n *",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name!= null? name.equals(element.name) : element.name == null;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (name!= null? name.hashCode() : 0);\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\npublic class RecipientListTest extends ContextTestSupport {",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name!= null? name.equals(element.name) : element.name == null;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (name!= null? name.hashCode() : 0);\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class Spl",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name!= null? name.equals(element.name) : element.name == null;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (name!= null? name.hashCode() : 0);\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\n/**\n * Unit test to verify that redelivery",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name!= null? name.equals(element.name) : element.name == null;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (name!= null? name.hashCode() : 0);\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class Dead",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name!= null? name.equals(element.name) : element.name == null;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (name!= null? name.hashCode() : 0);\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class Rec"
      ],
      "function range": "1167,5-1176,5"
    },
    "Jsoup_43_/src/main/java/org/jsoup/nodes/Element.java_574-575": {
      "loc": "574-575",
      "input": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);",
      "output": [
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algeb",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algeb",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOpt",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\n"
      ],
      "function range": "568,5-578,5"
    },
    "Jsoup_45_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_394-395": {
      "loc": "394-395",
      "input": "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; ",
      "output": [
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InHead);\n            break;\n        } else if (\"body\".equ",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        }\n        if (\"td\".equals(name) || \"th\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        }\n        if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        }\n        if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        }\n        if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        }\n        if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        }\n        if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        }\n        if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        }\n        if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        }\n        if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        }\n        if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        }\n        if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            ",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name) || \"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            ",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (last) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        }\n    }\n}\n<|java|",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frame\".equ",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (last) {",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        }\n        if (\"td\".equals(name) || \"th\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        }\n        if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        }\n        if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        }\n        if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        }\n        if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        }\n        if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        }\n        if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        }\n        if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        }\n        if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        }\n        if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        }\n    }\n    insertHtmlElement(stack);\n    if (last)\n        transition(HtmlTreeBuilderState",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        }\n        if (\"td\".equals(name) || \"th\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        }\n        if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        }\n        if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        }\n        if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        }\n        if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        }\n        if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        }\n        if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        }\n        if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        }\n        if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        }\n        if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        }\n    }\n    if (last)\n        transition(HtmlTreeBuilderState.BeforeHead);\n    else\n        ",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        }\n    }\n    if"
      ],
      "function range": "382,5-429,5"
    },
    "Jsoup_46_/src/main/java/org/jsoup/nodes/Entities.java_118-119": {
      "loc": "118-119",
      "input": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else",
      "output": [
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&##########################################################################################################################",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '<':\n                    if (inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '<':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '<':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '<':\n                    if (inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(\"<\");\n                    break;\n                case '>':\n                    if (inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(\">\");\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(\"\\\"\");",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&nbsp;&nbsp;\");\n                    break;\n                case '<':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(\"&lt;&lt;\");\n                    break;\n                case '>':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(\"&gt;&gt;\");\n                    break;\n                case '\"':\n                    ",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\\'':\n                    if (inAttribute)\n                        accum.append(\"&############",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '<':\n                    if (escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '<':\n                    if (inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&quot;\");\n                    else\n                        acc",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&nbsp;&nbsp;\");\n                    break;\n                case '<':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(\"&lt;&lt;\");\n                    break;\n                case '>':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(\"&gt;&gt;\");\n                    break;\n                default:\n                    if ("
      ],
      "function range": "79,5-154,5"
    },
    "Jsoup_47_/src/main/java/org/jsoup/nodes/Entities.java_122-123": {
      "loc": "122-123",
      "input": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':",
      "output": [
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(\"&########################################################################",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    if (inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(\"<\");\n                    break;\n                case '>':\n                    if (inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(\">\");\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\\'':\n                    if (inAttribute)\n                        accum.append(\"&########",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(\"&#############################",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    if (inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    if (inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(\"<\");\n                    break;\n                case '>':\n                    if (inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(\">\");\n                    break;\n                case '\"':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&quot;\");\n                    ",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    if (escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(\"<\");\n                    break;\n                case '>':\n                    if (escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(\">\");\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    if (inAttribute) {\n                        if (escapeMode!= EscapeMode.xhtml)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(\"&################################################################",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    if (!inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (inAttribute)\n                        accum.append(c);\n                    else\n                        accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    if (escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(\"<\");\n                    break;\n                case '>':\n                    if (escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(\">\");\n                    break;\n                case '\"':\n                    if (escapeMode == EscapeMode.xhtml)\n                        "
      ],
      "function range": "79,5-155,5"
    },
    "Jsoup_51_/src/main/java/org/jsoup/parser/CharacterReader.java_300-301": {
      "loc": "300-301",
      "input": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];",
      "output": [
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesNonLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesNonLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isLetter(c);\n  }\n\n  boolean matchesNonDigit() {\n    ",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigitOrWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c) || Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetters() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigits() {\n    if (isEmpty",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigitOrWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesWh",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesNonLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesNonLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigitOrWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetter",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigitOrWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesAny",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  boolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isDigit(c);\n  }\n\n  boolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isWhitespace(c);\n  }\n\n  boolean matchesNonWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return!Character.isWhitespace(c);\n  }\n\n  boolean matchesLetterOrDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetterOrDigit(c);\n  }\n\n  boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return Character.isLetter(c);\n  }\n\n  private boolean isEmpty() {\n    return pos >= input.length"
      ],
      "function range": "296,5-301,5"
    },
    "Jsoup_57_/src/main/java/org/jsoup/nodes/Attributes.java_125-126": {
      "loc": "125-126",
      "input": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))",
      "output": [
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.values().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equals(value)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.values().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.values().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equalsIgnoreCase(value)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public Set<String> keySet() {\n    if (attributes == null)\n        return Collections",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.values().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equalsIgnoreCase(value)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public Set<Map.Entry<String, String>> entrySet() {\n    if (attributes ==",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.values().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equalsIgnoreCase(value)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public boolean isEmpty() {\n    if (attributes == null)\n        return true;\n    ",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.values().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equalsIgnoreCase(value)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public Set<String> keySet() {\n    if (attributes == null)\n        return null",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.values().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equalsIgnoreCase(value)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public String get(String key) {\n    Validate.notEmpty(key);\n    if (",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.values().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equalsIgnoreCase(value)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public Set<java.util.Map.Entry<String, String>> entrySet() {\n    if",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.values().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equalsIgnoreCase(value)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public Set<Entry<String, String>> entrySet() {\n    if (attributes == null)",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.values().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equalsIgnoreCase(value)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public Set<String> keySet() {\n    if (attributes == null)\n        return new",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equalsIgnoreCase(value)) {\n            return true;\n        }\n    }\n    return false;\n  }\n\n  public Set<String> keySet() {\n    if (attributes == null)\n        return"
      ],
      "function range": "118,5-127,5"
    },
    "Jsoup_61_/src/main/java/org/jsoup/nodes/Element.java_1092-1093": {
      "loc": "1092-1093",
      "input": "public boolean hasClass(String className) {",
      "output": [
        "public boolean hasClass(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.log",
        "public boolean hasClass(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.",
        "public boolean hasClass(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.",
        "public boolean hasClass(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public boolean hasClass(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public boolean hasClass(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.algeb",
        "public boolean hasClass(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractBinaryJoinOperator;\nimport org.apache",
        "public boolean hasClass(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.",
        "public boolean hasClass(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOper",
        "public boolean hasClass(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.VariableReferenceExp"
      ],
      "function range": "1091,5-1132,5"
    },
    "Jsoup_68_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_468-472": {
      "loc": "468-472",
      "input": "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {",
      "output": [
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                if (inSpecificScope(targetNames[i], baseTypes, extraTypes)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return inSpecificScope(baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            for (int i = 0; i < extraTypes.length; i++) {\n                if (targetName.equals(extraTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                for (int j = 0; j < baseTypes.length; j++) {\n                    if (targetNames[i].equals(baseTypes[j])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                if (inSpecificScope(targetNames[i], baseTypes, extraTypes)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return inSpecificScope(baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            for (int i = 0; i < extraTypes.length; i++) {\n                if (targetName.equals(extraTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                for (int j = 0; j < baseTypes.length; j++) {\n                    if (targetNames[i].equals(baseTypes[j])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                if (inSpecificScope(targetNames[i], baseTypes, extraTypes)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return inSpecificScope(baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            for (int i = 0; i < extraTypes.length; i++) {\n                if (targetName.equals(extraTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                for (int j = 0; j < baseTypes.length; j++) {\n                    if (targetNames[i].equals(baseTypes[j])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName) {\n        if (targetName!= null) {\n            return true;\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                if (inSpecificScope(targetNames[i], baseTypes, extraTypes)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return inSpecificScope(baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            for (int i = 0; i < extraTypes.length; i++) {\n                if (targetName.equals(extraTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                for (int j = 0; j < baseTypes.length; j++) {\n                    if (targetNames[i].equals(baseTypes[j])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                if (inSpecificScope(targetNames[i], baseTypes, extraTypes)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return inSpecificScope(baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            for (int i = 0; i < extraTypes.length; i++) {\n                if (targetName.equals(extraTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                for (int j = 0; j < baseTypes.length; j++) {\n                    if (targetNames[i].equals(baseTypes[j])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName) {\n        if (targetName!= null) {\n            return true;\n        }\n        return false;\n    }\n\n    /*\n     * Checks if the given name is a valid java identifier.",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                if (inSpecificScope(targetNames[i], baseTypes, extraTypes)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return inSpecificScope(baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            for (int i = 0; i < extraTypes.length; i++) {\n                if (targetName.equals(extraTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                for (int j = 0; j < baseTypes.length; j++) {\n                    if (targetNames[i].equals(baseTypes[j])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName) {\n        if (targetName!= null) {\n            return true;\n        }\n        return false;\n    }\n}\n<|java|>/**\n * Licensed to the Apache Software",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                if (inSpecificScope(targetNames[i], baseTypes, extraTypes)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return inSpecificScope(baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            for (int i = 0; i < extraTypes.length; i++) {\n                if (targetName.equals(extraTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                for (int j = 0; j < baseTypes.length; j++) {\n                    if (targetNames[i].equals(baseTypes[j])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName) {\n        if (targetName!= null) {\n            return true;\n        }\n        return false;\n    }\n}\n<|java|>/**\n * Copyright (c) Microsoft",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                if (inSpecificScope(targetNames[i], baseTypes, extraTypes)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return inSpecificScope(baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            for (int i = 0; i < extraTypes.length; i++) {\n                if (targetName.equals(extraTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                for (int j = 0; j < baseTypes.length; j++) {\n                    if (targetNames[i].equals(baseTypes[j])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName) {\n        if (targetName!= null) {\n            return true;\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Copyright (c) 2015",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                if (inSpecificScope(targetNames[i], baseTypes, extraTypes)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return inSpecificScope(baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            for (int i = 0; i < extraTypes.length; i++) {\n                if (targetName.equals(extraTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                for (int j = 0; j < baseTypes.length; j++) {\n                    if (targetNames[i].equals(baseTypes[j])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName) {\n        if (targetName!= null) {\n            return true;\n        }\n        return false;\n    }\n}\n<|java|>/**\n * Copyright (c) 2010",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                if (inSpecificScope(targetNames[i], baseTypes, extraTypes)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return inSpecificScope(baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            for (int i = 0; i < extraTypes.length; i++) {\n                if (targetName.equals(extraTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes) {\n        if (targetNames!= null) {\n            for (int i = 0; i < targetNames.length; i++) {\n                for (int j = 0; j < baseTypes.length; j++) {\n                    if (targetNames[i].equals(baseTypes[j])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes) {\n        if (targetName!= null) {\n            for (int i = 0; i < baseTypes.length; i++) {\n                if (targetName.equals(baseTypes[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean inSpecificScope(String targetName) {\n        if (targetName!= null) {\n            return true;\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Copyright (c) 2016"
      ],
      "function range": "466,5-486,5"
    },
    "Jsoup_75_/src/main/java/org/jsoup/nodes/Attributes.java_319-321": {
      "loc": "319-321",
      "input": "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);",
      "output": [
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append(\"=\\\"\").append(val).append('\"');\n        }\n        if (i!= sz - 1) {\n            accum.append(' ');\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append(\"=\\\"\").append(val).append('\"');\n        }\n        if (i!= sz - 1) {\n            accum.append(' ');\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algeb",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append(\"=\\\"\").append(val).append('\"');\n        }\n        if (i!= sz - 1) {\n            accum.append(' ');\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append(\"=\\\"\").append(val).append('\"');\n        }\n        if (i!= sz - 1) {\n            accum.append(' ');\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append(\"=\\\"\").append(val).append('\"');\n        }\n        if (i!= sz - 1) {\n            accum.append(' ');\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append(\"=\\\"\").append(val).append('\"');\n        }\n        if (i < sz - 1) {\n            accum.append(' ');\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append(\"=\\\"\").append(val).append('\"');\n        }\n        if (i!= sz - 1) {\n            accum.append(' ');\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algeb",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append(\"=\\\"\").append(val).append('\"');\n        }\n        if (i!= sz - 1) {\n            accum.append(' ');\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append(\"=\\\"\").append(val).append('\"');\n        }\n        if (i!= sz - 1) {\n            accum.append(' ');\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algeb",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append(\"=\\\"\").append(val).append('\"');\n        }\n        if (i!= sz - 1) {\n            accum.append(' ');\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks"
      ],
      "function range": "310,5-326,5"
    },
    "Jsoup_77_/src/main/java/org/jsoup/parser/XmlTreeBuilder.java_117-118": {
      "loc": "117-118",
      "input": "private void popStackToClose(Token.EndTag endTag) {",
      "output": [
        "private void popStackToClose(Token.EndTag endTag) {\n    while (!stack.isEmpty() &&!stack.peek().matches(endTag)) {\n      stack.pop();\n    }\n    if (!stack.isEmpty()) {\n      stack.pop();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.oper",
        "private void popStackToClose(Token.EndTag endTag) {\n    while (!stack.isEmpty() &&!stack.peek().matches(endTag)) {\n      stack.pop();\n    }\n    if (!stack.isEmpty()) {\n      stack.pop();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.h",
        "private void popStackToClose(Token.EndTag endTag) {\n    while (!stack.isEmpty() &&!stack.peek().matches(endTag)) {\n      stack.pop();\n    }\n    if (!stack.isEmpty()) {\n      stack.pop();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOper",
        "private void popStackToClose(Token.EndTag endTag) {\n    while (!stack.isEmpty() &&!stack.peek().matches(endTag)) {\n      stack.pop();\n    }\n    if (!stack.isEmpty()) {\n      stack.pop();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators",
        "private void popStackToClose(Token.EndTag endTag) {\n    while (!stack.isEmpty() &&!stack.peek().matches(endTag)) {\n      stack.pop();\n    }\n    if (!stack.isEmpty()) {\n      stack.pop();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport",
        "private void popStackToClose(Token.EndTag endTag) {\n    while (!stack.isEmpty() &&!stack.peek().matches(endTag)) {\n      stack.pop();\n    }\n    if (!stack.isEmpty()) {\n      stack.pop();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator",
        "private void popStackToClose(Token.EndTag endTag) {\n    while (!stack.isEmpty() &&!stack.peek().matches(endTag)) {\n      stack.pop();\n    }\n    if (!stack.isEmpty()) {\n      stack.pop();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport",
        "private void popStackToClose(Token.EndTag endTag) {\n    while (!stack.isEmpty() &&!stack.peek().matches(endTag)) {\n      stack.pop();\n    }\n    if (!stack.isEmpty()) {\n      stack.pop();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyracks",
        "private void popStackToClose(Token.EndTag endTag) {\n    while (!stack.isEmpty() &&!stack.peek().matches(endTag)) {\n      stack.pop();\n    }\n    if (!stack.isEmpty()) {\n      stack.pop();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;",
        "private void popStackToClose(Token.EndTag endTag) {\n    while (!stack.isEmpty() &&!stack.peek().matches(endTag)) {\n      stack.pop();\n    }\n    if (!stack.isEmpty()) {\n      stack.pop();\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.ConstantExpression;\n"
      ],
      "function range": "116,5-136,5"
    },
    "Jsoup_86_/src/main/java/org/jsoup/nodes/Comment.java_78-79": {
      "loc": "78-79",
      "input": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;",
      "output": [
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.Logical",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algeb",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOpt",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptim",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalExpressionTag;\nimport org.",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator"
      ],
      "function range": "74,5-84,5"
    },
    "Jsoup_88_/src/main/java/org/jsoup/nodes/Attribute.java_80-81": {
      "loc": "80-81",
      "input": "public String getValue() {",
      "output": [
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the type property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * Sets the value of the type property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setType(String value) {\n        this.type = value;\n    }\n\n    /**\n     * Gets the value of the href property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getHref() {\n        return href;\n    }\n\n    /**\n     * Sets the value of the href property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setHref(String value) {\n        this.href = value;\n    }\n\n    /**\n     * Gets a map that contains attributes that aren't bound to any typed property on this class.\n     * \n     * <p>\n     * the map is keyed by the name of the attribute and \n     * the value is the string value of the attribute.\n     * \n     * the map returned by this method is live, and you can add new attribute\n     * by updating the map directly. Because of this design, there's no setter.\n     * \n     * \n     * @return\n     *     always non-null\n     */\n    public Map<QName, String> getOtherAttributes() {\n        return otherAttributes;\n    }\n\n}\n<|java|>",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the lang property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getLang() {\n        return lang;\n    }\n\n    /**\n     * Sets the value of the lang property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setLang(String value) {\n        this.lang = value;\n    }\n\n    /**\n     * Gets the value of the dir property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getDir() {\n        return dir;\n    }\n\n    /**\n     * Sets the value of the dir property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setDir(String value) {\n        this.dir = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets the value of the conref property.\n     * \n     * @return\n     *     possible object",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the lang property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getLang() {\n        return lang;\n    }\n\n    /**\n     * Sets the value of the lang property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setLang(String value) {\n        this.lang = value;\n    }\n\n    /**\n     * Gets the value of the dir property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getDir() {\n        return dir;\n    }\n\n    /**\n     * Sets the value of the dir property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setDir(String value) {\n        this.dir = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets the value of the clazz property.\n     * \n     * <p>\n     * This accessor",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the lang property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getLang() {\n        return lang;\n    }\n\n    /**\n     * Sets the value of the lang property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setLang(String value) {\n        this.lang = value;\n    }\n\n    /**\n     * Gets the value of the dir property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getDir() {\n        return dir;\n    }\n\n    /**\n     * Sets the value of the dir property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setDir(String value) {\n        this.dir = value;\n    }\n\n    /**\n     * Gets a map that contains attributes that aren't bound to any typed property on this class.\n     * \n     * <p>\n     * the map is keyed by the name of the attribute and \n     * the value is the string value of the attribute.\n     * \n     * the map returned by this method is live, and you can add new attribute\n     * by updating the map directly. Because of this design, there's no setter.\n     * \n     * \n     * @return\n     *     always non-null\n     */\n    public Map<QName, String> getOtherAttributes() {\n        return otherAttributes;\n    }\n\n}\n<|java|>",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets the value of the lang property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getLang() {\n        return lang;\n    }\n\n    /**\n     * Sets the value of the lang property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setLang(String value) {\n        this.lang = value;\n    }\n\n    /**\n     * Gets a map that contains attributes that aren't bound to any typed property on this class.\n     * \n     * <p>\n     * the map is keyed by the name of the attribute and \n     * the value is the string value of the attribute.\n     * \n     * the map returned by this method is live, and you can add new attribute\n     * by updating the map directly. Because of this design, there's no setter.\n     * \n     * \n     * @return\n     *     always non-null\n     */\n    public Map<QName, String> getOtherAttributes() {\n        return otherAttributes;\n    }\n\n}\n<|java|>",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the type property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * Sets the value of the type property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setType(String value) {\n        this.type = value;\n    }\n\n    /**\n     * Gets the value of the href property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getHref() {\n        return href;\n    }\n\n    /**\n     * Sets the value of the href property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setHref(String value) {\n        this.href = value;\n    }\n\n    /**\n     * Gets the value of the role property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getRole() {\n        return role;\n    }\n\n    /**\n     * Sets the value of the role property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setRole(String value) {\n        this.role = value;\n    }\n\n    /**\n     * Gets the value of the arcrole property.\n     * \n     * @return\n     *     possible object",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets the value of the lang property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getLang() {\n        return lang;\n    }\n\n    /**\n     * Sets the value of the lang property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setLang(String value) {\n        this.lang = value;\n    }\n\n    /**\n     * Gets the value of the space property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getSpace() {\n        return space;\n    }\n\n    /**\n     * Sets the value of the space property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setSpace(String value) {\n        this.space = value;\n    }\n\n    /**\n     * Gets the value of the base property.\n     * \n     * @return\n     *     possible object is",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets the value of the lang property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getLang() {\n        return lang;\n    }\n\n    /**\n     * Sets the value of the lang property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setLang(String value) {\n        this.lang = value;\n    }\n\n    /**\n     * Gets the value of the space property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getSpace() {\n        return space;\n    }\n\n    /**\n     * Sets the value of the space property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setSpace(String value) {\n        this.space = value;\n    }\n\n    /**\n     * Gets a map that contains attributes that aren't bound to any typed property on this class.\n     * \n     *",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the lang property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getLang() {\n        return lang;\n    }\n\n    /**\n     * Sets the value of the lang property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setLang(String value) {\n        this.lang = value;\n    }\n\n    /**\n     * Gets the value of the dir property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getDir() {\n        return dir;\n    }\n\n    /**\n     * Sets the value of the dir property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setDir(String value) {\n        this.dir = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets the value of the clazz property.\n     * \n     * @return\n     *     possible object",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the type property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * Sets the value of the type property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setType(String value) {\n        this.type = value;\n    }\n\n    /**\n     * Gets the value of the href property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getHref() {\n        return href;\n    }\n\n    /**\n     * Sets the value of the href property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setHref(String value) {\n        this.href = value;\n    }\n\n    /**\n     * Gets the value of the role property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getRole() {\n        return role;\n    }\n\n    /**\n     * Sets the value of the role property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setRole(String value) {\n        this.role = value;\n    }\n\n    /**\n     * Gets the value of the title property.\n     * \n     * @return\n     *     possible object is"
      ],
      "function range": "79,5-81,5"
    },
    "JxPath_5_/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java_665-668": {
      "loc": "665-668",
      "input": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0 ? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0 ? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1 != null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {",
      "output": [
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return p1.name.compareTo(p2.name);\n    }\n    return p1.name.compareTo(p2.name);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return p1.name.compareTo(p2.name);\n    }\n    return p1.name.compareTo(p2.name);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescript",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return p1.name.compareTo(p2.name);\n    }\n    return p1.name.compareTo(p2.name);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return p1.name.compareTo(p2.name);\n    }\n    return p1.name.compareTo(p2.name);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescript",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return p1.name.compareTo(p2.name);\n    }\n    return p1.name.compareTo(p2.name);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return p1.name.compareTo(p2.name);\n    }\n    return p1.name.compareTo(p2.name);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return p1.name.compareTo(p2.name);\n    }\n    return p1.name.compareTo(p2.name);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return p1.name.compareTo(p2.name);\n    }\n    return p1.name.compareTo(p2.name);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return p1.name.compareTo(p2.name);\n    }\n    return p1.name.compareTo(p2.name);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpression",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return p1.name.compareTo(p2.name);\n    }\n    return p1.name.compareTo(p2.name);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExp"
      ],
      "function range": "642,5-675,5"
    },
    "JxPath_10_/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java_42-43": {
      "loc": "42-43",
      "input": "public final Object computeValue(EvalContext context) {",
      "output": [
        "public final Object computeValue(EvalContext context) {\n        return computeValue(context, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader) {\n        return computeValue(context, classLoader, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread) {\n        return computeValue(context, classLoader, thread, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable) {\n        return computeValue(context, classLoader, thread, throwable, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args) {\n        return computeValue(context, classLoader, thread, throwable, args, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index) {\n        return computeValue(context, classLoader, thread, throwable, args, index, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object arg2) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, arg2, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object arg2, Object arg3) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, arg2, arg3, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object arg",
        "public final Object computeValue(EvalContext context) {\n        return computeValue(context, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader) {\n        return computeValue(context, classLoader, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread) {\n        return computeValue(context, classLoader, thread, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable) {\n        return computeValue(context, classLoader, thread, throwable, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args) {\n        return computeValue(context, classLoader, thread, throwable, args, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index) {\n        return computeValue(context, classLoader, thread, throwable, args, index, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, int index2) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, index2, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, int index2, Object arg2) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, index2, arg2, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, int index",
        "public final Object computeValue(EvalContext context) {\n        return computeValue(context, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader) {\n        return computeValue(context, classLoader, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread) {\n        return computeValue(context, classLoader, thread, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable) {\n        return computeValue(context, classLoader, thread, throwable, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args) {\n        return computeValue(context, classLoader, thread, throwable, args, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index) {\n        return computeValue(context, classLoader, thread, throwable, args, index, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, int argIndex) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, argIndex, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, int argIndex, Object arg2) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, argIndex, arg2, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, int arg",
        "public final Object computeValue(EvalContext context) {\n        return computeValue(context, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader) {\n        return computeValue(context, classLoader, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread) {\n        return computeValue(context, classLoader, thread, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable) {\n        return computeValue(context, classLoader, thread, throwable, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args) {\n        return computeValue(context, classLoader, thread, throwable, args, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index) {\n        return computeValue(context, classLoader, thread, throwable, args, index, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object[] args2) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, args2, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object[] args2, int index2) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, args2, index2, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg,",
        "public final Object computeValue(EvalContext context) {\n        return computeValue(context, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader) {\n        return computeValue(context, classLoader, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread) {\n        return computeValue(context, classLoader, thread, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable) {\n        return computeValue(context, classLoader, thread, throwable, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args) {\n        return computeValue(context, classLoader, thread, throwable, args, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index) {\n        return computeValue(context, classLoader, thread, throwable, args, index, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, int index2) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, index2, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, int index2, Object arg2) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, index2, arg2, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, int index",
        "public final Object computeValue(EvalContext context) {\n        return computeValue(context, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader) {\n        return computeValue(context, classLoader, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread) {\n        return computeValue(context, classLoader, thread, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable) {\n        return computeValue(context, classLoader, thread, throwable, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args) {\n        return computeValue(context, classLoader, thread, throwable, args, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int argIndex) {\n        return computeValue(context, classLoader, thread, throwable, args, argIndex, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int argIndex, Object arg) {\n        return computeValue(context, classLoader, thread, throwable, args, argIndex, arg, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int argIndex, Object arg, int argIndex2) {\n        return computeValue(context, classLoader, thread, throwable, args, argIndex, arg, argIndex2, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int argIndex, Object arg, int argIndex2, Object arg2) {\n        return computeValue(context, classLoader, thread, throwable, args, argIndex, arg, argIndex2, arg2, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable,",
        "public final Object computeValue(EvalContext context) {\n        return computeValue(context, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader) {\n        return computeValue(context, classLoader, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread) {\n        return computeValue(context, classLoader, thread, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable) {\n        return computeValue(context, classLoader, thread, throwable, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args) {\n        return computeValue(context, classLoader, thread, throwable, args, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index) {\n        return computeValue(context, classLoader, thread, throwable, args, index, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object arg2) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, arg2, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object arg2, Object arg3) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, arg2, arg3, null);\n    }\n\n    public Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object arg2",
        "public final Object computeValue(EvalContext context) {\n        return computeValue(context, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader) {\n        return computeValue(context, classLoader, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread) {\n        return computeValue(context, classLoader, thread, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable) {\n        return computeValue(context, classLoader, thread, throwable, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args) {\n        return computeValue(context, classLoader, thread, throwable, args, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index) {\n        return computeValue(context, classLoader, thread, throwable, args, index, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object arg2) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, arg2, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object arg2, Object arg3) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, arg2, arg3, null);\n    }\n\n    public abstract Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object arg",
        "public final Object computeValue(EvalContext context) {\n        return computeValue(context, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader) {\n        return computeValue(context, classLoader, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread) {\n        return computeValue(context, classLoader, thread, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable) {\n        return computeValue(context, classLoader, thread, throwable, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args) {\n        return computeValue(context, classLoader, thread, throwable, args, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index) {\n        return computeValue(context, classLoader, thread, throwable, args, index, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object arg2) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, arg2, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object arg2, Object arg3) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, arg2, arg3, null);\n    }\n\n    protected abstract Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object arg",
        "public final Object computeValue(EvalContext context) {\n        return computeValue(context, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader) {\n        return computeValue(context, classLoader, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread) {\n        return computeValue(context, classLoader, thread, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable) {\n        return computeValue(context, classLoader, thread, throwable, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args) {\n        return computeValue(context, classLoader, thread, throwable, args, 0);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index) {\n        return computeValue(context, classLoader, thread, throwable, args, index, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object arg2) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, arg2, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index, Object arg, Object arg2, Object arg3) {\n        return computeValue(context, classLoader, thread, throwable, args, index, arg, arg2, arg3, null);\n    }\n\n    public final Object computeValue(EvalContext context, ClassLoader classLoader, Thread thread, Throwable throwable, Object[] args, int index,\n            Object arg,"
      ],
      "function range": "41,5-44,5"
    },
    "JxPath_12_/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java_108-109": {
      "loc": "108-109",
      "input": "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);",
      "output": [
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard\n                || (namespaceURI == null && nodeNS == null)\n                || (namespaceURI!= null && namespaceURI.equals(nodeNS))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard\n                || (namespaceURI == null && nodeNS == null)\n                || (namespaceURI!= null && namespaceURI.equals(nodeNS))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int nodeType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == nodeType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        String localName = nameTest.getLocalName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        if (wildcard && localName == null) {\n            return true;\n        }\n        if (wildcard\n            || localName.equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard\n                || (namespaceURI == null && nodeNS == null)\n                || (namespaceURI",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard\n                || (namespaceURI == null && nodeNS == null)\n                || (namespaceURI!= null && namespaceURI.equals(nodeNS))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName().equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard\n                ||",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard\n                || (namespaceURI == null && nodeNS == null)\n                || (namespaceURI!= null && namespaceURI.equals(nodeNS))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n               .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard\n                || (namespaceURI == null && nodeNS == null)\n                || (namespaceURI!= null && namespaceURI.equals(nodeNS))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int nodeType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == nodeType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        String localName = nameTest.getLocalName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        if (wildcard && localName == null) {\n            return true;\n        }\n        if (wildcard || localName.equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard\n                || (namespaceURI == null && nodeNS == null)\n                || (namespaceURI!= null",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard\n                || (namespaceURI == null && nodeNS == null)\n                || (namespaceURI!= null && namespaceURI.equals(nodeNS))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard\n                || (names",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard\n                || (namespaceURI == null && nodeNS == null)\n                || (namespaceURI!= null && namespaceURI.equals(nodeNS))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int nodeType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == nodeType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        String localName = nameTest.getLocalName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        if (wildcard && localName == null) {\n            return true;\n        }\n        if (wildcard || localName.equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard || (namespaceURI == null && nodeNS == null)\n                || (namespaceURI!= null && namespace",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard\n                || (namespaceURI == null && nodeNS == null)\n                || (namespaceURI!= null && namespaceURI.equals(nodeNS))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || DOMNodePointer.getLocalName(node).equals(testName.getName())) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard\n                ",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard\n                || (namespaceURI == null && nodeNS == null)\n                || (namespaceURI!= null && namespaceURI.equals(nodeNS))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || (namespaceURI == null && DOMNodePointer.getNamespaceURI(node) == null)\n            || (namespaceURI!= null && namespaceURI.equals(DOMNodePointer.getNamespaceURI(",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (wildcard\n                || (namespaceURI == null && nodeNS == null)\n                || (namespaceURI!= null && namespaceURI.equals(nodeNS))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || (namespaceURI == null && DOMNodePointer.getNamespaceURI(node) == null)\n            || (namespaceURI!= null && namespaceURI.equals(\n                DOMNodePointer.getNamespace"
      ],
      "function range": "87,5-136,5"
    },
    "JxPath_21_/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java_152-153": {
      "loc": "152-153",
      "input": "public int getLength() {",
      "output": [
        "public int getLength() {\n        return length;\n    }\n\n    /**\n     * Sets the value of the length property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setLength(String value) {\n        this.length = value;\n    }\n\n    /**\n     * Gets the value of the clazz property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getClazz() {\n        return clazz;\n    }\n\n    /**\n     * Sets the value of the clazz property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setClazz(String value) {\n        this.clazz = value;\n    }\n\n    /**\n     * Gets the value of the style property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getStyle() {\n        return style;\n    }\n\n    /**\n     * Sets the value of the style property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setStyle(String value) {\n        this.style = value;\n    }\n\n    /**\n     * Gets the value of the titleAttr property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getTitleAttr() {\n        return titleAttr;\n    }\n\n    /**\n     * Sets the value of the titleAttr property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setTitleAttr(String value) {\n        this.titleAttr = value;\n    }\n\n    /**\n     * Gets the value of the alternativeTo property.",
        "public int getLength() {\n        return length;\n    }\n\n    /**\n     * Sets the value of the length property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setLength(int value) {\n        this.length = value;\n    }\n\n    /**\n     * Gets the value of the clazz property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getClazz() {\n        return clazz;\n    }\n\n    /**\n     * Sets the value of the clazz property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setClazz(String value) {\n        this.clazz = value;\n    }\n\n    /**\n     * Gets the value of the style property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getStyle() {\n        return style;\n    }\n\n    /**\n     * Sets the value of the style property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setStyle(String value) {\n        this.style = value;\n    }\n\n    /**\n     * Gets the value of the titleAttr property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getTitleAttr() {\n        return titleAttr;\n    }\n\n    /**\n     * Sets the value of the titleAttr property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setTitleAttr(String value) {\n        this.titleAttr = value;\n    }\n\n    /**\n     * Gets the value of the alternativeTo property.",
        "public int getLength() {\n        return length;\n    }\n\n    /**\n     * Sets the value of the length property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setLength(String value) {\n        this.length = value;\n    }\n\n    /**\n     * Gets the value of the clazz property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getClazz() {\n        return clazz;\n    }\n\n    /**\n     * Sets the value of the clazz property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setClazz(String value) {\n        this.clazz = value;\n    }\n\n    /**\n     * Gets the value of the style property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getStyle() {\n        return style;\n    }\n\n    /**\n     * Sets the value of the style property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setStyle(String value) {\n        this.style = value;\n    }\n\n    /**\n     * Gets the value of the titleAttr property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getTitleAttr() {\n        return titleAttr;\n    }\n\n    /**\n     * Sets the value of the titleAttr property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setTitleAttr(String value) {\n        this.titleAttr = value;\n    }\n\n    /**\n     * Gets a map that contains attributes that aren't",
        "public int getLength() {\n        return length;\n    }\n\n    /**\n     * Sets the value of the length property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setLength(int value) {\n        this.length = value;\n    }\n\n    /**\n     * Gets the value of the clazz property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getClazz() {\n        return clazz;\n    }\n\n    /**\n     * Sets the value of the clazz property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setClazz(String value) {\n        this.clazz = value;\n    }\n\n    /**\n     * Gets the value of the style property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getStyle() {\n        return style;\n    }\n\n    /**\n     * Sets the value of the style property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setStyle(String value) {\n        this.style = value;\n    }\n\n    /**\n     * Gets the value of the titleAttr property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getTitleAttr() {\n        return titleAttr;\n    }\n\n    /**\n     * Sets the value of the titleAttr property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setTitleAttr(String value) {\n        this.titleAttr = value;\n    }\n\n    /**\n     * Gets a map that contains attributes that aren't",
        "public int getLength() {\n        return length;\n    }\n\n    /**\n     * Sets the value of the length property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link BigInteger }\n     *     \n     */\n    public void setLength(BigInteger value) {\n        this.length = value;\n    }\n\n    /**\n     * Gets the value of the clazz property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getClazz() {\n        return clazz;\n    }\n\n    /**\n     * Sets the value of the clazz property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setClazz(String value) {\n        this.clazz = value;\n    }\n\n    /**\n     * Gets the value of the style property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getStyle() {\n        return style;\n    }\n\n    /**\n     * Sets the value of the style property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setStyle(String value) {\n        this.style = value;\n    }\n\n    /**\n     * Gets the value of the titleAttr property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getTitleAttr() {\n        return titleAttr;\n    }\n\n    /**\n     * Sets the value of the titleAttr property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setTitleAttr(String value) {\n        this.titleAttr = value;\n    }\n\n    /**\n     * Gets the value of the alternativeTo",
        "public int getLength() {\n        return length;\n    }\n\n    /**\n     * Sets the value of the length property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link BigInteger }\n     *     \n     */\n    public void setLength(BigInteger value) {\n        this.length = value;\n    }\n\n    /**\n     * Gets the value of the clazz property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getClazz() {\n        return clazz;\n    }\n\n    /**\n     * Sets the value of the clazz property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setClazz(String value) {\n        this.clazz = value;\n    }\n\n    /**\n     * Gets the value of the style property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getStyle() {\n        return style;\n    }\n\n    /**\n     * Sets the value of the style property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setStyle(String value) {\n        this.style = value;\n    }\n\n    /**\n     * Gets the value of the titleAttr property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getTitleAttr() {\n        return titleAttr;\n    }\n\n    /**\n     * Sets the value of the titleAttr property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setTitleAttr(String value) {\n        this.titleAttr = value;\n    }\n\n    /**\n     * Gets a map that contains attributes that",
        "public int getLength() {\n        return length;\n    }\n\n    /**\n     * Sets the value of the length property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setLength(int value) {\n        this.length = value;\n    }\n\n    /**\n     * Gets the value of the clazz property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getClazz() {\n        return clazz;\n    }\n\n    /**\n     * Sets the value of the clazz property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setClazz(String value) {\n        this.clazz = value;\n    }\n\n    /**\n     * Gets the value of the style property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getStyle() {\n        return style;\n    }\n\n    /**\n     * Sets the value of the style property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setStyle(String value) {\n        this.style = value;\n    }\n\n    /**\n     * Gets the value of the title property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getTitle() {\n        return title;\n    }\n\n    /**\n     * Sets the value of the title property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setTitle(String value) {\n        this.title = value;\n    }\n\n    /**\n     * Gets the value of the lang property.\n     * \n     * @return\n     *     ",
        "public int getLength() {\n        return length;\n    }\n\n    /**\n     * Sets the value of the length property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setLength(int value) {\n        this.length = value;\n    }\n\n    /**\n     * Gets the value of the clazz property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getClazz() {\n        return clazz;\n    }\n\n    /**\n     * Sets the value of the clazz property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setClazz(String value) {\n        this.clazz = value;\n    }\n\n    /**\n     * Gets the value of the style property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getStyle() {\n        return style;\n    }\n\n    /**\n     * Sets the value of the style property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setStyle(String value) {\n        this.style = value;\n    }\n\n    /**\n     * Gets the value of the titleAttr property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getTitleAttr() {\n        return titleAttr;\n    }\n\n    /**\n     * Sets the value of the titleAttr property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setTitleAttr(String value) {\n        this.titleAttr = value;\n    }\n\n    /**\n     * Gets the value of the lang property.\n",
        "public int getLength() {\n        return length;\n    }\n\n    /**\n     * Sets the value of the length property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link BigInteger }\n     *     \n     */\n    public void setLength(BigInteger value) {\n        this.length = value;\n    }\n\n    /**\n     * Gets the value of the clazz property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getClazz() {\n        return clazz;\n    }\n\n    /**\n     * Sets the value of the clazz property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setClazz(String value) {\n        this.clazz = value;\n    }\n\n    /**\n     * Gets the value of the style property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getStyle() {\n        return style;\n    }\n\n    /**\n     * Sets the value of the style property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setStyle(String value) {\n        this.style = value;\n    }\n\n    /**\n     * Gets the value of the titleAttr property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getTitleAttr() {\n        return titleAttr;\n    }\n\n    /**\n     * Sets the value of the titleAttr property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setTitleAttr(String value) {\n        this.titleAttr = value;\n    }\n\n}\n<|java|>/*\n *",
        "public int getLength() {\n        return length;\n    }\n\n    /**\n     * Sets the value of the length property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link BigInteger }\n     *     \n     */\n    public void setLength(BigInteger value) {\n        this.length = value;\n    }\n\n    /**\n     * Gets the value of the clazz property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getClazz() {\n        return clazz;\n    }\n\n    /**\n     * Sets the value of the clazz property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setClazz(String value) {\n        this.clazz = value;\n    }\n\n    /**\n     * Gets the value of the style property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getStyle() {\n        return style;\n    }\n\n    /**\n     * Sets the value of the style property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setStyle(String value) {\n        this.style = value;\n    }\n\n    /**\n     * Gets the value of the titleAttr property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getTitleAttr() {\n        return titleAttr;\n    }\n\n    /**\n     * Sets the value of the titleAttr property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setTitleAttr(String value) {\n        this.titleAttr = value;\n    }\n\n    /**\n     * Gets the value of the lang property"
      ],
      "function range": "151,5-153,5"
    },
    "Lang_6_/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java_95-96": {
      "loc": "95-96",
      "input": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {",
      "output": [
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            out.write(input.charAt(pos + pt));\n        }\n        pos+= consumed;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            out.write(input.charAt(pos + pt));\n        }\n        pos+= consumed;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            out.write(input.charAt(pos + pt));\n        }\n        pos+= consumed;\n    }\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            out.write(input.charAt(pos + pt));\n        }\n        pos+= consumed;\n    }\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            out.write(input.charAt(pos + pt));\n        }\n        pos+= consumed;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            out.write(input.charAt(pos + pt));\n        }\n        pos+= consumed;\n    }\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            out.write(input.charAt(pos + pt));\n        }\n        pos+= consumed;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.h",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            out.write(input.charAt(pos + pt));\n        }\n        pos+= consumed;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            out.write(input.charAt(pos + pt));\n        }\n        pos+= consumed;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOper",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            out.write(input.charAt(pos + pt));\n        }\n        pos+= consumed;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExp"
      ],
      "function range": "75,5-98,5"
    },
    "Lang_16_/src/main/java/org/apache/commons/lang3/math/NumberUtils.java_458-459": {
      "loc": "458-459",
      "input": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }",
      "output": [
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"##############################################################################################################################################################################################################################################################################################################################################################################################################################",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"+\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"E\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"e\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"+\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"X\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"x\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"B\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"b\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"K\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"k\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"M\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"+\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"E\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"e\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"+\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"X\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"x\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"B\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"b\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"D\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"d\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"F\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"+\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"E\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"e\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"+\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"X\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"x\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"B\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"b\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"D\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"d\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"N\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"+\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"E\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"e\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"+\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"X\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"x\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"B\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"b\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"D\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"d\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"%\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"+\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"E\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"e\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"+\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"X\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"x\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"B\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"b\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"%\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"%\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"%\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"+\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"E\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"e\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"+\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"X\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"x\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"B\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"b\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"D\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"d\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"Q\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"+\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"E\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"e\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"+\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"X\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"x\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"B\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"b\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"%\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"%\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"\\\\\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"0X\")) {\n        return Long.valueOf(str.substring(2), 16);\n    }\n    if (str.startsWith(\"0\") && str.length() > 1) {\n        return Long.valueOf(str.substring(1), 8);\n    }\n    try {\n        return Long.valueOf(str);\n    } catch (NumberFormatException e) {\n        try {\n            return Double.valueOf(str);\n        } catch (NumberFormatException e2) {\n            try {\n                return Float.valueOf(str);\n            } catch (NumberFormatException e3) {\n                try {\n                    return Integer.valueOf(str);\n                } catch (NumberFormatException e4) {\n                    try {\n                        return Short.valueOf(str);\n                    } catch (NumberFormatException e5) {\n                        try {\n                            return Byte.valueOf(str);\n                        } catch (NumberFormatException e6) {\n                            try {\n                                return new BigInteger(str);\n                            } catch (NumberFormatException e7) {\n                                try {\n                                    return new BigDecimal(str);\n                                } catch (NumberFormatException e8) {\n                                    try {\n                                        return new AtomicInteger(Integer.parseInt(str));\n                                    } catch (NumberFormatException e9) {\n                                        try {\n                                            return new AtomicLong(Long.parseLong(str));\n                                        } catch (NumberFormatException e10) {\n                                            try {\n                                                return new AtomicBoolean(Boolean.parseBoolean(str));\n                                            } catch (NumberFormatException e11) {\n                                                throw e;\n                                            }\n                                        ",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"0X\")) {\n        return Long.valueOf(str.substring(2), 16);\n    }\n    if (str.startsWith(\"0\") && str.length() > 1) {\n        return Long.valueOf(str.substring(1), 8);\n    }\n    try {\n        return Long.valueOf(str);\n    } catch (NumberFormatException e) {\n        try {\n            return Double.valueOf(str);\n        } catch (NumberFormatException e2) {\n            try {\n                return Float.valueOf(str);\n            } catch (NumberFormatException e3) {\n                try {\n                    return Integer.valueOf(str);\n                } catch (NumberFormatException e4) {\n                    try {\n                        return Short.valueOf(str);\n                    } catch (NumberFormatException e5) {\n                        try {\n                            return Byte.valueOf(str);\n                        } catch (NumberFormatException e6) {\n                            try {\n                                return new BigInteger(str);\n                            } catch (NumberFormatException e7) {\n                                try {\n                                    return new BigDecimal(str);\n                                } catch (NumberFormatException e8) {\n                                    try {\n                                        return new AtomicInteger(Integer.parseInt(str));\n                                    } catch (NumberFormatException e9) {\n                                        try {\n                                            return new AtomicLong(Long.parseLong(str));\n                                        } catch (NumberFormatException e10) {\n                                            try {\n                                                return new AtomicBoolean(Boolean.parseBoolean(str));\n                                            } catch (NumberFormatException e11) {\n                                                try {\n                                                    return new AtomicReference("
      ],
      "function range": "444,5-594,5"
    },
    "Lang_21_/src/main/java/org/apache/commons/lang3/time/DateUtils.java_265-266": {
      "loc": "265-266",
      "input": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&",
      "output": [
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Cal",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Cal",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n  }\n}\n<|java|",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n  }\n\n  /**\n   * Returns the",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n  }\n\n  /**\n   * <p",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n  }\n\n  public static boolean isSameLocal"
      ],
      "function range": "258,5-270,5"
    },
    "Lang_26_/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java_820-821": {
      "loc": "820-821",
      "input": "public String format(Date date) {",
      "output": [
        "public String format(Date date) {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        return sdf.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.alge",
        "public String format(Date date) {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        return sdf.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.oper",
        "public String format(Date date) {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        return sdf.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical",
        "public String format(Date date) {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        return sdf.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.",
        "public String format(Date date) {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        return sdf.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnest",
        "public String format(Date date) {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        return sdf.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOper",
        "public String format(Date date) {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        return sdf.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AggregateOperator",
        "public String format(Date date) {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        return sdf.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public String format(Date date) {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        return sdf.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.",
        "public String format(Date date) {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        return sdf.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractBinaryJoinOperator;\nimport org.apache.hyracks.al"
      ],
      "function range": "819,5-823,5"
    },
    "Lang_33_/src/main/java/org/apache/commons/lang3/ClassUtils.java_910-911": {
      "loc": "910-911",
      "input": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {",
      "output": [
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyr",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyr",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalExpressionTag;\nimport org.apache.hyracks.algebricks.core",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.al"
      ],
      "function range": "902,5-913,5"
    },
    "Lang_39_/src/java/org/apache/commons/lang3/StringUtils.java_3676-3677": {
      "loc": "3676-3677",
      "input": "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {",
      "output": [
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (searchList[i] == null || searchList[i].length() == 0 || \n            noMoreMatchesForReplIndex[i] || replacementList[i] == null) \n        {\n            continue;",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            increase",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || \n            replacementList[i] == null) \n        {\n            continue",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0\n            || replacementList[i] == null) \n        {\n            continue;\n",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            start +=",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null)\n        {\n            continue;\n",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            if (",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (searchList[i] == null || searchList[i].length() == 0 || \n            replacementList[i] == null) \n        {\n            continue;\n        }\n        while (textIndex!="
      ],
      "function range": "3605,5-3731,5"
    },
    "Lang_40_/src/java/org/apache/commons/lang/StringUtils.java_1048-1049": {
      "loc": "1048-1049",
      "input": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }",
      "output": [
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.toUpperCase().indexOf(searchStr.toUpperCase());\n}\n\npublic static int indexOf(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.indexOf(searchStr);\n}\n\npublic static int lastIndexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.toUpperCase",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return INDEX_NOT_FOUND;\n    }\n    return str.toUpperCase().indexOf(searchStr.toUpperCase());\n}\n\npublic static int indexOf(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return INDEX_NOT_FOUND;\n    }\n    return str.indexOf(searchStr);\n}\n\npublic static int lastIndexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return INDEX_NOT_",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr, int startIndex) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.toUpperCase().indexOf(searchStr.toUpperCase(), startIndex);\n}\n\npublic static int indexOf(String str, String searchStr, int startIndex) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.indexOf(searchStr, startIndex);\n}\n\npublic static int lastIndexOfIgnoreCase(String str, String searchStr, int startIndex) {\n    if (str == null || searchStr == null) {",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr, int start) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.toUpperCase().indexOf(searchStr.toUpperCase(), start);\n}\n\npublic static int indexOf(String str, String searchStr, int start) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.indexOf(searchStr, start);\n}\n\npublic static int lastIndexOfIgnoreCase(String str, String searchStr, int start) {\n    if (str == null || searchStr == null) {\n        return -1",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr, int startIndex) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.toUpperCase().indexOf(searchStr.toUpperCase(), startIndex);\n}\n\npublic static int indexOf(String str, String searchStr, int startIndex) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.indexOf(searchStr, startIndex);\n}\n\npublic static int lastIndexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr, int start) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.toUpperCase().indexOf(searchStr.toUpperCase(), start);\n}\n\npublic static int indexOf(String str, String searchStr, int start) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.indexOf(searchStr, start);\n}\n\npublic static int lastIndexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    ",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr, int startIndex) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.toUpperCase().indexOf(searchStr.toUpperCase(), startIndex);\n}\n\npublic static int indexOf(String str, String searchStr, int startIndex) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.indexOf(searchStr, startIndex);\n}\n\npublic static int lastIndexOfIgnoreCase(String str, String searchStr, int lastIndex) {\n    if (str == null || searchStr == null) {",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.toUpperCase().indexOf(searchStr.toUpperCase());\n}\n\npublic static int lastIndexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.toUpperCase().lastIndexOf(searchStr.toUpperCase());\n}\n\npublic static int indexOf(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static int indexOf(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.indexOf(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.toUpperCase().indexOf(searchStr.toUpperCase());\n}\n\npublic static int lastIndexOf(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.lastIndexOf(searchStr);\n}\n\npublic static int lastIndexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.toUpperCase().lastIndexOf(searchStr.toUpperCase());\n}\n\npublic static String replace(String str, String searchStr, String replaceStr) {\n    if (str == null || searchStr == null || replaceStr == null) {\n        return null;\n    }\n    return str.replace(searchStr, replaceStr);\n}\n\npublic static String replaceIgnoreCase(String str, String searchStr, String replaceStr) {\n    if (str == null || searchStr == null || replaceStr == null) {\n        return null;\n    }\n    return str.toUpperCase().replace(searchStr.toUpperCase(), replaceStr.toUpperCase());\n}\n\npublic static String replaceAll(String str, String searchStr, String replaceStr) {\n    if",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.toUpperCase().indexOf(searchStr.toUpperCase());\n}\n\npublic static int indexOf(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.indexOf(searchStr);\n}\n\npublic static int lastIndexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return str.toLowerCase()."
      ],
      "function range": "1044,5-1049,5"
    },
    "Lang_43_/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java_422-423": {
      "loc": "422-423",
      "input": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {",
      "output": [
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n      appendTo.append(QUOTE);\n      start++;\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n      appendTo.append(c[i]);\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n    }\n    if (escapingOn && c[c.length - 1] == QUOTE) {\n      appendTo.append(QUOTE);\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n      appendTo.append(QUOTE);\n      start++;\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n      appendTo.append(c[i]);\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n    }\n    if (escapingOn && c[c.length - 1] == QUOTE) {\n      appendTo.append(QUOTE);\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n      appendTo.append(QUOTE);\n      start++;\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n      appendTo.append(c[i]);\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n    }\n    if (escapingOn && c[c.length - 1] == QUOTE) {\n      appendTo.append(QUOTE);\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n      appendTo.append(QUOTE);\n      start++;\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n      appendTo.append(c[i]);\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n    }\n    if (escapingOn && c[c.length - 1] == QUOTE) {\n      appendTo.append(QUOTE);\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n      appendTo.append(QUOTE);\n      start++;\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n      appendTo.append(c[i]);\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n    }\n    if (escapingOn && c[c.length - 1] == QUOTE) {\n      appendTo.append(QUOTE);\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n      appendTo.append(QUOTE);\n      start++;\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n      appendTo.append(c[i]);\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n    }\n    if (escapingOn && c[c.length - 1] == QUOTE) {\n      appendTo.append(QUOTE);\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.Alge",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n      appendTo.append(QUOTE);\n      start++;\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n      appendTo.append(c[i]);\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n    }\n    if (escapingOn && c[c.length - 1] == QUOTE) {\n      appendTo.append(QUOTE);\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.Al",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n      appendTo.append(QUOTE);\n      start++;\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n      appendTo.append(c[i]);\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n    }\n    if (escapingOn && c[c.length - 1] == QUOTE) {\n      appendTo.append(QUOTE);\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExp",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n      appendTo.append(QUOTE);\n      start++;\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n      appendTo.append(c[i]);\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n    }\n    if (escapingOn && c[c.length - 1] == QUOTE) {\n      appendTo.append(QUOTE);\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor.Descriptor;\n",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n      appendTo.append(QUOTE);\n      start++;\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n      appendTo.append(c[i]);\n      if (c[i] == QUOTE) {\n        appendTo.append(QUOTE);\n      }\n    }\n    if (escapingOn && c[c.length - 1] == QUOTE) {\n      appendTo.append(QUOTE);\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor.Descriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.Vectorized"
      ],
      "function range": "417,5-444,5"
    },
    "Lang_51_/src/java/org/apache/commons/lang/BooleanUtils.java_682-683": {
      "loc": "682-683",
      "input": "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) == 's' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) == 's');\n            }",
      "output": [
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            return \n                (ch0 == 't' || ch0 == 'T') &&\n                (ch1 == 'r' || ch1 == 'R') &&\n                (ch2 == 'u' || ch2 == 'U') &&\n                (ch3 == 'e' || ch3 == 'E');\n        }\n        case 5: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            return \n                (ch0 == 'f' || ch0 == 'F') &&",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n            return false;\n        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            return \n                (ch0 == 't' || ch0 == 'T') &&\n                (ch1 == 'r' || ch1 == 'R') &&\n                (ch2 == 'u' || ch2 == 'U') &&\n                (ch3 == 'e' || ch3 == 'E');\n        }\n        case 5: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            return \n                (ch0 == 'f' || ch0",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n        }\n        case 4: {\n            char ch = str.charAt(0);\n            if (ch == 't' || ch == 'T') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                    (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n            }\n        }\n        case 5: {\n            char ch = str.charAt(0);\n            if (ch == 'f') {\n                return \n                    (str.charAt(1) == 'a' || str.charAt(1) == 'A') &&\n                    (str.charAt(2) == 'l' || str.charAt(2) == 'L') &&\n                    (str.charAt(3) =='s'",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n        }\n        case 5: {\n            char ch = str.charAt(0);\n            if (ch == 'f') {\n                return \n                    (str.charAt(1) == 'a' || str.charAt(1) == 'A') &&\n                    (str.charAt(2) == 'l' || str.charAt(2) == 'L') &&\n                    (str.charAt(3) =='s' || str.charAt(3) == 'S') &&\n                    (str.charAt(4) == 'e' || str.charAt(4) == 'E');\n            }\n            if (ch == 'F') {\n                return \n                    (str.charAt(1) == 'A' || str.charAt(1) == 'a') &&\n                    (str.charAt(2) == 'L' || str.charAt(2) == 'l') &&\n                    (str.charAt(3) == 'S'",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n            return false;\n        }\n        case 4: {\n            char ch = str.charAt(0);\n            if (ch == 't' || ch == 'T') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                    (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n            }\n            return false;\n        }\n        case 5: {\n            char ch = str.charAt(0);\n            if (ch == 'f') {\n                return \n                    (str.charAt(1) == 'a' || str.charAt(1) == 'A') &&\n                    (str.charAt(2) == 'l' || str.charAt(2) == 'L') &&\n                    (str",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n        }\n        case 5: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            return \n                (ch0 == 'f' || ch0 == 'F') &&\n                (ch1 == 'a' || ch1 == 'A') &&\n                (ch2 == 'l' || ch2 == 'L') &&\n                (ch3 =='s' || ch3 == 'S') &&\n                (ch4 == 'e' || ch4 == 'E');\n        }\n        case 6: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            char ch",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            return \n                (ch0 == 't' || ch0 == 'T') &&\n                (ch1 == 'r' || ch1 == 'R') &&\n                (ch2 == 'u' || ch2 == 'U') &&\n                (ch3 == 'e' || ch3 == 'E');\n        }\n        case 5: {\n            char ch = str.charAt(0);\n            if (ch == 't') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                    (str.char",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n            return false;\n        }\n        case 5: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            return \n                (ch0 == 'f' || ch0 == 'F') &&\n                (ch1 == 'a' || ch1 == 'A') &&\n                (ch2 == 'l' || ch2 == 'L') &&\n                (ch3 =='s' || ch3 == 'S') &&\n                (ch4 == 'e' || ch4 == 'E');\n        }\n        case 6: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            return \n                (ch0 == 'a' || ch0 == 'A') &&\n                (ch1 == 'l' || ch1 == 'L') &&\n                (ch2 =='s' || ch2 == 'S') &&\n                (ch3 == 'e' || ch3 == 'E');\n        }\n        case 5: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            return \n                (ch0 == 't' || ch0 == 'T') &&",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n        }\n        case 5: {\n            char ch = str.charAt(0);\n            if (ch == 'f') {\n                return \n                    (str.charAt(1) == 'a' || str.charAt(1) == 'A') &&\n                    (str.charAt(2) == 'l' || str.charAt(2) == 'L') &&\n                    (str.charAt(3) =='s' || str.charAt(3) == 'S') &&\n                    (str.charAt(4) == 'e' || str.charAt(4) == 'E');\n            }\n            if (ch == 'F') {\n                return \n                    (str.charAt(1) == 'A' || str.charAt(1) == 'a') &&\n                    (str.charAt(2) == 'L' || str.charAt(2) == 'L') &&\n                    (str.charAt(3) == 'S'"
      ],
      "function range": "649,5-700,5"
    },
    "Lang_57_/src/java/org/apache/commons/lang/LocaleUtils.java_223-224": {
      "loc": "223-224",
      "input": "public static boolean isAvailableLocale(Locale locale) {",
      "output": [
        "public static boolean isAvailableLocale(Locale locale) {\n        Locale[] locales = Locale.getAvailableLocales();\n        for (Locale availableLocale : locales) {\n            if (availableLocale.equals(locale)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algeb",
        "public static boolean isAvailableLocale(Locale locale) {\n        Locale[] locales = Locale.getAvailableLocales();\n        for (Locale availableLocale : locales) {\n            if (availableLocale.equals(locale)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators",
        "public static boolean isAvailableLocale(Locale locale) {\n        Locale[] locales = Locale.getAvailableLocales();\n        for (Locale availableLocale : locales) {\n            if (availableLocale.equals(locale)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks",
        "public static boolean isAvailableLocale(Locale locale) {\n        Locale[] locales = Locale.getAvailableLocales();\n        for (Locale availableLocale : locales) {\n            if (availableLocale.equals(locale)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public static boolean isAvailableLocale(Locale locale) {\n        Locale[] locales = Locale.getAvailableLocales();\n        for (Locale availableLocale : locales) {\n            if (availableLocale.equals(locale)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.",
        "public static boolean isAvailableLocale(Locale locale) {\n        Locale[] locales = Locale.getAvailableLocales();\n        for (Locale availableLocale : locales) {\n            if (availableLocale.equals(locale)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "public static boolean isAvailableLocale(Locale locale) {\n        Locale[] locales = Locale.getAvailableLocales();\n        for (Locale availableLocale : locales) {\n            if (availableLocale.equals(locale)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public static boolean isAvailableLocale(Locale locale) {\n        Locale[] locales = Locale.getAvailableLocales();\n        for (Locale availableLocale : locales) {\n            if (availableLocale.equals(locale)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.h",
        "public static boolean isAvailableLocale(Locale locale) {\n        Locale[] locales = Locale.getAvailableLocales();\n        for (Locale availableLocale : locales) {\n            if (availableLocale.equals(locale)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions",
        "public static boolean isAvailableLocale(Locale locale) {\n        Locale[] locales = Locale.getAvailableLocales();\n        for (Locale availableLocale : locales) {\n            if (availableLocale.equals(locale)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalExpressionTag;\nimport org.apache.hyracks.algebricks.core.algebra."
      ],
      "function range": "222,5-224,5"
    },
    "Lang_58_/src/java/org/apache/commons/lang/math/NumberUtils.java_454-456": {
      "loc": "454-456",
      "input": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null",
      "output": [
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (mant",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (isAll",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && mant.length",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && numeric.index",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && isAllZ",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && numeric.char",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && numeric.length",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (allZ",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null) {\n                    return create"
      ],
      "function range": "397,5-545,5"
    },
    "Lang_59_/src/java/org/apache/commons/lang/text/StrBuilder.java_884-885": {
      "loc": "884-885",
      "input": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {",
      "output": [
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < width - strLen; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < width - strLen; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < width - strLen; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadRight(int i, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        for (int j = size; j < size + width; j++) {\n            buffer[j] = padChar;\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadLeft(int i, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        for (int j = size; j < size + width; j++) {\n            buffer[j] = pad",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            for (int i = 0; i < width - strLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size);\n        }\n        size += width",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < width - strLen; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < width - strLen; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            for (int i = 0; i < width - strLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size);\n        }\n",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = width - strLen; i > 0; i--) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size +=",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < width - str",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        for (int i ="
      ],
      "function range": "878,5-895,5"
    },
    "Lang_61_/src/java/org/apache/commons/lang/text/StrBuilder.java_1776-1777": {
      "loc": "1776-1777",
      "input": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0 ? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;",
      "output": [
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n  }\n\n  @Override\n  public int lastIndexOf(String str) {\n    return lastIndexOf(str, size - 1);\n  }\n\n  @Override\n  public int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n  }\n\n  @Override\n  public String substring(int start) {\n    return substring(start, size);",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n  }\n\n  @Override\n  public int lastIndexOf(String str) {\n    return lastIndexOf(str, size - 1);\n  }\n\n  @Override\n  public int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex - 1; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n  }\n\n  @Override\n  public String substring(int start) {\n    return substring(start,",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n  }\n\n  public int lastIndexOf(String str) {\n    return lastIndexOf(str, size - 1);\n  }\n\n  public int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex - 1; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n  }\n\n  public String substring(int start) {\n    return substring(start, size);\n  }\n\n  public String substring(",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return lastIndexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex - 1; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic String substring(int start) {\n    return substring(start, size);\n}\n\npublic String substring(int",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return lastIndexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex - 1; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str) {\n    return lastIndexOf(str, size - str.length());\n}\n\n",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return lastIndexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex - 1; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic String substring(int start, int end) {\n    start = (start < 0? 0 : start);\n    end =",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n  }\n\n  @Override\n  public int lastIndexOf(String str) {\n    return lastIndexOf(str, size - 1);\n  }\n\n  @Override\n  public int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n  }\n\n  @Override\n  public String replace(char oldChar, char newChar) {\n    if (oldChar",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return lastIndexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex - 1; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str) {\n    return lastIndexOf(str, size - 1);\n}\n\npublic String",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return lastIndexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex - 1; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic String substring(int start, int end) {\n    start = (start < 0? 0 : start);\n    if (",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n  }\n\n  @Override\n  public int lastIndexOf(String str) {\n    return lastIndexOf(str, size - 1);\n  }\n\n  @Override\n  public int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex - 1; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n  }\n\n  @Override\n  public String replace(char oldChar, char newChar) {\n    if ("
      ],
      "function range": "1760,5-1787,5"
    },
    "Math_2_/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java_268-269": {
      "loc": "268-269",
      "input": "public double getNumericalMean() {",
      "output": [
        "public double getNumericalMean() {\n        return this.numericalMean;\n    }\n\n    public void setNumericalMean(double numericalMean) {\n        this.numericalMean = numericalMean;\n    }\n\n    public double getNumericalVariance() {\n        return this.numericalVariance;\n    }\n\n    public void setNumericalVariance(double numericalVariance) {\n        this.numericalVariance = numericalVariance;\n    }\n\n    public double getNumericalStandardDeviation() {\n        return this.numericalStandardDeviation;\n    }\n\n    public void setNumericalStandardDeviation(double numericalStandardDeviation) {\n        this.numericalStandardDeviation = numericalStandardDeviation;\n    }\n\n    public double getGeometricMean() {\n        return this.geometricMean;\n    }\n\n    public void setGeometricMean(double geometricMean) {\n        this.geometricMean = geometricMean;\n    }\n\n    public double getGeometricVariance() {\n        return this.geometricVariance;\n    }\n\n    public void setGeometricVariance(double geometricVariance) {\n        this.geometricVariance = geometricVariance;\n    }\n\n    public double getGeometricStandardDeviation() {\n        return this.geometricStandardDeviation;\n    }\n\n    public void setGeometricStandardDeviation(double geometricStandardDeviation) {\n        this.geometricStandardDeviation = geometricStandardDeviation;\n    }\n\n    public double getHarmonicMean() {\n        return this.harmonicMean;\n    }\n\n    public void setHarmonicMean(double harmonicMean) {\n        this.harmonicMean = harmonicMean;\n    }\n\n    public double getHarmonicVariance() {\n        return this.harmonicVariance;\n    }\n\n    public void setHarmonicVariance(double harmonicVariance) {\n        this.harmonicVariance = harmonicVariance;\n    }\n\n    public double getHarmonicStandardDeviation() {\n        return this.harmonicStandardDeviation;\n    }\n\n    public void setHarmonicStandardDeviation",
        "public double getNumericalMean() {\n        return this.numericalMean;\n    }\n\n    public void setNumericalMean(double numericalMean) {\n        this.numericalMean = numericalMean;\n    }\n\n    public double getNumericalVariance() {\n        return this.numericalVariance;\n    }\n\n    public void setNumericalVariance(double numericalVariance) {\n        this.numericalVariance = numericalVariance;\n    }\n\n    public double getNumericalStandardDeviation() {\n        return this.numericalStandardDeviation;\n    }\n\n    public void setNumericalStandardDeviation(double numericalStandardDeviation) {\n        this.numericalStandardDeviation = numericalStandardDeviation;\n    }\n\n    public double getGeometricMean() {\n        return this.geometricMean;\n    }\n\n    public void setGeometricMean(double geometricMean) {\n        this.geometricMean = geometricMean;\n    }\n\n    public double getGeometricVariance() {\n        return this.geometricVariance;\n    }\n\n    public void setGeometricVariance(double geometricVariance) {\n        this.geometricVariance = geometricVariance;\n    }\n\n    public double getGeometricStandardDeviation() {\n        return this.geometricStandardDeviation;\n    }\n\n    public void setGeometricStandardDeviation(double geometricStandardDeviation) {\n        this.geometricStandardDeviation = geometricStandardDeviation;\n    }\n\n    public double getArithmeticMean() {\n        return this.arithmeticMean;\n    }\n\n    public void setArithmeticMean(double arithmeticMean) {\n        this.arithmeticMean = arithmeticMean;\n    }\n\n    public double getArithmeticVariance() {\n        return this.arithmeticVariance;\n    }\n\n    public void setArithmeticVariance(double arithmeticVariance) {\n        this.arithmeticVariance = arithmeticVariance;\n    }\n\n    public double getArithmeticStandardDeviation() {\n        return this.arithmeticStandardDeviation;\n    }\n\n    public void setArithmeticStandardDeviation(double arithmeticStandardDeviation",
        "public double getNumericalMean() {\n        return this.numericalMean;\n    }\n\n    public void setNumericalMean(double numericalMean) {\n        this.numericalMean = numericalMean;\n    }\n\n    public double getNumericalVariance() {\n        return this.numericalVariance;\n    }\n\n    public void setNumericalVariance(double numericalVariance) {\n        this.numericalVariance = numericalVariance;\n    }\n\n    public double getNumericalSkewness() {\n        return this.numericalSkewness;\n    }\n\n    public void setNumericalSkewness(double numericalSkewness) {\n        this.numericalSkewness = numericalSkewness;\n    }\n\n    public double getNumericalKurtosis() {\n        return this.numericalKurtosis;\n    }\n\n    public void setNumericalKurtosis(double numericalKurtosis) {\n        this.numericalKurtosis = numericalKurtosis;\n    }\n\n    public double getGeometricMean() {\n        return this.geometricMean;\n    }\n\n    public void setGeometricMean(double geometricMean) {\n        this.geometricMean = geometricMean;\n    }\n\n    public double getGeometricVariance() {\n        return this.geometricVariance;\n    }\n\n    public void setGeometricVariance(double geometricVariance) {\n        this.geometricVariance = geometricVariance;\n    }\n\n    public double getGeometricSkewness() {\n        return this.geometricSkewness;\n    }\n\n    public void setGeometricSkewness(double geometricSkewness) {\n        this.geometricSkewness = geometricSkewness;\n    }\n\n    public double getGeometricKurtosis() {\n        return this.geometricKurtosis;\n    }\n\n    public void setGeometricKurtosis(double geometricKurtosis) {\n        this.geometricKurtosis = geometricKurtosis;\n    }\n\n    @Override\n    public String toString() {\n        ",
        "public double getNumericalMean() {\n        return this.numericalMean;\n    }\n\n    public void setNumericalMean(double numericalMean) {\n        this.numericalMean = numericalMean;\n    }\n\n    public double getNumericalVariance() {\n        return this.numericalVariance;\n    }\n\n    public void setNumericalVariance(double numericalVariance) {\n        this.numericalVariance = numericalVariance;\n    }\n\n    public double getNumericalSkewness() {\n        return this.numericalSkewness;\n    }\n\n    public void setNumericalSkewness(double numericalSkewness) {\n        this.numericalSkewness = numericalSkewness;\n    }\n\n    public double getNumericalKurtosis() {\n        return this.numericalKurtosis;\n    }\n\n    public void setNumericalKurtosis(double numericalKurtosis) {\n        this.numericalKurtosis = numericalKurtosis;\n    }\n\n    public double getGeometricMean() {\n        return this.geometricMean;\n    }\n\n    public void setGeometricMean(double geometricMean) {\n        this.geometricMean = geometricMean;\n    }\n\n    public double getGeometricVariance() {\n        return this.geometricVariance;\n    }\n\n    public void setGeometricVariance(double geometricVariance) {\n        this.geometricVariance = geometricVariance;\n    }\n\n    public double getGeometricSkewness() {\n        return this.geometricSkewness;\n    }\n\n    public void setGeometricSkewness(double geometricSkewness) {\n        this.geometricSkewness = geometricSkewness;\n    }\n\n    public double getGeometricKurtosis() {\n        return this.geometricKurtosis;\n    }\n\n    public void setGeometricKurtosis(double geometricKurtosis) {\n        this.geometricKurtosis = geometricKurtosis;\n    }\n\n    public double getStandardDeviation() {\n        return this",
        "public double getNumericalMean() {\n        return this.numericalMean;\n    }\n\n    public void setNumericalMean(double numericalMean) {\n        this.numericalMean = numericalMean;\n    }\n\n    public double getNumericalVariance() {\n        return this.numericalVariance;\n    }\n\n    public void setNumericalVariance(double numericalVariance) {\n        this.numericalVariance = numericalVariance;\n    }\n\n    public double getNumericalSkewness() {\n        return this.numericalSkewness;\n    }\n\n    public void setNumericalSkewness(double numericalSkewness) {\n        this.numericalSkewness = numericalSkewness;\n    }\n\n    public double getNumericalKurtosis() {\n        return this.numericalKurtosis;\n    }\n\n    public void setNumericalKurtosis(double numericalKurtosis) {\n        this.numericalKurtosis = numericalKurtosis;\n    }\n\n    public double getGeometricMean() {\n        return this.geometricMean;\n    }\n\n    public void setGeometricMean(double geometricMean) {\n        this.geometricMean = geometricMean;\n    }\n\n    public double getGeometricVariance() {\n        return this.geometricVariance;\n    }\n\n    public void setGeometricVariance(double geometricVariance) {\n        this.geometricVariance = geometricVariance;\n    }\n\n    public double getGeometricSkewness() {\n        return this.geometricSkewness;\n    }\n\n    public void setGeometricSkewness(double geometricSkewness) {\n        this.geometricSkewness = geometricSkewness;\n    }\n\n    public double getGeometricKurtosis() {\n        return this.geometricKurtosis;\n    }\n\n    public void setGeometricKurtosis(double geometricKurtosis) {\n        this.geometricKurtosis = geometricKurtosis;\n    }\n\n    public double getArithmeticMean() {\n        return",
        "public double getNumericalMean() {\n        return this.numericalMean;\n    }\n\n    public void setNumericalMean(double numericalMean) {\n        this.numericalMean = numericalMean;\n    }\n\n    public double getNumericalVariance() {\n        return this.numericalVariance;\n    }\n\n    public void setNumericalVariance(double numericalVariance) {\n        this.numericalVariance = numericalVariance;\n    }\n\n    public double getNumericalSkewness() {\n        return this.numericalSkewness;\n    }\n\n    public void setNumericalSkewness(double numericalSkewness) {\n        this.numericalSkewness = numericalSkewness;\n    }\n\n    public double getNumericalKurtosis() {\n        return this.numericalKurtosis;\n    }\n\n    public void setNumericalKurtosis(double numericalKurtosis) {\n        this.numericalKurtosis = numericalKurtosis;\n    }\n\n    public double getGeometricMean() {\n        return this.geometricMean;\n    }\n\n    public void setGeometricMean(double geometricMean) {\n        this.geometricMean = geometricMean;\n    }\n\n    public double getGeometricVariance() {\n        return this.geometricVariance;\n    }\n\n    public void setGeometricVariance(double geometricVariance) {\n        this.geometricVariance = geometricVariance;\n    }\n\n    public double getGeometricSkewness() {\n        return this.geometricSkewness;\n    }\n\n    public void setGeometricSkewness(double geometricSkewness) {\n        this.geometricSkewness = geometricSkewness;\n    }\n\n    public double getGeometricKurtosis() {\n        return this.geometricKurtosis;\n    }\n\n    public void setGeometricKurtosis(double geometricKurtosis) {\n        this.geometricKurtosis = geometricKurtosis;\n    }\n\n    public double getMax() {\n        return this.max",
        "public double getNumericalMean() {\n        return this.numericalMean;\n    }\n\n    public void setNumericalMean(double numericalMean) {\n        this.numericalMean = numericalMean;\n    }\n\n    public double getNumericalVariance() {\n        return this.numericalVariance;\n    }\n\n    public void setNumericalVariance(double numericalVariance) {\n        this.numericalVariance = numericalVariance;\n    }\n\n    public double getNumericalSkewness() {\n        return this.numericalSkewness;\n    }\n\n    public void setNumericalSkewness(double numericalSkewness) {\n        this.numericalSkewness = numericalSkewness;\n    }\n\n    public double getNumericalKurtosis() {\n        return this.numericalKurtosis;\n    }\n\n    public void setNumericalKurtosis(double numericalKurtosis) {\n        this.numericalKurtosis = numericalKurtosis;\n    }\n\n    public double getGeometricMean() {\n        return this.geometricMean;\n    }\n\n    public void setGeometricMean(double geometricMean) {\n        this.geometricMean = geometricMean;\n    }\n\n    public double getGeometricVariance() {\n        return this.geometricVariance;\n    }\n\n    public void setGeometricVariance(double geometricVariance) {\n        this.geometricVariance = geometricVariance;\n    }\n\n    public double getGeometricSkewness() {\n        return this.geometricSkewness;\n    }\n\n    public void setGeometricSkewness(double geometricSkewness) {\n        this.geometricSkewness = geometricSkewness;\n    }\n\n    public double getGeometricKurtosis() {\n        return this.geometricKurtosis;\n    }\n\n    public void setGeometricKurtosis(double geometricKurtosis) {\n        this.geometricKurtosis = geometricKurtosis;\n    }\n\n}\n<|java|>/*\n * Copyright",
        "public double getNumericalMean() {\n        return this.numericalMean;\n    }\n\n    public void setNumericalMean(double numericalMean) {\n        this.numericalMean = numericalMean;\n    }\n\n    public double getNumericalVariance() {\n        return this.numericalVariance;\n    }\n\n    public void setNumericalVariance(double numericalVariance) {\n        this.numericalVariance = numericalVariance;\n    }\n\n    public double getNumericalSkewness() {\n        return this.numericalSkewness;\n    }\n\n    public void setNumericalSkewness(double numericalSkewness) {\n        this.numericalSkewness = numericalSkewness;\n    }\n\n    public double getNumericalKurtosis() {\n        return this.numericalKurtosis;\n    }\n\n    public void setNumericalKurtosis(double numericalKurtosis) {\n        this.numericalKurtosis = numericalKurtosis;\n    }\n\n    public double getGeometricMean() {\n        return this.geometricMean;\n    }\n\n    public void setGeometricMean(double geometricMean) {\n        this.geometricMean = geometricMean;\n    }\n\n    public double getGeometricVariance() {\n        return this.geometricVariance;\n    }\n\n    public void setGeometricVariance(double geometricVariance) {\n        this.geometricVariance = geometricVariance;\n    }\n\n    public double getGeometricSkewness() {\n        return this.geometricSkewness;\n    }\n\n    public void setGeometricSkewness(double geometricSkewness) {\n        this.geometricSkewness = geometricSkewness;\n    }\n\n    public double getGeometricKurtosis() {\n        return this.geometricKurtosis;\n    }\n\n    public void setGeometricKurtosis(double geometricKurtosis) {\n        this.geometricKurtosis = geometricKurtosis;\n    }\n}\n<|java|>/*\n * Copyright (",
        "public double getNumericalMean() {\n        return this.numericalMean;\n    }\n\n    public void setNumericalMean(double numericalMean) {\n        this.numericalMean = numericalMean;\n    }\n\n    public double getNumericalVariance() {\n        return this.numericalVariance;\n    }\n\n    public void setNumericalVariance(double numericalVariance) {\n        this.numericalVariance = numericalVariance;\n    }\n\n    public double getNumericalSkewness() {\n        return this.numericalSkewness;\n    }\n\n    public void setNumericalSkewness(double numericalSkewness) {\n        this.numericalSkewness = numericalSkewness;\n    }\n\n    public double getNumericalKurtosis() {\n        return this.numericalKurtosis;\n    }\n\n    public void setNumericalKurtosis(double numericalKurtosis) {\n        this.numericalKurtosis = numericalKurtosis;\n    }\n\n    public double getGeometricMean() {\n        return this.geometricMean;\n    }\n\n    public void setGeometricMean(double geometricMean) {\n        this.geometricMean = geometricMean;\n    }\n\n    public double getGeometricVariance() {\n        return this.geometricVariance;\n    }\n\n    public void setGeometricVariance(double geometricVariance) {\n        this.geometricVariance = geometricVariance;\n    }\n\n    public double getGeometricSkewness() {\n        return this.geometricSkewness;\n    }\n\n    public void setGeometricSkewness(double geometricSkewness) {\n        this.geometricSkewness = geometricSkewness;\n    }\n\n    public double getGeometricKurtosis() {\n        return this.geometricKurtosis;\n    }\n\n    public void setGeometricKurtosis(double geometricKurtosis) {\n        this.geometricKurtosis = geometricKurtosis;\n    }\n}\n<|java|>/*\n * Licensed to",
        "public double getNumericalMean() {\n        return this.numericalMean;\n    }\n\n    public void setNumericalMean(double numericalMean) {\n        this.numericalMean = numericalMean;\n    }\n\n    public double getNumericalVariance() {\n        return this.numericalVariance;\n    }\n\n    public void setNumericalVariance(double numericalVariance) {\n        this.numericalVariance = numericalVariance;\n    }\n\n    public double getNumericalSkewness() {\n        return this.numericalSkewness;\n    }\n\n    public void setNumericalSkewness(double numericalSkewness) {\n        this.numericalSkewness = numericalSkewness;\n    }\n\n    public double getNumericalKurtosis() {\n        return this.numericalKurtosis;\n    }\n\n    public void setNumericalKurtosis(double numericalKurtosis) {\n        this.numericalKurtosis = numericalKurtosis;\n    }\n\n    public double getGeometricMean() {\n        return this.geometricMean;\n    }\n\n    public void setGeometricMean(double geometricMean) {\n        this.geometricMean = geometricMean;\n    }\n\n    public double getGeometricVariance() {\n        return this.geometricVariance;\n    }\n\n    public void setGeometricVariance(double geometricVariance) {\n        this.geometricVariance = geometricVariance;\n    }\n\n    public double getGeometricSkewness() {\n        return this.geometricSkewness;\n    }\n\n    public void setGeometricSkewness(double geometricSkewness) {\n        this.geometricSkewness = geometricSkewness;\n    }\n\n    public double getGeometricKurtosis() {\n        return this.geometricKurtosis;\n    }\n\n    public void setGeometricKurtosis(double geometricKurtosis) {\n        this.geometricKurtosis = geometricKurtosis;\n    }\n\n}\n<|java|>/*\n * Licensed"
      ],
      "function range": "267,5-269,5"
    },
    "Math_5_/src/main/java/org/apache/commons/math3/complex/Complex.java_305-306": {
      "loc": "305-306",
      "input": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {",
      "output": [
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    double scale = 1.0 / (real * real + imaginary * imaginary);\n    return new Complex(real * scale, -imaginary * scale);\n  }\n\n  public Complex conjugate() {\n    return new Complex(real, -imaginary);\n  }\n\n  public Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n  }\n\n  public Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n  }\n\n  public Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double newReal = real * z.real - imaginary * z.imaginary;\n    double newImaginary = real * z.imaginary + imaginary * z.real;\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double denom = z.real * z.real + z.imaginary * z.imaginary;\n    double newReal = (real * z.real + imaginary * z.imaginary) / denom;\n    double newImaginary = (imaginary * z.real - real * z.imaginary) / denom;\n    return new Complex(newReal, newImaginary);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass()!= o.getClass()) {\n      return false;\n    }\n\n    Complex complex = (Complex) o;",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    double scale = 1.0 / (real * real + imaginary * imaginary);\n    return new Complex(real * scale, -imaginary * scale);\n  }\n\n  public Complex conjugate() {\n    return new Complex(real, -imaginary);\n  }\n\n  public Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n  }\n\n  public Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n  }\n\n  public Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double newReal = real * z.real - imaginary * z.imaginary;\n    double newImaginary = real * z.imaginary + imaginary * z.real;\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double denom = z.real * z.real + z.imaginary * z.imaginary;\n    double newReal = (real * z.real + imaginary * z.imaginary) / denom;\n    double newImaginary = (imaginary * z.real - real * z.imaginary) / denom;\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex mod(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double denominator = z.real * z.real + z.imaginary * z.imaginary;\n    double x = real * z.real",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    double scale = 1.0 / (real * real + imaginary * imaginary);\n    return new Complex(real * scale, -imaginary * scale);\n  }\n\n  public Complex conjugate() {\n    return new Complex(real, -imaginary);\n  }\n\n  public Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n  }\n\n  public Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n  }\n\n  public Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double newReal = real * z.real - imaginary * z.imaginary;\n    double newImaginary = real * z.imaginary + imaginary * z.real;\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    if (z.real == 0 && z.imaginary == 0) {\n      return NaN;\n    }\n    double newReal = (real * z.real + imaginary * z.imaginary) / (z.real * z.real + z.imaginary * z.imaginary);\n    double newImaginary = (imaginary * z.real - real * z.imaginary) / (z.real * z.real + z.imaginary * z.imaginary);\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex pow(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    ",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    double scale = 1.0 / (real * real + imaginary * imaginary);\n    return new Complex(real * scale, -imaginary * scale);\n  }\n\n  public Complex conjugate() {\n    return new Complex(real, -imaginary);\n  }\n\n  public Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n  }\n\n  public Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n  }\n\n  public Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double newReal = real * z.real - imaginary * z.imaginary;\n    double newImaginary = real * z.imaginary + imaginary * z.real;\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double denom = z.real * z.real + z.imaginary * z.imaginary;\n    double newReal = (real * z.real + imaginary * z.imaginary) / denom;\n    double newImaginary = (imaginary * z.real - real * z.imaginary) / denom;\n    return new Complex(newReal, newImaginary);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass()!= o.getClass()) {\n      return false;\n    }\n    Complex complex = (Complex) o;",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    double scale = 1.0 / (real * real + imaginary * imaginary);\n    return new Complex(real * scale, -imaginary * scale);\n  }\n\n  public Complex conjugate() {\n    return new Complex(real, -imaginary);\n  }\n\n  public Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n  }\n\n  public Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n  }\n\n  public Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double newReal = real * z.real - imaginary * z.imaginary;\n    double newImaginary = real * z.imaginary + imaginary * z.real;\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double denom = z.real * z.real + z.imaginary * z.imaginary;\n    double newReal = (real * z.real + imaginary * z.imaginary) / denom;\n    double newImaginary = (imaginary * z.real - real * z.imaginary) / denom;\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex pow(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double newReal = real * z.real - imaginary * z.imaginary;\n    double newImaginary = real * z.imaginary +",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    double scale = 1.0 / (real * real + imaginary * imaginary);\n    return new Complex(real * scale, -imaginary * scale);\n  }\n\n  public Complex conjugate() {\n    return new Complex(real, -imaginary);\n  }\n\n  public Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n  }\n\n  public Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n  }\n\n  public Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double newReal = real * z.real - imaginary * z.imaginary;\n    double newImaginary = real * z.imaginary + imaginary * z.real;\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double denom = z.real * z.real + z.imaginary * z.imaginary;\n    double newReal = (real * z.real + imaginary * z.imaginary) / denom;\n    double newImaginary = (imaginary * z.real - real * z.imaginary) / denom;\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex mod(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double denominator = z.real * z.real + z.imaginary * z.imaginary;\n    double x = (real * z.",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    double scale = 1.0 / (real * real + imaginary * imaginary);\n    return new Complex(real * scale, -imaginary * scale);\n  }\n\n  public Complex conjugate() {\n    return new Complex(real, -imaginary);\n  }\n\n  public Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n  }\n\n  public Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n  }\n\n  public Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double newReal = real * z.real - imaginary * z.imaginary;\n    double newImaginary = real * z.imaginary + imaginary * z.real;\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    if (z.real == 0 && z.imaginary == 0) {\n      return NaN;\n    }\n    double newReal = (real * z.real + imaginary * z.imaginary) / (z.real * z.real + z.imaginary * z.imaginary);\n    double newImaginary = (imaginary * z.real - real * z.imaginary) / (z.real * z.real + z.imaginary * z.imaginary);\n    return new Complex(newReal, newImaginary);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    double scale = 1.0 / (real * real + imaginary * imaginary);\n    return new Complex(real * scale, -imaginary * scale);\n  }\n\n  public Complex conjugate() {\n    return new Complex(real, -imaginary);\n  }\n\n  public Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n  }\n\n  public Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n  }\n\n  public Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double newReal = real * z.real - imaginary * z.imaginary;\n    double newImaginary = real * z.imaginary + imaginary * z.real;\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    if (z.real == 0 && z.imaginary == 0) {\n      return NaN;\n    }\n    double newReal = (real * z.real + imaginary * z.imaginary) / (z.real * z.real + z.imaginary * z.imaginary);\n    double newImaginary = (imaginary * z.real - real * z.imaginary) / (z.real * z.real + z.imaginary * z.imaginary);\n    return new Complex(newReal, newImaginary);\n  }\n\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    double scale = 1.0 / (real * real + imaginary * imaginary);\n    return new Complex(real * scale, -imaginary * scale);\n  }\n\n  public Complex conjugate() {\n    return new Complex(real, -imaginary);\n  }\n\n  public Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n  }\n\n  public Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n  }\n\n  public Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double newReal = real * z.real - imaginary * z.imaginary;\n    double newImaginary = real * z.imaginary + imaginary * z.real;\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double denom = z.real * z.real + z.imaginary * z.imaginary;\n    double newReal = (real * z.real + imaginary * z.imaginary) / denom;\n    double newImaginary = (imaginary * z.real - real * z.imaginary) / denom;\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex mod(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double denominator = z.real * z.real + z.imaginary * z.imaginary;\n    double newReal = real * z.",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    double scale = 1.0 / (real * real + imaginary * imaginary);\n    return new Complex(real * scale, -imaginary * scale);\n  }\n\n  public Complex conjugate() {\n    return new Complex(real, -imaginary);\n  }\n\n  public Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n  }\n\n  public Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n  }\n\n  public Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double newReal = real * z.real - imaginary * z.imaginary;\n    double newImaginary = real * z.imaginary + imaginary * z.real;\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double denom = z.real * z.real + z.imaginary * z.imaginary;\n    double newReal = (real * z.real + imaginary * z.imaginary) / denom;\n    double newImaginary = (imaginary * z.real - real * z.imaginary) / denom;\n    return new Complex(newReal, newImaginary);\n  }\n\n  public Complex mod(Complex z) {\n    if (isNaN || z.isNaN) {\n      return NaN;\n    }\n    double denominator = z.real * z.real + z.imaginary * z.imaginary;\n    double x = z.real * real"
      ],
      "function range": "299,5-321,5"
    },
    "Math_9_/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java_87-88": {
      "loc": "87-88",
      "input": "public Line revert() {",
      "output": [
        "public Line revert() {\n        return new Line(x1, y1, x2, y2);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class SplitterTest extends ContextTestSupport {\n\n    @Test\n    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {\n        MockEndpoint resultEndpoint = getMockEndpoint(\"mock:result\");\n        resultEndpoint.expectedBodiesReceived(\"A\", \"B\", \"C\");\n\n        template.send(\"direct:start\", new",
        "public Line revert() {\n        return new Line(x1, y1, x2, y2);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class SplitterTest extends ContextTestSupport {\n\n    @Test\n    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {\n        MockEndpoint resultEndpoint = getMockEndpoint(\"mock:result\");\n        resultEndpoint.expectedBodiesReceived(\"James\", \"Guillaume\", \"Hiram\", \"Rob\");\n\n        // In",
        "public Line revert() {\n        return new Line(x1, y1, x2, y2);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class SplitterTest extends ContextTestSupport {\n\n    @Test\n    public void testSplitter() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:split\");\n        mock.expectedBodiesReceived(\"A\", \"B\", \"C\");\n\n        template.sendBody(\"direct:start\", \"A,B,C\");\n\n        assertMockEndpointsSatisf",
        "public Line revert() {\n        return new Line(x1, y1, x2, y2);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class MulticastTest extends ContextTestSupport {\n\n    @Test\n    public void testMulticast() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Hello World\");\n\n        template.sendBody(\"direct:start\", \"Hello World\");\n\n        assertMockEndpointsSatisfied();\n    }\n\n    @Test\n    public void testMulticastTwo() throws Exception {\n        ",
        "public Line revert() {\n        return new Line(x1, y1, x2, y2);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class SplitterTest extends ContextTestSupport {\n\n    @Test\n    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {\n        MockEndpoint resultEndpoint = getMockEndpoint(\"mock:result\");\n        resultEndpoint.expectedBodiesReceived(\"A\", \"B\", \"C\");\n\n        template.sendBody(\"direct:start\",",
        "public Line revert() {\n        return new Line(x1, y1, x2, y2);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class SplitterTest extends ContextTestSupport {\n\n    @Test\n    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {\n        MockEndpoint resultEndpoint = getMockEndpoint(\"mock:result\");\n        resultEndpoint.expectedBodiesReceived(\"A\", \"B\", \"C\");\n\n        sendBody(\"direct:start\", \"A",
        "public Line revert() {\n        return new Line(x1, y1, x2, y2);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class SplitterTest extends ContextTestSupport {\n\n    @Test\n    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {\n        MockEndpoint resultEndpoint = getMockEndpoint(\"mock:result\");\n        resultEndpoint.expectedBodiesReceived(\"A\", \"B\", \"C\");\n\n        // InOnly\n        template.send(\"",
        "public Line revert() {\n        return new Line(x1, y1, x2, y2);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class SplitterTest extends ContextTestSupport {\n\n    @Test\n    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {\n        MockEndpoint resultEndpoint = getMockEndpoint(\"mock:result\");\n        resultEndpoint.expectedBodiesReceived(\"James\", \"Guillaume\", \"Hiram\", \"Rob\", \"Roman\");\n\n",
        "public Line revert() {\n        return new Line(x1, y1, x2, y2);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class SplitterTest extends ContextTestSupport {\n\n    @Test\n    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {\n        MockEndpoint resultEndpoint = getMockEndpoint(\"mock:result\");\n        resultEndpoint.expectedBodiesReceived(\"James\", \"Guillaume\", \"Hiram\", \"Rob\");\n\n        template.",
        "public Line revert() {\n        return new Line(x1, y1, x2, y2);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class MulticastTest extends ContextTestSupport {\n\n    @Test\n    public void testMulticast() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Hello A\", \"Hello B\", \"Hello C\", \"Hello D\", \"Hello E\");\n\n        template.sendBody(\"direct:start\", \"Hello\");\n\n        assertMockEndpointsSatisfied();\n    }\n\n    @Test"
      ],
      "function range": "86,5-89,5"
    },
    "Math_11_/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java_183-184": {
      "loc": "183-184",
      "input": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length != dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }",
      "output": [
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n\n    final double x = vals[0];\n    final double y = vals[1];\n    final double z = vals[2];\n    final double r2 = x * x + y * y + z * z;\n    final double r = FastMath.sqrt(r2);\n    final double oneOverR = 1 / r;\n    final double oneOverR2 = oneOverR * oneOverR;\n    final double oneOverR3 = oneOverR2 * oneOverR;\n    final double x2 = 2 * x * oneOverR;\n    final double y2 = 2 * y * oneOverR;\n    final double z2 = 2 * z * oneOverR;\n    final double x3 = 3 * x2 * oneOverR;\n    final double y3 = 3 * y2 * oneOverR;\n    final double z3 = 3 * z2 * oneOverR;\n    final double x4 = 4 * x3 * oneOverR;\n    final double y4 = 4 * y3 * oneOverR;\n    final double z4 = 4 * z3 * oneOverR;\n    final double x5 = 5 * x4 * oneOverR;\n    final double y5 = 5 * y4 * oneOverR;\n    final double z5 = 5 * z4 * oneOverR;\n    final double x6 = 6 * x5 * oneOverR;\n    final double y6 = 6 * y5 * oneOverR;\n    final double z6 = 6 * z5 * oneOverR;\n    final double x7 = 7 * x6 * oneOverR;\n    final double y7 = 7 * y6 * oneOverR;\n    final double z7 = 7 * z6 * oneOverR;\n    final double x8 = 8 * x7 * oneOverR;\n    final double y8 = 8 * y7 * oneOverR;\n    final double z8 = 8 * z7 * oneOverR;\n    final double x9 = 9",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n\n    final double x = vals[0];\n    final double y = vals[1];\n    final double z = vals[2];\n    final double r2 = x * x + y * y + z * z;\n    final double r = FastMath.sqrt(r2);\n    final double oneOverR = 1 / r;\n    final double oneOverR2 = oneOverR * oneOverR;\n    final double oneOverR3 = oneOverR2 * oneOverR;\n    final double x2 = 2 * x * oneOverR;\n    final double y2 = 2 * y * oneOverR;\n    final double z2 = 2 * z * oneOverR;\n    final double x3 = 3 * x2 * oneOverR;\n    final double y3 = 3 * y2 * oneOverR;\n    final double z3 = 3 * z2 * oneOverR;\n    final double x4 = 4 * x2 * x2 * oneOverR2;\n    final double y4 = 4 * y2 * y2 * oneOverR2;\n    final double z4 = 4 * z2 * z2 * oneOverR2;\n    final double x5 = 5 * x4 * oneOverR2;\n    final double y5 = 5 * y4 * oneOverR2;\n    final double z5 = 5 * z4 * oneOverR2;\n    final double x6 = 6 * x4 * x2 * oneOverR2;\n    final double y6 = 6 * y4 * y2 * oneOverR2;\n    final double z6 = 6 * z4 * z2 * oneOverR2;\n    final double x7 = 7 * x4 * x3 * oneOverR2;\n    final double y7 = 7 * y4 * y3 * oneOverR2;\n    final double z7 = 7 * z4 * z3 * oneOverR2;\n    final double x8 = 8 * x4 * x2 * x2",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n\n    final double x = vals[0];\n    final double y = vals[1];\n    final double z = vals[2];\n    final double r2 = x * x + y * y + z * z;\n    final double r = FastMath.sqrt(r2);\n    final double oneOverR = 1 / r;\n    final double oneOverR2 = oneOverR * oneOverR;\n    final double oneOverR3 = oneOverR2 * oneOverR;\n    final double x2 = 2 * x * oneOverR;\n    final double y2 = 2 * y * oneOverR;\n    final double z2 = 2 * z * oneOverR;\n    final double x3 = 3 * x2 * oneOverR;\n    final double y3 = 3 * y2 * oneOverR;\n    final double z3 = 3 * z2 * oneOverR;\n    final double x4 = 4 * x2 * x2 * oneOverR2;\n    final double y4 = 4 * y2 * y2 * oneOverR2;\n    final double z4 = 4 * z2 * z2 * oneOverR2;\n    final double x5 = 5 * x4 * oneOverR2;\n    final double y5 = 5 * y4 * oneOverR2;\n    final double z5 = 5 * z4 * oneOverR2;\n    final double x6 = 6 * x4 * x2 * oneOverR2;\n    final double y6 = 6 * y4 * y2 * oneOverR2;\n    final double z6 = 6 * z4 * z2 * oneOverR2;\n    final double x7 = 7 * x4 * x3 * oneOverR2;\n    final double y7 = 7 * y4 * y3 * oneOverR2;\n    final double z7 = 7 * z4 * z3 * oneOverR2;\n    final double x8 = 8 * x4 * x4 * x2",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n\n    final double x = vals[0];\n    final double y = vals[1];\n    final double z = vals[2];\n    final double r2 = x * x + y * y + z * z;\n    final double r = FastMath.sqrt(r2);\n    final double oneOverR = 1 / r;\n    final double oneOverR2 = oneOverR * oneOverR;\n    final double oneOverR3 = oneOverR2 * oneOverR;\n    final double x2 = 2 * x * oneOverR;\n    final double y2 = 2 * y * oneOverR;\n    final double z2 = 2 * z * oneOverR;\n    final double x3 = 3 * x2 * oneOverR;\n    final double y3 = 3 * y2 * oneOverR;\n    final double z3 = 3 * z2 * oneOverR;\n    final double x4 = 4 * x2 * x2 * oneOverR2;\n    final double y4 = 4 * y2 * y2 * oneOverR2;\n    final double z4 = 4 * z2 * z2 * oneOverR2;\n    final double x5 = 5 * x4 * oneOverR2;\n    final double y5 = 5 * y4 * oneOverR2;\n    final double z5 = 5 * z4 * oneOverR2;\n    final double x6 = 6 * x4 * x2 * oneOverR2;\n    final double y6 = 6 * y4 * y2 * oneOverR2;\n    final double z6 = 6 * z4 * z2 * oneOverR2;\n    final double x7 = 7 * x5 * oneOverR2;\n    final double y7 = 7 * y5 * oneOverR2;\n    final double z7 = 7 * z5 * oneOverR2;\n    final double x8 = 8 * x5 * x2 * oneOverR2;\n    final double y8",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n\n    final double x = vals[0];\n    final double y = vals[1];\n    final double z = vals[2];\n    final double r2 = x * x + y * y + z * z;\n    final double r = FastMath.sqrt(r2);\n    final double oneOverR = 1 / r;\n    final double oneOverR2 = oneOverR * oneOverR;\n    final double oneOverR3 = oneOverR2 * oneOverR;\n    final double x2 = 2 * x * oneOverR;\n    final double y2 = 2 * y * oneOverR;\n    final double z2 = 2 * z * oneOverR;\n    final double x3 = 3 * x2 * oneOverR;\n    final double y3 = 3 * y2 * oneOverR;\n    final double z3 = 3 * z2 * oneOverR;\n    final double x4 = 4 * x2 * x2 * oneOverR2;\n    final double y4 = 4 * y2 * y2 * oneOverR2;\n    final double z4 = 4 * z2 * z2 * oneOverR2;\n    final double x5 = 5 * x4 * oneOverR2;\n    final double y5 = 5 * y4 * oneOverR2;\n    final double z5 = 5 * z4 * oneOverR2;\n    final double x6 = 6 * x4 * x2 * oneOverR2;\n    final double y6 = 6 * y4 * x2 * oneOverR2;\n    final double z6 = 6 * z4 * x2 * oneOverR2;\n    final double x7 = 7 * x4 * x4 * oneOverR2;\n    final double y7 = 7 * y4 * y4 * oneOverR2;\n    final double z7 = 7 * z4 * z4 * oneOverR2;\n    final double x8 = 8 * x4 * x4 * x2",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n\n    final double x = vals[0];\n    final double y = vals[1];\n    final double z = vals[2];\n    final double r2 = x * x + y * y + z * z;\n    final double r = FastMath.sqrt(r2);\n    final double oneOverR = 1 / r;\n    final double oneOverR2 = oneOverR * oneOverR;\n    final double oneOverR3 = oneOverR2 * oneOverR;\n    final double x2 = 2 * x * oneOverR;\n    final double y2 = 2 * y * oneOverR;\n    final double z2 = 2 * z * oneOverR;\n    final double x3 = 3 * x2 * oneOverR;\n    final double y3 = 3 * y2 * oneOverR;\n    final double z3 = 3 * z2 * oneOverR;\n    final double x4 = 4 * x2 * x2 * oneOverR2;\n    final double y4 = 4 * y2 * y2 * oneOverR2;\n    final double z4 = 4 * z2 * z2 * oneOverR2;\n    final double x5 = 5 * x4 * oneOverR2;\n    final double y5 = 5 * y4 * oneOverR2;\n    final double z5 = 5 * z4 * oneOverR2;\n    final double x6 = 6 * x4 * x2 * oneOverR2;\n    final double y6 = 6 * y4 * y2 * oneOverR2;\n    final double z6 = 6 * z4 * z2 * oneOverR2;\n    final double x7 = 7 * x6 * oneOverR2;\n    final double y7 = 7 * y6 * oneOverR2;\n    final double z7 = 7 * z6 * oneOverR2;\n    final double x8 = 8 * x6 * x3 * oneOverR2;\n    final double y8",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n\n    final double x = vals[0];\n    final double y = vals[1];\n    final double z = vals[2];\n    final double r2 = x * x + y * y + z * z;\n    final double r = FastMath.sqrt(r2);\n    final double oneOverR = 1 / r;\n    final double oneOverR2 = oneOverR * oneOverR;\n    final double oneOverR3 = oneOverR2 * oneOverR;\n    final double x2 = 2 * x * oneOverR;\n    final double y2 = 2 * y * oneOverR;\n    final double z2 = 2 * z * oneOverR;\n    final double x3 = 3 * x2 * oneOverR;\n    final double y3 = 3 * y2 * oneOverR;\n    final double z3 = 3 * z2 * oneOverR;\n    final double x4 = 4 * x2 * x2 * oneOverR2;\n    final double y4 = 4 * y2 * y2 * oneOverR2;\n    final double z4 = 4 * z2 * z2 * oneOverR2;\n    final double x5 = 5 * x4 * oneOverR2;\n    final double y5 = 5 * y4 * oneOverR2;\n    final double z5 = 5 * z4 * oneOverR2;\n    final double x6 = 6 * x4 * x2 * oneOverR2;\n    final double y6 = 6 * y4 * y2 * oneOverR2;\n    final double z6 = 6 * z4 * z2 * oneOverR2;\n    final double x7 = 7 * x4 * x3 * oneOverR2;\n    final double y7 = 7 * y4 * y3 * oneOverR2;\n    final double z7 = 7 * z4 * z3 * oneOverR2;\n    final double x8 = 8 * x4 * x4 * oneOver",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n\n    final double x = vals[0];\n    final double y = vals[1];\n    final double z = vals[2];\n    final double r2 = x * x + y * y + z * z;\n    final double r = FastMath.sqrt(r2);\n    final double oneOverR = 1 / r;\n    final double oneOverR2 = oneOverR * oneOverR;\n    final double oneOverR3 = oneOverR2 * oneOverR;\n    final double x2 = 2 * x * oneOverR;\n    final double y2 = 2 * y * oneOverR;\n    final double z2 = 2 * z * oneOverR;\n    final double x3 = 3 * x2 * oneOverR;\n    final double y3 = 3 * y2 * oneOverR;\n    final double z3 = 3 * z2 * oneOverR;\n    final double x4 = 4 * x2 * x2 * oneOverR2;\n    final double y4 = 4 * y2 * y2 * oneOverR2;\n    final double z4 = 4 * z2 * z2 * oneOverR2;\n    final double x5 = 5 * x4 * oneOverR2;\n    final double y5 = 5 * y4 * oneOverR2;\n    final double z5 = 5 * z4 * oneOverR2;\n    final double x6 = 6 * x4 * x2 * oneOverR2;\n    final double y6 = 6 * y4 * y2 * oneOverR2;\n    final double z6 = 6 * z4 * z2 * oneOverR2;\n    final double x7 = 7 * x6 * oneOverR2;\n    final double y7 = 7 * y6 * oneOverR2;\n    final double z7 = 7 * z6 * oneOverR2;\n    final double x8 = 8 * x4 * x3 * oneOverR2;\n    final double y8",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n\n    final double x = vals[0];\n    final double y = vals[1];\n    final double z = vals[2];\n    final double r2 = x * x + y * y + z * z;\n    final double r = FastMath.sqrt(r2);\n    final double oneOverR = 1 / r;\n    final double oneOverR2 = oneOverR * oneOverR;\n    final double oneOverR3 = oneOverR2 * oneOverR;\n    final double x2 = 2 * x * oneOverR;\n    final double y2 = 2 * y * oneOverR;\n    final double z2 = 2 * z * oneOverR;\n    final double x3 = 3 * x2 * oneOverR;\n    final double y3 = 3 * y2 * oneOverR;\n    final double z3 = 3 * z2 * oneOverR;\n    final double x4 = 4 * x2 * x2 * oneOverR2;\n    final double y4 = 4 * y2 * y2 * oneOverR2;\n    final double z4 = 4 * z2 * z2 * oneOverR2;\n    final double x5 = 5 * x4 * oneOverR2;\n    final double y5 = 5 * y4 * oneOverR2;\n    final double z5 = 5 * z4 * oneOverR2;\n    final double x6 = 6 * x4 * x2 * oneOverR2;\n    final double y6 = 6 * y4 * y2 * oneOverR2;\n    final double z6 = 6 * z4 * z2 * oneOverR2;\n    final double x7 = 7 * x5 * oneOverR2;\n    final double y7 = 7 * y5 * oneOverR2;\n    final double z7 = 7 * z5 * oneOverR2;\n    final double x8 = 8 * x4 * x3 * oneOverR2;\n    final double y8",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n\n    final double x = vals[0];\n    final double y = vals[1];\n    final double z = vals[2];\n    final double r2 = x * x + y * y + z * z;\n    final double r = FastMath.sqrt(r2);\n    final double oneOverR = 1 / r;\n    final double oneOverR2 = oneOverR * oneOverR;\n    final double oneOverR3 = oneOverR2 * oneOverR;\n    final double x2 = 2 * x * oneOverR;\n    final double y2 = 2 * y * oneOverR;\n    final double z2 = 2 * z * oneOverR;\n    final double x3 = 3 * x2 * oneOverR;\n    final double y3 = 3 * y2 * oneOverR;\n    final double z3 = 3 * z2 * oneOverR;\n    final double x4 = 4 * x2 * x2 * oneOverR2;\n    final double y4 = 4 * y2 * y2 * oneOverR2;\n    final double z4 = 4 * z2 * z2 * oneOverR2;\n    final double x5 = 5 * x4 * oneOverR2;\n    final double y5 = 5 * y4 * oneOverR2;\n    final double z5 = 5 * z4 * oneOverR2;\n    final double x6 = 6 * x4 * x2 * oneOverR2;\n    final double y6 = 6 * y4 * y2 * oneOverR2;\n    final double z6 = 6 * z4 * z2 * oneOverR2;\n    final double x7 = 7 * x6 * oneOverR2;\n    final double y7 = 7 * y6 * oneOverR2;\n    final double z7 = 7 * z6 * oneOverR2;\n    final double x8 = 8 * x6 * x2 * oneOverR3;\n    final double y8"
      ],
      "function range": "177,5-186,5"
    },
    "Math_20_/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java_921-922": {
      "loc": "921-922",
      "input": "public double[] repairAndDecode(final double[] x) {",
      "output": [
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repairAndDecode(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repairAndDecode(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repairAndDecode(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repairAndDecode(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.Logical",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repairAndDecode(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.al",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repairAndDecode(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.Logical",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repairAndDecode(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperator",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repairAndDecode(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repairAndDecode(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoin",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repairAndDecode(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnn"
      ],
      "function range": "920,9-923,9"
    },
    "Math_27_/src/main/java/org/apache/commons/math3/fraction/Fraction.java_597-598": {
      "loc": "597-598",
      "input": "public double percentageValue() {",
      "output": [
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    public void setPercentageValue(double percentageValue) {\n        this.percentageValue = percentageValue;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    public void setPercentageValue(double percentageValue) {\n        this.percentageValue = percentageValue;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.log",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    public void setPercentageValue(double percentageValue) {\n        this.percentageValue = percentageValue;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLog",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    public void setPercentageValue(double percentageValue) {\n        this.percentageValue = percentageValue;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    public void setPercentageValue(double percentageValue) {\n        this.percentageValue = percentageValue;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    public void setPercentageValue(double percentageValue) {\n        this.percentageValue = percentageValue;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    public void setPercentageValue(double percentageValue) {\n        this.percentageValue = percentageValue;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\n",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    public void setPercentageValue(double percentageValue) {\n        this.percentageValue = percentageValue;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AggregateOperator;\nimport",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    public void setPercentageValue(double percentageValue) {\n        this.percentageValue = percentageValue;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractBinaryJoinOperator;\nimport org.apache.hyracks.algebricks",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    public void setPercentageValue(double percentageValue) {\n        this.percentageValue = percentageValue;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators"
      ],
      "function range": "596,5-598,5"
    },
    "Math_30_/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java_173-174": {
      "loc": "173-174",
      "input": "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {",
      "output": [
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        if (n1 < 0 || n2 < 0) {\n            return Double.NaN;\n        }\n        if (n1 == 0 || n2 == 0) {\n            return Double.NaN;\n        }\n        if (n1 == 1 || n2 == 1) {\n            return Double.NaN;\n        }\n        if (n1 == 2 || n2 == 2) {\n            return Double.NaN;\n        }\n        if (n1 == 3 || n2 == 3) {\n            return Double.NaN;\n        }\n        if (n1 == 4 || n2 == 4) {\n            return Double.NaN;\n        }\n        if (n1 == 5 || n2 == 5) {\n            return Double.NaN;\n        }\n        if (n1 == 6 || n2 == 6) {\n            return Double.NaN;\n        }\n        if (n1 == 7 || n2 == 7) {\n            return Double.NaN;\n        }\n        if (n1 == 8 || n2 == 8) {\n            return Double.NaN;\n        }\n        if (n1 == 9 || n2 == 9) {\n            return Double.NaN;\n        }\n        if (n1 == 10 || n2 == 10) {\n            return Double.NaN;\n        }\n        if (n1 == 11 || n2 == 11) {\n            return Double.NaN;\n        }\n        if (n1 == 12 || n2 == 12) {\n            return Double.NaN;\n        }\n        if (n1 == 13 || n2 == 13) {\n            return Double.NaN;\n        }\n        if (n1 == 14 || n2 == 14) {\n            return Double.NaN;\n        }\n        if (n1 == 15 || n2 == 15) {\n            return Double.NaN;\n        }\n        if (n1 == 16 || n2 == 16) {\n            return Double.NaN;\n",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        if (n1 < 0 || n2 < 0) {\n            return Double.NaN;\n        }\n        if (n1 == 0 || n2 == 0) {\n            return Double.NaN;\n        }\n        if (n1 == 1 || n2 == 1) {\n            return Double.NaN;\n        }\n        if (n1 == 2 || n2 == 2) {\n            return Double.NaN;\n        }\n        if (n1 == 3 || n2 == 3) {\n            return Double.NaN;\n        }\n        if (n1 == 4 || n2 == 4) {\n            return Double.NaN;\n        }\n        if (n1 == 5 || n2 == 5) {\n            return Double.NaN;\n        }\n        if (n1 == 6 || n2 == 6) {\n            return Double.NaN;\n        }\n        if (n1 == 7 || n2 == 7) {\n            return Double.NaN;\n        }\n        if (n1 == 8 || n2 == 8) {\n            return Double.NaN;\n        }\n        if (n1 == 9 || n2 == 9) {\n            return Double.NaN;\n        }\n        if (n1 == 10 || n2 == 10) {\n            return Double.NaN;\n        }\n        if (n1 == 11 || n2 == 11) {\n            return Double.NaN;\n        }\n        if (n1 == 12 || n2 == 12) {\n            return Double.NaN;\n        }\n        if (n1 == 13 || n2 == 13) {\n            return Double.NaN;\n        }\n        if (n1 == 14 || n2 == 14) {\n            return Double.NaN;\n        }\n        if (n1 == 15 || n2 == 15) {\n            return Double.NaN;\n        }\n        if (n1 > 15 || n2 > 15) {\n            return Double.NaN;\n",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        if (n1 < 0 || n2 < 0) {\n            return Double.NaN;\n        }\n        if (n1 == 0 || n2 == 0) {\n            return Double.NaN;\n        }\n        if (n1 == 1 || n2 == 1) {\n            return Double.NaN;\n        }\n        if (n1 == 2 || n2 == 2) {\n            return Double.NaN;\n        }\n        if (n1 == 3 || n2 == 3) {\n            return Double.NaN;\n        }\n        if (n1 == 4 || n2 == 4) {\n            return Double.NaN;\n        }\n        if (n1 == 5 || n2 == 5) {\n            return Double.NaN;\n        }\n        if (n1 == 6 || n2 == 6) {\n            return Double.NaN;\n        }\n        if (n1 == 7 || n2 == 7) {\n            return Double.NaN;\n        }\n        if (n1 == 8 || n2 == 8) {\n            return Double.NaN;\n        }\n        if (n1 == 9 || n2 == 9) {\n            return Double.NaN;\n        }\n        if (n1 == 10 || n2 == 10) {\n            return Double.NaN;\n        }\n        if (n1 == 11 || n2 == 11) {\n            return Double.NaN;\n        }\n        if (n1 == 12 || n2 == 12) {\n            return Double.NaN;\n        }\n        if (n1 == 13 || n2 == 13) {\n            return Double.NaN;\n        }\n        if (n1 == 14 || n2 == 14) {\n            return Double.NaN;\n        }\n        if (n1 == 15 || n2 == 15) {\n            return Double.NaN;\n        }\n        if (n1 == 16 || n2 == 16) {\n            return 0.0;\n        ",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        if (n1 < 0 || n2 < 0) {\n            return Double.NaN;\n        }\n        if (n1 == 0 || n2 == 0) {\n            return Double.NaN;\n        }\n        if (n1 == 1 || n2 == 1) {\n            return Double.NaN;\n        }\n        if (n1 == 2 || n2 == 2) {\n            return Double.NaN;\n        }\n        if (n1 == 3 || n2 == 3) {\n            return Double.NaN;\n        }\n        if (n1 == 4 || n2 == 4) {\n            return Double.NaN;\n        }\n        if (n1 == 5 || n2 == 5) {\n            return Double.NaN;\n        }\n        if (n1 == 6 || n2 == 6) {\n            return Double.NaN;\n        }\n        if (n1 == 7 || n2 == 7) {\n            return Double.NaN;\n        }\n        if (n1 == 8 || n2 == 8) {\n            return Double.NaN;\n        }\n        if (n1 == 9 || n2 == 9) {\n            return Double.NaN;\n        }\n        if (n1 == 10 || n2 == 10) {\n            return Double.NaN;\n        }\n        if (n1 == 11 || n2 == 11) {\n            return Double.NaN;\n        }\n        if (n1 == 12 || n2 == 12) {\n            return Double.NaN;\n        }\n        if (n1 == 13 || n2 == 13) {\n            return Double.NaN;\n        }\n        if (n1 == 14 || n2 == 14) {\n            return Double.NaN;\n        }\n        if (n1 == 15 || n2 == 15) {\n            return Double.NaN;\n        }\n        return hypergeometricDistribution.probability(n1, n2, Umin);\n    ",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        if (n1 < 0 || n2 < 0) {\n            return Double.NaN;\n        }\n        if (n1 == 0 || n2 == 0) {\n            return Double.NaN;\n        }\n        if (n1 == 1 || n2 == 1) {\n            return Double.NaN;\n        }\n        if (n1 == 2 || n2 == 2) {\n            return Double.NaN;\n        }\n        if (n1 == 3 || n2 == 3) {\n            return Double.NaN;\n        }\n        if (n1 == 4 || n2 == 4) {\n            return Double.NaN;\n        }\n        if (n1 == 5 || n2 == 5) {\n            return Double.NaN;\n        }\n        if (n1 == 6 || n2 == 6) {\n            return Double.NaN;\n        }\n        if (n1 == 7 || n2 == 7) {\n            return Double.NaN;\n        }\n        if (n1 == 8 || n2 == 8) {\n            return Double.NaN;\n        }\n        if (n1 == 9 || n2 == 9) {\n            return Double.NaN;\n        }\n        if (n1 == 10 || n2 == 10) {\n            return Double.NaN;\n        }\n        if (n1 == 11 || n2 == 11) {\n            return Double.NaN;\n        }\n        if (n1 == 12 || n2 == 12) {\n            return Double.NaN;\n        }\n        if (n1 == 13 || n2 == 13) {\n            return Double.NaN;\n        }\n        if (n1 == 14 || n2 == 14) {\n            return Double.NaN;\n        }\n        if (n1 == 15 || n2 == 15) {\n            return Double.NaN;\n        }\n        return hypergeometricDistribution.probability(Umin, n1, n2);\n    ",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        if (n1 < 0 || n2 < 0) {\n            return Double.NaN;\n        }\n        if (n1 == 0 || n2 == 0) {\n            return Double.NaN;\n        }\n        if (n1 == 1 || n2 == 1) {\n            return Double.NaN;\n        }\n        if (n1 == 2 || n2 == 2) {\n            return Double.NaN;\n        }\n        if (n1 == 3 || n2 == 3) {\n            return Double.NaN;\n        }\n        if (n1 == 4 || n2 == 4) {\n            return Double.NaN;\n        }\n        if (n1 == 5 || n2 == 5) {\n            return Double.NaN;\n        }\n        if (n1 == 6 || n2 == 6) {\n            return Double.NaN;\n        }\n        if (n1 == 7 || n2 == 7) {\n            return Double.NaN;\n        }\n        if (n1 == 8 || n2 == 8) {\n            return Double.NaN;\n        }\n        if (n1 == 9 || n2 == 9) {\n            return Double.NaN;\n        }\n        if (n1 == 10 || n2 == 10) {\n            return Double.NaN;\n        }\n        if (n1 == 11 || n2 == 11) {\n            return Double.NaN;\n        }\n        if (n1 == 12 || n2 == 12) {\n            return Double.NaN;\n        }\n        if (n1 == 13 || n2 == 13) {\n            return Double.NaN;\n        }\n        if (n1 == 14 || n2 == 14) {\n            return Double.NaN;\n        }\n        if (n1 == 15 || n2 == 15) {\n            return Double.NaN;\n        }\n        return hypergeometricDistribution.probability(n1, n2, n1 + n2",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        if (n1 < 0 || n2 < 0) {\n            return Double.NaN;\n        }\n        if (n1 == 0 || n2 == 0) {\n            return Double.NaN;\n        }\n        if (n1 == 1 || n2 == 1) {\n            return Double.NaN;\n        }\n        if (n1 == 2 || n2 == 2) {\n            return Double.NaN;\n        }\n        if (n1 == 3 || n2 == 3) {\n            return Double.NaN;\n        }\n        if (n1 == 4 || n2 == 4) {\n            return Double.NaN;\n        }\n        if (n1 == 5 || n2 == 5) {\n            return Double.NaN;\n        }\n        if (n1 == 6 || n2 == 6) {\n            return Double.NaN;\n        }\n        if (n1 == 7 || n2 == 7) {\n            return Double.NaN;\n        }\n        if (n1 == 8 || n2 == 8) {\n            return Double.NaN;\n        }\n        if (n1 == 9 || n2 == 9) {\n            return Double.NaN;\n        }\n        if (n1 == 10 || n2 == 10) {\n            return Double.NaN;\n        }\n        if (n1 == 11 || n2 == 11) {\n            return Double.NaN;\n        }\n        if (n1 == 12 || n2 == 12) {\n            return Double.NaN;\n        }\n        if (n1 == 13 || n2 == 13) {\n            return Double.NaN;\n        }\n        if (n1 == 14 || n2 == 14) {\n            return Double.NaN;\n        }\n        if (n1 == 15 || n2 == 15) {\n            return Double.NaN;\n        }\n        if (n1 == 16 || n2 == 16) {\n            return 1.0;\n        ",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        if (n1 < 0 || n2 < 0) {\n            return Double.NaN;\n        }\n        if (n1 == 0 || n2 == 0) {\n            return Double.NaN;\n        }\n        if (n1 == 1 || n2 == 1) {\n            return Double.NaN;\n        }\n        if (n1 == 2 || n2 == 2) {\n            return Double.NaN;\n        }\n        if (n1 == 3 || n2 == 3) {\n            return Double.NaN;\n        }\n        if (n1 == 4 || n2 == 4) {\n            return Double.NaN;\n        }\n        if (n1 == 5 || n2 == 5) {\n            return Double.NaN;\n        }\n        if (n1 == 6 || n2 == 6) {\n            return Double.NaN;\n        }\n        if (n1 == 7 || n2 == 7) {\n            return Double.NaN;\n        }\n        if (n1 == 8 || n2 == 8) {\n            return Double.NaN;\n        }\n        if (n1 == 9 || n2 == 9) {\n            return Double.NaN;\n        }\n        if (n1 == 10 || n2 == 10) {\n            return Double.NaN;\n        }\n        if (n1 == 11 || n2 == 11) {\n            return Double.NaN;\n        }\n        if (n1 == 12 || n2 == 12) {\n            return Double.NaN;\n        }\n        if (n1 == 13 || n2 == 13) {\n            return Double.NaN;\n        }\n        if (n1 == 14 || n2 == 14) {\n            return Double.NaN;\n        }\n        if (n1 == 15 || n2 == 15) {\n            return Double.NaN;\n        }\n        if (n1 > 15 || n2 > 15) {\n            throw new ConvergenceException(Local",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        if (n1 < 0 || n2 < 0) {\n            return Double.NaN;\n        }\n        if (n1 == 0 || n2 == 0) {\n            return Double.NaN;\n        }\n        if (n1 == 1 || n2 == 1) {\n            return Double.NaN;\n        }\n        if (n1 == 2 || n2 == 2) {\n            return Double.NaN;\n        }\n        if (n1 == 3 || n2 == 3) {\n            return Double.NaN;\n        }\n        if (n1 == 4 || n2 == 4) {\n            return Double.NaN;\n        }\n        if (n1 == 5 || n2 == 5) {\n            return Double.NaN;\n        }\n        if (n1 == 6 || n2 == 6) {\n            return Double.NaN;\n        }\n        if (n1 == 7 || n2 == 7) {\n            return Double.NaN;\n        }\n        if (n1 == 8 || n2 == 8) {\n            return Double.NaN;\n        }\n        if (n1 == 9 || n2 == 9) {\n            return Double.NaN;\n        }\n        if (n1 == 10 || n2 == 10) {\n            return Double.NaN;\n        }\n        if (n1 == 11 || n2 == 11) {\n            return Double.NaN;\n        }\n        if (n1 == 12 || n2 == 12) {\n            return Double.NaN;\n        }\n        if (n1 == 13 || n2 == 13) {\n            return Double.NaN;\n        }\n        if (n1 == 14 || n2 == 14) {\n            return Double.NaN;\n        }\n        if (n1 == 15 || n2 == 15) {\n            return Double.NaN;\n        }\n        if (n1 > 15 || n2 > 15) {\n            throw new ConvergenceException();\n",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        if (n1 < 0 || n2 < 0) {\n            return Double.NaN;\n        }\n        if (n1 == 0 || n2 == 0) {\n            return Double.NaN;\n        }\n        if (n1 == 1 || n2 == 1) {\n            return Double.NaN;\n        }\n        if (n1 == 2 || n2 == 2) {\n            return Double.NaN;\n        }\n        if (n1 == 3 || n2 == 3) {\n            return Double.NaN;\n        }\n        if (n1 == 4 || n2 == 4) {\n            return Double.NaN;\n        }\n        if (n1 == 5 || n2 == 5) {\n            return Double.NaN;\n        }\n        if (n1 == 6 || n2 == 6) {\n            return Double.NaN;\n        }\n        if (n1 == 7 || n2 == 7) {\n            return Double.NaN;\n        }\n        if (n1 == 8 || n2 == 8) {\n            return Double.NaN;\n        }\n        if (n1 == 9 || n2 == 9) {\n            return Double.NaN;\n        }\n        if (n1 == 10 || n2 == 10) {\n            return Double.NaN;\n        }\n        if (n1 == 11 || n2 == 11) {\n            return Double.NaN;\n        }\n        if (n1 == 12 || n2 == 12) {\n            return Double.NaN;\n        }\n        if (n1 == 13 || n2 == 13) {\n            return Double.NaN;\n        }\n        if (n1 == 14 || n2 == 14) {\n            return Double.NaN;\n        }\n        if (n1 == 15 || n2 == 15) {\n            return Double.NaN;\n        }\n        if (n1 == 16 || n2 == 16) {\n            return 0;\n        }\n"
      ],
      "function range": "168,5-184,5"
    },
    "Math_32_/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java_136-137": {
      "loc": "136-137",
      "input": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);",
      "output": [
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> hyperplane =\n            (SubHyperplane<Euclidean2D>) tree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> otherTree = hyperplane.getTree(false);\n        if (otherTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> otherHyperplane =\n            (SubHyperplane<Euclidean2D>) otherTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> parentTree = otherHyperplane.getTree(false);\n        if (parentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> parentHyperplane =\n            (SubHyperplane<Euclidean2D>) parentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> grandParentTree = parentHyperplane.getTree(false);\n        if (grandParentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> grandParentHyperplane =\n            (SubHyperplane<Euclidean2D>) grandParentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatGrandParentTree = grandParentHyperplane.getTree(false);\n        if (greatGrandParentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> greatGrandParentHyperplane =\n            (SubHyperplane<Euclidean2D>) greatGrandParentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatGreatGrandParentTree =\n            greatGrand",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> hyperplane =\n            (SubHyperplane<Euclidean2D>) tree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> otherTree = hyperplane.getTree(false);\n        if (otherTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> otherHyperplane =\n            (SubHyperplane<Euclidean2D>) otherTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> parentTree = otherHyperplane.getTree(false);\n        if (parentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> parentHyperplane =\n            (SubHyperplane<Euclidean2D>) parentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> grandparentTree = parentHyperplane.getTree(false);\n        if (grandparentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> grandparentHyperplane =\n            (SubHyperplane<Euclidean2D>) grandparentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatGrandparentTree = grandparentHyperplane.getTree(false);\n        if (greatGrandparentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> greatGrandparentHyperplane =\n            (SubHyperplane<Euclidean2D>) greatGrandparentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatGreatGrandparentTree =\n            greatGrand",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> hyperplane =\n            (SubHyperplane<Euclidean2D>) tree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> otherTree = hyperplane.getTree(false);\n        if (otherTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> otherHyperplane =\n            (SubHyperplane<Euclidean2D>) otherTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> parentTree = otherHyperplane.getTree(false);\n        if (parentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> parentHyperplane =\n            (SubHyperplane<Euclidean2D>) parentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> grandParentTree = parentHyperplane.getTree(false);\n        if (grandParentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> grandParentHyperplane =\n            (SubHyperplane<Euclidean2D>) grandParentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatGrandParentTree = grandParentHyperplane.getTree(false);\n        if (greatGrandParentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> greatGrandParentHyperplane =\n            (SubHyperplane<Euclidean2D>) greatGrandParentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatGreatGrandParentTree = greatGrandParentHyper",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> hyperplane =\n            (SubHyperplane<Euclidean2D>) tree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> otherTree = hyperplane.getTree(false);\n        if (otherTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> otherHyperplane =\n            (SubHyperplane<Euclidean2D>) otherTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> parentTree = otherHyperplane.getTree(false);\n        if (parentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> parentHyperplane =\n            (SubHyperplane<Euclidean2D>) parentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> grandparentTree = parentHyperplane.getTree(false);\n        if (grandparentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> grandparentHyperplane =\n            (SubHyperplane<Euclidean2D>) grandparentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatGrandparentTree = grandparentHyperplane.getTree(false);\n        if (greatGrandparentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> greatGrandparentHyperplane =\n            (SubHyperplane<Euclidean2D>) greatGrandparentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatGreatGrandparentTree = greatGrandparentHyper",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> hyperplane =\n            (SubHyperplane<Euclidean2D>) tree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> otherTree = hyperplane.getTree(false);\n        if (otherTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> otherHyperplane =\n            (SubHyperplane<Euclidean2D>) otherTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> parentTree = otherHyperplane.getTree(false);\n        if (parentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> parentHyperplane =\n            (SubHyperplane<Euclidean2D>) parentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> grandParentTree = parentHyperplane.getTree(false);\n        if (grandParentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> grandParentHyperplane =\n            (SubHyperplane<Euclidean2D>) grandParentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatGrandParentTree =\n            grandParentHyperplane.getTree(false);\n        if (greatGrandParentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> greatGrandParentHyperplane =\n            (SubHyperplane<Euclidean2D>) greatGrandParentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatGreatGrandParentTree =\n            ",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> hyperplane =\n            (SubHyperplane<Euclidean2D>) tree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> otherTree = hyperplane.getTree(false);\n        if (otherTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> otherHyperplane =\n            (SubHyperplane<Euclidean2D>) otherTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> parentTree = otherHyperplane.getTree(false);\n        if (parentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> parentHyperplane =\n            (SubHyperplane<Euclidean2D>) parentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> grandparentTree = parentHyperplane.getTree(false);\n        if (grandparentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> grandparentHyperplane =\n            (SubHyperplane<Euclidean2D>) grandparentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatGrandparentTree =\n            grandparentHyperplane.getTree(false);\n        if (greatGrandparentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> greatGrandparentHyperplane =\n            (SubHyperplane<Euclidean2D>) greatGrandparentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatGreatGrandparentTree =\n            ",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> hyperplane =\n            (SubHyperplane<Euclidean2D>) tree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> otherTree = hyperplane.getTree(false);\n        if (otherTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> otherHyperplane =\n            (SubHyperplane<Euclidean2D>) otherTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> parentTree = otherHyperplane.getTree(false);\n        if (parentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> parentHyperplane =\n            (SubHyperplane<Euclidean2D>) parentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> grandParentTree = parentHyperplane.getTree(false);\n        if (grandParentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> grandParentHyperplane =\n            (SubHyperplane<Euclidean2D>) grandParentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatGrandParentTree = grandParentHyperplane.getTree(false);\n        if (greatGrandParentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> greatGrandParentHyperplane =\n            (SubHyperplane<Euclidean2D>) greatGrandParentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> root = greatGrandParentHyperplane.getTree",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> hyperplane =\n            (SubHyperplane<Euclidean2D>) tree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> otherTree = hyperplane.getTree(false);\n        if (otherTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> otherHyperplane =\n            (SubHyperplane<Euclidean2D>) otherTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> parentTree = otherHyperplane.getTree(false);\n        if (parentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> parentHyperplane =\n            (SubHyperplane<Euclidean2D>) parentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> grandParentTree = parentHyperplane.getTree(false);\n        if (grandParentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> grandParentHyperplane =\n            (SubHyperplane<Euclidean2D>) grandParentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatParentTree = grandParentHyperplane.getTree(false);\n        if (greatParentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> greatParentHyperplane =\n            (SubHyperplane<Euclidean2D>) greatParentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> rootTree = greatParentHyperplane.getTree(false);\n",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> hyperplane =\n            (SubHyperplane<Euclidean2D>) tree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> otherTree = hyperplane.getTree(false);\n        if (otherTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> otherHyperplane =\n            (SubHyperplane<Euclidean2D>) otherTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> parentTree = otherHyperplane.getTree(false);\n        if (parentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> parentHyperplane =\n            (SubHyperplane<Euclidean2D>) parentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> grandparentTree = parentHyperplane.getTree(false);\n        if (grandparentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> grandparentHyperplane =\n            (SubHyperplane<Euclidean2D>) grandparentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatgrandparentTree = grandparentHyperplane.getTree(false);\n        if (greatgrandparentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> greatgrandparentHyperplane =\n            (SubHyperplane<Euclidean2D>) greatgrandparentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatgreatgrandparentTree =\n            greatgrand",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> hyperplane =\n            (SubHyperplane<Euclidean2D>) tree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> otherTree = hyperplane.getTree(false);\n        if (otherTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> otherHyperplane =\n            (SubHyperplane<Euclidean2D>) otherTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> parentTree = otherHyperplane.getTree(false);\n        if (parentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> parentHyperplane =\n            (SubHyperplane<Euclidean2D>) parentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> grandparentTree = parentHyperplane.getTree(false);\n        if (grandparentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> grandparentHyperplane =\n            (SubHyperplane<Euclidean2D>) grandparentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> greatGrandparentTree = grandparentHyperplane.getTree(false);\n        if (greatGrandparentTree.getCut() == null) {\n            return;\n        }\n        final SubHyperplane<Euclidean2D> greatGrandparentHyperplane =\n            (SubHyperplane<Euclidean2D>) greatGrandparentTree.getCut().getHyperplane();\n        final BSPTree<Euclidean2D> parentOfParentTree =\n            greatGrandparent"
      ],
      "function range": "129,5-181,5"
    },
    "Math_33_/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java_338-339": {
      "loc": "338-339",
      "input": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);",
      "output": [
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        int columnToDrop = columnsToDrop.get(i);\n        for (int j = i + 1; j < columnsToDrop.size(); j++) {\n            columnsToDrop.set(j - 1, columnsToDrop.get(j));\n        }\n        columnsToDrop.set(columnsToDrop.size() - 1, columnToDrop);\n        for (int j = 0; j < getNumObjectiveFunctions(); j++) {\n            tableau.setEntry(j, columnToDrop, tableau.getEntry(j, columnToDrop));\n        }\n        for (int j = 0; j < getNumArtificialVariables(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + j, columnToDrop, tableau.getEntry(getNumObjectiveFunctions() + j, columnToDrop));\n        }\n        for (int j = 0; j < getNumConstraints(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + getNumArtificialVariables() + j, columnToDrop, tableau.getEntry(getNumObjectiveFunctions() + getNumArt",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        int columnToDrop = columnsToDrop.get(i);\n        for (int j = i + 1; j < columnsToDrop.size(); j++) {\n            columnsToDrop.set(j - 1, columnsToDrop.get(j));\n        }\n        columnsToDrop.set(columnsToDrop.size() - 1, columnToDrop);\n        for (int j = 0; j < getNumObjectiveFunctions(); j++) {\n            tableau.setEntry(j, columnToDrop, tableau.getEntry(j, columnToDrop));\n        }\n        for (int j = 0; j < getNumArtificialVariables(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + j, columnToDrop, tableau.getEntry(getNumObjectiveFunctions() + j, columnToDrop));\n        }\n        for (int j = 0; j < getNumArtificialVariables(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + getNumArtificialVariables() + j, columnToDrop, tableau.getEntry(getNumObjectiveFunctions() + getNum",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        int columnToDrop = columnsToDrop.get(i);\n        for (int j = i + 1; j < columnsToDrop.size(); j++) {\n            columnsToDrop.set(j - 1, columnsToDrop.get(j));\n        }\n        columnsToDrop.set(columnsToDrop.size() - 1, columnToDrop);\n        for (int j = 0; j < getNumObjectiveFunctions(); j++) {\n            tableau.setEntry(j, columnToDrop, tableau.getEntry(j, columnToDrop));\n        }\n        for (int j = 0; j < getNumArtificialVariables(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + j, columnToDrop, tableau.getEntry(getNumObjectiveFunctions() + j, columnToDrop));\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        int columnToDrop = columnsToDrop.get(i);\n        for (int j = 0; j < getNumObjectiveFunctions(); j++) {\n            tableau",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        int columnToDrop = columnsToDrop.get(i);\n        for (int j = i + 1; j < columnsToDrop.size(); j++) {\n            columnsToDrop.set(j - 1, columnsToDrop.get(j));\n        }\n        columnsToDrop.set(columnsToDrop.size() - 1, columnToDrop);\n        for (int j = 0; j < getNumObjectiveFunctions(); j++) {\n            tableau.setEntry(j, columnToDrop, tableau.getEntry(j, columnToDrop));\n        }\n        for (int j = 0; j < getNumArtificialVariables(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + j, columnToDrop, tableau.getEntry(getNumObjectiveFunctions() + j, columnToDrop));\n        }\n        for (int j = 0; j < getNumConstraints(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + getNumArtificialVariables() + j, columnToDrop,\n                             tableau.getEntry(getNumObjectiveFunctions() + get",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        int columnToDrop = columnsToDrop.get(i);\n        for (int j = i + 1; j < columnsToDrop.size(); j++) {\n            columnsToDrop.set(j - 1, columnsToDrop.get(j));\n        }\n        columnsToDrop.set(columnsToDrop.size() - 1, columnToDrop);\n        for (int j = 0; j < getNumObjectiveFunctions(); j++) {\n            tableau.setEntry(j, columnToDrop, tableau.getEntry(j, columnToDrop));\n        }\n        for (int j = 0; j < getNumArtificialVariables(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + j, columnToDrop, tableau.getEntry(getNumObjectiveFunctions() + j, columnToDrop));\n        }\n        for (int j = 0; j < getNumConstraints(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + getNumArtificialVariables() + j, columnToDrop,\n                    tableau.getEntry(getNumObjectiveFunctions() + get",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        int columnToDrop = columnsToDrop.get(i);\n        for (int j = i + 1; j < columnsToDrop.size(); j++) {\n            columnsToDrop.set(j - 1, columnsToDrop.get(j));\n        }\n        columnsToDrop.set(columnsToDrop.size() - 1, columnToDrop);\n        for (int j = 0; j < getNumObjectiveFunctions(); j++) {\n            tableau.setEntry(j, columnToDrop, tableau.getEntry(j, columnToDrop));\n        }\n        for (int j = 0; j < getNumArtificialVariables(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + j, columnToDrop, tableau.getEntry(getNumObjectiveFunctions() + j, columnToDrop));\n        }\n        for (int j = 0; j < getNumConstraints(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + getNumArtificialVariables() + j, columnToDrop,\n                            tableau.getEntry(getNumObjectiveFunctions() + get",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        int columnToDrop = columnsToDrop.get(i);\n        for (int j = i + 1; j < columnsToDrop.size(); j++) {\n            columnsToDrop.set(j - 1, columnsToDrop.get(j));\n        }\n        columnsToDrop.set(columnsToDrop.size() - 1, columnToDrop);\n        for (int j = 0; j < getNumObjectiveFunctions(); j++) {\n            tableau.setEntry(j, columnToDrop, tableau.getEntry(j, columnToDrop));\n        }\n        for (int j = 0; j < getNumArtificialVariables(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + j, columnToDrop, tableau.getEntry(getNumObjectiveFunctions() + j, columnToDrop));\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        int columnToDrop = columnsToDrop.get(i);\n        for (int j = i + 1; j < columnsToDrop.size(); j++) {\n            column",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        int columnToDrop = columnsToDrop.get(i);\n        for (int j = i + 1; j < columnsToDrop.size(); j++) {\n            columnsToDrop.set(j - 1, columnsToDrop.get(j));\n        }\n        columnsToDrop.set(columnsToDrop.size() - 1, columnToDrop);\n        for (int j = 0; j < getNumObjectiveFunctions(); j++) {\n            tableau.setEntry(j, columnToDrop, tableau.getEntry(j, columnToDrop));\n        }\n        for (int j = 0; j < getNumArtificialVariables(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + j, columnToDrop, tableau.getEntry(getNumObjectiveFunctions() + j, columnToDrop));\n        }\n        for (int j = 0; j < getNumArtificialVariables(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + getNumArtificialVariables() + j, columnToDrop,\n                    tableau.getEntry(getNumObjectiveFunctions() +",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        int columnToDrop = columnsToDrop.get(i);\n        for (int j = i + 1; j < columnsToDrop.size(); j++) {\n            columnsToDrop.set(j - 1, columnsToDrop.get(j));\n        }\n        columnsToDrop.set(columnsToDrop.size() - 1, columnToDrop);\n        for (int j = 0; j < getNumObjectiveFunctions(); j++) {\n            tableau.setEntry(j, columnToDrop, tableau.getEntry(j, columnToDrop));\n        }\n        for (int j = 0; j < getNumArtificialVariables(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + j, columnToDrop, tableau.getEntry(getNumObjectiveFunctions() + j, columnToDrop));\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        int columnToDrop = columnsToDrop.get(i);\n        for (int j = 0; j < getNumArtificialVariables(); j++) {\n            tableau",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, 1e-9) < 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        int columnToDrop = columnsToDrop.get(i);\n        for (int j = i + 1; j < columnsToDrop.size(); j++) {\n            columnsToDrop.set(j - 1, columnsToDrop.get(j));\n        }\n        columnsToDrop.set(columnsToDrop.size() - 1, columnToDrop);\n        for (int j = 0; j < getNumObjectiveFunctions(); j++) {\n            tableau.setEntry(j, columnToDrop, tableau.getEntry(j, columnToDrop));\n        }\n        for (int j = 0; j < getNumArtificialVariables(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + j, columnToDrop, tableau.getEntry(getNumObjectiveFunctions() + j, columnToDrop));\n        }\n        for (int j = 0; j < getNumArtificialVariables(); j++) {\n            tableau.setEntry(getNumObjectiveFunctions() + getNumArtificialVariables() + j, columnToDrop,\n                             tableau.getEntry(getNumObjectiveFunctions() +"
      ],
      "function range": "327,5-367,5"
    },
    "Math_34_/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java_209-210": {
      "loc": "209-210",
      "input": "public Iterator<Chromosome> iterator() {",
      "output": [
        "public Iterator<Chromosome> iterator() {\n        return chromosomes.values().iterator();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.",
        "public Iterator<Chromosome> iterator() {\n        return chromosomes.values().iterator();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.express",
        "public Iterator<Chromosome> iterator() {\n        return chromosomes.values().iterator();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyracks.algebricks.core.al",
        "public Iterator<Chromosome> iterator() {\n        return chromosomes.values().iterator();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;",
        "public Iterator<Chromosome> iterator() {\n        return chromosomes.values().iterator();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.algebricks.core.al",
        "public Iterator<Chromosome> iterator() {\n        return chromosomes.values().iterator();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.oper",
        "public Iterator<Chromosome> iterator() {\n        return chromosomes.values().iterator();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public Iterator<Chromosome> iterator() {\n        return chromosomes.values().iterator();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.VariableReferenceExpression;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.",
        "public Iterator<Chromosome> iterator() {\n        return chromosomes.values().iterator();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AggregateOperator;\nimport org",
        "public Iterator<Chromosome> iterator() {\n        return chromosomes.values().iterator();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport"
      ],
      "function range": "208,5-210,5"
    },
    "Math_41_/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java_520-521": {
      "loc": "520-521",
      "input": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;",
      "output": [
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            if (sumWts > 0) {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n            }\n        }\n    }\n    return var;\n  }\n\n  public double evaluate(final double[] values, final double[] weights,\n                         final double[] means, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - means[i];\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            if (sumWts > 0) {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumW",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            if (sumWts > 0) {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n            }\n        }\n    }\n    return var;\n  }\n\n  public double evaluate(final double[] values, final double[] weights,\n                         final double[] means, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n      if (length == 1) {\n        var = 0.0;\n      } else if (length > 1) {\n        double accum = 0.0;\n        double dev = 0.0;\n        double accum2 = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n          dev = values[i] - means[i];\n          accum += weights[i] * (dev * dev);\n          accum2 += weights[i] * dev;\n        }\n        double sumWts = 0;\n        for (int i = begin; i < begin + length; i++) {\n          sumWts += weights[i];\n        }\n        if (sumWts > 0) {\n          var = (accum - (accum2 * accum2 / sumWts)) / sumW",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n        }\n    }\n    return var;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double[] means, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n      if (length == 1) {\n        var = 0.0;\n      } else if (length > 1) {\n        double accum = 0.0;\n        double dev = 0.0;\n        double accum2 = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n          dev = values[i] - means[i];\n          accum += weights[i] * (dev * dev);\n          accum2 += weights[i] * dev;\n        }\n        double sumWts = 0;\n        for (int i = begin; i < begin + length; i++) {\n          sumWts += weights[i];\n        }\n        var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n      }",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n        }\n    }\n    return var;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double[] means, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - means[i];\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n        }",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n        }\n    }\n    return var;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double[] mu, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n      if (length == 1) {\n        var = 0.0;\n      } else if (length > 1) {\n        double accum = 0.0;\n        double dev = 0.0;\n        double accum2 = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n          dev = values[i] - mu[i];\n          accum += weights[i] * (dev * dev);\n          accum2 += weights[i] * dev;\n        }\n        double sumWts = 0;\n        for (int i = begin; i < begin + length; i++) {\n          sumWts += weights[i];\n        }\n        var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n      }",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            if (sumWts > 0) {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n            }\n        }\n    }\n    return var;\n  }\n\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double[] mu, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mu[i];\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            if (sumWts > 0) {\n                var = (accum - (accum2 * accum2 / sumWts",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            if (sumWts > 0) {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n            }\n        }\n    }\n    return var;\n  }\n\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double[] mu, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n      if (length == 1) {\n        var = 0.0;\n      } else if (length > 1) {\n        double accum = 0.0;\n        double dev = 0.0;\n        double accum2 = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n          dev = values[i] - mu[i];\n          accum += weights[i] * (dev * dev);\n          accum2 += weights[i] * dev;\n        }\n        double sumWts = 0;\n        for (int i = begin; i < begin + length; i++) {\n          sumWts += weights[i];\n        }\n        if (sumWts > 0) {\n          var = (accum - (accum2 * accum2 / sumWts",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n        }\n    }\n    return var;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double[] mu, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, mu, begin, length)) {\n      if (length == 1) {\n        var = 0.0;\n      } else if (length > 1) {\n        double accum = 0.0;\n        double dev = 0.0;\n        double accum2 = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n          dev = values[i] - mu[i];\n          accum += weights[i] * (dev * dev);\n          accum2 += weights[i] * dev;\n        }\n        double sumWts = 0;\n        for (int i = begin; i < begin + length; i++) {\n          sumWts += weights[i];\n        }\n        var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            if (sumWts > 0) {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n            }\n        }\n    }\n    return var;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double[] mu, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n      if (length == 1) {\n        var = 0.0;\n      } else if (length > 1) {\n        double accum = 0.0;\n        double dev = 0.0;\n        double accum2 = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n          dev = values[i] - mu[i];\n          accum += weights[i] * (dev * dev);\n          accum2 += weights[i] * dev;\n        }\n        double sumWts = 0;\n        for (int i = begin; i < begin + length; i++) {\n          sumWts += weights[i];\n        }\n        if (sumWts > 0) {\n          var",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            if (sumWts > 0) {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n            }\n        }\n    }\n    return var;\n  }\n\n  public double evaluate(final double[] values, final double[] weights,\n                         final double[] means, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n      if (length == 1) {\n        var = 0.0;\n      } else if (length > 1) {\n        double accum = 0.0;\n        double dev = 0.0;\n        double accum2 = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n            dev = values[i] - means[i];\n            accum += weights[i] * (dev * dev);\n            accum2 += weights[i] * dev;\n        }\n        double sumWts = 0;\n        for (int i = begin; i < begin + length; i++) {\n            sumWts += weights[i];\n        }\n        if (sumWts > 0) {\n          var = (accum - (accum2 * accum2 / sumWts)) / sumW"
      ],
      "function range": "501,5-532,5"
    },
    "Math_48_/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java_189-190": {
      "loc": "189-190",
      "input": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:",
      "output": [
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(x1 - x0) <= atol) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(f1) <= rtol * Math.abs(f0)) {\n            return inverted? x1 : x0;\n        }\n    }\n}\n}\n<|java|>package",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        }\n        if (Math.abs(f1) <= ftol * (Math.abs(f1) + Math.abs(f0))) {\n            return x;\n        }\n        if (Math.abs(x1 - x0) <= atol || Math.abs(f1 - f0) <= rtol * (Math.abs(f1) + Math.abs(f0))) {\n            ",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(x1 - x0) <= atol) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(f1) <= rtol * Math.abs(f0)) {\n            return inverted? x1 : x0;\n        }\n    }\n}\n}\n<|java|>/*",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(f1) <= atol || Math.abs(f0) <= atol) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(x1 - x0) <= rtol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        }\n        if (Math.abs(f1) <= atol) {\n            return x;\n        }\n        if (Math.abs(f0) <= atol) {\n            return x0;\n        }\n        if (Math.abs(x1 - x0) <= rtol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        ",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        }\n        if (Math.abs(f1) <= ftol * Math.abs(f0)) {\n            return x;\n        }\n        if (Math.abs(f0) <= atol || Math.abs(f1) <= atol) {\n            return x;\n        }\n        if (Math.abs(x1 - x0) <= rtol * (Math.abs(x1",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(x1 - x0) <= atol) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(f1) <= rtol * Math.abs(f0)) {\n            return inverted? x1 : x0;\n        }\n    }\n}\n\n}\n<|java|>",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(x1 - x0) <= atol) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(f1) <= rtol * Math.abs(f0)) {\n            return inverted? x1 : x0;\n        }\n    }\n}\n}\n<|java|>/**",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(x1 - x0) <= atol) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(f1) <= rtol * Math.abs(f0)) {\n            return inverted? x1 : x0;\n        }\n    }\n}\n<|java|>/*\n *",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        }\n        if (Math.abs(f1) <= ftol * (Math.abs(f1) + Math.abs(f0))) {\n            return x;\n        }\n        if (Math.abs(f0) <= atol || Math.abs(f1) <= atol) {\n            return x;\n        }\n        if (Math.abs(x1 - x0) <= rt"
      ],
      "function range": "129,5-251,5"
    },
    "Math_50_/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java_187-191": {
      "loc": "187-191",
      "input": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:",
      "output": [
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(x1 - x0) <= atol) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(f1) <= rtol * Math.abs(f0)) {\n            return inverted? x1 : x0;\n        }\n    }\n}\n}\n<|java|>package",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        }\n        if (Math.abs(f1) <= ftol * (Math.abs(f1) + Math.abs(f0))) {\n            return x;\n        }\n        if (Math.abs(x1 - x0) <= atol || Math.abs(f1 - f0) <= rtol * (Math.abs(f1) + Math.abs(f0))) {\n            ",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(x1 - x0) <= atol) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(f1) <= rtol * Math.abs(f0)) {\n            return inverted? x1 : x0;\n        }\n    }\n}\n}\n<|java|>/*",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(f1) <= atol || Math.abs(f0) <= atol) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(x1 - x0) <= rtol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        }\n        if (Math.abs(f1) <= atol) {\n            return x;\n        }\n        if (Math.abs(f0) <= atol) {\n            return x0;\n        }\n        if (Math.abs(x1 - x0) <= rtol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        ",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        }\n        if (Math.abs(f1) <= ftol * Math.abs(f0)) {\n            return x;\n        }\n        if (Math.abs(f0) <= atol || Math.abs(f1) <= atol) {\n            return x;\n        }\n        if (Math.abs(x1 - x0) <= rtol * (Math.abs(x1",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(x1 - x0) <= atol) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(f1) <= rtol * Math.abs(f0)) {\n            return inverted? x1 : x0;\n        }\n    }\n}\n\n}\n<|java|>",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(x1 - x0) <= atol) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(f1) <= rtol * Math.abs(f0)) {\n            return inverted? x1 : x0;\n        }\n    }\n}\n}\n<|java|>/**",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(x1 - x0) <= atol) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(f1) <= rtol * Math.abs(f0)) {\n            return inverted? x1 : x0;\n        }\n    }\n}\n<|java|>/*\n *",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= fx / (fx + f1);\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= ftol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        }\n        if (Math.abs(f1) <= ftol * (Math.abs(f1) + Math.abs(f0))) {\n            return x;\n        }\n        if (Math.abs(f0) <= atol || Math.abs(f1) <= atol) {\n            return x;\n        }\n        if (Math.abs(x1 - x0) <= rt"
      ],
      "function range": "128,5-253,5"
    },
    "Math_53_/src/main/java/org/apache/commons/math/complex/Complex.java_153-154": {
      "loc": "153-154",
      "input": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);",
      "output": [
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re + rhs.re, im + rhs.im);\n  }\n\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re - rhs.re, im - rhs.im);\n  }\n\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    double newRe = re * rhs.re - im * rhs.im;\n    double newIm = re * rhs.im + im * rhs.re;\n    return new Complex(newRe, newIm);\n  }\n\n  public Complex multiply(double scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar, im * scalar);\n  }\n\n  public Complex multiply(int scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar, im * scalar);\n  }\n\n  public Complex multiply(long scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar, im * scalar);\n  }\n\n  public Complex multiply(float scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar, im * scalar);\n  }\n\n  public Complex multiply(BigDecimal scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar.doubleValue(), im * scalar.doubleValue());\n  }\n\n  public Complex multiply(BigInteger scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar.double",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re + rhs.re, im + rhs.im);\n  }\n\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re - rhs.re, im - rhs.im);\n  }\n\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    double newRe = re * rhs.re - im * rhs.im;\n    double newIm = re * rhs.im + im * rhs.re;\n    return new Complex(newRe, newIm);\n  }\n\n  public Complex multiply(double scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(int scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(long scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(float scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(BigDecimal scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar.doubleValue() * re, scalar.doubleValue() * im);\n  }\n\n  public Complex multiply(BigInteger scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re + rhs.re, im + rhs.im);\n  }\n\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re - rhs.re, im - rhs.im);\n  }\n\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    double newRe = re * rhs.re - im * rhs.im;\n    double newIm = re * rhs.im + im * rhs.re;\n    return new Complex(newRe, newIm);\n  }\n\n  public Complex multiply(double scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar, im * scalar);\n  }\n\n  public Complex multiply(int scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar, im * scalar);\n  }\n\n  public Complex multiply(long scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar, im * scalar);\n  }\n\n  public Complex multiply(float scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar, im * scalar);\n  }\n\n  public Complex multiply(BigDecimal scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar.doubleValue(),\n                       im * scalar.doubleValue());\n  }\n\n  public Complex multiply(BigInteger scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re + rhs.re, im + rhs.im);\n  }\n\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re - rhs.re, im - rhs.im);\n  }\n\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    double newRe = re * rhs.re - im * rhs.im;\n    double newIm = re * rhs.im + im * rhs.re;\n    return new Complex(newRe, newIm);\n  }\n\n  public Complex multiply(double scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(int scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(long scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(float scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(BigDecimal scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar.multiply(BigDecimal.valueOf(re)).doubleValue(),\n                       scalar.multiply(BigDecimal.valueOf(im)).doubleValue());\n  }\n\n  public Complex multiply(BigInteger scalar)\n    throws Null",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re + rhs.re, im + rhs.im);\n  }\n\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re - rhs.re, im - rhs.im);\n  }\n\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    double newRe = re * rhs.re - im * rhs.im;\n    double newIm = re * rhs.im + im * rhs.re;\n    return new Complex(newRe, newIm);\n  }\n\n  public Complex multiply(double scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(int scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(long scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(float scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(BigDecimal scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar.doubleValue() * re,\n                       scalar.doubleValue() * im);\n  }\n\n  public Complex multiply(BigInteger scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    ",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re + rhs.re, im + rhs.im);\n  }\n\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re - rhs.re, im - rhs.im);\n  }\n\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    double newRe = re * rhs.re - im * rhs.im;\n    double newIm = re * rhs.im + im * rhs.re;\n    return new Complex(newRe, newIm);\n  }\n\n  public Complex multiply(double scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(int scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(long scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(float scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(BigDecimal scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar.multiply(new BigDecimal(re)).doubleValue(),\n                       scalar.multiply(new BigDecimal(im)).doubleValue());\n  }\n\n  public Complex multiply(BigInteger scalar)\n    throws NullArgumentException {",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re + rhs.re, im + rhs.im);\n  }\n\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re - rhs.re, im - rhs.im);\n  }\n\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    double newRe = re * rhs.re - im * rhs.im;\n    double newIm = re * rhs.im + im * rhs.re;\n    return new Complex(newRe, newIm);\n  }\n\n  public Complex multiply(double scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(int scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(long scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(float scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(BigDecimal scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar.multiply(BigDecimal.valueOf(re)).doubleValue(),\n                       scalar.multiply(BigDecimal.valueOf(im)).doubleValue());\n  }\n\n  public Complex divide(Complex rhs)\n    throws Null",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re + rhs.re, im + rhs.im);\n  }\n\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re - rhs.re, im - rhs.im);\n  }\n\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    double newRe = re * rhs.re - im * rhs.im;\n    double newIm = re * rhs.im + im * rhs.re;\n    return new Complex(newRe, newIm);\n  }\n\n  public Complex multiply(double scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(int scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(long scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(float scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(Complex scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    double newRe = re * scalar.re - im * scalar.im;\n    double newIm = re * scalar.im + im * scalar.re;\n    return new Complex(newRe, newIm);\n  }\n\n  public Complex divide(Complex rhs)\n    ",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re + rhs.re, im + rhs.im);\n  }\n\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re - rhs.re, im - rhs.im);\n  }\n\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    double newRe = re * rhs.re - im * rhs.im;\n    double newIm = re * rhs.im + im * rhs.re;\n    return new Complex(newRe, newIm);\n  }\n\n  public Complex multiply(double scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(int scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(long scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(float scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(scalar * re, scalar * im);\n  }\n\n  public Complex multiply(Complex scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    double newRe = re * scalar.re - im * scalar.im;\n    double newIm = re * scalar.im + im * scalar.re;\n    return new Complex(newRe, newIm);\n  }\n\n  public Complex divide(Complex scalar)\n    ",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re + rhs.re, im + rhs.im);\n  }\n\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(re - rhs.re, im - rhs.im);\n  }\n\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    double newRe = re * rhs.re - im * rhs.im;\n    double newIm = re * rhs.im + im * rhs.re;\n    return new Complex(newRe, newIm);\n  }\n\n  public Complex multiply(double scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar, im * scalar);\n  }\n\n  public Complex multiply(int scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar, im * scalar);\n  }\n\n  public Complex multiply(long scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar, im * scalar);\n  }\n\n  public Complex multiply(BigInteger scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar.doubleValue(), im * scalar.doubleValue());\n  }\n\n  public Complex multiply(BigDecimal scalar)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(scalar);\n    return new Complex(re * scalar.doubleValue(), im * scalar.doubleValue());\n  }\n\n  public Complex divide(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    double denom ="
      ],
      "function range": "150,5-155,5"
    },
    "Math_56_/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java_237-244": {
      "loc": "237-244",
      "input": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }",
      "output": [
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.alge",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\n",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org"
      ],
      "function range": "216,5-246,5"
    },
    "Math_57_/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java_175-176": {
      "loc": "175-176",
      "input": "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {",
      "output": [
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      double minDx2 = Double.POSITIVE_INFINITY;\n      int index = -1;\n      for (int i = 0; i < dx2.length; i++) {\n        final T p = pointSet.get(i);\n        final double d2 = p.squaredEuclideanDistance(firstPoint);\n        if (d2 < minDx2) {\n          minDx2 = d2;\n          index = i;\n        }\n      }\n      final T p = pointSet.remove(index);\n      resultSet.add(new Cluster<T>(p));\n      dx2[index] = minDx2;\n    }\n    return resultSet;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      double minDx2 = Double.POSITIVE_INFINITY;\n      int index = -1;\n      for (int i = 0; i < dx2.length; i++) {\n        final T p = pointSet.get(i);\n        final double d2 = p.squaredEuclideanDistance(firstPoint);\n        if (d2 < minDx2) {\n          minDx2 = d2;\n          index = i;\n        }\n      }\n      final T p = pointSet.remove(index);\n      resultSet.add(new Cluster<T>(p));\n      dx2[index] = minDx2;\n    }\n    return resultSet;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      double minDx2 = Double.POSITIVE_INFINITY;\n      int index = -1;\n      for (int i = 0; i < dx2.length; i++) {\n        final T p = pointSet.get(i);\n        final double d2 = p.squaredEuclideanDistance(firstPoint);\n        if (d2 < minDx2) {\n          minDx2 = d2;\n          index = i;\n        }\n      }\n      final T p = pointSet.remove(index);\n      resultSet.add(new Cluster<T>(p));\n      dx2[index] = minDx2;\n    }\n    return resultSet;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n *",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      double minDx2 = Double.POSITIVE_INFINITY;\n      int index = -1;\n      for (int i = 0; i < dx2.length; i++) {\n        final T p = pointSet.get(i);\n        final double d2 = p.squaredEuclideanDistance(firstPoint);\n        if (d2 < minDx2) {\n          minDx2 = d2;\n          index = i;\n        }\n      }\n      final T p = pointSet.remove(index);\n      resultSet.add(new Cluster<T>(p));\n      dx2[index] = minDx2;\n    }\n    return resultSet;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      double minDx2 = Double.POSITIVE_INFINITY;\n      int index = -1;\n      for (int i = 0; i < dx2.length; i++) {\n        final T p = pointSet.remove(random.nextInt(pointSet.size()));\n        dx2[i] = firstPoint.squaredDistance(p);\n        if (dx2[i] < minDx2) {\n          minDx2 = dx2[i];\n          index = i;\n        }\n      }\n      final T p = pointSet.remove(index);\n      resultSet.add(new Cluster<T>(p));\n      dx2[index] = Double.POSITIVE_INFINITY;\n    }\n    return resultSet;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      double minDx2 = Double.POSITIVE_INFINITY;\n      int index = -1;\n      for (int i = 0; i < dx2.length; i++) {\n        final T p = pointSet.remove(random.nextInt(pointSet.size()));\n        dx2[i] = firstPoint.squaredDistance(p);\n        if (dx2[i] < minDx2) {\n          minDx2 = dx2[i];\n          index = i;\n        }\n      }\n      final T p = pointSet.remove(index);\n      resultSet.add(new Cluster<T>(p));\n      dx2[index] = Double.POSITIVE_INFINITY;\n    }\n    return resultSet;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      double minDx2 = Double.POSITIVE_INFINITY;\n      int index = -1;\n      for (int i = 0; i < dx2.length; i++) {\n        final T p = pointSet.get(i);\n        final double d2 = p.squaredEuclideanDistance(firstPoint);\n        if (d2 < minDx2) {\n          minDx2 = d2;\n          index = i;\n        }\n      }\n      final T p = pointSet.remove(index);\n      resultSet.add(new Cluster<T>(p));\n      dx2[index] = minDx2;\n    }\n    return resultSet;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      double minDx2 = Double.POSITIVE_INFINITY;\n      int index = -1;\n      for (int i = 0; i < dx2.length; i++) {\n        final T p = pointSet.remove(random.nextInt(pointSet.size()));\n        dx2[i] = firstPoint.squaredDistance(p);\n        if (dx2[i] < minDx2) {\n          minDx2 = dx2[i];\n          index = i;\n        }\n      }\n      final T p = pointSet.remove(index);\n      resultSet.add(new Cluster<T>(p));\n      dx2[index] = Double.POSITIVE_INFINITY;\n    }\n    return resultSet;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      double minDx2 = Double.POSITIVE_INFINITY;\n      int index = -1;\n      for (int i = 0; i < dx2.length; i++) {\n        final T p = pointSet.get(i);\n        final double d2 = p.squaredEuclideanDistance(firstPoint);\n        if (d2 < minDx2) {\n          minDx2 = d2;\n          index = i;\n        }\n      }\n      final T p = pointSet.remove(index);\n      resultSet.add(new Cluster<T>(p));\n      dx2[index] = minDx2;\n    }\n    return resultSet;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      double minDx2 = Double.POSITIVE_INFINITY;\n      int index = -1;\n      for (int i = 0; i < dx2.length; i++) {\n        final T p = pointSet.remove(random.nextInt(pointSet.size()));\n        dx2[i] = firstPoint.squaredDistance(p);\n        if (dx2[i] < minDx2) {\n          minDx2 = dx2[i];\n          index = i;\n        }\n      }\n      final T p = pointSet.remove(index);\n      resultSet.add(new Cluster<T>(p));\n      dx2[index] = Double.POSITIVE_INFINITY;\n    }\n    return resultSet;\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
      ],
      "function range": "161,5-198,5"
    },
    "Math_58_/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java_121-122": {
      "loc": "121-122",
      "input": "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();",
      "output": [
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x, y);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x, y, z);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x, y, z, w);\n    }\n    return result;\n  }\n\n  public double",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x) {\n    final double[] guess = (new ParameterGuesser(getObservations(), x)).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y) {\n    final double[] guess = (new ParameterGuesser(getObservations(), x, y)).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z) {\n    final double[] guess = (new ParameterGuesser(getObservations(), x, y, z)).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w) {\n    final double[] guess = (new ParameterGuesser(getObservations(), x, y, z, w)).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(x, guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(x, y, guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(x, y, z, guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(x, y, z, w, guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess(x);\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess(x, y);\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess(x, y, z);\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess(x, y, z, w);\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(x, guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(x, y, guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(x, y, z, guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double a) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(x, y, z, a, guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x, y);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x, y, z);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double t) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x, y, z, t);\n    }\n    return result;\n  }\n\n  public double",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x, y);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x, y, z);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x, y, z, w);\n    }\n    return result;\n  }\n}\n",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x) {\n    return fit(new double[] { x });\n  }\n\n  public double[] fit(final double x, final double y) {\n    return fit(new double[] { x, y });\n  }\n\n  public double[] fit(final double x, final double y, final double z) {\n    return fit(new double[] { x, y, z });\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w) {\n    return fit(new double[] { x, y, z, w });\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w, final double u) {\n    return fit(new double[] { x, y, z, w, u });\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w, final double u, final double v) {\n    return fit(new double[] { x, y, z, w, u, v });\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w, final double u, final double v,\n      final double a) {\n    return fit(new double[] { x, y, z, w, u, v, a });\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w, final double u, final double v,\n      final double a, final double b) {\n    return fit(new double[] { x, y, z, w, u, v, a, b });\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w, final double u, final double v,\n      final double a, final double b, final double c",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x) {\n    return fit(new double[] { x });\n  }\n\n  public double[] fit(final double x, final double y) {\n    return fit(new double[] { x, y });\n  }\n\n  public double[] fit(final double x, final double y, final double z) {\n    return fit(new double[] { x, y, z });\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w) {\n    return fit(new double[] { x, y, z, w });\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w, final double u) {\n    return fit(new double[] { x, y, z, w, u });\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w, final double u,\n      final double v) {\n    return fit(new double[] { x, y, z, w, u, v });\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w, final double u,\n      final double v, final double a) {\n    return fit(new double[] { x, y, z, w, u, v, a });\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w, final double u,\n      final double v, final double a, final double b) {\n    return fit(new double[] { x, y, z, w, u, v, a, b });\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w, final double u,\n      final double v, final double a, final double b, final",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i]);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x, y);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x, y, z);\n    }\n    return result;\n  }\n\n  public double[] fit(final double x, final double y, final double z, final double w) {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final double[] result = new double[guess.length];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = fit(guess[i], x, y, z, w);\n    }\n    return result;\n  }\n\n  public static"
      ],
      "function range": "119,5-122,5"
    },
    "Math_59_/src/main/java/org/apache/commons/math/util/FastMath.java_3482-3483": {
      "loc": "3482-3483",
      "input": "public static float max(final float a, final float b) {",
      "output": [
        "public static float max(final float a, final float b) {\n        return a > b? a : b;\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e, f), g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e, f, g), h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e, f, g, h), i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max(max(a, b, c, d, e, f, g, h, i), j);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final",
        "public static float max(final float a, final float b) {\n        return a > b? a : b;\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e), f, g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e), f, g, h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e), f, g, h, i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max(max(a, b, c, d, e), f, g, h, i, j);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final",
        "public static float max(final float a, final float b) {\n        return a > b? a : b;\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e), f, g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e, f), g, h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e, f, g), h, i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max(max(a, b, c, d, e, f, g, h), i, j);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final",
        "public static float max(final float a, final float b) {\n        return a > b? a : b;\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e, f), g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e, f, g), h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e, f, g), h, i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max(max(a, b, c, d, e, f, g), h, i, j);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final",
        "public static float max(final float a, final float b) {\n        return a > b? a : b;\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e), f, g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e, f), g, h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e, f, g), h, i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max(max(a, b, c, d, e, f, g), h, i, j);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final",
        "public static float max(final float a, final float b) {\n        return a > b? a : b;\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e, f), g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e, f, g), h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e, f, g), h, i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max(max(a, b, c, d, e, f, g, h), i, j);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final",
        "public static float max(final float a, final float b) {\n        return a > b? a : b;\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e), f, g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e), f, g, h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e), f, g, h, i);\n    }\n\n    public static float min(final float a, final float b) {\n        return a < b? a : b;\n    }\n\n    public static float min(final float a, final float b, final float c) {\n        return min(min(a, b), c);\n    }\n\n    public static float min(final float a, final float b, final float c, final float d) {\n        return min(min(a, b, c), d);\n",
        "public static float max(final float a, final float b) {\n        return a > b? a : b;\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e), f, g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e, f), g, h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e, f), g, h, i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max(max(a, b, c, d, e, f, g), h, i, j);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final",
        "public static float max(final float a, final float b) {\n        return a > b? a : b;\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e, f), g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e, f, g), h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e, f, g, h), i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max(max(a, b, c, d, e, f, g, h, i), j);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n *",
        "public static float max(final float a, final float b) {\n        return a > b? a : b;\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e, f), g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e, f, g), h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e, f, g, h), i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max(max(a, b, c, d, e, f, g, h, i), j);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more"
      ],
      "function range": "3481,5-3483,5"
    },
    "Math_63_/src/main/java/org/apache/commons/math/util/MathUtils.java_417-418": {
      "loc": "417-418",
      "input": "public static boolean equals(double x, double y) {",
      "output": [
        "public static boolean equals(double x, double y) {\n        return Double.doubleToLongBits(x) == Double.doubleToLongBits(y);\n    }\n\n    public static boolean equals(float x, float y) {\n        return Float.floatToIntBits(x) == Float.floatToIntBits(y);\n    }\n\n    public static boolean equals(long x, long y) {\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        if (x.getClass()!= y.getClass()) {\n            return false;\n        }\n        return x.equals(y);\n    }\n\n    public static int hashCode(boolean x) {\n        return x? 1231 : 1237;\n    }\n\n    public static int hashCode(byte x) {\n        return x;\n    }\n\n    public static int hashCode(char x) {\n        return x;\n    }\n\n    public static int hashCode(double x) {\n        long bits = Double.doubleToLongBits(x);\n        return (int) (bits ^ (bits >>> 32));\n    }\n\n    public static int hashCode(float x) {\n        return Float.floatToIntBits(x);\n    }\n\n    public static int hashCode(int x) {\n        return x;\n    }\n\n    public static int hashCode(long x) {\n        return (int) (x ^ (x >>> 32));\n    }\n\n    public static int hashCode(Object x",
        "public static boolean equals(double x, double y) {\n        return Double.doubleToLongBits(x) == Double.doubleToLongBits(y);\n    }\n\n    public static boolean equals(float x, float y) {\n        return Float.floatToIntBits(x) == Float.floatToIntBits(y);\n    }\n\n    public static boolean equals(long x, long y) {\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        if (x.getClass()!= y.getClass()) {\n            return false;\n        }\n        return x.equals(y);\n    }\n\n    public static int hashCode(boolean x) {\n        return x? 1231 : 1237;\n    }\n\n    public static int hashCode(byte x) {\n        return x;\n    }\n\n    public static int hashCode(char x) {\n        return x;\n    }\n\n    public static int hashCode(double x) {\n        long bits = Double.doubleToLongBits(x);\n        return (int) (bits ^ (bits >>> 32));\n    }\n\n    public static int hashCode(float x) {\n        return Float.floatToIntBits(x);\n    }\n\n    public static int hashCode(int x) {\n        return x;\n    }\n\n    public static int hashCode(long x) {\n        return (int) (x ^ (x >>> 32));\n    }\n\n    public static int hashCode(short x",
        "public static boolean equals(double x, double y) {\n        return Double.doubleToLongBits(x) == Double.doubleToLongBits(y);\n    }\n\n    public static boolean equals(float x, float y) {\n        return Float.floatToIntBits(x) == Float.floatToIntBits(y);\n    }\n\n    public static boolean equals(long x, long y) {\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equals(y);\n    }\n\n    public static boolean equalsIgnoreCase(String x, String y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equalsIgnoreCase(y);\n    }\n\n    public static int hashCode(boolean x) {\n        return x? 1231 : 1237;\n    }\n\n    public static int hashCode(byte x) {\n        return x;\n    }\n\n    public static int hashCode(char x) {\n        return x;\n    }\n\n    public static int hashCode(double x) {\n        long bits = Double.doubleToLongBits(x);\n        return (int) (bits ^ (bits >>> 32));\n    }\n\n    public static int hashCode(float x) {\n        return Float.floatToIntBits(x);\n    }\n\n    public static int hashCode(int x) {",
        "public static boolean equals(double x, double y) {\n        return Double.doubleToLongBits(x) == Double.doubleToLongBits(y);\n    }\n\n    public static boolean equals(float x, float y) {\n        return Float.floatToIntBits(x) == Float.floatToIntBits(y);\n    }\n\n    public static boolean equals(long x, long y) {\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        if (x.getClass()!= y.getClass()) {\n            return false;\n        }\n        return x.equals(y);\n    }\n\n    public static int hashCode(boolean x) {\n        return x? 1231 : 1237;\n    }\n\n    public static int hashCode(byte x) {\n        return x;\n    }\n\n    public static int hashCode(char x) {\n        return x;\n    }\n\n    public static int hashCode(short x) {\n        return x;\n    }\n\n    public static int hashCode(int x) {\n        return x;\n    }\n\n    public static int hashCode(long x) {\n        return (int) (x ^ (x >>> 32));\n    }\n\n    public static int hashCode(float x) {\n        return Float.floatToIntBits(x);\n    }\n\n    public static int hashCode(double x) {\n        long bits = Double.doubleToLongBits(x);\n        return (int) (",
        "public static boolean equals(double x, double y) {\n        return Double.doubleToLongBits(x) == Double.doubleToLongBits(y);\n    }\n\n    public static boolean equals(float x, float y) {\n        return Float.floatToIntBits(x) == Float.floatToIntBits(y);\n    }\n\n    public static boolean equals(long x, long y) {\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equals(y);\n    }\n\n    public static boolean equalsIgnoreCase(String x, String y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equalsIgnoreCase(y);\n    }\n\n    public static boolean equalsIgnoreCase(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return equalsIgnoreCase(x.toString(), y.toString());\n    }\n\n    public static boolean equalsIgnoreCase(byte[] x, byte[] y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        if (x.length!= y.length) {\n            return false;",
        "public static boolean equals(double x, double y) {\n        return Double.doubleToLongBits(x) == Double.doubleToLongBits(y);\n    }\n\n    public static boolean equals(float x, float y) {\n        return Float.floatToIntBits(x) == Float.floatToIntBits(y);\n    }\n\n    public static boolean equals(long x, long y) {\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equals(y);\n    }\n\n    public static boolean equalsIgnoreCase(String x, String y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equalsIgnoreCase(y);\n    }\n\n    public static boolean equalsIgnoreCase(byte[] x, byte[] y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        if (x.length!= y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; i++) {\n            if (x[i]!= y[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean equalsIgnoreCase(char[] x, char[] y) {\n        if",
        "public static boolean equals(double x, double y) {\n        return Double.doubleToLongBits(x) == Double.doubleToLongBits(y);\n    }\n\n    public static boolean equals(float x, float y) {\n        return Float.floatToIntBits(x) == Float.floatToIntBits(y);\n    }\n\n    public static boolean equals(long x, long y) {\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equals(y);\n    }\n\n    public static boolean equalsIgnoreCase(String x, String y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equalsIgnoreCase(y);\n    }\n\n    public static int hashCode(boolean x) {\n        return x? 1231 : 1237;\n    }\n\n    public static int hashCode(byte x) {\n        return x;\n    }\n\n    public static int hashCode(char x) {\n        return x;\n    }\n\n    public static int hashCode(double x) {\n        long bits = Double.doubleToLongBits(x);\n        return (int)(bits ^ (bits >>> 32));\n    }\n\n    public static int hashCode(float x) {\n        return Float.floatToIntBits(x);\n    }\n\n    public static int hashCode(int x) {\n",
        "public static boolean equals(double x, double y) {\n        return Double.doubleToLongBits(x) == Double.doubleToLongBits(y);\n    }\n\n    public static boolean equals(float x, float y) {\n        return Float.floatToIntBits(x) == Float.floatToIntBits(y);\n    }\n\n    public static boolean equals(long x, long y) {\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equals(y);\n    }\n\n    public static boolean equalsIgnoreCase(String x, String y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equalsIgnoreCase(y);\n    }\n\n    public static boolean equalsIgnoreCase(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return equalsIgnoreCase(x.toString(), y.toString());\n    }\n\n    public static boolean equalsIgnoreCase(String x, String y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equalsIgnoreCase(y);\n    }\n\n    public static",
        "public static boolean equals(double x, double y) {\n        return Double.doubleToLongBits(x) == Double.doubleToLongBits(y);\n    }\n\n    public static boolean equals(float x, float y) {\n        return Float.floatToIntBits(x) == Float.floatToIntBits(y);\n    }\n\n    public static boolean equals(long x, long y) {\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        if (x.getClass()!= y.getClass()) {\n            return false;\n        }\n        return x.equals(y);\n    }\n\n    public static int hashCode(boolean x) {\n        return x? 1231 : 1237;\n    }\n\n    public static int hashCode(byte x) {\n        return x;\n    }\n\n    public static int hashCode(char x) {\n        return x;\n    }\n\n    public static int hashCode(short x) {\n        return x;\n    }\n\n    public static int hashCode(int x) {\n        return x;\n    }\n\n    public static int hashCode(long x) {\n        return (int) (x ^ (x >>> 32));\n    }\n\n    public static int hashCode(float x) {\n        return Float.floatToIntBits(x);\n    }\n\n    public static int hashCode(double x) {\n        return Double.doubleToLongBits(x);\n    }\n\n    public static int hash",
        "public static boolean equals(double x, double y) {\n        return Double.doubleToLongBits(x) == Double.doubleToLongBits(y);\n    }\n\n    public static boolean equals(float x, float y) {\n        return Float.floatToIntBits(x) == Float.floatToIntBits(y);\n    }\n\n    public static boolean equals(long x, long y) {\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equals(y);\n    }\n\n    public static boolean equalsIgnoreCase(String x, String y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equalsIgnoreCase(y);\n    }\n\n    public static int hashCode(boolean x) {\n        return x? 1231 : 1237;\n    }\n\n    public static int hashCode(byte x) {\n        return x;\n    }\n\n    public static int hashCode(char x) {\n        return x;\n    }\n\n    public static int hashCode(double x) {\n        long bits = Double.doubleToLongBits(x);\n        return (int) (bits ^ (bits >>> 32));\n    }\n\n    public static int hashCode(float x) {\n        int bits = Float.floatToIntBits(x);\n        return bits ^ (bits >>> 16) ^ (bits"
      ],
      "function range": "416,5-418,5"
    },
    "Math_69_/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java_171-172": {
      "loc": "171-172",
      "input": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));",
      "output": [
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = tDistribution.cumulativeProbability(-t);\n                out[j][i] = out[i][j];\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = covarianceMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovariancePValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = covarianceMatrix.getEntry(i, j",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = tDistribution.cumulativeProbability(-t);\n                out[j][i] = out[i][j];\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                out[i][j] = covarianceMatrix.getEntry(i, j);\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovariancePValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = tDistribution.cumulativeProbability(-t);\n                out[j][i] = out[i][j];\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = covarianceMatrix.getEntry(i, j);\n                out[i][j] = r;\n                out[j][i] = r;\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCorrelationMatrix() throws MathException {\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] =",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = tDistribution.cumulativeProbability(-t);\n                out[j][i] = out[i][j];\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = covarianceMatrix.getEntry(i, j);\n                out[i][j] = r;\n                out[j][i] = r;\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovariancePValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < n",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = tDistribution.cumulativeProbability(-t);\n                out[j][i] = out[i][j];\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = covarianceMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovariancePValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double cov = covarianceMatrix.getEntry(i, j",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = tDistribution.cumulativeProbability(-t);\n                out[j][i] = out[i][j];\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = covarianceMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovariancePValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double c = covarianceMatrix.getEntry(i, j",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = tDistribution.cumulativeProbability(-t);\n                out[j][i] = out[i][j];\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = covarianceMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCorrelationMatrix() throws MathException {\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = correlationMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getVarianceMatrix() throws MathException {\n    int nVars = varianceMatrix.",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = tDistribution.cumulativeProbability(-t);\n                out[j][i] = out[i][j];\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = covarianceMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovariancePValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double t = Math.abs(covarianceMatrix.",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = tDistribution.cumulativeProbability(-t);\n                out[j][i] = out[i][j];\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = covarianceMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCorrelationMatrix() throws MathException {\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = correlationMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getVarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = tDistribution.cumulativeProbability(-t);\n                out[j][i] = out[i][j];\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = covarianceMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCorrelationMatrix() throws MathException {\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = correlationMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix(int var) throws MathException {\n    int nV"
      ],
      "function range": "160,5-176,5"
    },
    "Math_70_/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java_72-73": {
      "loc": "72-73",
      "input": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {",
      "output": [
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max, f);\n        verifySequence(min, initial, max, f);\n        if (isBracketing(min, initial, f)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     *",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max, f);\n        verifySequence(min, initial, max, f);\n        if (isBracketing(min, initial, f)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     *",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial, null);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @param maxEval Maximum number of evaluations.\n     * @return the point at which the function value is zero.\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f,\n                        double min, double max, double initial, int maxEval)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max, f);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, f)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero.\n     * @throws MaxIterationsExceededException if the",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial, null);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @param maxEval Maximum number of evaluations.\n     * @return the point at which the function value is zero.\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f,\n                        double min, double max, double initial, int maxEval)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max, f);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, f)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n\n    }\n\n    /**\n     * Find a real root in the given interval.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial, null);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @param maxEval Maximum number of evaluations.\n     * @return the point at which the function value is zero.\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f,\n                        double min, double max, double initial, int maxEval)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max, f);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, f)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max, f);\n        verifySequence(min, initial, max, f);\n        if (isBracketing(min, initial, f)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * @throws FunctionEvaluationException if an error",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max, f);\n        verifySequence(min, initial, max, f);\n        if (isBracketing(min, initial, f)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * @throws FunctionEvaluationException if an error",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial, null);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @param maxEval Maximum number of evaluations.\n     * @return the point at which the function value is zero.\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f,\n                        double min, double max, double initial, int maxEval)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max, f);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, f)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @param maxEval Maximum number of evaluations.\n     * @return the",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial, null);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @param maxEval Maximum number of evaluations.\n     * @return the point at which the function value is zero.\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f,\n                        double min, double max, double initial, int maxEval)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max, f);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, f)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @return the point at which the function value is zero.\n     * @",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial, null);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @param maxEval Maximum number of evaluations.\n     * @return the point at which the function value is zero.\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f,\n                        double min, double max, double initial, int maxEval)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max, f);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, f)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param maxEval Maximum number of evaluations.\n     * @return the point at which the function value is zero.\n     "
      ],
      "function range": "70,5-73,5"
    },
    "Math_73_/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java_136-137": {
      "loc": "136-137",
      "input": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }",
      "output": [
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, min, yMin, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve\n   * @param min the lower bound for the interval\n   * @param max the upper bound for the interval\n   * @param initial the start value to use\n   * @param y0 the value of the function at the start value\n   * @param yMin the value of the function at the lower bound\n   * @param yMax the value of the function at the upper bound\n   * @return the point at which the function value is zero\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems otherwise\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function\n   * @throws IllegalArgumentException if any parameters are invalid\n   */\n  private double solve(final UnivariateRealFunction f",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, min, yMin, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve.\n   * @param min the lower bound for the interval.\n   * @param yMin the value of the function at the lower bound.\n   * @param max the upper bound for the interval.\n   * @param yMax the value of the function at the upper bound.\n   * @param initial the start value to use.\n   * @param yInitial the value of the function at the start value.\n   * @return the point at which the function value is zero.\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems.\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function.\n   */\n  private double solve(final UnivariateRealFunction f,\n                       final double min",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, min, yMin, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve.\n   * @param min the lower bound for the interval.\n   * @param yMin the value of the function at the lower bound.\n   * @param max the upper bound for the interval.\n   * @param yMax the value of the function at the upper bound.\n   * @param initial the start value to use.\n   * @param yInitial the value of the function at the start value.\n   * @return the point at which the function value is zero.\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems.\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function.\n   * @throws IllegalArgumentException if any parameters are invalid.\n   */\n  ",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, max, yMax, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve\n   * @param min the lower bound for the interval\n   * @param max the upper bound for the interval\n   * @param initial the start value to use\n   * @param y0 the value of the function at the start value\n   * @param yMin the value of the function at the lower bound\n   * @param yMax the value of the function at the upper bound\n   * @return the point at which the function value is zero\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems otherwise\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function\n   * @throws IllegalArgumentException if any parameters are invalid\n   */\n  private double solve(final UnivariateRealFunction f",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, min, yMin, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve\n   * @param min the lower bound for the interval\n   * @param yMin the value of the function at the lower bound\n   * @param max the upper bound for the interval\n   * @param yMax the value of the function at the upper bound\n   * @param initial the start value to use\n   * @param yInitial the value of the function at the start value\n   * @return the point at which the function value is zero\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems otherwise\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function\n   * @throws IllegalArgumentException if any parameters are invalid\n   */\n  private double solve(final UnivariateRealFunction f",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, max, yMax, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve.\n   * @param min the lower bound for the interval.\n   * @param max the upper bound for the interval.\n   * @param initial the start value to use.\n   * @param yInitial the value of the function at the start value.\n   * @param minY the value of the function at <code>min</code>.\n   * @param maxY the value of the function at <code>max</code>.\n   * @return the point at which the function value is zero.\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems.\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function.\n   */\n  private double solve(final UnivariateRealFunction f",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, min, yMin, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve.\n   * @param min the lower bound for the interval.\n   * @param yMin the value of the function at the lower bound.\n   * @param max the upper bound for the interval.\n   * @param yMax the value of the function at the upper bound.\n   * @param initial the start value to use.\n   * @param yInitial the value of the function at the start value.\n   * @return the point at which the function value is zero.\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems.\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function.\n   */\n  private double solve(final UnivariateRealFunction f,\n                      final double min",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, max, yMax, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve.\n   * @param min the lower bound for the interval.\n   * @param max the upper bound for the interval.\n   * @param initial the start value to use.\n   * @param yInitial the value of the function at the start value.\n   * @param minY the value of the function at <code>min</code>.\n   * @param maxY the value of the function at <code>max</code>.\n   * @return the point at which the function value is zero.\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems.\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function.\n   * @throws IllegalArgumentException if any parameters are invalid",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, min, yMin, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve.\n   * @param min the lower bound for the interval.\n   * @param yMin the value of the function at the lower bound.\n   * @param max the upper bound for the interval.\n   * @param yMax the value of the function at the upper bound.\n   * @param initial the start value to use.\n   * @param yInitial the value of the function at the start value.\n   * @return the point at which the function value is zero.\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems otherwise.\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function.\n   */\n  private double solve(final UnivariateRealFunction f,\n                       final double",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, min, yMin, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve\n   * @param min the lower bound for the interval\n   * @param max the upper bound for the interval\n   * @param initial the start value to use\n   * @param y0 the value of the function at the start value\n   * @param yMin the value of the function at the lower bound\n   * @param yMax the value of the function at the upper bound\n   * @return the point at which the function value is zero\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems otherwise\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function\n   */\n  private double solve(final UnivariateRealFunction f,\n                       final double min, final double y0, final double max"
      ],
      "function range": "98,5-140,5"
    },
    "Math_75_/src/main/java/org/apache/commons/math/stat/Frequency.java_303-304": {
      "loc": "303-304",
      "input": "@Deprecated\npublic double getPct(Object v) {",
      "output": [
        "@Deprecated\npublic double getPct(Object v) {\n    if (v instanceof Number) {\n      return ((Number) v).doubleValue();\n    } else if (v instanceof Boolean) {\n      return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n    } else if (v instanceof String) {\n      return Double.parseDouble((String) v);\n    } else {\n      return 0.0;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache",
        "@Deprecated\npublic double getPct(Object v) {\n    if (v instanceof Number) {\n      return ((Number) v).doubleValue();\n    } else if (v instanceof Boolean) {\n      return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n    } else if (v instanceof String) {\n      return Double.parseDouble((String) v);\n    } else {\n      return 0.0;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks",
        "@Deprecated\npublic double getPct(Object v) {\n    if (v instanceof Number) {\n      return ((Number) v).doubleValue();\n    } else if (v instanceof Boolean) {\n      return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n    } else if (v instanceof String) {\n      return Double.parseDouble((String) v);\n    } else {\n      return 0.0;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache",
        "@Deprecated\npublic double getPct(Object v) {\n    if (v instanceof Number) {\n      return ((Number) v).doubleValue();\n    } else if (v instanceof Boolean) {\n      return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n    } else if (v instanceof String) {\n      return Double.parseDouble((String) v);\n    } else {\n      return 0.0;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks",
        "@Deprecated\npublic double getPct(Object v) {\n    if (v instanceof Number) {\n      return ((Number) v).doubleValue();\n    } else if (v instanceof Boolean) {\n      return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n    } else if (v instanceof String) {\n      return Double.parseDouble((String) v);\n    } else {\n      return 0.0;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.",
        "@Deprecated\npublic double getPct(Object v) {\n    if (v instanceof Number) {\n      return ((Number) v).doubleValue();\n    } else if (v instanceof Boolean) {\n      return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n    } else if (v instanceof String) {\n      return Double.parseDouble((String) v);\n    } else {\n      return 0.0;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.",
        "@Deprecated\npublic double getPct(Object v) {\n    if (v instanceof Number) {\n      return ((Number) v).doubleValue();\n    } else if (v instanceof Boolean) {\n      return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n    } else if (v instanceof String) {\n      return Double.parseDouble((String) v);\n    } else {\n      return 0.0;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core",
        "@Deprecated\npublic double getPct(Object v) {\n    if (v instanceof Number) {\n      return ((Number) v).doubleValue();\n    } else if (v instanceof Boolean) {\n      return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n    } else if (v instanceof String) {\n      return Double.parseDouble((String) v);\n    } else {\n      return 0.0;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalExpressionTag;\nimport org.",
        "@Deprecated\npublic double getPct(Object v) {\n    if (v instanceof Number) {\n      return ((Number) v).doubleValue();\n    } else if (v instanceof Boolean) {\n      return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n    } else if (v instanceof String) {\n      return Double.parseDouble((String) v);\n    } else {\n      return 0.0;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator",
        "@Deprecated\npublic double getPct(Object v) {\n    if (v instanceof Number) {\n      return ((Number) v).doubleValue();\n    } else if (v instanceof Boolean) {\n      return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n    } else if (v instanceof String) {\n      return Double.parseDouble((String) v);\n    } else {\n      return 0.0;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.serde2.io.HiveDecimalWritable;\nimport org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\nimport org.apache."
      ],
      "function range": "301,5-304,5"
    },
    "Math_80_/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java_1135-1136": {
      "loc": "1135-1136",
      "input": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {",
      "output": [
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[4 * n + pingPong] = work[4 * (n - 1) + pingPong];\n      work[4 * n + pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[4 * n + pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[4 * n + pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[4 * n + pingPong + 4] = work[4 * (n - 1) + pingPong + 4];\n      work[4 * n + pingPong + 5] = work[4 * (n - 1) + pingPong + 5];\n      work[4 * n + pingPong + 6] = work[4 * (n - 1) + pingPong + 6];\n      work[4 * n + pingPong + 7] = work[4 * (n - 1) + pingPong + 7];\n      work[4 * n + pingPong + 8] = work[4 * (n - 1) + pingPong + 8];\n      work[4 * n + pingPong + 9] = work[4 * (n - 1) + pingPong + 9];\n      work[4 * n + pingPong + 10] = work[4 * (n - 1) + pingPong + 10];\n      work[4 * n + pingPong + 11] = work[4 * (n - 1) + pingPong + 11];\n      work[4 * n + pingPong + 12] = work[4 * (n - 1) + pingPong + 12];\n      work[4 * n + pingPong + 13] = work[4 * (n - 1) + pingPong + 13];\n      work[4 * n + pingPong + 14] = work[4 * (n - 1) + pingPong + 14];\n      work[4",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[4 * n + pingPong] = work[4 * (n - 1) + pingPong];\n      work[4 * n + pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[4 * n + pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[4 * n + pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[4 * n + pingPong + step] = work[4 * (n - 1) + pingPong + step];\n      work[4 * n + pingPong + step + 1] = work[4 * (n - 1) + pingPong + step + 1];\n      work[4 * n + pingPong + step + 2] = work[4 * (n - 1) + pingPong + step + 2];\n      work[4 * n + pingPong + step + 3] = work[4 * (n - 1) + pingPong + step + 3];\n      work[4 * n + pingPong + step + step] = work[4 * (n - 1) + pingPong + step + step];\n      work[4 * n + pingPong + step + step + 1] = work[4 * (n - 1) + pingPong + step + step + 1];\n      work[4 * n + pingPong + step + step + 2] = work[4 * (n - 1) + pingPong + step + step + 2];\n      work[4 * n + pingPong + step + step + 3] = work[4 * (n - 1) + pingPong + step + step + 3];\n      work[4 * n + pingPong + step + step + step] = work[4 * (n - 1) + pingPong + step + step + step];\n      work[4 * n + pingPong + step + step + step + 1",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[4 * n + pingPong] = work[4 * (n - 1) + pingPong];\n      work[4 * n + pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[4 * n + pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[4 * n + pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[4 * n + pingPong + 4] = work[4 * (n - 1) + pingPong + 4];\n      work[4 * n + pingPong + 5] = work[4 * (n - 1) + pingPong + 5];\n      work[4 * n + pingPong + 6] = work[4 * (n - 1) + pingPong + 6];\n      work[4 * n + pingPong + 7] = work[4 * (n - 1) + pingPong + 7];\n      work[4 * n + pingPong + 8] = work[4 * (n - 1) + pingPong + 8];\n      work[4 * n + pingPong + 9] = work[4 * (n - 1) + pingPong + 9];\n      work[4 * n + pingPong + step] = work[4 * (n - 1) + pingPong + step];\n      work[4 * n + pingPong + step + 1] = work[4 * (n - 1) + pingPong + step + 1];\n      work[4 * n + pingPong + step + 2] = work[4 * (n - 1) + pingPong + step + 2];\n      work[4 * n + pingPong + step + 3] = work[4 * (n - 1) + pingPong + step + 3];\n      work[4 * n + pingPong + step + 4] = work[4 * (n -",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[4 * n + pingPong] = work[4 * (n - 1) + pingPong];\n      work[4 * n + pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[4 * n + pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[4 * n + pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[4 * n + pingPong + step] = work[4 * (n - 1) + pingPong + step];\n      work[4 * n + pingPong + step + 1] = work[4 * (n - 1) + pingPong + step + 1];\n      work[4 * n + pingPong + step + 2] = work[4 * (n - 1) + pingPong + step + 2];\n      work[4 * n + pingPong + step + 3] = work[4 * (n - 1) + pingPong + step + 3];\n      work[4 * n + pingPong + step + step] = work[4 * (n - 1) + pingPong + step + step];\n      work[4 * n + pingPong + step + step + 1] = work[4 * (n - 1) + pingPong + step + step + 1];\n      work[4 * n + pingPong + step + step + 2] = work[4 * (n - 1) + pingPong + step + step + 2];\n      work[4 * n + pingPong + step + step + 3] = work[4 * (n - 1) + pingPong + step + step + 3];\n      work[4 * n + pingPong + step + step + step + 1] = work[4 * (n - 1) + pingPong + step + step + step + 1];\n      work[4 * n + pingPong + step + step",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[4 * n + pingPong] = work[4 * (n - 1) + pingPong];\n      work[4 * n + pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[4 * n + pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[4 * n + pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[4 * n + pingPong + step] = work[4 * (n - 1) + pingPong + step];\n      work[4 * n + pingPong + step + 1] = work[4 * (n - 1) + pingPong + step + 1];\n      work[4 * n + pingPong + step + 2] = work[4 * (n - 1) + pingPong + step + 2];\n      work[4 * n + pingPong + step + 3] = work[4 * (n - 1) + pingPong + step + 3];\n      work[4 * n + pingPong + step + step] = work[4 * (n - 1) + pingPong + step + step];\n      work[4 * n + pingPong + step + step + 1] =\n          work[4 * (n - 1) + pingPong + step + step + 1];\n      work[4 * n + pingPong + step + step + 2] =\n          work[4 * (n - 1) + pingPong + step + step + 2];\n      work[4 * n + pingPong + step + step + 3] =\n          work[4 * (n - 1) + pingPong + step + step + 3];\n      work[4 * n + pingPong + step + step + step] =\n          work[4 * (n - 1) + pingPong + step + step + step];\n      work[4 * n + pingPong",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[4 * n + pingPong] = work[4 * (n - 1) + pingPong];\n      work[4 * n + pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[4 * n + pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[4 * n + pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[4 * n + pingPong + step] = work[4 * (n - 1) + pingPong + step];\n      work[4 * n + pingPong + step + 1] = work[4 * (n - 1) + pingPong + step + 1];\n      work[4 * n + pingPong + step + 2] = work[4 * (n - 1) + pingPong + step + 2];\n      work[4 * n + pingPong + step + 3] = work[4 * (n - 1) + pingPong + step + 3];\n      work[4 * n + pingPong + step + step] = work[4 * (n - 1) + pingPong + step + step];\n      work[4 * n + pingPong + step + step + 1] = work[4 * (n - 1) + pingPong + step + step + 1];\n      work[4 * n + pingPong + step + step + 2] = work[4 * (n - 1) + pingPong + step + step + 2];\n      work[4 * n + pingPong + step + step + 3] = work[4 * (n - 1) + pingPong + step + step + 3];\n      work[4 * n + pingPong + 2 * step] = work[4 * (n - 1) + pingPong + 2 * step];\n      work[4 * n + pingPong + 2 * step + 1] = work[4 *",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[4 * n + pingPong] = work[4 * (n - 1) + pingPong];\n      work[4 * n + pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[4 * n + pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[4 * n + pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[4 * n + pingPong + step] = work[4 * (n - 1) + pingPong + step];\n      work[4 * n + pingPong + step + 1] = work[4 * (n - 1) + pingPong + step + 1];\n      work[4 * n + pingPong + step + 2] = work[4 * (n - 1) + pingPong + step + 2];\n      work[4 * n + pingPong + step + 3] = work[4 * (n - 1) + pingPong + step + 3];\n      work[4 * n + pingPong + step + step] = work[4 * (n - 1) + pingPong + step + step];\n      work[4 * n + pingPong + step + step + 1] = work[4 * (n - 1) + pingPong + step + step + 1];\n      work[4 * n + pingPong + step + step + 2] = work[4 * (n - 1) + pingPong + step + step + 2];\n      work[4 * n + pingPong + step + step + 3] = work[4 * (n - 1) + pingPong + step + step + 3];\n      work[4 * n + pingPong + step + step + step] =\n          work[4 * (n - 1) + pingPong + step + step + step];\n      work[4 * n + pingPong + step + step + step",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[4 * n + pingPong] = work[4 * (n - 1) + pingPong];\n      work[4 * n + pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[4 * n + pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[4 * n + pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[4 * n + pingPong + step] = work[4 * (n - 1) + pingPong + step];\n      work[4 * n + pingPong + step + 1] = work[4 * (n - 1) + pingPong + step + 1];\n      work[4 * n + pingPong + step + 2] = work[4 * (n - 1) + pingPong + step + 2];\n      work[4 * n + pingPong + step + 3] = work[4 * (n - 1) + pingPong + step + 3];\n      work[4 * n + pingPong + step + step] = work[4 * (n - 1) + pingPong + step + step];\n      work[4 * n + pingPong + step + step + 1] = work[4 * (n - 1) + pingPong + step + step + 1];\n      work[4 * n + pingPong + step + step + 2] = work[4 * (n - 1) + pingPong + step + step + 2];\n      work[4 * n + pingPong + step + step + 3] = work[4 * (n - 1) + pingPong + step + step + 3];\n      work[4 * n + pingPong + step + step + step] = work[4 * (n - 1) + pingPong + step + step + step + 1];\n      work[4 * n + pingPong + step + step + step",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[4 * n + pingPong] = work[4 * (n - 1) + pingPong];\n      work[4 * n + pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[4 * n + pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[4 * n + pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[4 * n + pingPong + 4] = work[4 * (n - 1) + pingPong + 4];\n      work[4 * n + pingPong + 5] = work[4 * (n - 1) + pingPong + 5];\n      work[4 * n + pingPong + 6] = work[4 * (n - 1) + pingPong + 6];\n      work[4 * n + pingPong + 7] = work[4 * (n - 1) + pingPong + 7];\n      work[4 * n + pingPong + 8] = work[4 * (n - 1) + pingPong + 8];\n      work[4 * n + pingPong + 9] = work[4 * (n - 1) + pingPong + 9];\n      work[4 * n + pingPong + 10] = work[4 * (n - 1) + pingPong + 10];\n      work[4 * n + pingPong + 11] = work[4 * (n - 1) + pingPong + 11];\n      work[4 * n + pingPong + 12] = work[4 * (n - 1) + pingPong + 12];\n      work[4 * n + pingPong + 13] = work[4 * (n - 1) + pingPong + 13];\n      work[4 * n + pingPong + 14] = work[4 * (n - 1) + pingPong + 14];\n      pingPong",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[4 * n + pingPong] = work[4 * (n - 1) + pingPong];\n      work[4 * n + pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[4 * n + pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[4 * n + pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[4 * n + pingPong + 4] = work[4 * (n - 1) + pingPong + 4];\n      work[4 * n + pingPong + 5] = work[4 * (n - 1) + pingPong + 5];\n      work[4 * n + pingPong + 6] = work[4 * (n - 1) + pingPong + 6];\n      work[4 * n + pingPong + 7] = work[4 * (n - 1) + pingPong + 7];\n      work[4 * n + pingPong + 8] = work[4 * (n - 1) + pingPong + 8];\n      work[4 * n + pingPong + 9] = work[4 * (n - 1) + pingPong + 9];\n      work[4 * n + pingPong + 10] = work[4 * (n - 1) + pingPong + 10];\n      work[4 * n + pingPong + 11] = work[4 * (n - 1) + pingPong + 11];\n      work[4 * n + pingPong + 12] = work[4 * (n - 1) + pingPong + 12];\n      work[4 * n + pingPong + 13] = work[4 * (n - 1) + pingPong + 13];\n      work[4 * n + pingPong + 14] = work[4 * (n - 1) + pingPong + 14];\n\n      work[4"
      ],
      "function range": "1132,5-1147,5"
    },
    "Math_82_/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java_82-83": {
      "loc": "82-83",
      "input": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);",
      "output": [
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (Precision.compareTo(entry, 0d, 1)!= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (Precision.compareTo(entry, 0d, 1)!= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (Precision.compareTo(entry, 0d, 1)!= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.al",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (Precision.compareTo(entry, 0d, 1)!= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (Precision.compareTo(entry, 0d, 1)!= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (Precision.compareTo(entry, 0d, 1)!= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (Precision.compareTo(entry, 0d, 1)!= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (Precision.compareTo(entry, 0d, 1)!= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyr",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (Precision.compareTo(entry, 0d, 1)!= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (Precision.compareTo(entry, 0d, 1)!= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hado"
      ],
      "function range": "76,5-91,5"
    },
    "Math_85_/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java_198-199": {
      "loc": "198-199",
      "input": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));",
      "output": [
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"unable to bracket optimum in {0} iterations\", numIterations);\n    }\n    return new double[] {a, b};\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"unable to bracket optimum in {0} iterations\", numIterations);\n    }\n    return new double[] {a, b};\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"unable to bracket optimum in {0} iterations\", numIterations);\n    }\n    return new double[] {a, b};\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n                \"unable to bracket optimum in {0} iterations\",\n                numIterations);\n    }\n    return new double[] {a, b};\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"unable to bracket optimum in {0} iterations\", numIterations);\n    }\n    return new double[] {a, b};\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"unable to bracket optimum in {0} iterations\",\n              numIterations);\n    }\n    return new double[] {a, b};\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n                \"unable to bracket optimum in {0} iterations\",\n                numIterations);\n    }\n    return new double[] {a, b};\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n                  \"unable to bracket optimum in {0} iterations\",\n                  numIterations);\n    }\n    return new double[] {a, b};\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n                \"unable to bracket optimum in {0} iterations\",\n                numIterations);\n    }\n    return new double[] {a, b};\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"unable to bracket optimum in {0} iterations\",\n              numIterations);\n    }\n    return new double[] {a, b};\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http"
      ],
      "function range": "165,5-208,5"
    },
    "Math_91_/src/java/org/apache/commons/math/fraction/Fraction.java_259-261": {
      "loc": "259-261",
      "input": "public int compareTo(Fraction object) {",
      "output": [
        "public int compareTo(Fraction object) {\r\n        if (object == null) {\r\n            return -1;\r\n        }\r\n        if (object == this) {\r\n            return 0;\r\n        }\r\n        return getNumerator() - object.getNumerator();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>double</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>double</code> value\r\n     */\r\n    public double doubleValue() {\r\n        return (double) getNumerator() / (double) getDenominator();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>float</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>float</code> value\r\n     */\r\n    public float floatValue() {\r\n        return (float) doubleValue();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as an <code>int</code> value.</p>\r\n     *\r\n     * @return the fraction as an <code>int</code> value\r\n     */\r\n    public int intValue() {\r\n        return (int) doubleValue();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>long</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>long</code> value\r\n     */\r\n    public long longValue() {\r\n        return (long) doubleValue();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>short</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>short</code> value\r\n     */\r\n    public short shortValue() {\r\n        return (short) doubleValue();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>byte</code> value.</p>\r\n     *",
        "public int compareTo(Fraction object) {\r\n        if (object == null) {\r\n            return -1;\r\n        }\r\n        if (object == this) {\r\n            return 0;\r\n        }\r\n        return getNumerator() - object.getNumerator();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>double</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>double</code> value\r\n     */\r\n    public double doubleValue() {\r\n        return (double) getNumerator() / (double) getDenominator();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>float</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>float</code> value\r\n     */\r\n    public float floatValue() {\r\n        return (float) getNumerator() / (float) getDenominator();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as an <code>int</code> value.</p>\r\n     *\r\n     * @return the fraction as an <code>int</code> value\r\n     */\r\n    public int intValue() {\r\n        return (int) (getNumerator() / getDenominator());\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>long</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>long</code> value\r\n     */\r\n    public long longValue() {\r\n        return (long) (getNumerator() / getDenominator());\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>short</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>short</code> value\r\n     */\r\n    public short shortValue() {\r\n        return (short) (getNumerator() / getDenominator());",
        "public int compareTo(Fraction object) {\r\n        if (object == null) {\r\n            return -1;\r\n        }\r\n        if (object == this) {\r\n            return 0;\r\n        }\r\n        return getNumerator() - object.getNumerator();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>double</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>double</code> value\r\n     */\r\n    public double doubleValue() {\r\n        return (double) getNumerator() / (double) getDenominator();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>float</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>float</code> value\r\n     */\r\n    public float floatValue() {\r\n        return (float) doubleValue();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as an <code>int</code> value.</p>\r\n     *\r\n     * @return the fraction as an <code>int</code> value\r\n     */\r\n    public int intValue() {\r\n        return (int) doubleValue();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>long</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>long</code> value\r\n     */\r\n    public long longValue() {\r\n        return (long) doubleValue();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>short</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>short</code> value\r\n     */\r\n    public short shortValue() {\r\n        return (short) doubleValue();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as an <code>byte</code> value.</p>\r\n     *",
        "public int compareTo(Fraction object) {\r\n        if (object == null) {\r\n            return -1;\r\n        }\r\n        if (object == this) {\r\n            return 0;\r\n        }\r\n        return getNumerator() - object.getNumerator();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>double</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>double</code> value\r\n     */\r\n    public double doubleValue() {\r\n        return (double) getNumerator() / (double) getDenominator();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>float</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>float</code> value\r\n     */\r\n    public float floatValue() {\r\n        return (float) doubleValue();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as an <code>int</code> value.</p>\r\n     *\r\n     * @return the fraction as an <code>int</code> value\r\n     */\r\n    public int intValue() {\r\n        return (int) doubleValue();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>long</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>long</code> value\r\n     */\r\n    public long longValue() {\r\n        return (long) doubleValue();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>byte</code> value.</p>\r\n     *\r\n     * @return the fraction as a <code>byte</code> value\r\n     */\r\n    public byte byteValue() {\r\n        return (byte) doubleValue();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>short</code> value.</p>\r\n     *",
        "public int compareTo(Fraction object) {\r\n        if (object == null) {\r\n            return -1;\r\n        }\r\n        if (object == this) {\r\n            return 0;\r\n        }\r\n        return getNumerator() - object.getNumerator();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>String</code>.</p>\r\n     *\r\n     * <p>The format used is '<i>numerator</i>/<i>denominator</i>' always.\r\n     *\r\n     * @return a <code>String</code> form of the fraction\r\n     */\r\n    public String toString() {\r\n        if (toString == null) {\r\n            toString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString();\r\n        }\r\n        return toString;\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>\r\n     *\r\n     * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.\r\n     * If the whole number is zero it will be ommitted. If the numerator is zero,\r\n     * only the whole number is returned.</p>\r\n     *\r\n     * @return a <code>String</code> form of the fraction\r\n     */\r\n    public String toProperString() {\r\n        if (toProperString == null) {\r\n            if (numerator == 0) {\r\n                toProperString = \"0\";\r\n            } else if (numerator == denominator) {\r\n                toProperString = \"1\";\r\n            } else if (numerator == -1 * denominator) {\r\n                toProperString = \"-1\";\r\n            } else if ((numerator > 0? -numerator : numerator) < -denominator) {\r\n",
        "public int compareTo(Fraction object) {\r\n        if (object == null) {\r\n            return -1;\r\n        }\r\n        if (object == this) {\r\n            return 0;\r\n        }\r\n        return getNumerator() - object.getNumerator();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>String</code>.</p>\r\n     *\r\n     * <p>The format used is '<i>numerator</i>/<i>denominator</i>' always.\r\n     *\r\n     * @return a <code>String</code> form of the fraction\r\n     */\r\n    public String toString() {\r\n        if (toString == null) {\r\n            toString = new StringBuilder(32)\r\n               .append(getNumerator())\r\n               .append('/')\r\n               .append(getDenominator()).toString();\r\n        }\r\n        return toString;\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>\r\n     *\r\n     * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.\r\n     * If the whole number is zero it will be ommitted. If the numerator is zero,\r\n     * only the whole number is returned.</p>\r\n     *\r\n     * @return a <code>String</code> form of the fraction\r\n     */\r\n    public String toProperString() {\r\n        if (toProperString == null) {\r\n            if (numerator == 0) {\r\n                toProperString = \"0\";\r\n            } else if (numerator == denominator) {\r\n                toProperString = \"1\";\r\n            } else if (numerator == -1 * denominator) {\r\n                toProperString = \"-1\";\r\n            } else if ((numerator>0?-numerator:n",
        "public int compareTo(Fraction object) {\r\n        if (object == null) {\r\n            return -1;\r\n        }\r\n        if (object == this) {\r\n            return 0;\r\n        }\r\n        return getNumerator() - object.getNumerator();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>String</code>.</p>\r\n     *\r\n     * <p>The format used is '<i>numerator</i>/<i>denominator</i>' always.\r\n     *\r\n     * @return a <code>String</code> form of the fraction\r\n     */\r\n    public String toString() {\r\n        if (toString == null) {\r\n            toString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString();\r\n        }\r\n        return toString;\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>\r\n     *\r\n     * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.\r\n     * If the whole number is zero it will be ommitted. If the numerator is zero,\r\n     * only the whole number is returned.</p>\r\n     *\r\n     * @return a <code>String</code> form of the fraction\r\n     */\r\n    public String toProperString() {\r\n        if (toProperString == null) {\r\n            if (numerator == 0) {\r\n                toProperString = \"0\";\r\n            } else if (numerator == denominator) {\r\n                toProperString = \"1\";\r\n            } else if (numerator == -1 * denominator) {\r\n                toProperString = \"-1\";\r\n            } else if ((numerator>0?-numerator:numerator) < -denominator) {\r",
        "public int compareTo(Fraction object) {\r\n        if (object == null) {\r\n            return -1;\r\n        }\r\n        if (object == this) {\r\n            return 0;\r\n        }\r\n        return getNumerator() - object.getNumerator();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>String</code>.</p>\r\n     *\r\n     * <p>The format used is '<i>numerator</i>/<i>denominator</i>' always.\r\n     *\r\n     * @return a <code>String</code> form of the fraction\r\n     */\r\n    public String toString() {\r\n        if (toString == null) {\r\n            toString = new StringBuffer(32)\r\n               .append(getNumerator())\r\n               .append('/')\r\n               .append(getDenominator()).toString();\r\n        }\r\n        return toString;\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>\r\n     *\r\n     * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.\r\n     * If the whole number is zero it will be ommitted. If the numerator is zero,\r\n     * only the whole number is returned.</p>\r\n     *\r\n     * @return a <code>String</code> form of the fraction\r\n     */\r\n    public String toProperString() {\r\n        if (toProperString == null) {\r\n            if (numerator == 0) {\r\n                toProperString = \"0\";\r\n            } else if (numerator == denominator) {\r\n                toProperString = \"1\";\r\n            } else if (numerator == -1 * denominator) {\r\n                toProperString = \"-1\";\r\n            } else if ((numerator>0?-numerator:n",
        "public int compareTo(Fraction object) {\r\n        if (object == null) {\r\n            return -1;\r\n        }\r\n        if (object == this) {\r\n            return 0;\r\n        }\r\n        return getNumerator() - object.getNumerator();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>String</code>.</p>\r\n     *\r\n     * <p>The format used is '<i>numerator</i>/<i>denominator</i>' always.\r\n     *\r\n     * @return a <code>String</code> form of the fraction\r\n     */\r\n    public String toString() {\r\n        if (toString == null) {\r\n            toString = getNumerator() + \"/\" + getDenominator();\r\n        }\r\n        return toString;\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>\r\n     *\r\n     * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.\r\n     * If the whole number is zero it will be ommitted. If the numerator is zero,\r\n     * only the whole number is returned.</p>\r\n     *\r\n     * @return a <code>String</code> form of the fraction\r\n     */\r\n    public String toProperString() {\r\n        if (toProperString == null) {\r\n            if (numerator == 0) {\r\n                toProperString = \"0\";\r\n            } else if (numerator == denominator) {\r\n                toProperString = \"1\";\r\n            } else if (numerator == -1 * denominator) {\r\n                toProperString = \"-1\";\r\n            } else if ((numerator > 0? -numerator : numerator) < -denominator) {\r\n                // note that we do the magnitude comparison test above with\r\n                ",
        "public int compareTo(Fraction object) {\r\n        if (object == null) {\r\n            return -1;\r\n        }\r\n        if (object == this) {\r\n            return 0;\r\n        }\r\n        return getNumerator() - object.getNumerator();\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a <code>String</code>.</p>\r\n     *\r\n     * <p>The format used is '<i>numerator</i>/<i>denominator</i>' always.\r\n     *\r\n     * @return a <code>String</code> form of the fraction\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        if (toString == null) {\r\n            toString = new StringBuilder(32)\r\n               .append(getNumerator())\r\n               .append('/')\r\n               .append(getDenominator()).toString();\r\n        }\r\n        return toString;\r\n    }\r\n\r\n    /**\r\n     * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>\r\n     *\r\n     * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.\r\n     * If the whole number is zero it will be ommitted. If the numerator is zero,\r\n     * only the whole number is returned.</p>\r\n     *\r\n     * @return a <code>String</code> form of the fraction\r\n     */\r\n    public String toProperString() {\r\n        if (toProperString == null) {\r\n            if (numerator == 0) {\r\n                toProperString = \"0\";\r\n            } else if (numerator == denominator) {\r\n                toProperString = \"1\";\r\n            } else if (numerator == -1 * denominator) {\r\n                toProperString = \"-1\";\r\n            } else if ((numerator>0?-"
      ],
      "function range": "258,5-262,5"
    },
    "Math_94_/src/java/org/apache/commons/math/util/MathUtils.java_412-413": {
      "loc": "412-413",
      "input": "public static int gcd(int u, int v) {",
      "output": [
        "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            if (v < 0) {\n                return gcd(-u, -v);\n            } else {\n                return gcd(-u, v);\n            }\n        } else {\n            if (v < 0) {\n                return gcd(u, -v);\n            } else {\n                return gcd(u, v);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            if (v < 0) {\n                return gcd(-u, -v);\n            } else {\n                return gcd(-u, v);\n            }\n        } else {\n            if (v < 0) {\n                return gcd(u, -v);\n            } else {\n                return gcd(u, v);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.",
        "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            if (v < 0) {\n                return gcd(-u, -v);\n            } else {\n                return gcd(-u, v);\n            }\n        } else {\n            if (v < 0) {\n                return gcd(u, -v);\n            } else {\n                return gcd(u, v);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.",
        "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            if (v < 0) {\n                return gcd(-u, -v);\n            } else {\n                return gcd(-u, v);\n            }\n        } else {\n            if (v < 0) {\n                return gcd(u, -v);\n            } else {\n                return gcd(u, v);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\n",
        "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            if (v < 0) {\n                return gcd(-u, -v);\n            } else {\n                return gcd(-u, v);\n            }\n        } else {\n            if (v < 0) {\n                return gcd(u, -v);\n            } else {\n                return gcd(u, v);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.al",
        "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            if (v < 0) {\n                return gcd(-u, -v);\n            } else {\n                return gcd(-u, v);\n            }\n        } else {\n            if (v < 0) {\n                return gcd(u, -v);\n            } else {\n                return gcd(u, v);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag",
        "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            if (v < 0) {\n                return gcd(-u, -v);\n            } else {\n                return gcd(-u, v);\n            }\n        } else {\n            if (v < 0) {\n                return gcd(u, -v);\n            } else {\n                return gcd(u, v);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.",
        "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            if (v < 0) {\n                return gcd(-u, -v);\n            } else {\n                return gcd(-u, v);\n            }\n        } else {\n            if (v < 0) {\n                return gcd(u, -v);\n            } else {\n                return gcd(u, v);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.al",
        "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            if (v < 0) {\n                return gcd(-u, -v);\n            } else {\n                return gcd(-u, v);\n            }\n        } else {\n            if (v < 0) {\n                return gcd(u, -v);\n            } else {\n                return gcd(u, v);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.util.JavaDataModel;\nimport org.apache.",
        "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            if (v < 0) {\n                return gcd(-u, -v);\n            } else {\n                return gcd(-u, v);\n            }\n        } else {\n            if (v < 0) {\n                return gcd(u, -v);\n            } else {\n                return gcd(u, v);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.serde2.io.HiveDecimalWritable;\n"
      ],
      "function range": "411,5-460,5"
    },
    "Math_96_/src/java/org/apache/commons/math/complex/Complex.java_258-259": {
      "loc": "258-259",
      "input": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {",
      "output": [
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.real.equals(rhs.real) && this.imaginary.equals(rhs.imaginary);\n            }\n        } catch (ClassCastException ex) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 17;\n    result = 31 * result + real.hashCode();\n    result = 31 * result + imaginary.hashCode();\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(\");\n    sb.append(real);\n    sb.append(\", \");\n    sb.append(imaginary);\n    sb.append(\")\");\n    return sb.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.real.equals(rhs.real) && this.imaginary.equals(rhs.imaginary);\n            }\n        } catch (ClassCastException ex) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 17;\n    result = 31 * result + real.hashCode();\n    result = 31 * result + imaginary.hashCode();\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(\");\n    sb.append(real);\n    sb.append(\", \");\n    sb.append(imaginary);\n    sb.append(\")\");\n    return sb.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.real.equals(rhs.real) && this.imaginary.equals(rhs.imaginary);\n            }\n        } catch (ClassCastException ex) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 17;\n    result = 31 * result + real.hashCode();\n    result = 31 * result + imaginary.hashCode();\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(\");\n    sb.append(real);\n    sb.append(\", \");\n    sb.append(imaginary);\n    sb.append(\")\");\n    return sb.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.real.equals(rhs.real) && this.imaginary.equals(rhs.imaginary);\n            }\n        } catch (ClassCastException ex) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 17;\n    result = 31 * result + real.hashCode();\n    result = 31 * result + imaginary.hashCode();\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(\");\n    sb.append(real);\n    sb.append(\", \");\n    sb.append(imaginary);\n    sb.append(\")\");\n    return sb.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport java.util",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.real.equals(rhs.real) && this.imaginary.equals(rhs.imaginary);\n            }\n        } catch (ClassCastException ex) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 17;\n    result = 31 * result + real.hashCode();\n    result = 31 * result + imaginary.hashCode();\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(\");\n    sb.append(real);\n    sb.append(\", \");\n    sb.append(imaginary);\n    sb.append(\")\");\n    return sb.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.storage.am.lsm.",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.real.equals(rhs.real) && this.imaginary.equals(rhs.imaginary);\n            }\n        } catch (ClassCastException ex) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 17;\n    result = 31 * result + real.hashCode();\n    result = 31 * result + imaginary.hashCode();\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(\");\n    sb.append(real);\n    sb.append(\", \");\n    sb.append(imaginary);\n    sb.append(\")\");\n    return sb.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.aggregation.dat",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.real.equals(rhs.real) && this.imaginary.equals(rhs.imaginary);\n            }\n        } catch (ClassCastException ex) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 17;\n    result = 31 * result + real.hashCode();\n    result = 31 * result + imaginary.hashCode();\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(\");\n    sb.append(real);\n    sb.append(\", \");\n    sb.append(imaginary);\n    sb.append(\")\");\n    return sb.toString();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rew",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.real.equals(rhs.real) && this.imaginary.equals(rhs.imaginary);\n            }\n        } catch (ClassCastException ex) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 17;\n    result = 31 * result + real.hashCode();\n    result = 31 * result + imaginary.hashCode();\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(\");\n    sb.append(real);\n    sb.append(\", \");\n    sb.append(imaginary);\n    sb.append(\")\");\n    return sb.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.ddl.table",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.real.equals(rhs.real) && this.imaginary.equals(rhs.imaginary);\n            }\n        } catch (ClassCastException ex) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 17;\n    result = 31 * result + real.hashCode();\n    result = 31 * result + imaginary.hashCode();\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(\");\n    sb.append(real);\n    sb.append(\", \");\n    sb.append(imaginary);\n    sb.append(\")\");\n    return sb.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.indexing.common.task",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.real.equals(rhs.real) && this.imaginary.equals(rhs.imaginary);\n            }\n        } catch (ClassCastException ex) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 17;\n    result = 31 * result + real.hashCode();\n    result = 31 * result + imaginary.hashCode();\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(\");\n    sb.append(real);\n    sb.append(\", \");\n    sb.append(imaginary);\n    sb.append(\")\");\n    return sb.toString();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache.distributed.dht;"
      ],
      "function range": "245,5-267,5"
    },
    "Math_101_/src/java/org/apache/commons/math/complex/ComplexFormat.java_377-378": {
      "loc": "377-378",
      "input": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;",
      "output": [
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on number parsing.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed.\n   * @return A <code>Number</code> parsed from the string.\n   * @exception ParseException if the beginning of the specified string\n   *            cannot be parsed.\n   ",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.regionMatches(startIndex, getImaginaryCharacter(), 0, n)) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on number parsing.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed.\n   * @return A <code>Number</code> parsed from the string.\n   * @exception ParseException if the beginning of the specified string\n   *",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on number parsing.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed.\n   * @param pos A <code>ParsePosition</code> object with index and error\n   *            index information as described above.\n   * @return A <code>Number</code> parsed",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on message parsing.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed.\n   * @return A <code>Number</code> parsed from the string.\n   * @exception ParseException if the beginning of the specified string\n   *            cannot be parsed.\n   ",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.regionMatches(startIndex, getImaginaryCharacter(), 0, n)) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on message parsing.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed.\n   * @return A <code>Number</code> parsed from the string.\n   * @exception ParseException if the beginning of the specified string\n   *",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.regionMatches(startIndex, getImaginaryCharacter(), 0, n)) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on number parsing.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed.\n   * @param pos A <code>ParsePosition</code> object with index and error\n   *            index information as described above.\n   * @return A",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on number parsing.\n   *\n   * @param source A <code>String</code>, part of which should be parsed.\n   * @param pos A <code>ParsePosition</code> object with index and error\n   *            index information as described above.\n   * @return A <code>Number</code>",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on usage of this method.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed.\n   * @return A <code>Number</code> parsed from the string.\n   * @exception ParseException if the beginning of the specified string\n   *            cannot be parsed.",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.regionMatches(startIndex, getImaginaryCharacter(), 0, n)) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on usage of this method.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed.\n   * @return A <code>Number</code> parsed from the string.\n   * @exception ParseException if the beginning of the specified string\n",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.regionMatches(startIndex, getImaginaryCharacter(), 0, n)) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on number parsing.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed.\n   * @return A <code>Number</code> parsed from the string.\n   * @throws ParseException if the beginning of the specified string cannot\n   "
      ],
      "function range": "320,5-389,5"
    },
    "Math_105_/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java_264-265": {
      "loc": "264-265",
      "input": "public double getSumSquaredErrors() {",
      "output": [
        "public double getSumSquaredErrors() {\n        return sumSquaredErrors;\n    }\n\n    /**\n     * Sets the value of the sumSquaredErrors property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setSumSquaredErrors(double value) {\n        this.sumSquaredErrors = value;\n    }\n\n    /**\n     * Gets the value of the rSquared property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getRSquared() {\n        return rSquared;\n    }\n\n    /**\n     * Sets the value of the rSquared property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setRSquared(double value) {\n        this.rSquared = value;\n    }\n\n    /**\n     * Gets the value of the adjustedRSquared property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getAdjustedRSquared() {\n        return adjustedRSquared;\n    }\n\n    /**\n     * Sets the value of the adjustedRSquared property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setAdjustedRSquared(double value) {\n        this.adjustedRSquared = value;\n    }\n\n    /**\n     * Gets the value of the r2 property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getR2() {\n        return r2;\n    }\n\n    /**\n     * Sets the value of the r2 property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     ",
        "public double getSumSquaredErrors() {\n        return sumSquaredErrors;\n    }\n\n    /**\n     * Sets the value of the sumSquaredErrors property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setSumSquaredErrors(double value) {\n        this.sumSquaredErrors = value;\n    }\n\n    /**\n     * Gets the value of the rSquared property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getRSquared() {\n        return rSquared;\n    }\n\n    /**\n     * Sets the value of the rSquared property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setRSquared(double value) {\n        this.rSquared = value;\n    }\n\n    /**\n     * Gets the value of the rootMeanSquaredError property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getRootMeanSquaredError() {\n        return rootMeanSquaredError;\n    }\n\n    /**\n     * Sets the value of the rootMeanSquaredError property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setRootMeanSquaredError(double value) {\n        this.rootMeanSquaredError = value;\n    }\n\n    /**\n     * Gets the value of the aic property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getAic() {\n        return aic;\n    }\n\n    /**\n     * Sets the value of the aic property.\n     * \n     * @param value\n     *     allowed object is\n     *     {",
        "public double getSumSquaredErrors() {\n        return sumSquaredErrors;\n    }\n\n    /**\n     * Sets the value of the sumSquaredErrors property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setSumSquaredErrors(double value) {\n        this.sumSquaredErrors = value;\n    }\n\n    /**\n     * Gets the value of the rSquared property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getRSquared() {\n        return rSquared;\n    }\n\n    /**\n     * Sets the value of the rSquared property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setRSquared(double value) {\n        this.rSquared = value;\n    }\n\n    /**\n     * Gets the value of the adjustedRSquared property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getAdjustedRSquared() {\n        return adjustedRSquared;\n    }\n\n    /**\n     * Sets the value of the adjustedRSquared property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setAdjustedRSquared(double value) {\n        this.adjustedRSquared = value;\n    }\n\n    /**\n     * Gets the value of the mse property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getMse() {\n        return mse;\n    }\n\n    /**\n     * Sets the value of the mse property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     ",
        "public double getSumSquaredErrors() {\n        return sumSquaredErrors;\n    }\n\n    /**\n     * Sets the value of the sumSquaredErrors property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setSumSquaredErrors(double value) {\n        this.sumSquaredErrors = value;\n    }\n\n    /**\n     * Gets the value of the rSquared property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getRSquared() {\n        return rSquared;\n    }\n\n    /**\n     * Sets the value of the rSquared property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setRSquared(double value) {\n        this.rSquared = value;\n    }\n\n    /**\n     * Gets the value of the adjustedRSquared property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getAdjustedRSquared() {\n        return adjustedRSquared;\n    }\n\n    /**\n     * Sets the value of the adjustedRSquared property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setAdjustedRSquared(double value) {\n        this.adjustedRSquared = value;\n    }\n\n    /**\n     * Gets the value of the mae property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getMAE() {\n        return mae;\n    }\n\n    /**\n     * Sets the value of the mae property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     ",
        "public double getSumSquaredErrors() {\n        return sumSquaredErrors;\n    }\n\n    /**\n     * Sets the value of the sumSquaredErrors property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setSumSquaredErrors(double value) {\n        this.sumSquaredErrors = value;\n    }\n\n    /**\n     * Gets the value of the rSquared property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getRSquared() {\n        return rSquared;\n    }\n\n    /**\n     * Sets the value of the rSquared property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setRSquared(double value) {\n        this.rSquared = value;\n    }\n\n    /**\n     * Gets the value of the residualDegreesOfFreedom property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getResidualDegreesOfFreedom() {\n        return residualDegreesOfFreedom;\n    }\n\n    /**\n     * Sets the value of the residualDegreesOfFreedom property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setResidualDegreesOfFreedom(double value) {\n        this.residualDegreesOfFreedom = value;\n    }\n\n    /**\n     * Gets the value of the residualError property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getResidualError() {\n        return residualError;\n    }\n\n    /**\n     * Sets the value of the residualError property.\n     * \n     * @param value\n     *     ",
        "public double getSumSquaredErrors() {\n        return sumSquaredErrors;\n    }\n\n    /**\n     * Sets the value of the sumSquaredErrors property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setSumSquaredErrors(double value) {\n        this.sumSquaredErrors = value;\n    }\n\n    /**\n     * Gets the value of the rSquared property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getRSquared() {\n        return rSquared;\n    }\n\n    /**\n     * Sets the value of the rSquared property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setRSquared(double value) {\n        this.rSquared = value;\n    }\n\n    /**\n     * Gets the value of the rootMeanSquaredError property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getRootMeanSquaredError() {\n        return rootMeanSquaredError;\n    }\n\n    /**\n     * Sets the value of the rootMeanSquaredError property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setRootMeanSquaredError(double value) {\n        this.rootMeanSquaredError = value;\n    }\n\n    /**\n     * Gets the value of the r2 property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getR2() {\n        return r2;\n    }\n\n    /**\n     * Sets the value of the r2 property.\n     * \n     * @param value\n     *     allowed object is\n     *     {",
        "public double getSumSquaredErrors() {\n        return sumSquaredErrors;\n    }\n\n    /**\n     * Sets the value of the sumSquaredErrors property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setSumSquaredErrors(double value) {\n        this.sumSquaredErrors = value;\n    }\n\n    /**\n     * Gets the value of the rSquared property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getRSquared() {\n        return rSquared;\n    }\n\n    /**\n     * Sets the value of the rSquared property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setRSquared(double value) {\n        this.rSquared = value;\n    }\n\n    /**\n     * Gets the value of the adjustedRSquared property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getAdjustedRSquared() {\n        return adjustedRSquared;\n    }\n\n    /**\n     * Sets the value of the adjustedRSquared property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setAdjustedRSquared(double value) {\n        this.adjustedRSquared = value;\n    }\n\n    /**\n     * Gets the value of the rootMeanSquaredError property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getRootMeanSquaredError() {\n        return rootMeanSquaredError;\n    }\n\n    /**\n     * Sets the value of the rootMeanSquaredError property.\n     * \n     * @param value\n     *     allowed object",
        "public double getSumSquaredErrors() {\n        return sumSquaredErrors;\n    }\n\n    /**\n     * Sets the value of the sumSquaredErrors property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setSumSquaredErrors(double value) {\n        this.sumSquaredErrors = value;\n    }\n\n    /**\n     * Gets the value of the rSquared property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getRSquared() {\n        return rSquared;\n    }\n\n    /**\n     * Sets the value of the rSquared property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setRSquared(double value) {\n        this.rSquared = value;\n    }\n\n    /**\n     * Gets the value of the residualDegreesOfFreedom property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getResidualDegreesOfFreedom() {\n        return residualDegreesOfFreedom;\n    }\n\n    /**\n     * Sets the value of the residualDegreesOfFreedom property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setResidualDegreesOfFreedom(double value) {\n        this.residualDegreesOfFreedom = value;\n    }\n\n    /**\n     * Gets the value of the residuals property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getResiduals() {\n        return residuals;\n    }\n\n    /**\n     * Sets the value of the residuals property.\n     * \n     * @param value\n     *     ",
        "public double getSumSquaredErrors() {\n        return sumSquaredErrors;\n    }\n\n    /**\n     * Sets the value of the sumSquaredErrors property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setSumSquaredErrors(double value) {\n        this.sumSquaredErrors = value;\n    }\n\n    /**\n     * Gets the value of the rSquared property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getRSquared() {\n        return rSquared;\n    }\n\n    /**\n     * Sets the value of the rSquared property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setRSquared(double value) {\n        this.rSquared = value;\n    }\n\n    /**\n     * Gets the value of the residualDegreesOfFreedom property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getResidualDegreesOfFreedom() {\n        return residualDegreesOfFreedom;\n    }\n\n    /**\n     * Sets the value of the residualDegreesOfFreedom property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setResidualDegreesOfFreedom(double value) {\n        this.residualDegreesOfFreedom = value;\n    }\n\n    /**\n     * Gets the value of the residualMeanSquare property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getResidualMeanSquare() {\n        return residualMeanSquare;\n    }\n\n    /**\n     * Sets the value of the residualMeanSquare property.\n     * \n     ",
        "public double getSumSquaredErrors() {\n        return sumSquaredErrors;\n    }\n\n    /**\n     * Sets the value of the sumSquaredErrors property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setSumSquaredErrors(double value) {\n        this.sumSquaredErrors = value;\n    }\n\n    /**\n     * Gets the value of the rSquared property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getRSquared() {\n        return rSquared;\n    }\n\n    /**\n     * Sets the value of the rSquared property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setRSquared(double value) {\n        this.rSquared = value;\n    }\n\n    /**\n     * Gets the value of the residualDegreesOfFreedom property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getResidualDegreesOfFreedom() {\n        return residualDegreesOfFreedom;\n    }\n\n    /**\n     * Sets the value of the residualDegreesOfFreedom property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setResidualDegreesOfFreedom(double value) {\n        this.residualDegreesOfFreedom = value;\n    }\n\n    /**\n     * Gets the value of the residual degrees of freedom property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Double }\n     *     \n     */\n    public double getResidualDegreesOfFreedomStandardError() {\n        return residualDegreesOfFreedomStandardError;\n    }\n\n    /**\n     * Sets the value of the residual degrees of freedom"
      ],
      "function range": "263,5-265,5"
    },
    "Mockito_1_/src/org/mockito/internal/invocation/InvocationMatcher.java_123-124": {
      "loc": "123-124",
      "input": "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;",
      "output": [
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int i = 0; i < indexOfVararg; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int i = 0; i < indexOfVararg; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.alge",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int i = 0; i < indexOfVararg; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int i = 0; i < indexOfVararg; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int i = 0; i < indexOfVararg; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int i = 0; i < indexOfVararg; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.alge",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int i = 0; i < indexOfVararg; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\n",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int i = 0; i < indexOfVararg; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.alge",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int i = 0; i < indexOfVararg; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.util.JavaDataModel;\nimport org.apache.hado",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int i = 0; i < indexOfVararg; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            arguments.add(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.serde2.io.HiveDecimalWritable;\nimport org"
      ],
      "function range": "120,5-150,5"
    },
    "Mockito_5_/src/org/mockito/internal/verification/VerificationOverTimeImpl.java_91-92": {
      "loc": "91-92",
      "input": "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }",
      "output": [
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (MockitoException e) {\n            error = handleVerifyException(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n  }\n\n  private AssertionError handleVerifyException(MockitoException e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    return error;\n  }\n\n  @Override\n  public void reset() {\n    delegate.reset();\n  }\n\n  @Override\n  public int getInvocationsCount() {\n    return delegate.getInvocationsCount();\n  }\n\n  @Override\n  public int getSuccessesCount() {\n    return delegate.getSuccessesCount();\n  }\n\n  @Override\n  public int getFailuresCount() {\n    return delegate.getFailuresCount();\n  }\n\n  @Override\n  public int getVerificationsCount() {\n    return delegate.getVerificationsCount();\n  }\n\n  @Override\n  public int getInvocations() {\n    return delegate.getInvocations();\n  }\n\n  @Override\n  public int getSuccesses() {\n    return delegate.getSuccesses();\n  }\n\n  @Override\n  public int getFailures() {\n    return delegate.getFailures();\n  }\n\n  @Override\n  public int getSkipped() {\n    return delegate.getSkipped();\n  }\n\n  @Override\n  public int getVerified() {\n    return delegate.getVerified();\n  }\n\n  @Override\n  public int getVerifiedInvocations() {\n    return delegate.getVerifiedInvocations();\n  }\n\n  @Override\n  public int",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (MockitoException e) {\n            error = handleVerifyException(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n  }\n\n  private AssertionError handleVerifyException(MockitoException e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    return error;\n  }\n\n  @Override\n  public void reset() {\n    delegate.reset();\n  }\n\n  @Override\n  public int getInvocationsCount() {\n    return delegate.getInvocationsCount();\n  }\n\n  @Override\n  public int getSuccessesCount() {\n    return delegate.getSuccessesCount();\n  }\n\n  @Override\n  public int getFailuresCount() {\n    return delegate.getFailuresCount();\n  }\n\n  @Override\n  public int getVerificationsCount() {\n    return delegate.getVerificationsCount();\n  }\n\n  @Override\n  public int getInvocations() {\n    return delegate.getInvocations();\n  }\n\n  @Override\n  public int getSuccesses() {\n    return delegate.getSuccesses();\n  }\n\n  @Override\n  public int getFailures() {\n    return delegate.getFailures();\n  }\n\n  @Override\n  public int getSkipped() {\n    return delegate.getSkipped();\n  }\n\n  @Override\n  public int getVerified() {\n    return delegate.getVerified();\n  }\n\n  @Override\n  public int getVerifiedInvocationsCount() {\n    return delegate.getVerifiedInvocationsCount();\n  }\n\n  @Override\n  ",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (MockitoException e) {\n            error = handleVerifyException(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n  }\n\n  private AssertionError handleVerifyException(MockitoException e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    return error;\n  }\n\n  @Override\n  public void reset() {\n    delegate.reset();\n  }\n\n  @Override\n  public int getInvocationsCount() {\n    return delegate.getInvocationsCount();\n  }\n\n  @Override\n  public int getSuccessesCount() {\n    return delegate.getSuccessesCount();\n  }\n\n  @Override\n  public int getFailuresCount() {\n    return delegate.getFailuresCount();\n  }\n\n  @Override\n  public int getVerificationsCount() {\n    return delegate.getVerificationsCount();\n  }\n\n  @Override\n  public int getInvocations() {\n    return delegate.getInvocations();\n  }\n\n  @Override\n  public int getSuccesses() {\n    return delegate.getSuccesses();\n  }\n\n  @Override\n  public int getFailures() {\n    return delegate.getFailures();\n  }\n\n  @Override\n  public int getSkipped() {\n    return delegate.getSkipped();\n  }\n\n  @Override\n  public int getVerifications() {\n    return delegate.getVerifications();\n  }\n\n  @Override\n  public long getDuration() {\n    return delegate.getDuration();\n  }\n\n  @Override\n  public long getStartTime() {\n    return",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (MockitoException e) {\n            error = handleVerifyException(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n  }\n\n  private AssertionError handleVerifyException(MockitoException e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    return error;\n  }\n\n  @Override\n  public void reset() {\n    delegate.reset();\n  }\n\n  @Override\n  public int getInvocationsCount() {\n    return delegate.getInvocationsCount();\n  }\n\n  @Override\n  public int getSuccessesCount() {\n    return delegate.getSuccessesCount();\n  }\n\n  @Override\n  public int getFailuresCount() {\n    return delegate.getFailuresCount();\n  }\n\n  @Override\n  public int getVerificationsCount() {\n    return delegate.getVerificationsCount();\n  }\n\n  @Override\n  public int getInvocations() {\n    return delegate.getInvocations();\n  }\n\n  @Override\n  public int getSuccesses() {\n    return delegate.getSuccesses();\n  }\n\n  @Override\n  public int getFailures() {\n    return delegate.getFailures();\n  }\n\n  @Override\n  public int getVerifications() {\n    return delegate.getVerifications();\n  }\n\n  @Override\n  public int getMocked() {\n    return delegate.getMocked();\n  }\n\n  @Override\n  public int getNotMocked() {\n    return delegate.getNotMocked();\n  }\n\n  @Override\n  public int getIgnored()",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (MockitoException e) {\n            error = handleVerifyException(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n  }\n\n  private AssertionError handleVerifyException(MockitoException e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    return error;\n  }\n\n  @Override\n  public void reset() {\n    delegate.reset();\n  }\n\n  @Override\n  public int getInvocationsCount() {\n    return delegate.getInvocationsCount();\n  }\n\n  @Override\n  public int getSuccessesCount() {\n    return delegate.getSuccessesCount();\n  }\n\n  @Override\n  public int getFailuresCount() {\n    return delegate.getFailuresCount();\n  }\n\n  @Override\n  public int getVerificationsCount() {\n    return delegate.getVerificationsCount();\n  }\n\n  @Override\n  public int getInvocations() {\n    return delegate.getInvocations();\n  }\n\n  @Override\n  public int getSuccesses() {\n    return delegate.getSuccesses();\n  }\n\n  @Override\n  public int getFailures() {\n    return delegate.getFailures();\n  }\n\n  @Override\n  public int getSkipped() {\n    return delegate.getSkipped();\n  }\n\n  @Override\n  public int getVerified() {\n    return delegate.getVerified();\n  }\n\n  @Override\n  public int getVerifiedInvocations() {\n    return delegate.getVerifiedInvocations();\n  }\n\n  @Override\n  public long",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (MockitoException e) {\n            error = handleVerifyException(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n  }\n\n  private AssertionError handleVerifyException(MockitoException e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    return error;\n  }\n\n  @Override\n  public void reset() {\n    delegate.reset();\n  }\n\n  @Override\n  public int getInvocationsCount() {\n    return delegate.getInvocationsCount();\n  }\n\n  @Override\n  public int getSuccessesCount() {\n    return delegate.getSuccessesCount();\n  }\n\n  @Override\n  public int getFailuresCount() {\n    return delegate.getFailuresCount();\n  }\n\n  @Override\n  public int getVerificationsCount() {\n    return delegate.getVerificationsCount();\n  }\n\n  @Override\n  public int getInvocations() {\n    return delegate.getInvocations();\n  }\n\n  @Override\n  public int getSuccesses() {\n    return delegate.getSuccesses();\n  }\n\n  @Override\n  public int getFailures() {\n    return delegate.getFailures();\n  }\n\n  @Override\n  public int getVerifications() {\n    return delegate.getVerifications();\n  }\n\n  @Override\n  public int getMocked() {\n    return delegate.getMocked();\n  }\n\n  @Override\n  public int getNotMocked() {\n    return delegate.getNotMocked();\n  }\n}\n<|java|>/*\n *",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (MockitoException e) {\n            error = handleVerifyException(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n  }\n\n  private AssertionError handleVerifyException(MockitoException e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    return error;\n  }\n\n  @Override\n  public void reset() {\n    delegate.reset();\n  }\n\n  @Override\n  public int getInvocationsCount() {\n    return delegate.getInvocationsCount();\n  }\n\n  @Override\n  public int getSuccessesCount() {\n    return delegate.getSuccessesCount();\n  }\n\n  @Override\n  public int getFailuresCount() {\n    return delegate.getFailuresCount();\n  }\n\n  @Override\n  public int getVerificationsCount() {\n    return delegate.getVerificationsCount();\n  }\n\n  @Override\n  public int getInvocations() {\n    return delegate.getInvocations();\n  }\n\n  @Override\n  public int getSuccesses() {\n    return delegate.getSuccesses();\n  }\n\n  @Override\n  public int getFailures() {\n    return delegate.getFailures();\n  }\n\n  @Override\n  public int getVerifications() {\n    return delegate.getVerifications();\n  }\n\n  @Override\n  public int getMocked() {\n    return delegate.getMocked();\n  }\n\n  @Override\n  public int getNotMocked() {\n    return delegate.getNotMocked();\n  }\n\n  @Override\n  public MockCreationSettings get",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (MockitoException e) {\n            error = handleVerifyException(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n  }\n\n  private AssertionError handleVerifyException(MockitoException e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    return error;\n  }\n\n  @Override\n  public void reset() {\n    delegate.reset();\n  }\n\n  @Override\n  public int getInvocationsCount() {\n    return delegate.getInvocationsCount();\n  }\n\n  @Override\n  public int getSuccessesCount() {\n    return delegate.getSuccessesCount();\n  }\n\n  @Override\n  public int getFailuresCount() {\n    return delegate.getFailuresCount();\n  }\n\n  @Override\n  public int getVerificationsCount() {\n    return delegate.getVerificationsCount();\n  }\n\n  @Override\n  public int getInvocations() {\n    return delegate.getInvocations();\n  }\n\n  @Override\n  public int getSuccesses() {\n    return delegate.getSuccesses();\n  }\n\n  @Override\n  public int getFailures() {\n    return delegate.getFailures();\n  }\n\n  @Override\n  public int getVerifications() {\n    return delegate.getVerifications();\n  }\n\n  @Override\n  public int getMocked() {\n    return delegate.getMocked();\n  }\n\n  @Override\n  public int getNotMocked() {\n    return delegate.getNotMocked();\n  }\n\n  @Override\n  public int getMockedBut",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (MockitoException e) {\n            error = handleVerifyException(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n  }\n\n  private AssertionError handleVerifyException(MockitoException e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    return error;\n  }\n\n  @Override\n  public void reset() {\n    delegate.reset();\n  }\n\n  @Override\n  public int getInvocationsCount() {\n    return delegate.getInvocationsCount();\n  }\n\n  @Override\n  public int getSuccessesCount() {\n    return delegate.getSuccessesCount();\n  }\n\n  @Override\n  public int getFailuresCount() {\n    return delegate.getFailuresCount();\n  }\n\n  @Override\n  public int getVerificationsCount() {\n    return delegate.getVerificationsCount();\n  }\n\n  @Override\n  public int getInvocations() {\n    return delegate.getInvocations();\n  }\n\n  @Override\n  public int getSuccesses() {\n    return delegate.getSuccesses();\n  }\n\n  @Override\n  public int getFailures() {\n    return delegate.getFailures();\n  }\n\n  @Override\n  public int getSkipped() {\n    return delegate.getSkipped();\n  }\n\n  @Override\n  public int getVerified() {\n    return delegate.getVerified();\n  }\n\n  @Override\n  public int getVerificationCount() {\n    return delegate.getVerificationCount();\n  }\n\n  @Override\n  public long getDuration() {",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (MockitoException e) {\n            error = handleVerifyException(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n  }\n\n  private AssertionError handleVerifyException(MockitoException e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    return error;\n  }\n\n  @Override\n  public void reset() {\n    delegate.reset();\n  }\n\n  @Override\n  public int getInvocationsCount() {\n    return delegate.getInvocationsCount();\n  }\n\n  @Override\n  public int getSuccessesCount() {\n    return delegate.getSuccessesCount();\n  }\n\n  @Override\n  public int getFailuresCount() {\n    return delegate.getFailuresCount();\n  }\n\n  @Override\n  public int getVerificationsCount() {\n    return delegate.getVerificationsCount();\n  }\n\n  @Override\n  public int getInvocations() {\n    return delegate.getInvocations();\n  }\n\n  @Override\n  public int getSuccesses() {\n    return delegate.getSuccesses();\n  }\n\n  @Override\n  public int getFailures() {\n    return delegate.getFailures();\n  }\n\n  @Override\n  public int getSkipped() {\n    return delegate.getSkipped();\n  }\n\n  @Override\n  public int getVerified() {\n    return delegate.getVerified();\n  }\n\n  @Override\n  public int getVerifiedInvocations() {\n    return delegate.getVerifiedInvocations();\n  }\n\n  @Override\n  public Mock"
      ],
      "function range": "75,5-99,5"
    },
    "Mockito_7_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_379-380": {
      "loc": "379-380",
      "input": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }",
      "output": [
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof Class) {\n      registerTypeVariablesOn((Class<?>) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable<?>) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Class<?> clazz) {\n    for (TypeVariable<?> typeVariable : clazz.getTypeParameters()) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType parameterizedType) {\n    registerTypeVariablesOn(parameterizedType.getRawType());\n    for (Type type : parameterizedType.getActualTypeArguments()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType genericArrayType) {\n    registerTypeVariablesOn(genericArrayType.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(TypeVariable<?> typeVariable) {\n    registerTypeVariable(typeVariable);\n  }\n\n  private void registerTypeVariablesOn(WildcardType wildcardType) {\n    for (Type type : wildcardType.getLowerBounds()) {\n      registerTypeVariablesOn(type);\n    }\n    for (Type type : wildcardType.getUpperBounds()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable<?> typeVariable) {\n    if (!typeVariables.containsKey(typeVariable.getName())) {\n      typeVariables.put(typeVariable.getName",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof Class) {\n      registerTypeVariablesOn((Class<?>) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable<?>) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Class<?> clazz) {\n    for (TypeVariable<?> typeVariable : clazz.getTypeParameters()) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType genericArrayType) {\n    registerTypeVariablesOn(genericArrayType.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType parameterizedType) {\n    registerTypeVariablesOn(parameterizedType.getRawType());\n    for (Type type : parameterizedType.getActualTypeArguments()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(TypeVariable<?> typeVariable) {\n    registerTypeVariable(typeVariable);\n  }\n\n  private void registerTypeVariablesOn(WildcardType wildcardType) {\n    for (Type type : wildcardType.getLowerBounds()) {\n      registerTypeVariablesOn(type);\n    }\n    for (Type type : wildcardType.getUpperBounds()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable<?> typeVariable) {\n    if (!typeVariables.containsKey(typeVariable)) {\n      typeVariables.put(typeVariable, typeVariable);\n    }",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof Class) {\n      registerTypeVariablesOn((Class<?>) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable<?>) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Class<?> clazz) {\n    for (TypeVariable<?> typeVariable : clazz.getTypeParameters()) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType parameterizedType) {\n    registerTypeVariablesOn(parameterizedType.getRawType());\n    for (Type type : parameterizedType.getActualTypeArguments()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType genericArrayType) {\n    registerTypeVariablesOn(genericArrayType.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(TypeVariable<?> typeVariable) {\n    registerTypeVariable(typeVariable);\n  }\n\n  private void registerTypeVariablesOn(WildcardType wildcardType) {\n    for (Type type : wildcardType.getLowerBounds()) {\n      registerTypeVariablesOn(type);\n    }\n    for (Type type : wildcardType.getUpperBounds()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable<?> typeVariable) {\n    if (!typeVariables.containsKey(typeVariable)) {\n      typeVariables.put(typeVariable, typeVariable);\n    }",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof Class) {\n      registerTypeVariablesOn((Class<?>) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable<?>) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Class<?> clazz) {\n    for (TypeVariable<?> typeVariable : clazz.getTypeParameters()) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType parameterizedType) {\n    registerTypeVariablesOn(parameterizedType.getRawType());\n    for (Type type : parameterizedType.getActualTypeArguments()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType genericArrayType) {\n    registerTypeVariablesOn(genericArrayType.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(TypeVariable<?> typeVariable) {\n    registerTypeVariable(typeVariable);\n  }\n\n  private void registerTypeVariablesOn(WildcardType wildcardType) {\n    for (Type type : wildcardType.getLowerBounds()) {\n      registerTypeVariablesOn(type);\n    }\n    for (Type type : wildcardType.getUpperBounds()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable<?> typeVariable) {\n    typeVariables.put(typeVariable.getName(), typeVariable);\n  }\n}\n<|java|>/*\n * Copyright",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof Class) {\n      registerTypeVariablesOn((Class<?>) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable<?>) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Class<?> clazz) {\n    for (TypeVariable<?> typeVariable : clazz.getTypeParameters()) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType genericArrayType) {\n    registerTypeVariablesOn(genericArrayType.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType parameterizedType) {\n    registerTypeVariablesOn(parameterizedType.getRawType());\n    for (Type type : parameterizedType.getActualTypeArguments()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(TypeVariable<?> typeVariable) {\n    registerTypeVariable(typeVariable);\n  }\n\n  private void registerTypeVariablesOn(WildcardType wildcardType) {\n    for (Type type : wildcardType.getLowerBounds()) {\n      registerTypeVariablesOn(type);\n    }\n    for (Type type : wildcardType.getUpperBounds()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable<?> typeVariable) {\n    typeVariables.put(typeVariable.getName(), typeVariable);\n  }\n}\n<|java|>/*\n * Copyright",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof Class) {\n      registerTypeVariablesOn((Class<?>) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable<?>) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Class<?> clazz) {\n    for (TypeVariable<?> typeVariable : clazz.getTypeParameters()) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType parameterizedType) {\n    registerTypeVariablesOn(parameterizedType.getRawType());\n    for (Type type : parameterizedType.getActualTypeArguments()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType genericArrayType) {\n    registerTypeVariablesOn(genericArrayType.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(TypeVariable<?> typeVariable) {\n    registerTypeVariable(typeVariable);\n  }\n\n  private void registerTypeVariablesOn(WildcardType wildcardType) {\n    for (Type type : wildcardType.getLowerBounds()) {\n      registerTypeVariablesOn(type);\n    }\n    for (Type type : wildcardType.getUpperBounds()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable<?> typeVariable) {\n    typeVariables.put(typeVariable.getName(), typeVariable);\n  }\n}\n<|java|>/*\n * Licensed",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof Class) {\n      registerTypeVariablesOn((Class<?>) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable<?>) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Class<?> clazz) {\n    for (TypeVariable<?> typeVariable : clazz.getTypeParameters()) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType genericArrayType) {\n    registerTypeVariablesOn(genericArrayType.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType parameterizedType) {\n    registerTypeVariablesOn(parameterizedType.getRawType());\n    for (Type type : parameterizedType.getActualTypeArguments()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(TypeVariable<?> typeVariable) {\n    registerTypeVariable(typeVariable);\n  }\n\n  private void registerTypeVariablesOn(WildcardType wildcardType) {\n    for (Type type : wildcardType.getLowerBounds()) {\n      registerTypeVariablesOn(type);\n    }\n    for (Type type : wildcardType.getUpperBounds()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable<?> typeVariable) {\n    if (!typeVariables.containsKey(typeVariable)) {\n      typeVariables.put(typeVariable, typeVariable.getBounds",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof Class) {\n      registerTypeVariablesOn((Class<?>) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable<?>) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Class<?> clazz) {\n    for (TypeVariable<?> typeVariable : clazz.getTypeParameters()) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType genericArrayType) {\n    registerTypeVariablesOn(genericArrayType.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType parameterizedType) {\n    registerTypeVariablesOn(parameterizedType.getRawType());\n    for (Type type : parameterizedType.getActualTypeArguments()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(TypeVariable<?> typeVariable) {\n    registerTypeVariable(typeVariable);\n  }\n\n  private void registerTypeVariablesOn(WildcardType wildcardType) {\n    for (Type type : wildcardType.getLowerBounds()) {\n      registerTypeVariablesOn(type);\n    }\n    for (Type type : wildcardType.getUpperBounds()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable<?> typeVariable) {\n    typeVariables.put(typeVariable.getName(), typeVariable);\n  }\n}\n<|java|>/*\n * Licensed",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof Class) {\n      registerTypeVariablesOn((Class<?>) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable<?>) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Class<?> clazz) {\n    for (TypeVariable<?> typeVariable : clazz.getTypeParameters()) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType parameterizedType) {\n    registerTypeVariablesOn(parameterizedType.getRawType());\n    for (Type type : parameterizedType.getActualTypeArguments()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType genericArrayType) {\n    registerTypeVariablesOn(genericArrayType.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(TypeVariable<?> typeVariable) {\n    registerTypeVariable(typeVariable);\n  }\n\n  private void registerTypeVariablesOn(WildcardType wildcardType) {\n    for (Type type : wildcardType.getLowerBounds()) {\n      registerTypeVariablesOn(type);\n    }\n    for (Type type : wildcardType.getUpperBounds()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable<?> typeVariable) {\n    typeVariables.put(typeVariable.getName(), typeVariable);\n  }\n}\n<|java|>package com.github",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof Class) {\n      registerTypeVariablesOn((Class<?>) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable<?>) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Class<?> clazz) {\n    for (TypeVariable<?> typeVariable : clazz.getTypeParameters()) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType parameterizedType) {\n    registerTypeVariablesOn(parameterizedType.getRawType());\n    for (Type type : parameterizedType.getActualTypeArguments()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType genericArrayType) {\n    registerTypeVariablesOn(genericArrayType.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(TypeVariable<?> typeVariable) {\n    registerTypeVariable(typeVariable);\n  }\n\n  private void registerTypeVariablesOn(WildcardType wildcardType) {\n    for (Type type : wildcardType.getLowerBounds()) {\n      registerTypeVariablesOn(type);\n    }\n    for (Type type : wildcardType.getUpperBounds()) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable<?> typeVariable) {\n    typeVariables.put(typeVariable.getName(), typeVariable);\n  }\n}\n<|java|>/*\n *  "
      ],
      "function range": "375,9-380,9"
    },
    "Mockito_8_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_79-80": {
      "loc": "79-80",
      "input": "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));",
      "output": [
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    Type[] upperBounds = wildcardType.getUpperBounds();\n    Type[] lowerBounds = wildcardType.getLowerBounds();\n    Type[] bounds = new Type[upperBounds.length + lowerBounds.length];\n    System.arraycopy(upperBounds, 0, bounds, 0, upperBounds.length);\n    System.arraycopy(lowerBounds, 0, bounds, upperBounds.length, lowerBounds.length);\n    return bounds;\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getClass().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(TypeVariable typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[] boundsOf(Class<?> classType)",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(TypeVariable typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getClass().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[] boundsOf(Class<?> classType)",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(TypeVariable typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[] boundsOf(Class<?> classType) {\n    ",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getClass().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[] boundsOf(TypeVariable typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Type[] boundsOf(Class<?> classType)",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[] boundsOf(TypeVariable typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Type[] boundsOf(Class<?> classType) {\n    ",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getClass().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(TypeVariable typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[] boundsOf(Class<?> clazz)",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(TypeVariable typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[] boundsOf(Class<?> clazz) {\n    ",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getClass().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[] boundsOf(TypeVariable typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Type[] boundsOf(Class<?> clazz)",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getClass().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[] boundsOf(TypeVariable<?> typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Type[] boundsOf(Class<?> class"
      ],
      "function range": "66,5-84,5"
    },
    "Mockito_22_/src/org/mockito/internal/matchers/Equality.java_13-14": {
      "loc": "13-14",
      "input": "public static boolean areEqual(Object o1, Object o2) {",
      "output": [
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            }\n            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            }\n            if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            }\n            if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            }\n            if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            }\n            if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            }\n            if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            }\n            if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            }\n            if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n        }\n        return false;\n    ",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == null && o2 == null) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            }\n            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            }\n            if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            }\n            if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            }\n            if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            }\n            if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            }\n            if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            }\n            if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            }\n            if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n        }\n        return",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            }\n            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            }\n            if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            }\n            if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            }\n            if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n            if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            }\n            if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            }\n            if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            }\n            if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            }\n        }\n        return false;\n    ",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            }\n            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            }\n            if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            }\n            if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            }\n            if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            }\n            if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            }\n            if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            }\n            if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            }\n            if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n            return false;\n        }\n        ",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == null && o2 == null) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            }\n            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            }\n            if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            }\n            if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            }\n            if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            }\n            if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            }\n            if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            }\n            if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            }\n            if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n            if (o1",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            }\n            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            }\n            if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            }\n            if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            }\n            if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            }\n            if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            }\n            if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            }\n            if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            }\n            if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n            return Arrays.equals((Object",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            }\n            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            }\n            if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            }\n            if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            }\n            if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            }\n            if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            }\n            if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            }\n            if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            }\n            if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n        }\n        if (o1 instance",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == null && o2 == null) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            }\n            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            }\n            if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            }\n            if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            }\n            if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            }\n            if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            }\n            if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            }\n            if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            }\n            if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n            return false;\n",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == null && o2 == null) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            }\n            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            }\n            if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            }\n            if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            }\n            if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            }\n            if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            }\n            if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            }\n            if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            }\n            if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n        }\n        if",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            }\n            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            }\n            if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            }\n            if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            }\n            if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            }\n            if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            }\n            if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            }\n            if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            }\n            if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n            if (o1 instanceof Object[]"
      ],
      "function range": "12,5-20,5"
    },
    "Mockito_24_/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java_76-77": {
      "loc": "76-77",
      "input": "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {",
      "output": [
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock1 = invocation.getArguments()[0];\n        Object mock2 = invocation.getArguments()[1];\n        MockName name1 = mockUtil.getMockName(mock1);\n        MockName name2 = mockUtil.getMockName(mock2);\n        if (name1.isDefault() && name2.isDefault()) {\n            return 0;\n        } else if (name1.isDefault()) {\n            return -1;\n        } else if (name2.isDefault()) {\n            return 1;\n        } else {\n            return name1.compareTo(name2);\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock1 = invocation.getArguments()[0];\n        Object mock2 = invocation.getArguments()[1];\n        MockName name1 = mockUtil.getMockName(mock1);\n        MockName name2 = mockUtil.getMockName(mock2);\n        if (name1.isDefault() && name2.isDefault()) {\n            return true;\n        } else if (name1.isDefault()) {\n            return false;\n        } else if (name2.isDefault()) {\n            return false;\n        } else {\n            return name1.equals(name2);\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock1 = invocation.getArguments()[0];\n        Object mock2 = invocation.getArguments()[1];\n        MockName name1 = mockUtil.getMockName(mock1);\n        MockName name2 = mockUtil.getMockName(mock2);\n        if (name1.isDefault()) {\n            return -1;\n        } else if (name2.isDefault()) {\n            return 1;\n        } else {\n            return name1.compareTo(name2);\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock1 = invocation.getArguments()[0];\n        Object mock2 = invocation.getArguments()[1];\n        MockName name1 = mockUtil.getMockName(mock1);\n        MockName name2 = mockUtil.getMockName(mock2);\n        if (name1.isDefault()) {\n            return false;\n        } else if (name2.isDefault()) {\n            return false;\n        } else {\n            return name1.equals(name2);\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.hashCode();\n        } else {\n",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    }\n    return null;\n  }",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return -1;\n        } else {\n            return name.toString().compareTo(invocation.getArguments()[0].toString());\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return false;\n        } else {\n            return name.toString().equals(invocation.getArguments()[0].toString());\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.hashCode();\n        } else {\n            return name.toString().hashCode();\n        }\n    } else if (methodsGuru.isToStringMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock1 = invocation.getArguments()[0];\n        Object mock2 = invocation.getArguments()[1];\n        MockName name1 = mockUtil.getMockName(mock1);\n        MockName name2 = mockUtil.getMockName(mock2);\n        if (name1.isDefault()) {\n            return -1;\n        } else if (name2.isDefault()) {\n            return 1;\n        } else {\n            return name1.compareTo(name2);\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock1 = invocation.getArguments()[0];\n        Object mock2 = invocation.getArguments()[1];\n        MockName name1 = mockUtil.getMockName(mock1);\n        MockName name2 = mockUtil.getMockName(mock2);\n        if (name1.isDefault()) {\n            return false;\n        } else if (name2.isDefault()) {\n            return true;\n        } else {\n            return name1.equals(name2);\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.hashCode();\n        } else {\n",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    }\n    return invocation.proceed();",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock1 = invocation.getArguments()[0];\n        Object mock2 = invocation.getArguments()[1];\n        MockName name1 = mockUtil.getMockName(mock1);\n        MockName name2 = mockUtil.getMockName(mock2);\n        if (name1.isDefault()) {\n            return -1;\n        } else if (name2.isDefault()) {\n            return 1;\n        } else {\n            return name1.compareTo(name2);\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock1 = invocation.getArguments()[0];\n        Object mock2 = invocation.getArguments()[1];\n        MockName name1 = mockUtil.getMockName(mock1);\n        MockName name2 = mockUtil.getMockName(mock2);\n        if (name1.isDefault() || name2.isDefault()) {\n            return false;\n        } else {\n            return name1.equals(name2);\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.hashCode();\n        } else {\n            return name.hashCode();\n        }\n",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock1 = invocation.getArguments()[0];\n        Object mock2 = invocation.getArguments()[1];\n        MockName name1 = mockUtil.getMockName(mock1);\n        MockName name2 = mockUtil.getMockName(mock2);\n        if (name1.isDefault() && name2.isDefault()) {\n            return 0;\n        } else if (name1.isDefault()) {\n            return -1;\n        } else if (name2.isDefault()) {\n            return 1;\n        } else {\n            return name1.compareTo(name2);\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock1 = invocation.getArguments()[0];\n        Object mock2 = invocation.getArguments()[1];\n        MockName name1 = mockUtil.getMockName(mock1);\n        MockName name2 = mockUtil.getMockName(mock2);\n        if (name1.isDefault() && name2.isDefault()) {\n            return true;\n        } else if (name1.isDefault() || name2.isDefault()) {\n            return false;\n        } else {\n            return name1.equals(name2);\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        Mock",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else {\n        return invocation.pro"
      ],
      "function range": "63,5-81,5"
    },
    "Mockito_27_/src/org/mockito/internal/util/MockUtil.java_64-66": {
      "loc": "64-66",
      "input": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);",
      "output": [
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.resetMock(mock);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.resetMock(mock);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.resetMock(mock);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.resetMock(mock);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.resetMock(mock);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.resetMock(mock);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.resetMock(mock);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.resetMock(mock);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyracks.al",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.resetMock(mock);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.resetMock(mock);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOper"
      ],
      "function range": "62,5-67,5"
    },
    "Mockito_28_/src/org/mockito/internal/configuration/DefaultInjectionEngine.java_93-94": {
      "loc": "93-94",
      "input": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {",
      "output": [
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      try {\n        field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = Lists.newArrayList(clazz.getDeclaredFields());\n    Collections.sort(fields, new Comparator<Field>() {\n      @Override\n      public int compare(Field f1, Field f2) {\n        return f1.getName().compareTo(f2.getName());\n      }\n    });\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.h",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      try {\n        field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = Lists.newArrayList(clazz.getDeclaredFields());\n    Collections.sort(fields, new Comparator<Field>() {\n      @Override\n      public int compare(Field o1, Field o2) {\n        return o1.getName().compareTo(o2.getName());\n      }\n    });\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.h",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      try {\n        field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = Lists.newArrayList(clazz.getDeclaredFields());\n    Collections.sort(fields, new Comparator<Field>() {\n      @Override\n      public int compare(Field f1, Field f2) {\n        return f1.getName().compareTo(f2.getName());\n      }\n    });\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOper",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      try {\n        field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = Lists.newArrayList(clazz.getDeclaredFields());\n    Collections.sort(fields, new Comparator<Field>() {\n      @Override\n      public int compare(Field o1, Field o2) {\n        return o1.getName().compareTo(o2.getName());\n      }\n    });\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOper",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      try {\n        field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = Lists.newArrayList(clazz.getDeclaredFields());\n    Collections.sort(fields, new Comparator<Field>() {\n      @Override\n      public int compare(Field f1, Field f2) {\n        return f1.getName().compareTo(f2.getName());\n      }\n    });\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      try {\n        field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = Lists.newArrayList(clazz.getDeclaredFields());\n    Collections.sort(fields, new Comparator<Field>() {\n      @Override\n      public int compare(Field o1, Field o2) {\n        return o1.getName().compareTo(o2.getName());\n      }\n    });\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      try {\n        field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = Lists.newArrayList(clazz.getDeclaredFields());\n    Collections.sort(fields, new Comparator<Field>() {\n      @Override\n      public int compare(Field f1, Field f2) {\n        return f1.getName().compareTo(f2.getName());\n      }\n    });\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      try {\n        field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = Lists.newArrayList(clazz.getDeclaredFields());\n    Collections.sort(fields, new Comparator<Field>() {\n      @Override\n      public int compare(Field o1, Field o2) {\n        return o1.getName().compareTo(o2.getName());\n      }\n    });\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      try {\n        field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = Lists.newArrayList(clazz.getDeclaredFields());\n    Collections.sort(fields, new Comparator<Field>() {\n      @Override\n      public int compare(Field f1, Field f2) {\n        return f1.getName().compareTo(f2.getName());\n      }\n    });\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      try {\n        field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = Lists.newArrayList(clazz.getDeclaredFields());\n    Collections.sort(fields, new Comparator<Field>() {\n      @Override\n      public int compare(Field f1, Field f2) {\n        return f1.getName().compareTo(f2.getName());\n      }\n    });\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExp"
      ],
      "function range": "91,5-95,5"
    },
    "Mockito_29_/src/org/mockito/internal/matchers/Same.java_29-30": {
      "loc": "29-30",
      "input": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);",
      "output": [
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  protected void describeMismatchSafely(Object item, Description description) {\n    description.appendText(\"was \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  protected void describeMismatchSafely(Object item, Description mismatchDescription) {\n    mismatchDescription.appendText(\"was \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  protected void describeMismatchSafely(Object item, Description description) {\n    description.appendText(\"was \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  private void appendQuoting",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  protected void describeMismatchSafely(Object item, Description mismatchDescription) {\n    mismatchDescription.appendText(\"was \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\")\");\n  }\n\n  private void appendQuoting(Description",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  protected void describeMismatchSafely(Object item, Description description) {\n    description.appendText(\"was \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n  }\n\n  private void appendQuoting(Description description) {\n    description.",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  protected void describeMismatchSafely(Object item, Description description) {\n    description.appendText(\"was \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  private static void appendQu",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  protected void describeMismatchSafely(Object item, Description mismatchDescription) {\n    mismatchDescription.appendText(\"was \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\")\");\n  }\n\n  private static void appendQuoting(",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  protected void describeMismatchSafely(Object item, Description description) {\n    description.appendText(\"was \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  protected",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  protected void describeMismatchSafely(Object item, Description mismatchDescription) {\n    mismatchDescription.appendText(\"was \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\", \");\n    appendQuoting(mismatchDescription);\n    mismatchDescription.appendText(\")\");\n  }\n\n  @Override\n  protected boolean matches",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  protected void describeMismatchSafely(Object item, Description description) {\n    description.appendText(\"was \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n  }\n\n  private void appendQuoting(Description description) {\n    if ("
      ],
      "function range": "26,5-32,5"
    },
    "Mockito_34_/src/org/mockito/internal/invocation/InvocationMatcher.java_106-107": {
      "loc": "106-107",
      "input": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {",
      "output": [
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.oper",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.alge",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractBinaryJoinOperator;\nimport",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\n",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnn"
      ],
      "function range": "103,5-111,5"
    },
    "Mockito_38_/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java_48-49": {
      "loc": "48-49",
      "input": "private boolean toStringEquals(Matcher m, Object arg) {",
      "output": [
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.log",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyr",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport org.apache.hyracks.",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\n",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AggregateOperator;\nimport org.apache.hyracks.al",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractBinaryJoinOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators."
      ],
      "function range": "47,5-49,5"
    },
    "Time_4_/src/main/java/org/joda/time/Partial.java_464-465": {
      "loc": "464-465",
      "input": "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);",
      "output": [
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n    } else {\n        int[] newValues = new int[iValues.length];\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newValues[index]",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n    } else if (value!= iValues[index]) {\n        int[] newValues = new int[iValues.length];\n        System.arraycopy(iValues, 0, newValues, 0,",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n    } else if (iValues[index]!= value) {\n        int[] newValues = new int[iValues.length];\n        System.arraycopy(iValues, 0, newValues, 0",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n    } else {\n        int[] newValues = new int[iValues.length];\n        System.arraycopy(iValues, 0, newValues, 0, iValues.length);\n        newValues",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n    } else {\n        iTypes[index] = fieldType;\n        iValues[index] = value;\n    }\n    return this;\n  }\n\n  //-----------------------------------------------------------------------\n  /**\n",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n        i = i + 1;\n    }\n    iTypes[index] = fieldType;\n    iValues[index] = value;\n    return this;\n  }\n\n  //-----------------------------------------------------------------------\n",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n        i = i + 1;\n    }\n    iTypes[index] = fieldType;\n    iValues[index] = value;\n    return this;\n  }\n\n  /**\n   *",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n    } else {\n        iValues[index] = value;\n    }\n    return this;\n  }\n\n  //-----------------------------------------------------------------------\n  /**\n   * Gets the value of the field at the specified",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n    } else {\n        iValues[index] = value;\n    }\n    return new Partial(iTypes, iValues, iChronology);\n  }\n\n  /**\n   * Gets a",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n    } else {\n        iValues[index] = value;\n    }\n    return this;\n  }\n\n  //-----------------------------------------------------------------------\n  /**\n   * Gets the value of the field at the spec"
      ],
      "function range": "426,5-474,5"
    },
    "Time_15_/src/main/java/org/joda/time/field/FieldUtils.java_138-139": {
      "loc": "138-139",
      "input": "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:",
      "output": [
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n            return 0;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        case 33:\n            return val1 << 32;\n        case 34:\n            return val1 << 33;\n        case 35:\n            return val1 << 34;\n        case 36:\n            return val1 << 35;",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n            return 0;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 * val1;\n        case 3:\n            return val1 * val1 * val1;\n        case 4:\n            return val1 * val1 * val1 * val1;\n        case 5:\n            return val1 * val1 * val1 * val1 * val1;\n        case 6:\n            return val1 * val1 * val1 * val1 * val1 * val1;\n        case 7:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 8:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 9:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 10:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 11:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 12:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 13:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 14:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 15:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n            return -val1;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        case 33:\n            return val1 << 32;\n        case 34:\n            return val1 << 33;\n        case 35:\n            return val1 << 34;\n        case 36:\n            return val1 <<",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n            return 0;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        default:\n            return val1 * val2;\n    }\n}\n\npublic static long safeMultiply(long val1, long val2) {\n    switch (val2) {\n        case -1:\n",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n            return 0;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        case 33:\n            return val1 << 32;\n        case 34:\n            return val1 << 33;\n        case 35:\n            return val1 << 34;\n        default:\n            return val1 * val2;",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n            return 0;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        case 33:\n            return val1 << 32;\n        case 34:\n            return val1 << 33;\n        case 35:\n            return val1 << 34;\n    }\n    return val1 * val2;\n",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n            return 0;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        case 33:\n            return val1 << 32;\n        case 34:\n            return val1 << 33;\n        case 35:\n            return val1 << 34;\n        default:\n            return val1 << val2;",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n            return -val1;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        case 33:\n            return val1 << 32;\n        case 34:\n            return val1 << 33;\n        case 35:\n            return val1 << 34;\n    }\n    return val1 * val2",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n            return -val1;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        case 33:\n            return val1 << 32;\n        case 34:\n            return val1 << 33;\n        case 35:\n            return val1 << 34;\n        default:\n            return val1 * val",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n            return -val1;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        case 33:\n            return val1 << 32;\n        case 34:\n            return val1 << 33;\n        case 35:\n            return val1 << 34;\n        default:\n            return val1 << val"
      ],
      "function range": "135,5-149,5"
    },
    "Time_16_/src/main/java/org/joda/time/format/DateTimeFormatter.java_709-710": {
      "loc": "709-710",
      "input": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(",
      "output": [
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    instant.setMillis(instantLocal + chrono.getZone().getOffset(instantLocal));\n    return position + bucket.getText().length();\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (date == null) {\n        throw new IllegalArgumentException(\"DateTime must not be null\");\n    }\n    long instantMillis = date.getMillis();\n    Chronology chrono = date.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    date.setMillis(instantLocal + chrono.getZone().getOffset(instantLocal));\n",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    instant.setMillis(instantLocal - chrono.getZone().getOffset(instantLocal));\n    return position + bucket.getText().length();\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (date == null) {\n        throw new IllegalArgumentException(\"DateTime must not be null\");\n    }\n    long instantMillis = date.getMillis();\n    Chronology chrono = date.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    date.setMillis(instantLocal - chrono.getZone().getOffset(instantLocal));\n",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    instant.setMillis(instantLocal - chrono.getZone().getOffset(instantLocal));\n    return position + bucket.getText().length();\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (date == null) {\n        throw new IllegalArgumentException(\"DateTime must not be null\");\n    }\n    long instantMillis = date.getMillis();\n    Chronology chrono = date.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    instantMillis = instantLocal - chrono.getZone().getOffset(instantLocal);\n    date",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    instant.setMillis(instantLocal + chrono.getZone().getOffset(instantLocal));\n    return position + bucket.getText().length();\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (date == null) {\n        throw new IllegalArgumentException(\"DateTime must not be null\");\n    }\n    Chronology chrono = selectChronology(date.getChronology());\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    long instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    date.setMillis(instantLocal + chrono.getZone().getOffset(instantLocal));\n    return position + bucket.getText().length();\n  }\n\n  @Override\n  public int parseInto(ReadWritablePeriod period, String text, int position) {\n    DateTimeParser",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    instant.setMillis(instantLocal + chrono.getZone().getOffset(instantLocal));\n    return position + bucket.getText().length();\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(date.getChronology());\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    long instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    date.setMillis(instantLocal + chrono.getZone().getOffset(instantLocal));\n    return position + bucket.getText().length();\n  }\n\n  @Override\n  public int parseInto(ReadWritablePeriod period, String text, int position) {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(period.getChronology());\n    Date",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    instant.setMillis(instantLocal + chrono.getZone().getOffset(instantLocal));\n    return position + bucket.getText().length();\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (date == null) {\n        throw new IllegalArgumentException(\"DateTime must not be null\");\n    }\n    long instantMillis = date.getMillis();\n    Chronology chrono = date.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    instantMillis = instantLocal + chrono.getZone().getOffset(instantLocal);\n    date",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    instant.setMillis(instantLocal - chrono.getZone().getOffset(instantLocal));\n    return position + bucket.getText().length();\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (date == null) {\n        throw new IllegalArgumentException(\"DateTime must not be null\");\n    }\n    long instantMillis = date.getMillis();\n    Chronology chrono = date.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    instantMillis = instantLocal - chrono.getZone().getOffset(instantMillis);\n    ",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    instant.setMillis(instantLocal - chrono.getZone().getOffset(instantLocal));\n    return position + bucket.getText().length();\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (date == null) {\n        throw new IllegalArgumentException(\"DateTime must not be null\");\n    }\n    Chronology chrono = selectChronology(date.getChronology());\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    long instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    date.setMillis(instantLocal - chrono.getZone().getOffset(instantLocal));\n    return position + bucket.getText().length();\n  }\n\n  @Override\n  public int parseInto(ReadWritablePeriod period, String text, int position) {\n    DateTimeParser",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    instant.setMillis(instantLocal - chrono.getZone().getOffset(instantLocal));\n    return position + bucket.getText().length();\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (date == null) {\n        throw new IllegalArgumentException(\"DateTime must not be null\");\n    }\n    long instantMillis = date.getMillis();\n    Chronology chrono = date.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    date.setMillis(instantLocal);\n    return position + bucket.getText().length();\n  ",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    instant.setMillis(instantLocal - chrono.getZone().getOffset(instantLocal));\n    return position + bucket.getText().length();\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (date == null) {\n        throw new IllegalArgumentException(\"DateTime must not be null\");\n    }\n    Chronology chrono = selectChronology(date.getChronology());\n    DateTimeParserBucket bucket = new DateTimeParserBucket(this, text, position, chrono);\n    if (parser.parseInto(bucket, text, position) == ~position) {\n        return ~position;\n    }\n    long instantLocal = bucket.computeMillis(0, text);\n    if (instantLocal == Long.MIN_VALUE) {\n        return ~position;\n    }\n    long instantMillis = instantLocal - chrono.getZone().getOffset(instantLocal);\n    date.setMillis(instantMillis);\n    return position + bucket.getText().length();\n  }\n\n  @Override\n  public int parseInto(ReadWritablePeriod period, String"
      ],
      "function range": "697,5-724,5"
    },
    "Time_19_/src/main/java/org/joda/time/DateTimeZone.java_900-901": {
      "loc": "900-901",
      "input": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal != offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }",
      "output": [
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      index++;\n    }\n    return standardOffsets[index];\n  }\n\n  /**\n   * Gets the amount of daylight savings in use for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    if (index == 0) {\n      return standardOffsets[0];\n    }\n    long trans = savingsInstantTransitions[index - 1];\n    ZoneOffset offset = null;\n    ",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    if (index == 0) {\n      return standardOffsets[0];\n    }\n    long trans = savingsInstantTransitions[index - 1];\n    ZoneOffset offsetBefore = standardOffsets",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    if (index == 0) {\n      return standardOffsets[0];\n    }\n    long trans = savingsInstantTransitions[index - 1];\n    ZoneOffset offset = standardOffsets[",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    if (index == 0) {\n      return standardOffsets[0];\n    }\n    long trans = savingsInstantTransitions[index - 1];\n    ZoneOffset offsetBefore = standardOffsets[",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   * @throws IllegalArgumentException if the instant is invalid\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    if (index == 0) {\n      return standardOffsets[0];\n    }\n    long trans = savingsInstantTransitions",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    // inline for performance\n    if (index < savingsInstantTransitions.length) {\n      return standardOffsets[index + 1];\n    }\n    if (index == savingsInstantTransitions.",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    if (index == 0) {\n      return standardOffsets[0];\n    }\n    long trans = savingsInstantTransitions[index - 1];\n    ZoneOffset offset = ZoneOffset.of",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    // inline for performance\n    if (index < savingsInstantTransitions.length) {\n      return standardOffsets[index + 1];\n    }\n    // inline for performance\n    if (index",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    if (index == 0) {\n      return standardOffsets[0];\n    }\n    long trans = savingsInstantTransitions[index - 1];\n    ZoneOffset offset = ZoneOffsetTransition"
      ],
      "function range": "880,5-911,5"
    }
  }
}