{
  "config": "CODEGEN_COMPLETE_CODEFORM_NOCOMMENT",
  "model": "codegen-2B-multi",
  "data": {
    "Chart_14_source/org/jfree/chart/plot/CategoryPlot.java_2166-2167": {
      "loc": "2166-2167",
      "input": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }",
      "output": [
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n  }\n\n  /**\n   * Removes all domain markers for the specified layer and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   *\n   * @param layer  the layer (<code>null</code> not permitted).\n   */\n  public void removeDomainMarkers(Layer layer) {\n    if (layer == null) {\n        throw new IllegalArgumentException(\"Null 'layer' argument.\");\n    }\n    Collection markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = this.foregroundDomainMarkers.values();\n        this.foregroundDomainMarkers.clear();\n    }\n    else {\n        markers = this.backgroundDomainMarkers.values();\n        this.backgroundDomainMarkers.clear();\n    }\n    Iterator iterator = markers.iterator();\n    while (iterator.hasNext()) {\n        Marker m = (Marker) iterator.next();\n        m.removeChangeListener(this);\n    }\n    fireChangeEvent();\n  }\n\n  /**\n   * Clears all the domain markers for the plot and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   */\n  public void clearDomainMarkers() {\n    if (this.backgroundDomainMarkers!= null) {\n        Set keys = this.backgroundDomainMarkers.keySet();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Integer key = (Integer) iterator.next();\n            clearDomainMarkers(key.int",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n  }\n\n  /**\n   * Removes all domain markers for the specified layer and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   *\n   * @param layer  the layer (<code>null</code> not permitted).\n   */\n  public void removeDomainMarkers(Layer layer) {\n    if (layer == null) {\n        throw new IllegalArgumentException(\"Null 'layer' argument.\");\n    }\n    Collection markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = this.foregroundDomainMarkers.values();\n        this.foregroundDomainMarkers.clear();\n    }\n    else {\n        markers = this.backgroundDomainMarkers.values();\n        this.backgroundDomainMarkers.clear();\n    }\n    Iterator iterator = markers.iterator();\n    while (iterator.hasNext()) {\n        Marker m = (Marker) iterator.next();\n        m.removeChangeListener(this);\n    }\n    fireChangeEvent();\n  }\n\n  /**\n   * Clears all the domain markers for the plot and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   */\n  public void clearDomainMarkers() {\n    if (this.backgroundDomainMarkers!= null) {\n        Set keys = this.backgroundDomainMarkers.keySet();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Object key = iterator.next();\n            clearDomainMarkers(key);\n        }\n",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n  }\n\n  /**\n   * Removes all domain markers for the specified layer and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   *\n   * @param layer  the layer (<code>null</code> not permitted).\n   */\n  public void removeDomainMarkers(Layer layer) {\n    if (layer == null) {\n        throw new IllegalArgumentException(\"Null 'layer' argument.\");\n    }\n    Collection markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = this.foregroundDomainMarkers.values();\n        this.foregroundDomainMarkers.clear();\n    }\n    else {\n        markers = this.backgroundDomainMarkers.values();\n        this.backgroundDomainMarkers.clear();\n    }\n    Iterator iterator = markers.iterator();\n    while (iterator.hasNext()) {\n        Marker m = (Marker) iterator.next();\n        m.removeChangeListener(this);\n    }\n    fireChangeEvent();\n  }\n\n  /**\n   * Clears all the domain markers for the plot and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   */\n  public void clearDomainMarkers() {\n    if (this.backgroundDomainMarkers!= null) {\n        Set keys = this.backgroundDomainMarkers.keySet();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Integer key = (Integer) iterator.next();\n            removeDomainMarker(key.int",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n  }\n\n  /**\n   * Removes all domain markers for the specified layer and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   *\n   * @param layer  the layer (<code>null</code> not permitted).\n   */\n  public void removeDomainMarkers(Layer layer) {\n    if (layer == null) {\n        throw new IllegalArgumentException(\"Null 'layer' argument.\");\n    }\n    Collection markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = this.foregroundDomainMarkers.values();\n        this.foregroundDomainMarkers.clear();\n    }\n    else {\n        markers = this.backgroundDomainMarkers.values();\n        this.backgroundDomainMarkers.clear();\n    }\n    Iterator iterator = markers.iterator();\n    while (iterator.hasNext()) {\n        Marker m = (Marker) iterator.next();\n        m.removeChangeListener(this);\n    }\n    fireChangeEvent();\n  }\n\n  /**\n   * Clears all the domain markers.\n   */\n  public void clearDomainMarkers() {\n    if (this.backgroundDomainMarkers!= null) {\n        this.backgroundDomainMarkers.clear();\n    }\n    if (this.foregroundDomainMarkers!= null) {\n        this.foregroundDomainMarkers.clear();\n    }\n    fireChangeEvent();\n  }\n\n  /**\n   * Adds a marker change listener.\n   *\n   * @param listener  the listener",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n  }\n\n  /**\n   * Removes all domain markers for the specified layer and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   *\n   * @param layer  the layer (<code>null</code> not permitted).\n   */\n  public void removeDomainMarkers(Layer layer) {\n    if (layer == null) {\n      throw new IllegalArgumentException(\"Null 'layer' argument.\");\n    }\n    Collection markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = this.foregroundDomainMarkers.values();\n        this.foregroundDomainMarkers.clear();\n    }\n    else {\n        markers = this.backgroundDomainMarkers.values();\n        this.backgroundDomainMarkers.clear();\n    }\n    Iterator iterator = markers.iterator();\n    while (iterator.hasNext()) {\n      Marker m = (Marker) iterator.next();\n      m.removeChangeListener(this);\n    }\n    fireChangeEvent();\n  }\n\n  /**\n   * Clears all the domain markers for the plot and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   */\n  public void clearDomainMarkers() {\n    if (this.backgroundDomainMarkers!= null) {\n        Set keys = this.backgroundDomainMarkers.keySet();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Object key = iterator.next();\n            clearDomainMarkers(key);\n        }\n",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n  }\n\n  /**\n   * Removes all domain markers for the specified layer and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   *\n   * @param layer  the layer (<code>null</code> not permitted).\n   */\n  public void removeDomainMarkers(Layer layer) {\n    if (layer == null) {\n        throw new IllegalArgumentException(\"Null 'layer' argument.\");\n    }\n    Collection markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = this.foregroundDomainMarkers.values();\n        this.foregroundDomainMarkers.clear();\n    }\n    else {\n        markers = this.backgroundDomainMarkers.values();\n        this.backgroundDomainMarkers.clear();\n    }\n    markers.clear();\n    fireChangeEvent();\n  }\n\n  /**\n   * Clears all the domain markers for the plot and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   */\n  public void clearDomainMarkers() {\n    if (this.backgroundDomainMarkers!= null) {\n        this.backgroundDomainMarkers.clear();\n    }\n    if (this.foregroundDomainMarkers!= null) {\n        this.foregroundDomainMarkers.clear();\n    }\n    fireChangeEvent();\n  }\n\n  /**\n   * Adds a marker for display (in the foreground) against the range axis and\n   * sends a {@link MarkerChangeEvent} to all registered listeners.\n   *",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n  }\n\n  /**\n   * Removes all domain markers for the specified layer and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   *\n   * @param layer  the layer (<code>null</code> not permitted).\n   */\n  public void removeDomainMarkers(Layer layer) {\n    if (layer == null) {\n        throw new IllegalArgumentException(\"Null 'layer' argument.\");\n    }\n    Collection markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = this.foregroundDomainMarkers.values();\n        this.foregroundDomainMarkers.clear();\n    }\n    else {\n        markers = this.backgroundDomainMarkers.values();\n        this.backgroundDomainMarkers.clear();\n    }\n    Iterator iterator = markers.iterator();\n    while (iterator.hasNext()) {\n        Marker m = (Marker) iterator.next();\n        m.removeChangeListener(this);\n    }\n    fireChangeEvent();\n  }\n\n  /**\n   * Clears all the domain markers for the plot and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   */\n  public void clearDomainMarkers() {\n    if (this.backgroundDomainMarkers.size() > 0\n            || this.foregroundDomainMarkers.size() > 0) {\n        this.backgroundDomainMarkers.clear();\n        this.foregroundDomainMarkers.clear();\n        fireChangeEvent();\n    }\n  }\n\n  /**",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n  }\n\n  /**\n   * Removes all domain markers for the specified layer and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   *\n   * @param layer  the layer (<code>null</code> not permitted).\n   */\n  public void removeDomainMarkers(Layer layer) {\n    if (layer == null) {\n        throw new IllegalArgumentException(\"Null 'layer' argument.\");\n    }\n    Collection markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = this.foregroundDomainMarkers.values();\n        this.foregroundDomainMarkers.clear();\n    }\n    else {\n        markers = this.backgroundDomainMarkers.values();\n        this.backgroundDomainMarkers.clear();\n    }\n    Iterator iterator = markers.iterator();\n    while (iterator.hasNext()) {\n        Marker m = (Marker) iterator.next();\n        m.removeChangeListener(this);\n    }\n    fireChangeEvent();\n  }\n\n  /**\n   * Clears all the domain markers for the plot and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   */\n  public void clearDomainMarkers() {\n    if (this.backgroundDomainMarkers.size() > 0) {\n        this.backgroundDomainMarkers.clear();\n    }\n    if (this.foregroundDomainMarkers.size() > 0) {\n        this.foregroundDomainMarkers.clear();\n    }\n    fireChangeEvent();",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n  }\n\n  /**\n   * Removes all domain markers for the specified layer and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   *\n   * @param layer  the layer (<code>null</code> not permitted).\n   */\n  public void removeDomainMarkers(Layer layer) {\n    if (layer == null) {\n        throw new IllegalArgumentException(\"Null 'layer' argument.\");\n    }\n    Collection markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = this.foregroundDomainMarkers.values();\n        this.foregroundDomainMarkers.clear();\n    }\n    else {\n        markers = this.backgroundDomainMarkers.values();\n        this.backgroundDomainMarkers.clear();\n    }\n    Iterator iterator = markers.iterator();\n    while (iterator.hasNext()) {\n        Marker m = (Marker) iterator.next();\n        m.removeChangeListener(this);\n    }\n    fireChangeEvent();\n  }\n\n  /**\n   * Clears all the domain markers for the plot and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   */\n  public void clearDomainMarkers() {\n    if (this.backgroundDomainMarkers!= null) {\n        Set keys = this.backgroundDomainMarkers.keySet();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Object key = iterator.next();\n            Collection markers = (Collection) this.backgroundDomainMark",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n        return false;\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n  }\n\n  /**\n   * Removes all domain markers for the specified layer and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   *\n   * @param layer  the layer (<code>null</code> not permitted).\n   */\n  public void removeDomainMarkers(Layer layer) {\n    if (layer == null) {\n        throw new IllegalArgumentException(\"Null 'layer' argument.\");\n    }\n    Collection markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = this.foregroundDomainMarkers.values();\n        this.foregroundDomainMarkers.clear();\n    }\n    else {\n        markers = this.backgroundDomainMarkers.values();\n        this.backgroundDomainMarkers.clear();\n    }\n    markers.clear();\n    fireChangeEvent();\n  }\n\n  /**\n   * Clears all the domain markers for the plot and sends a\n   * {@link MarkerChangeEvent} to all registered listeners.\n   */\n  public void clearDomainMarkers() {\n    if (this.backgroundDomainMarkers!= null) {\n        this.backgroundDomainMarkers.clear();\n    }\n    if (this.foregroundDomainMarkers!= null) {\n        this.foregroundDomainMarkers.clear();\n    }\n    fireChangeEvent();\n  }\n\n  /**\n   * Adds a marker for display (in the foreground) against the range axis and\n   * sends a {@link MarkerChangeEvent} to all registered listeners.  The\n"
      ],
      "function range": "2155,5-2171,5"
    },
    "Closure_40_src/com/google/javascript/jscomp/NameAnalyzer.java_635-636": {
      "loc": "635-636",
      "input": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns != null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns != null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null && ns.onlyAffectsClassDef) {",
      "output": [
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(nameNode.getString(), true);\n      refNodes.add(new ClassDefiningFunctionNode(name, n));\n    }\n  }\n}\n\n  /**\n   * Records the assignment of a value to a global name.\n   *\n   * @param name Fully qualified name\n   * @param node The top node representing the name\n   */\n  private void recordSet(String name, Node node) {\n    JsName jsn =",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(nameNode.getString(), true);\n      refNodes.add(new ClassDefiningFunctionNode(name, n));\n    }\n  }\n}\n\n  /**\n   * Records the assignment of a value to a global name.\n   *\n   * @param name Fully qualified name\n   * @param node The top node representing the name (GETPROP, NAME, or STRING\n   * [objlit key])\n   */\n  private",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, false);\n      if (name!= null) {\n        refNodes.add(new ClassDefiningFunctionNode(name, n));\n      }\n    }\n  }\n}\n\n  /**\n   * Records the assignment of a value to a global name.\n   *\n   * @param name Fully qualified name\n   * @param node The top node representing the name\n   */\n  private void recordSet(String name, Node",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, false);\n      if (name!= null) {\n        refNodes.add(new ClassDefiningFunctionNode(name, n));\n      }\n    }\n  } else if (n.isNew()) {\n    Node callee = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, callee, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, false);\n      if (name!= null) {\n        refNodes.add(new ClassDefiningFunctionNode(name, n));\n      }\n    }\n  } else if (n.isNew() || n.isFunction()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      recordSet",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, false);\n      if (name!= null) {\n        refNodes.add(new ClassDefiningFunctionNode(name, n));\n      }\n    }\n  } else if (n.isNew() || n.isFunction()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffect",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, false);\n      if (name!= null) {\n        refNodes.add(new ClassDefiningFunctionNode(name, n));\n      }\n    }\n  }\n}\n\n  /**\n   * Records the assignment of a value to a global name.\n   *\n   * @param name Fully qualified name\n   * @param node The top node representing the name (GETPROP, NAME, or STRING\n   * [",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(nameNode.getString(), true);\n      refNodes.add(new ClassDefiningFunctionNode(name, n));\n    }\n  }\n}\n\n  private void recordPrototypeSet(String className, String propName,\n      Node n) {\n    JsName name = getName(className, true);\n    name.prototypeNames.add(new Property(propName, n));\n  }\n\n  private void recordSet(String",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(nameNode.getString(), true);\n      refNodes.add(new ClassDefiningFunctionNode(name, n));\n    }\n  }\n}\n\n  private void recordPrototypeSet(\n      String className, String prototypeProperty, Node n) {\n    JsName name = getName(className, true);\n    name.prototypeNames.add(new Property(prototypeProperty, n));\n  }\n\n  private void recordSet(String",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, false);\n      if (name!= null) {\n        refNodes.add(new ClassDefiningFunctionNode(name, n));\n      }\n    }\n  } else if (n.isNew()) {\n    Node callee = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, callee, n);\n    if (ns!= null) {\n      refNodes.add(new Called"
      ],
      "function range": "595,5-642,5"
    },
    "Closure_46_src/com/google/javascript/rhino/jstype/RecordType.java_142-145": {
      "loc": "142-145",
      "input": "@Override\npublic JSType getLeastSupertype(JSType that) {",
      "output": [
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    return getCommonLeastSupertype(this, that);\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    return getCommonGreatestSubtype(this, that);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.TRUE;\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public String toDebugHashCodeString() {\n    return \"NoType\";\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    return getCommonLeastSupertype(this, that);\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    return getCommonGreatestSubtype(this, that);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.TRUE;\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public String toDebugHashCodeString() {\n    return \"NoType\";\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    return getCommonLeastSupertype(this, that);\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    return getCommonGreatestSubtype(this, that);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.EMPTY;\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public String toDebugHashCodeString() {\n    return \"NoType\";\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    return getCommonLeastSupertype(this, that);\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    return getCommonGreatestSubtype(this, that);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.EMPTY;\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public String toDebugHashCodeString() {\n    return \"NoType\";\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    return getCommonLeastSupertype(this, that);\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    return getCommonGreatestSubtype(this, that);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.TRUE;\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public String toDebugHashCodeString() {\n    return \"NoType\";\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    return getCommonLeastSupertype(this, that);\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    return getCommonGreatestSubtype(this, that);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.TRUE;\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public String toDebugHashCodeString() {\n    return \"NoType\";\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    return getCommonLeastSupertype(this, that);\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    return getCommonGreatestSubtype(this, that);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.TRUE;\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public String toDebugHashCodeString() {\n    return \"NoType\";\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public String toString() {\n    return \"NoType\";\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\");",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    return getCommonLeastSupertype(this, that);\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    return getCommonGreatestSubtype(this, that);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.TRUE;\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public String toDebugHashCodeString() {\n    return \"NoType\";\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    return getCommonLeastSupertype(this, that);\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    return getCommonGreatestSubtype(this, that);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.EMPTY;\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public String toDebugHashCodeString() {\n    return \"NoType\";\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n    return getCommonLeastSupertype(this, that);\n  }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n    return getCommonGreatestSubtype(this, that);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.TRUE;\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public String toDebugHashCodeString() {\n    return \"NoType\";\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoType(that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public String toString() {\n    return \"NoType\";\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.EMPTY;\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoType();\n  }\n\n  @Override\n  "
      ],
      "function range": "140,3-155,3"
    },
    "Closure_77_src/com/google/javascript/jscomp/CodeGenerator.java_967-967": {
      "loc": "967-967",
      "input": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;",
      "output": [
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\0': sb.append(\"\\\\000\"); break;\n      case '\\1': sb.append(\"\\\\001\"); break;\n      case '\\2': sb.append(\"\\\\002\"); break;\n      case '\\3': sb.append(\"\\\\003\"); break;\n      case '\\4': sb.append(\"\\\\004\"); break;\n      case '\\5': sb.append(\"\\\\005\"); break;\n      case '\\6': sb.append(\"\\\\006\"); break;\n      case '\\7': sb.append(\"\\\\007\"); break;\n      default:\n        if (outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          // Unicode-escape the character.\n          appendHexJavaScriptRepresentation(sb, c);\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\nprivate static void appendHexJavaScriptRepresentation(\n    StringBuilder sb, char c) {\n  appendHexJavaScriptRepresentation(",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\"':  sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '<':  sb.append(\"\\\\u003c\"); break;\n      case '>':  sb.append(\"\\\\u003e\"); break;\n      case '&':  sb.append(\"\\\\u0026\"); break;\n      case '=':  sb.append(\"\\\\u003d\"); break;\n      case '{':  sb.append(\"\\\\u007b\"); break;\n      case '}':  sb.append(\"\\\\u007d\"); break;\n      case '[':  sb.append(\"\\\\u005b\"); break;\n      case ']':  sb.append(\"\\\\u005d\"); break;\n      case '#############################################################################################################",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\"':  sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '<':  sb.append(\"\\\\u003c\"); break;\n      case '>':  sb.append(\"\\\\u003e\"); break;\n      case '&':  sb.append(\"\\\\u0026\"); break;\n      case '=':  sb.append(\"\\\\u003d\"); break;\n      case '?':  sb.append(\"\\\\u003f\"); break;\n      case '##################################################################################################################################################################",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\0': sb.append(\"\\\\000\"); break;\n      case '\\1': sb.append(\"\\\\001\"); break;\n      case '\\2': sb.append(\"\\\\002\"); break;\n      case '\\3': sb.append(\"\\\\003\"); break;\n      case '\\4': sb.append(\"\\\\004\"); break;\n      case '\\5': sb.append(\"\\\\005\"); break;\n      case '\\6': sb.append(\"\\\\006\"); break;\n      case '\\7': sb.append(\"\\\\007\"); break;\n      default:\n        if (outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          // Unicode-escape the character.\n          appendHexJavaScriptRepresentation(sb, c);\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\nprivate static void appendHexJavaScriptRepresentation(\n    StringBuilder sb, char c) {\n  sb.append(\"\\\\u\");\n",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\0': sb.append(\"\\\\000\"); break;\n      case '\\1': sb.append(\"\\\\001\"); break;\n      case '\\2': sb.append(\"\\\\002\"); break;\n      case '\\3': sb.append(\"\\\\003\"); break;\n      case '\\4': sb.append(\"\\\\004\"); break;\n      case '\\5': sb.append(\"\\\\005\"); break;\n      case '\\6': sb.append(\"\\\\006\"); break;\n      case '\\7': sb.append(\"\\\\007\"); break;\n      default:\n        if (outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          // Unicode-escape the character.\n          appendHexJavaScriptRepresentation(sb, c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\nprivate static void appendHexJavaScriptRepresentation(\n    StringBuilder sb, char c) {\n  appendHexJava",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\0': sb.append(\"\\\\000\"); break;\n      case '\\1': sb.append(\"\\\\001\"); break;\n      case '\\2': sb.append(\"\\\\002\"); break;\n      case '\\3': sb.append(\"\\\\003\"); break;\n      case '\\4': sb.append(\"\\\\004\"); break;\n      case '\\5': sb.append(\"\\\\005\"); break;\n      case '\\6': sb.append(\"\\\\006\"); break;\n      case '\\7': sb.append(\"\\\\007\"); break;\n      default:\n        if (outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          // Unicode-escape the character.\n          appendHexJavaScriptRepresentation(sb, c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\nstatic void appendHexJavaScriptRepresentation(StringBuilder sb, char c) {\n  appendHexJavaScriptRepresentation",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\0': sb.append(\"\\\\000\"); break;\n      case '\\1': sb.append(\"\\\\001\"); break;\n      case '\\2': sb.append(\"\\\\002\"); break;\n      case '\\3': sb.append(\"\\\\003\"); break;\n      case '\\4': sb.append(\"\\\\004\"); break;\n      case '\\5': sb.append(\"\\\\005\"); break;\n      case '\\6': sb.append(\"\\\\006\"); break;\n      case '\\7': sb.append(\"\\\\007\"); break;\n      default:\n        if (outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          // Unicode-escape the character.\n          appendHexJavaScriptRepresentation(sb, c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\nstatic void appendHexJavaScriptRepresentation(\n    StringBuilder sb, char c) {\n  appendHexJavaScript",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\0': sb.append(\"\\\\000\"); break;\n      case '\\1': sb.append(\"\\\\001\"); break;\n      case '\\2': sb.append(\"\\\\002\"); break;\n      case '\\3': sb.append(\"\\\\003\"); break;\n      case '\\4': sb.append(\"\\\\004\"); break;\n      case '\\5': sb.append(\"\\\\005\"); break;\n      case '\\6': sb.append(\"\\\\006\"); break;\n      case '\\7': sb.append(\"\\\\007\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      default:\n        if (outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\0': sb.append(\"\\\\000\"); break;\n      case '\\1': sb.append(\"\\\\001\"); break;\n      case '\\2': sb.append(\"\\\\002\"); break;\n      case '\\3': sb.append(\"\\\\003\"); break;\n      case '\\4': sb.append(\"\\\\004\"); break;\n      case '\\5': sb.append(\"\\\\005\"); break;\n      case '\\6': sb.append(\"\\\\006\"); break;\n      case '\\7': sb.append(\"\\\\007\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      default:\n        if (outputCharsetEncoder!= null) {\n          CharBuffer cb = outputCharsetEncoder.encode(",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\0': sb.append(\"\\\\000\"); break;\n      case '\\1': sb.append(\"\\\\001\"); break;\n      case '\\2': sb.append(\"\\\\002\"); break;\n      case '\\3': sb.append(\"\\\\003\"); break;\n      case '\\4': sb.append(\"\\\\004\"); break;\n      case '\\5': sb.append(\"\\\\005\"); break;\n      case '\\6': sb.append(\"\\\\006\"); break;\n      case '\\7': sb.append(\"\\\\007\"); break;\n      default:\n        if (outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          // Unicode-escape the character.\n          appendHexJavaScriptRepresentation(sb, c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\nprivate static void appendHexJavaScriptRepresentation(\n    StringBuilder sb, char c) {\n  sb.append(\""
      ],
      "function range": "956,3-1025,3"
    },
    "Closure_119_src/com/google/javascript/jscomp/GlobalNamespace.java_366-366": {
      "loc": "366-366",
      "input": "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent != null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;",
      "output": [
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n        }\n      }\n      name = n.getString();\n      break;\n    default:\n",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n        }\n      }\n      name = n.getString();\n      break;\n    case Token.",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          default:\n            if (NodeUtil.isAssignmentOp(parent) &&\n                parent.",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          case Token.CATCH:\n          case Token.INC:\n          case Token.DEC:\n            ",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          default:\n            break;\n        }\n      }\n      name = n.getString();\n",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n        }\n      }\n      break;\n    case Token.GETPROP:\n      name = n",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n        }\n      }\n      isPropAssign = true;\n      name = n.getString();",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n        }\n      } else {\n        type = Name.Type.OTHER;\n      }\n      name",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          default:\n            if (NodeUtil.isAssignmentOp(parent) && parent.getFirst",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          case Token.CATCH:\n          case Token.INC:\n          case Token.DEC:\n          "
      ],
      "function range": "306,5-430,5"
    },
    "Lang_10_src/main/java/org/apache/commons/lang3/time/FastDateParser.java_307-314": {
      "loc": "307-314",
      "input": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);",
      "output": [
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                wasWhite= false;\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                wasWhite= false;\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                wasWhite= false;\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                wasWhite= false;\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                wasWhite= false;\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                wasWhite= false;\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                wasWhite= false;\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                wasWhite= false;\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                wasWhite= false;\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                wasWhite= false;\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                wasWhite= false;\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                wasWhite= false;\n                break;\n            case ',':\n                regex.append(\"\\\\,\");\n                wasWhite= false;\n                break;\n            case '-':\n                regex.append(\"\\\\-\");\n                wasWhite= false;\n                break;\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                wasWhite= false;\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                wasWhite= false;\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                wasWhite= false;\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                wasWhite= false;\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                wasWhite= false;\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                wasWhite= false;\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                wasWhite= false;\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                wasWhite= false;\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                wasWhite= false;\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                wasWhite= false;\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                wasWhite= false;\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case ',':\n                regex.append(\"\\\\,\");\n                wasWhite= false;\n                break;\n            case '&':\n                regex.append(\"\\\\&\");",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                wasWhite= false;\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                wasWhite= false;\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                wasWhite= false;\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                wasWhite= false;\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                wasWhite= false;\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                wasWhite= false;\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                wasWhite= false;\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                wasWhite= false;\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                wasWhite= false;\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                wasWhite= false;\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                wasWhite= false;\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case ',':\n                regex.append(\"\\\\,\");\n                wasWhite= false;\n                break;\n            case '{':\n                regex.append(\"\\\\{\");",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                wasWhite= false;\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                wasWhite= false;\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                wasWhite= false;\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                wasWhite= false;\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                wasWhite= false;\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                wasWhite= false;\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                wasWhite= false;\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                wasWhite= false;\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                wasWhite= false;\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                wasWhite= false;\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                wasWhite= false;\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                wasWhite= false;\n                break;\n            case ',':\n                regex.append(\"\\\\,\");\n                wasWhite= false;\n                break;\n            case '-':\n                regex.append(\"\\\\-\");\n                wasWhite= false;\n                break;\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                wasWhite= false;\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                wasWhite= false;\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                wasWhite= false;\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                wasWhite= false;\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                wasWhite= false;\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                wasWhite= false;\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                wasWhite= false;\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                wasWhite= false;\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                wasWhite= false;\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                wasWhite= false;\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                wasWhite= false;\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case ',':\n                regex.append(\"\\\\,\");\n                wasWhite= false;\n                break;\n            case ':':\n                regex.append(\"\\\\:\");",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                wasWhite= false;\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                wasWhite= false;\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                wasWhite= false;\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                wasWhite= false;\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                wasWhite= false;\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                wasWhite= false;\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                wasWhite= false;\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                wasWhite= false;\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                wasWhite= false;\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                wasWhite= false;\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                wasWhite= false;\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case '@':\n                regex.append(\"\\\\@\");\n                wasWhite= false;\n                break;\n            case '.':\n                regex.append(\"\\\\.\");",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                wasWhite= false;\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                wasWhite= false;\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                wasWhite= false;\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                wasWhite= false;\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                wasWhite= false;\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                wasWhite= false;\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                wasWhite= false;\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                wasWhite= false;\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                wasWhite= false;\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                wasWhite= false;\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                wasWhite= false;\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case ',':\n                regex.append(\"\\\\,\");\n                wasWhite= false;\n                break;\n            case'':\n                regex.append(\"\\\\ \");",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                wasWhite= false;\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                wasWhite= false;\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                wasWhite= false;\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                wasWhite= false;\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                wasWhite= false;\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                wasWhite= false;\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                wasWhite= false;\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                wasWhite= false;\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                wasWhite= false;\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                wasWhite= false;\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                wasWhite= false;\n                break;\n            case ',':\n                regex.append(\"\\\\,\");\n                wasWhite= false;\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                wasWhite= false;\n                break;\n            case '&':\n                regex.append(\"\\\\&\");\n                wasWhite= false;\n                break;\n            case'':\n                regex.append(\"\\\\ \");",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                wasWhite= false;\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                wasWhite= false;\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                wasWhite= false;\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                wasWhite= false;\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                wasWhite= false;\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                wasWhite= false;\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                wasWhite= false;\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                wasWhite= false;\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                wasWhite= false;\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                wasWhite= false;\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                wasWhite= false;\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case ',':\n                regex.append(\"\\\\,\");\n                wasWhite= false;\n                break;\n            case'':\n                regex.append(\"\\\\s\");",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                wasWhite= false;\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                wasWhite= false;\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                wasWhite= false;\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                wasWhite= false;\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                wasWhite= false;\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                wasWhite= false;\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                wasWhite= false;\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                wasWhite= false;\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                wasWhite= false;\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                wasWhite= false;\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                wasWhite= false;\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                wasWhite= false;\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                wasWhite= false;\n                break;\n            case '@':\n                regex.append(\"\\\\@\");\n                wasWhite= false;\n                break;\n            case '.':\n                regex.append(\".\");\n"
      ],
      "function range": "303,5-343,5"
    },
    "Lang_38_src/java/org/apache/commons/lang3/time/FastDateFormat.java_872-872": {
      "loc": "872-872",
      "input": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {",
      "output": [
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      calendar = (Calendar) calendar.clone();\n      calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      calendar = (Calendar) calendar.clone();\n      calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      calendar = (Calendar) calendar.clone();\n      calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      calendar = (Calendar) calendar.clone();\n      calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      calendar = (Calendar) calendar.clone();\n      calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      calendar = (Calendar) calendar.clone();\n      calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.data.std",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      calendar = (Calendar) calendar.clone();\n      calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class Numeric",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      calendar = (Calendar) calendar.clone();\n      calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.h",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      calendar = (Calendar) calendar.clone();\n      calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\n\npublic class N",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n      calendar = (Calendar) calendar.clone();\n      calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class Nth"
      ],
      "function range": "870,5-876,5"
    },
    "Math_65_src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java_258-259": {
      "loc": "258-259",
      "input": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];",
      "output": [
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        for (int j = 0; j < columns; ++j) {\n            chiSquare += residuals[i] * residuals[j];\n        }\n    }\n    return chiSquare;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.h",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        for (int j = 0; j < cols; ++j) {\n            chiSquare += residuals[i] * residuals[j];\n        }\n    }\n    return chiSquare;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        for (int j = 0; j < columns; ++j) {\n            chiSquare += residuals[i] * residuals[j];\n        }\n    }\n    return chiSquare;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        for (int j = 0; j < cols; ++j) {\n            chiSquare += residuals[i] * residuals[j];\n        }\n    }\n    return chiSquare;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        for (int j = 0; j < columns; ++j) {\n            chiSquare += residuals[i] * residuals[j];\n        }\n    }\n    return chiSquare;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        for (int j = 0; j < cols; ++j) {\n            chiSquare += residuals[i] * residuals[j];\n        }\n    }\n    return chiSquare;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        for (int j = 0; j < columns; ++j) {\n            chiSquare += residuals[i] * residuals[j];\n        }\n    }\n    return chiSquare;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        for (int j = 0; j < columns; ++j) {\n            chiSquare += residuals[i] * residuals[j];\n        }\n    }\n    return chiSquare;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        for (int j = 0; j < cols; ++j) {\n            chiSquare += residuals[i] * residuals[j];\n        }\n    }\n    return chiSquare;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        for (int j = 0; j < columns; ++j) {\n            chiSquare += residuals[i] * residuals[j];\n        }\n    }\n    return chiSquare;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\n"
      ],
      "function range": "254,5-261,5"
    },
    "Math_79_src/main/java/org/apache/commons/math/util/MathUtils.java_1624-1625": {
      "loc": "1624-1625",
      "input": "public static double distance(int[] p1, int[] p2) {",
      "output": [
        "public static double distance(int[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(int[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(int[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1",
        "public static double distance(int[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(int[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(int[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1",
        "public static double distance(int[] p1, int[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, int[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(int[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, int[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(int[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, int[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1",
        "public static double distance(int[] p1, int[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, int[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(int[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, int[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(int[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1",
        "public static double distance(int[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(int[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(int[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(int[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1",
        "public static double distance(int[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(int[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(int[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(int[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1",
        "public static double distance(int[] p1, int[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, int[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(int[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, int[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(int[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(int[] p1, int[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1",
        "public static double distance(int[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(int[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(int[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, double[] p2, double[] p3) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.",
        "public static double distance(int[] p1, int[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, int[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(int[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, int[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(int[] p1, double[] p2) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n\t}\n\n\tpublic static double distance(double[] p1, double[] p2, double[] p3) {\n\t\treturn Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.",
        "public static double distance(int[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(int[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, int[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(int[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n\n    public static double distance(double[] p1, double[] p2, double[] p3) {\n        return Math.sqrt(distance(p1, p2) + distance(p1, p3) + distance(p"
      ],
      "function range": "1623,5-1630,5"
    },
    "Math_98_src/java/org/apache/commons/math/linear/BigMatrixImpl.java_991-992": {
      "loc": "991-992",
      "input": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length != this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();",
      "output": [
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] result = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        result[row] = sum;\n    }\n    return result;\n}\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n        if (v.length!= this.getRowDimension()) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] result = new BigDecimal[nRows];\n        for (int row = 0; row < nRows; row++) {\n            BigDecimal sum = BigDecimal.ZERO;\n            for (int col = 0; col < nCols; col++) {\n                sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n            }\n            result[row] = sum;\n        }\n        return result;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double[] operate(double[] v) throws IllegalArgumentException {\n        if (v.length!= this.getColumnDimension()) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] result = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        result[row] = sum;\n    }\n    return result;\n}\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n        if (v.length!= this.getColumnDimension()) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] result = new BigDecimal[nRows];\n        for (int row = 0; row < nRows; row++) {\n            BigDecimal sum = BigDecimal.ZERO;\n            for (int col = 0; col < nCols; col++) {\n                sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n            }\n            result[row] = sum;\n        }\n        return result;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[][] preMultiply(BigDecimal[][] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[][] result = new BigDecimal[nRows][nCol",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        out[row] = sum;\n    }\n    return out;\n}\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n        if (v.length!= this.getRowDimension()) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[nRows];\n        for (int row = 0; row < nRows; row++) {\n            BigDecimal sum = BigDecimal.ZERO;\n            for (int col = 0; col < nCols; col++) {\n                sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n            }\n            out[row] = sum;\n        }\n        return out;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[][] preMultiply(BigDecimal[][] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[][] out = new BigDecimal[nRows][nCol",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] result = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        result[row] = sum;\n    }\n    return result;\n}\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n        if (v.length!= this.getRowDimension()) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] result = new BigDecimal[nRows];\n        for (int row = 0; row < nRows; row++) {\n            BigDecimal sum = BigDecimal.ZERO;\n            for (int col = 0; col < nCols; col++) {\n                sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n            }\n            result[row] = sum;\n        }\n        return result;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[][] preMultiply(BigDecimal[][] v) throws IllegalArgumentException {\n        if (v.length!= this.getRowDimension()) {\n            throw new IllegalArgumentException(\"matrix has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] result = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        result[row] = sum;\n    }\n    return result;\n}\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n        if (v.length!= this.getRowDimension()) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] result = new BigDecimal[nRows];\n        for (int row = 0; row < nRows; row++) {\n            BigDecimal sum = BigDecimal.ZERO;\n            for (int col = 0; col < nCols; col++) {\n                sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n            }\n            result[row] = sum;\n        }\n        return result;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[][] preMultiply(BigDecimal[][] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        if (v.length!= nRows) {\n            throw new IllegalArgumentException(\"",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] result = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        result[row] = sum;\n    }\n    return result;\n}\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n        if (v.length!= this.getRowDimension()) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] result = new BigDecimal[nRows];\n        for (int row = 0; row < nRows; row++) {\n            BigDecimal sum = BigDecimal.ZERO;\n            for (int col = 0; col < nCols; col++) {\n                sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n            }\n            result[row] = sum;\n        }\n        return result;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[][] preMultiply(BigDecimal[][] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[][] result = new BigDecimal[nRows][nCol",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] result = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        result[row] = sum;\n    }\n    return result;\n}\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n        if (v.length!= this.getColumnDimension()) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] result = new BigDecimal[nRows];\n        for (int row = 0; row < nRows; row++) {\n            BigDecimal sum = BigDecimal.ZERO;\n            for (int col = 0; col < nCols; col++) {\n                sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n            }\n            result[row] = sum;\n        }\n        return result;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[][] preMultiply(BigDecimal[][] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        if (v.length!= nRows) {\n            throw new IllegalArgumentException(\"",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        out[row] = sum;\n    }\n    return out;\n}\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n        if (v.length!= this.getRowDimension()) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[nRows];\n        for (int row = 0; row < nRows; row++) {\n            BigDecimal sum = BigDecimal.ZERO;\n            for (int col = 0; col < nCols; col++) {\n                sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n            }\n            out[row] = sum;\n        }\n        return out;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[][] preMultiply(BigDecimal[][] v) throws IllegalArgumentException {\n        if (v.length!= this.getRowDimension()) {\n            throw new IllegalArgumentException(\"matrix has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] result = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        result[row] = sum;\n    }\n    return result;\n}\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n        if (v.length!= this.getRowDimension()) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] result = new BigDecimal[nRows];\n        for (int row = 0; row < nRows; row++) {\n            BigDecimal sum = BigDecimal.ZERO;\n            for (int col = 0; col < nCols; col++) {\n                sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n            }\n            result[row] = sum;\n        }\n        return result;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[][] preMultiply(BigDecimal[][] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[][] result = new BigDecimal[nRows][];\n",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] result = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        result[row] = sum;\n    }\n    return result;\n}\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n        if (v.length!= this.getColumnDimension()) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[] result = new BigDecimal[nRows];\n        for (int row = 0; row < nRows; row++) {\n            BigDecimal sum = BigDecimal.ZERO;\n            for (int col = 0; col < nCols; col++) {\n                sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n            }\n            result[row] = sum;\n        }\n        return result;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public BigDecimal[][] preMultiply(BigDecimal[][] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        final BigDecimal[][] result = new BigDecimal[nRows][];\n"
      ],
      "function range": "985,5-1000,5"
    },
    "Chart_1_/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java_1797-1798": {
      "loc": "1797-1798",
      "input": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);",
      "output": [
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    for (int i = 0; i < seriesCount; i++) {\n        if (isSeriesVisibleInLegend(i)) {\n            LegendItem item = getLegendItem(index, i);\n            if (item!= null) {\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}\n\n    /**\n     * Returns the legend item label generator.\n     *\n     * @return The label generator (never <code>null</code>).\n     *\n     * @see #setLegendItemLabelGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemLabelGenerator() {\n        return this.legendItemLabelGenerator;\n    }\n\n    /**\n     * Sets the legend item label generator and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> not permitted).\n     *\n     * @see #getLegendItemLabelGenerator()\n     */\n    public void setLegendItemLabelGenerator(\n            CategorySeriesLabelGenerator generator) {\n        ParamChecks.nullNotPermitted(generator, \"generator\");\n        this.legendItemLabelGenerator = generator;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend item tool tip generator.\n     *\n     * @return The tool tip generator (possibly <code>null</code>).\n     *\n     * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemToolTipGenerator() {\n        return this.legendItemToolTipGenerator;\n    }\n\n    /**\n     * Sets the legend item tool",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    for (int i = 0; i < seriesCount; i++) {\n        if (isSeriesVisibleInLegend(i)) {\n            LegendItem item = getLegendItem(index, i);\n            if (item!= null) {\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}\n\n    /**\n     * Returns the legend item label generator.\n     *\n     * @return The label generator (never <code>null</code>).\n     *\n     * @see #setLegendItemLabelGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemLabelGenerator() {\n        return this.legendItemLabelGenerator;\n    }\n\n    /**\n     * Sets the legend item label generator and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> not permitted).\n     *\n     * @see #getLegendItemLabelGenerator()\n     */\n    public void setLegendItemLabelGenerator(\n            CategorySeriesLabelGenerator generator) {\n        if (generator == null) {\n            throw new IllegalArgumentException(\"Null 'generator' argument.\");\n        }\n        this.legendItemLabelGenerator = generator;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend item tool tip generator.\n     *\n     * @return The tool tip generator (possibly <code>null</code>).\n     *\n     * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemToolTipGenerator() {\n        return this.legendItemToolTipGenerator;\n    ",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    for (int i = 0; i < seriesCount; i++) {\n        if (isSeriesVisibleInLegend(i)) {\n            LegendItem item = getLegendItem(index, i);\n            if (item!= null) {\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}\n\n    /**\n     * Returns the legend item label generator.\n     *\n     * @return The label generator (never <code>null</code>).\n     *\n     * @see #setLegendItemLabelGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemLabelGenerator() {\n        return this.legendItemLabelGenerator;\n    }\n\n    /**\n     * Sets the legend item label generator.\n     *\n     * @param generator  the generator (<code>null</code> not permitted).\n     *\n     * @see #getLegendItemLabelGenerator()\n     */\n    public void setLegendItemLabelGenerator(\n            CategorySeriesLabelGenerator generator) {\n        ParamChecks.nullNotPermitted(generator, \"generator\");\n        this.legendItemLabelGenerator = generator;\n    }\n\n    /**\n     * Returns the legend item tool tip generator.\n     *\n     * @return The tool tip generator (possibly <code>null</code>).\n     *\n     * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemToolTipGenerator() {\n        return this.legendItemToolTipGenerator;\n    }\n\n    /**\n     * Sets the legend item tool tip generator and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    for (int i = 0; i < seriesCount; i++) {\n        if (isSeriesVisibleInLegend(i)) {\n            LegendItem item = getLegendItem(index, i);\n            if (item!= null) {\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}\n\n    /**\n     * Returns the legend item label generator.\n     *\n     * @return The label generator (never <code>null</code>).\n     *\n     * @see #setLegendItemLabelGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemLabelGenerator() {\n        return this.legendItemLabelGenerator;\n    }\n\n    /**\n     * Sets the legend item label generator.\n     *\n     * @param generator  the generator (<code>null</code> not permitted).\n     *\n     * @see #getLegendItemLabelGenerator()\n     */\n    public void setLegendItemLabelGenerator(\n            CategorySeriesLabelGenerator generator) {\n        ParamChecks.nullNotPermitted(generator, \"generator\");\n        this.legendItemLabelGenerator = generator;\n    }\n\n    /**\n     * Returns the legend item tool tip generator.\n     *\n     * @return The tool tip generator (possibly <code>null</code>).\n     *\n     * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemToolTipGenerator() {\n        return this.legendItemToolTipGenerator;\n    }\n\n    /**\n     * Sets the legend item tool tip generator.\n     *\n     * @param generator  the generator (<code>null</code> permitted).",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    for (int i = 0; i < seriesCount; i++) {\n        if (isSeriesVisibleInLegend(i)) {\n            LegendItem item = getLegendItem(index, i);\n            if (item!= null) {\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}\n\n    /**\n     * Returns the legend item label generator.\n     *\n     * @return The label generator (never <code>null</code>).\n     *\n     * @see #setLegendItemLabelGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemLabelGenerator() {\n        return this.legendItemLabelGenerator;\n    }\n\n    /**\n     * Sets the legend item label generator and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     *\n     * @see #getLegendItemLabelGenerator()\n     */\n    public void setLegendItemLabelGenerator(\n            CategorySeriesLabelGenerator generator) {\n        this.legendItemLabelGenerator = generator;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend item tool tip generator.\n     *\n     * @return The tool tip generator (possibly <code>null</code>).\n     *\n     * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemToolTipGenerator() {\n        return this.legendItemToolTipGenerator;\n    }\n\n    /**\n     * Sets the legend item tool tip generator and sends a\n     * {@link RendererChangeEvent} to all registered",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    for (int i = 0; i < seriesCount; i++) {\n        if (isSeriesVisibleInLegend(i)) {\n            LegendItem item = getLegendItem(index, i);\n            if (item!= null) {\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}\n\n    /**\n     * Returns the legend item label generator.\n     *\n     * @return The label generator (never <code>null</code>).\n     *\n     * @see #setLegendItemLabelGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemLabelGenerator() {\n        return this.legendItemLabelGenerator;\n    }\n\n    /**\n     * Sets the legend item label generator and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> not permitted).\n     *\n     * @see #getLegendItemLabelGenerator()\n     */\n    public void setLegendItemLabelGenerator(\n            CategorySeriesLabelGenerator generator) {\n        ParamChecks.nullNotPermitted(generator, \"generator\");\n        this.legendItemLabelGenerator = generator;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend item tool tip generator.\n     *\n     * @return The tool tip generator (possibly <code>null</code>).\n     *\n     * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemToolTipGenerator() {\n        return this.legendItemToolTipGenerator;\n    }\n\n    /**\n     * Sets the tool tip generator",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    for (int i = 0; i < seriesCount; i++) {\n        if (isSeriesVisibleInLegend(i)) {\n            LegendItem item = getLegendItem(index, i);\n            if (item!= null) {\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}\n\n    /**\n     * Returns the legend item label generator.\n     *\n     * @return The label generator (never <code>null</code>).\n     *\n     * @see #setLegendItemLabelGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemLabelGenerator() {\n        return this.legendItemLabelGenerator;\n    }\n\n    /**\n     * Sets the legend item label generator.\n     *\n     * @param generator  the generator (<code>null</code> not permitted).\n     *\n     * @see #getLegendItemLabelGenerator()\n     */\n    public void setLegendItemLabelGenerator(\n            CategorySeriesLabelGenerator generator) {\n        if (generator == null) {\n            throw new IllegalArgumentException(\"Null 'generator' argument.\");\n        }\n        this.legendItemLabelGenerator = generator;\n    }\n\n    /**\n     * Returns the legend item tool tip generator.\n     *\n     * @return The tool tip generator (possibly <code>null</code>).\n     *\n     * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemToolTipGenerator() {\n        return this.legendItemToolTipGenerator;\n    }\n\n    /**\n     * Sets the legend item tool tip generator.\n     *\n     * @param generator",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    for (int i = 0; i < seriesCount; i++) {\n        if (isSeriesVisibleInLegend(i)) {\n            LegendItem item = getLegendItem(index, i);\n            if (item!= null) {\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}\n\n    /**\n     * Returns the legend item label generator.\n     *\n     * @return The label generator (never <code>null</code>).\n     *\n     * @see #setLegendItemLabelGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemLabelGenerator() {\n        return this.legendItemLabelGenerator;\n    }\n\n    /**\n     * Sets the legend item label generator.\n     *\n     * @param generator  the generator (<code>null</code> not permitted).\n     *\n     * @see #getLegendItemLabelGenerator()\n     */\n    public void setLegendItemLabelGenerator(\n            CategorySeriesLabelGenerator generator) {\n        ParamChecks.nullNotPermitted(generator, \"generator\");\n        this.legendItemLabelGenerator = generator;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend item tool tip generator.\n     *\n     * @return The tool tip generator (possibly <code>null</code>).\n     *\n     * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemToolTipGenerator() {\n        return this.legendItemToolTipGenerator;\n    }\n\n    /**\n     * Sets the legend item tool tip generator and sends a\n     * {@link RendererChangeEvent} to all",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    for (int i = 0; i < seriesCount; i++) {\n        if (isSeriesVisibleInLegend(i)) {\n            LegendItem item = getLegendItem(index, i);\n            if (item!= null) {\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}\n\n    /**\n     * Returns the legend item label generator.\n     *\n     * @return The label generator (never <code>null</code>).\n     *\n     * @see #setLegendItemLabelGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemLabelGenerator() {\n        return this.legendItemLabelGenerator;\n    }\n\n    /**\n     * Sets the legend item label generator.\n     *\n     * @param generator  the generator (<code>null</code> not permitted).\n     *\n     * @see #getLegendItemLabelGenerator()\n     */\n    public void setLegendItemLabelGenerator(\n            CategorySeriesLabelGenerator generator) {\n        if (generator == null) {\n            throw new IllegalArgumentException(\"Null 'generator' argument.\");\n        }\n        this.legendItemLabelGenerator = generator;\n    }\n\n    /**\n     * Returns the legend item tool tip generator.\n     *\n     * @return The tool tip generator (possibly <code>null</code>).\n     *\n     * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemToolTipGenerator() {\n        return this.legendItemToolTipGenerator;\n    }\n\n    /**\n     * Sets the legend item tool tip generator and sends a\n     * {@link Rend",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    for (int i = 0; i < seriesCount; i++) {\n        if (isSeriesVisibleInLegend(i)) {\n            LegendItem item = getLegendItem(index, i);\n            if (item!= null) {\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}\n\n/**\n * Returns the legend item label generator.\n *\n * @return The label generator (never <code>null</code>).\n *\n * @see #setLegendItemLabelGenerator(CategorySeriesLabelGenerator)\n */\npublic CategorySeriesLabelGenerator getLegendItemLabelGenerator() {\n    return this.legendItemLabelGenerator;\n}\n\n/**\n * Sets the legend item label generator.\n *\n * @param generator  the generator (<code>null</code> not permitted).\n *\n * @see #getLegendItemLabelGenerator()\n */\npublic void setLegendItemLabelGenerator(CategorySeriesLabelGenerator generator) {\n    ParamChecks.nullNotPermitted(generator, \"generator\");\n    this.legendItemLabelGenerator = generator;\n}\n\n/**\n * Returns the legend item tool tip generator.\n *\n * @return The tool tip generator (possibly <code>null</code>).\n *\n * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)\n */\npublic CategorySeriesLabelGenerator getLegendItemToolTipGenerator() {\n    return this.legendItemToolTipGenerator;\n}\n\n/**\n * Sets the legend item tool tip generator.\n *\n * @param generator  the generator (<code>null</code> permitted).\n *\n * @see #getLegendItemToolTipGenerator()\n */\npublic void setLegendItemToolTipGenerator(Category"
      ],
      "function range": "1790,5-1822,5"
    },
    "Chart_3_/source/org/jfree/data/time/TimeSeries.java_1057-1058": {
      "loc": "1057-1058",
      "input": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();",
      "output": [
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start + 1];\n    System.arraycopy(data, start, copy.data, 0, end - start + 1);\n    return copy;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start + 1];\n    System.arraycopy(data, start, copy.data, 0, end - start + 1);\n    return copy;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start + 1];\n    System.arraycopy(data, start, copy.data, 0, end - start + 1);\n    return copy;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start + 1];\n    System.arraycopy(data, start, copy.data, 0, end - start + 1);\n    return copy;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEval",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start + 1];\n    System.arraycopy(data, start, copy.data, 0, end - start + 1);\n    return copy;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.common.annotations.MissingNullInOutFunction;\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScal",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start + 1];\n    System.arraycopy(data, start, copy.data, 0, end - start + 1);\n    return copy;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start + 1];\n    System.arraycopy(data, start, copy.data, 0, end - start + 1);\n    return copy;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.AsterixBuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.al",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start + 1];\n    System.arraycopy(data, start, copy.data, 0, end - start + 1);\n    return copy;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluator;\nimport org.apache.hyracks.algebricks.",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start + 1];\n    System.arraycopy(data, start, copy.data, 0, end - start + 1);\n    return copy;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.common.annotations.MissingNullInOutFunction;\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEval",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new double[end - start + 1];\n    System.arraycopy(data, start, copy.data, 0, end - start + 1);\n    return copy;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext"
      ],
      "function range": "1048,5-1072,5"
    },
    "Chart_6_/source/org/jfree/chart/util/ShapeList.java_111-112": {
      "loc": "111-112",
      "input": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }",
      "output": [
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList that = (ShapeList) obj;\n    if (this.size()!= that.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(that.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyr",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList that = (ShapeList) obj;\n    if (this.size()!= that.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(that.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyr",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList that = (ShapeList) obj;\n    if (this.size()!= that.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(that.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\n\npublic class NumericAddDescriptor extends AbstractSc",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.core."
      ],
      "function range": "103,5-113,5"
    },
    "Chart_8_/source/org/jfree/data/time/Week.java_175-176": {
      "loc": "175-176",
      "input": "public Week(Date time, TimeZone zone) {",
      "output": [
        "public Week(Date time, TimeZone zone) {\r\n\t\tthis.time = time;\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the time\r\n\t */\r\n\tpublic Date getTime() {\r\n\t\treturn time;\r\n\t}\r\n\r\n\t/**\r\n\t * @param time\r\n\t *            the time to set\r\n\t */\r\n\tpublic void setTime(Date time) {\r\n\t\tthis.time = time;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the zone\r\n\t */\r\n\tpublic TimeZone getZone() {\r\n\t\treturn zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @param zone\r\n\t *            the zone to set\r\n\t */\r\n\tpublic void setZone(TimeZone zone) {\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\tfinal int prime = 31;\r\n\t\tint result = 1;\r\n\t\tresult = prime * result + ((time == null)? 0 : time.hashCode());\r\n\t\tresult = prime * result + ((zone == null)? 0 : zone.hashCode());\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (this == obj)\r\n\t\t\treturn true;\r\n\t\tif (obj == null)\r\n\t\t\treturn false;\r\n\t\tif (getClass()!= obj.getClass())\r\n\t\t\treturn false;\r\n\t\tWeek other = (Week) obj;\r\n\t\tif (time == null) {\r\n\t\t\tif (other.time!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!time.equals(other.time))\r\n\t\t\treturn false;\r\n\t\tif (zone == null) {\r\n\t\t\tif (other.zone!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!zone.equals(other.zone))\r\n\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Week [time=\" + time",
        "public Week(Date time, TimeZone zone) {\r\n\t\tthis.time = time;\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the time\r\n\t */\r\n\tpublic Date getTime() {\r\n\t\treturn time;\r\n\t}\r\n\r\n\t/**\r\n\t * @param time\r\n\t *            the time to set\r\n\t */\r\n\tpublic void setTime(Date time) {\r\n\t\tthis.time = time;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the zone\r\n\t */\r\n\tpublic TimeZone getZone() {\r\n\t\treturn zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @param zone\r\n\t *            the zone to set\r\n\t */\r\n\tpublic void setZone(TimeZone zone) {\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\tfinal int prime = 31;\r\n\t\tint result = 1;\r\n\t\tresult = prime * result + ((time == null)? 0 : time.hashCode());\r\n\t\tresult = prime * result + ((zone == null)? 0 : zone.hashCode());\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (this == obj) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (obj == null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (getClass()!= obj.getClass()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tWeek other = (Week) obj;\r\n\t\tif (time == null) {\r\n\t\t\tif (other.time!= null) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} else if (!time.equals(other.time)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (zone == null) {\r\n\t\t\tif (other.zone!= null) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} else if (!zone.equals(other.zone)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n",
        "public Week(Date time, TimeZone zone) {\r\n\t\tthis.time = time;\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the time\r\n\t */\r\n\tpublic Date getTime() {\r\n\t\treturn time;\r\n\t}\r\n\r\n\t/**\r\n\t * @param time\r\n\t *            the time to set\r\n\t */\r\n\tpublic void setTime(Date time) {\r\n\t\tthis.time = time;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the zone\r\n\t */\r\n\tpublic TimeZone getZone() {\r\n\t\treturn zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @param zone\r\n\t *            the zone to set\r\n\t */\r\n\tpublic void setZone(TimeZone zone) {\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\tfinal int prime = 31;\r\n\t\tint result = 1;\r\n\t\tresult = prime * result + ((zone == null)? 0 : zone.hashCode());\r\n\t\tresult = prime * result + ((time == null)? 0 : time.hashCode());\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (this == obj) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (obj == null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (getClass()!= obj.getClass()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tWeek other = (Week) obj;\r\n\t\tif (zone == null) {\r\n\t\t\tif (other.zone!= null) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} else if (!zone.equals(other.zone)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (time == null) {\r\n\t\t\tif (other.time!= null) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} else if (!time.equals(other.time)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n",
        "public Week(Date time, TimeZone zone) {\r\n\t\tthis.time = time;\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the time\r\n\t */\r\n\tpublic Date getTime() {\r\n\t\treturn time;\r\n\t}\r\n\r\n\t/**\r\n\t * @param time\r\n\t *            the time to set\r\n\t */\r\n\tpublic void setTime(Date time) {\r\n\t\tthis.time = time;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the zone\r\n\t */\r\n\tpublic TimeZone getZone() {\r\n\t\treturn zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @param zone\r\n\t *            the zone to set\r\n\t */\r\n\tpublic void setZone(TimeZone zone) {\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\tfinal int prime = 31;\r\n\t\tint result = 1;\r\n\t\tresult = prime * result + ((zone == null)? 0 : zone.hashCode());\r\n\t\tresult = prime * result + ((time == null)? 0 : time.hashCode());\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (this == obj)\r\n\t\t\treturn true;\r\n\t\tif (obj == null)\r\n\t\t\treturn false;\r\n\t\tif (getClass()!= obj.getClass())\r\n\t\t\treturn false;\r\n\t\tWeek other = (Week) obj;\r\n\t\tif (zone == null) {\r\n\t\t\tif (other.zone!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!zone.equals(other.zone))\r\n\t\t\treturn false;\r\n\t\tif (time == null) {\r\n\t\t\tif (other.time!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!time.equals(other.time))\r\n\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Week [time=\" + time",
        "public Week(Date time, TimeZone zone) {\r\n\t\tthis.time = time;\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the time\r\n\t */\r\n\tpublic Date getTime() {\r\n\t\treturn time;\r\n\t}\r\n\r\n\t/**\r\n\t * @param time\r\n\t *            the time to set\r\n\t */\r\n\tpublic void setTime(Date time) {\r\n\t\tthis.time = time;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the zone\r\n\t */\r\n\tpublic TimeZone getZone() {\r\n\t\treturn zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @param zone\r\n\t *            the zone to set\r\n\t */\r\n\tpublic void setZone(TimeZone zone) {\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\tfinal int prime = 31;\r\n\t\tint result = 1;\r\n\t\tresult = prime * result + ((time == null)? 0 : time.hashCode());\r\n\t\tresult = prime * result\r\n\t\t\t\t+ ((zone == null)? 0 : zone.hashCode());\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (this == obj)\r\n\t\t\treturn true;\r\n\t\tif (obj == null)\r\n\t\t\treturn false;\r\n\t\tif (getClass()!= obj.getClass())\r\n\t\t\treturn false;\r\n\t\tWeek other = (Week) obj;\r\n\t\tif (time == null) {\r\n\t\t\tif (other.time!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!time.equals(other.time))\r\n\t\t\treturn false;\r\n\t\tif (zone == null) {\r\n\t\t\tif (other.zone!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!zone.equals(other.zone))\r\n\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Week [time",
        "public Week(Date time, TimeZone zone) {\r\n\t\tthis.time = time;\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the time\r\n\t */\r\n\tpublic Date getTime() {\r\n\t\treturn time;\r\n\t}\r\n\r\n\t/**\r\n\t * @param time\r\n\t *            the time to set\r\n\t */\r\n\tpublic void setTime(Date time) {\r\n\t\tthis.time = time;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the zone\r\n\t */\r\n\tpublic TimeZone getZone() {\r\n\t\treturn zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @param zone\r\n\t *            the zone to set\r\n\t */\r\n\tpublic void setZone(TimeZone zone) {\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\tfinal int prime = 31;\r\n\t\tint result = 1;\r\n\t\tresult = prime * result + ((time == null)? 0 : time.hashCode());\r\n\t\tresult = prime * result + ((zone == null)? 0 : zone.hashCode());\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (this == obj)\r\n\t\t\treturn true;\r\n\t\tif (obj == null)\r\n\t\t\treturn false;\r\n\t\tif (getClass()!= obj.getClass())\r\n\t\t\treturn false;\r\n\t\tWeek other = (Week) obj;\r\n\t\tif (time == null) {\r\n\t\t\tif (other.time!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!time.equals(other.time))\r\n\t\t\treturn false;\r\n\t\tif (zone == null) {\r\n\t\t\tif (other.zone!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!zone.equals(other.zone))\r\n\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn time.toString();\r\n",
        "public Week(Date time, TimeZone zone) {\r\n\t\tthis.time = time;\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the time\r\n\t */\r\n\tpublic Date getTime() {\r\n\t\treturn time;\r\n\t}\r\n\r\n\t/**\r\n\t * @param time\r\n\t *            the time to set\r\n\t */\r\n\tpublic void setTime(Date time) {\r\n\t\tthis.time = time;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the zone\r\n\t */\r\n\tpublic TimeZone getZone() {\r\n\t\treturn zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @param zone\r\n\t *            the zone to set\r\n\t */\r\n\tpublic void setZone(TimeZone zone) {\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\tfinal int prime = 31;\r\n\t\tint result = 1;\r\n\t\tresult = (prime * result) + ((time == null)? 0 : time.hashCode());\r\n\t\tresult = (prime * result) + ((zone == null)? 0 : zone.hashCode());\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (this == obj)\r\n\t\t\treturn true;\r\n\t\tif (obj == null)\r\n\t\t\treturn false;\r\n\t\tif (getClass()!= obj.getClass())\r\n\t\t\treturn false;\r\n\t\tWeek other = (Week) obj;\r\n\t\tif (time == null) {\r\n\t\t\tif (other.time!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!time.equals(other.time))\r\n\t\t\treturn false;\r\n\t\tif (zone == null) {\r\n\t\t\tif (other.zone!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!zone.equals(other.zone))\r\n\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Week [",
        "public Week(Date time, TimeZone zone) {\r\n\t\tthis.time = time;\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the time\r\n\t */\r\n\tpublic Date getTime() {\r\n\t\treturn time;\r\n\t}\r\n\r\n\t/**\r\n\t * @param time\r\n\t *            the time to set\r\n\t */\r\n\tpublic void setTime(Date time) {\r\n\t\tthis.time = time;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the zone\r\n\t */\r\n\tpublic TimeZone getZone() {\r\n\t\treturn zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @param zone\r\n\t *            the zone to set\r\n\t */\r\n\tpublic void setZone(TimeZone zone) {\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\tfinal int prime = 31;\r\n\t\tint result = 1;\r\n\t\tresult = prime * result + ((zone == null)? 0 : zone.hashCode());\r\n\t\tresult = prime * result + ((time == null)? 0 : time.hashCode());\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (this == obj)\r\n\t\t\treturn true;\r\n\t\tif (obj == null)\r\n\t\t\treturn false;\r\n\t\tif (getClass()!= obj.getClass())\r\n\t\t\treturn false;\r\n\t\tWeek other = (Week) obj;\r\n\t\tif (zone == null) {\r\n\t\t\tif (other.zone!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!zone.equals(other.zone))\r\n\t\t\treturn false;\r\n\t\tif (time == null) {\r\n\t\t\tif (other.time!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!time.equals(other.time))\r\n\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Week [zone=\" + zone",
        "public Week(Date time, TimeZone zone) {\r\n\t\tthis.time = time;\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the time\r\n\t */\r\n\tpublic Date getTime() {\r\n\t\treturn time;\r\n\t}\r\n\r\n\t/**\r\n\t * @param time\r\n\t *            the time to set\r\n\t */\r\n\tpublic void setTime(Date time) {\r\n\t\tthis.time = time;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the zone\r\n\t */\r\n\tpublic TimeZone getZone() {\r\n\t\treturn zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @param zone\r\n\t *            the zone to set\r\n\t */\r\n\tpublic void setZone(TimeZone zone) {\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\tfinal int prime = 31;\r\n\t\tint result = 1;\r\n\t\tresult = prime * result + ((time == null)? 0 : time.hashCode());\r\n\t\tresult = prime * result + ((zone == null)? 0 : zone.hashCode());\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (this == obj)\r\n\t\t\treturn true;\r\n\t\tif (obj == null)\r\n\t\t\treturn false;\r\n\t\tif (getClass()!= obj.getClass())\r\n\t\t\treturn false;\r\n\t\tWeek other = (Week) obj;\r\n\t\tif (time == null) {\r\n\t\t\tif (other.time!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!time.equals(other.time))\r\n\t\t\treturn false;\r\n\t\tif (zone == null) {\r\n\t\t\tif (other.zone!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!zone.equals(other.zone))\r\n\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn time.toString() + \"",
        "public Week(Date time, TimeZone zone) {\r\n\t\tthis.time = time;\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the time\r\n\t */\r\n\tpublic Date getTime() {\r\n\t\treturn time;\r\n\t}\r\n\r\n\t/**\r\n\t * @param time\r\n\t *            the time to set\r\n\t */\r\n\tpublic void setTime(Date time) {\r\n\t\tthis.time = time;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the zone\r\n\t */\r\n\tpublic TimeZone getZone() {\r\n\t\treturn zone;\r\n\t}\r\n\r\n\t/**\r\n\t * @param zone\r\n\t *            the zone to set\r\n\t */\r\n\tpublic void setZone(TimeZone zone) {\r\n\t\tthis.zone = zone;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\tfinal int prime = 31;\r\n\t\tint result = 1;\r\n\t\tresult = prime * result + ((time == null)? 0 : time.hashCode());\r\n\t\tresult = prime * result + ((zone == null)? 0 : zone.hashCode());\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (this == obj)\r\n\t\t\treturn true;\r\n\t\tif (obj == null)\r\n\t\t\treturn false;\r\n\t\tif (getClass()!= obj.getClass())\r\n\t\t\treturn false;\r\n\t\tWeek other = (Week) obj;\r\n\t\tif (time == null) {\r\n\t\t\tif (other.time!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!time.equals(other.time))\r\n\t\t\treturn false;\r\n\t\tif (zone == null) {\r\n\t\t\tif (other.zone!= null)\r\n\t\t\t\treturn false;\r\n\t\t} else if (!zone.equals(other.zone))\r\n\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Week [\" + time + \""
      ],
      "function range": "173,5-176,5"
    },
    "Chart_9_/source/org/jfree/data/time/TimeSeries.java_944-945": {
      "loc": "944-945",
      "input": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null 'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }",
      "output": [
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex >= this.data.size()) {\n        if (emptyRange) {\n            endIndex = this.data.size() - 1;\n        }\n        else {\n            endIndex = this.data.size() - 2;\n        }\n    }\n    TimeSeries clone = (TimeSeries) super.clone();\n    clone.data = new java.util.ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = startIndex; index <= endIndex; index++) {\n            TimeSeriesDataItem item \n                = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem cloneItem \n                = (TimeSeriesDataItem) item.clone();\n            clone.data.add(cloneItem);\n        }\n    }\n    return clone;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\");",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex >= this.data.size()) {\n        if (emptyRange) {\n            endIndex = this.data.size() - 1;\n        }\n        else {\n            endIndex = this.data.size() - 2;\n        }\n    }\n    TimeSeries clone = (TimeSeries) super.clone();\n    clone.data = new java.util.ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = startIndex; index <= endIndex; index++) {\n            TimeSeriesDataItem item \n                = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem cloneItem \n                = (TimeSeriesDataItem) item.clone();\n            clone.data.add(cloneItem);\n        }\n    }\n    return clone;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n *",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex >= this.data.size()) {\n        if (emptyRange) {\n            endIndex = this.data.size() - 1;\n        }\n        else {\n            endIndex = this.data.size() - 2;\n        }\n    }\n    TimeSeries clone = (TimeSeries) super.clone();\n    clone.data = new java.util.ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = startIndex; index <= endIndex; index++) {\n            TimeSeriesDataItem item \n                = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem cloneItem \n                = (TimeSeriesDataItem) item.clone();\n            clone.data.add(cloneItem);\n        }\n    }\n    return clone;\n    \n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex >= this.data.size()) {\n        if (emptyRange) {\n            endIndex = this.data.size() - 1;\n        }\n        else {\n            endIndex = this.data.size() - 2;\n        }\n    }\n    TimeSeries clone = (TimeSeries) super.clone();\n    clone.data = new java.util.ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = startIndex; index <= endIndex; index++) {\n            TimeSeriesDataItem item \n                = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem cloneItem \n                = (TimeSeriesDataItem) item.clone();\n            clone.data.add(cloneItem);\n        }\n    }\n    return clone;\n    \n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex >= this.data.size()) {\n        if (emptyRange) {\n            endIndex = this.data.size() - 1;\n        }\n        else {\n            endIndex = this.data.size() - 2;\n        }\n    }\n    TimeSeries clone = (TimeSeries) super.clone();\n    clone.data = new java.util.ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = startIndex; index <= endIndex; index++) {\n            TimeSeriesDataItem item \n                = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem cloneItem \n                = (TimeSeriesDataItem) item.clone();\n            clone.data.add(cloneItem);\n        }\n    }\n    return clone;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\");",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex >= this.data.size()) {\n        if (emptyRange) {\n            endIndex = this.data.size() - 1;\n        }\n        else {\n            endIndex = this.data.size() - 2;\n        }\n    }\n    TimeSeries clone = (TimeSeries) super.clone();\n    clone.data = new java.util.ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = startIndex; index <= endIndex; index++) {\n            TimeSeriesDataItem item \n                = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem cloneItem \n                = (TimeSeriesDataItem) item.clone();\n            clone.data.add(cloneItem);\n        }\n    }\n    return clone;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex >= this.data.size()) {\n        if (emptyRange) {\n            endIndex = this.data.size() - 1;\n        }\n        else {\n            endIndex = this.data.size() - 2;\n        }\n    }\n    TimeSeries clone = (TimeSeries) super.clone();\n    clone.data = new java.util.ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = startIndex; index <= endIndex; index++) {\n            TimeSeriesDataItem item \n                = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem cloneItem \n                = (TimeSeriesDataItem) item.clone();\n            clone.data.add(cloneItem);\n        }\n    }\n    else {\n        clone.data.add(new TimeSeriesDataItem(end.getFirstMillisecond(), \n                end.getLastMillisecond()));\n    }\n    return clone;\n}\n\n/**\n * Tests the series for equality with another object.\n *\n * @param obj  the object (<code>null</code> permitted).\n *\n",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex >= this.data.size()) {\n        if (emptyRange) {\n            endIndex = this.data.size() - 1;\n        }\n        else {\n            endIndex = this.data.size() - 2;\n        }\n    }\n    TimeSeries clone = (TimeSeries) super.clone();\n    clone.data = new java.util.ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = startIndex; index <= endIndex; index++) {\n            TimeSeriesDataItem item \n                = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem cloneItem \n                = (TimeSeriesDataItem) item.clone();\n            clone.data.add(cloneItem);\n        }\n    }\n    return clone;\n    \n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex >= this.data.size()) {\n        if (emptyRange) {\n            endIndex = this.data.size() - 1;\n        }\n        else {\n            endIndex = this.data.size() - 2;\n        }\n    }\n    TimeSeries clone = (TimeSeries) super.clone();\n    clone.data = new java.util.ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = startIndex; index <= endIndex; index++) {\n            TimeSeriesDataItem item \n                = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem cloneItem \n                = (TimeSeriesDataItem) item.clone();\n            clone.data.add(cloneItem);\n        }\n    }\n    else {\n        clone.data.add(new TimeSeriesDataItem(end.getFirstMillisecond(), \n                end.getLastMillisecond()));\n    }\n    return clone;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex >= this.data.size()) {\n        if (emptyRange) {\n            endIndex = this.data.size() - 1;\n        }\n        else {\n            endIndex = this.data.size() - 2;\n        }\n    }\n    TimeSeries clone = (TimeSeries) super.clone();\n    clone.data = new java.util.ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = startIndex; index <= endIndex; index++) {\n            TimeSeriesDataItem item \n                = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem cloneItem \n                = (TimeSeriesDataItem) item.clone();\n            clone.data.add(cloneItem);\n        }\n    }\n    else {\n        clone.data.add(new TimeSeriesDataItem(end.getFirstMillisecond(), \n                end.getLastMillisecond()));\n    }\n    return clone;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the"
      ],
      "function range": "918,5-956,5"
    },
    "Chart_10_/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java_65-66": {
      "loc": "65-66",
      "input": "public String generateToolTipFragment(String toolTipText) {",
      "output": [
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class LocalSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class MaxAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    ",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregateFunctionDynamicDesc",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\n/**",
        "public String generateToolTipFragment(String toolTipText) {\n        return toolTipText;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAggregateDescriptor extends AbstractAggregateFunctionDynamic"
      ],
      "function range": "64,5-67,5"
    },
    "Chart_11_/source/org/jfree/chart/util/ShapeUtilities.java_275-276": {
      "loc": "275-276",
      "input": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);",
      "output": [
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        int type1 = iterator1.currentSegment(coords1);\n        int type2 = iterator2.currentSegment(coords2);\n        if (type1!= type2) {\n            return false;\n        }\n        if (type1 == SEG_LINETO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]) {\n                return false;\n            }\n        } else if (type1 == SEG_QUADTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]) {\n                return false;\n            }\n        } else if (type1 == SEG_CUBICTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]\n                    || coords1[4]!= coords2[4] || coords1[5]!= coords2[5]) {\n                return false;\n            }\n        } else if (type1 == SEG_MOVETO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= co",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] coords1 = new double[6];\n    double[] coords2 = new double[6];\n    while (!iterator1.isDone()) {\n        int type1 = iterator1.currentSegment(coords1);\n        int type2 = iterator2.currentSegment(coords2);\n        if (type1!= type2) {\n            return false;\n        }\n        if (type1 == SEG_LINETO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]) {\n                return false;\n            }\n        } else if (type1 == SEG_QUADTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]) {\n                return false;\n            }\n        } else if (type1 == SEG_CUBICTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]\n                    || coords1[4]!= coords2[4] || coords1[5]!= coords2[5]) {\n                return false;\n            }\n        } else if (type1 == SEG_MOVETO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= co",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        int type1 = iterator1.currentSegment(coords1);\n        int type2 = iterator2.currentSegment(coords2);\n        if (type1!= type2) {\n            return false;\n        }\n        if (type1 == SEG_LINETO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]) {\n                return false;\n            }\n        } else if (type1 == SEG_QUADTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]) {\n                return false;\n            }\n        } else if (type1 == SEG_CUBICTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]\n                    || coords1[4]!= coords2[4] || coords1[5]!= coords2[5]) {\n                return false;\n            }\n        } else if (type1 == SEG_CLOSE) {\n        } else {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n    ",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        int type1 = iterator1.currentSegment(coords1);\n        int type2 = iterator2.currentSegment(coords2);\n        if (type1!= type2) {\n            return false;\n        }\n        if (type1 == SEG_LINETO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]) {\n                return false;\n            }\n        } else if (type1 == SEG_QUADTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]) {\n                return false;\n            }\n        } else if (type1 == SEG_CUBICTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]\n                    || coords1[4]!= coords2[4] || coords1[5]!= coords2[5]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        int type1 = iterator1.currentSegment(coords1);\n        int type2 = iterator2.currentSegment(coords2);\n        if (type1!= type2) {\n            return false;\n        }\n        if (type1 == SEG_LINETO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]) {\n                return false;\n            }\n        } else if (type1 == SEG_QUADTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]) {\n                return false;\n            }\n        } else if (type1 == SEG_CUBICTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]\n                    || coords1[4]!= coords2[4] || coords1[5]!= coords2[5]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        int type1 = iterator1.currentSegment(coords1);\n        int type2 = iterator2.currentSegment(coords2);\n        if (type1!= type2) {\n            return false;\n        }\n        if (type1 == SEG_LINETO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]) {\n                return false;\n            }\n        } else if (type1 == SEG_QUADTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]) {\n                return false;\n            }\n        } else if (type1 == SEG_CUBICTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]\n                    || coords1[4]!= coords2[4] || coords1[5]!= coords2[5]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}\n\n}\n<|java|>/*\n * Copyright (c)",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] coords1 = new double[6];\n    double[] coords2 = new double[6];\n    while (!iterator1.isDone()) {\n        int type1 = iterator1.currentSegment(coords1);\n        int type2 = iterator2.currentSegment(coords2);\n        if (type1!= type2) {\n            return false;\n        }\n        if (type1 == SEG_LINETO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]) {\n                return false;\n            }\n        } else if (type1 == SEG_QUADTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]) {\n                return false;\n            }\n        } else if (type1 == SEG_CUBICTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]\n                    || coords1[4]!= coords2[4] || coords1[5]!= coords2[5]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}\n\n}\n<|java|>/*\n * Copyright (c)",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        int type1 = iterator1.currentSegment(coords1);\n        int type2 = iterator2.currentSegment(coords2);\n        if (type1!= type2) {\n            return false;\n        }\n        if (type1 == SEG_LINETO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]) {\n                return false;\n            }\n        } else if (type1 == SEG_QUADTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]) {\n                return false;\n            }\n        } else if (type1 == SEG_CUBICTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]\n                    || coords1[4]!= coords2[4] || coords1[5]!= coords2[5]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}\n}\n<|java|>/*\n * Copyright (c) 2015",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        int type1 = iterator1.currentSegment(coords1);\n        int type2 = iterator2.currentSegment(coords2);\n        if (type1!= type2) {\n            return false;\n        }\n        if (type1 == SEG_LINETO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]) {\n                return false;\n            }\n        } else if (type1 == SEG_QUADTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]) {\n                return false;\n            }\n        } else if (type1 == SEG_CUBICTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]\n                    || coords1[4]!= coords2[4] || coords1[5]!= coords2[5]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}\n}\n<|java|>/*\n * Copyright (c) 2008",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        int type1 = iterator1.currentSegment(coords1);\n        int type2 = iterator2.currentSegment(coords2);\n        if (type1!= type2) {\n            return false;\n        }\n        if (type1 == SEG_LINETO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]) {\n                return false;\n            }\n        } else if (type1 == SEG_QUADTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]) {\n                return false;\n            }\n        } else if (type1 == SEG_CUBICTO) {\n            if (coords1[0]!= coords2[0] || coords1[1]!= coords2[1]\n                    || coords1[2]!= coords2[2] || coords1[3]!= coords2[3]\n                    || coords1[4]!= coords2[4] || coords1[5]!= coords2[5]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}\n}\n<|java|>/*\n * Copyright (C) 2015"
      ],
      "function range": "264,5-296,5"
    },
    "Chart_12_/source/org/jfree/chart/plot/MultiplePiePlot.java_145-146": {
      "loc": "145-146",
      "input": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();",
      "output": [
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset for the plot.\n   *\n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset for the plot.\n   *\n   * @param dataset  the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the label generator.\n   *\n   * @return The label generator (never <code>null</code>).\n   *\n   * @see #setLabelGenerator(PieToolTipGenerator)\n   */\n  public PieToolTipGenerator getLabelGenerator() {\n    return this.labelGenerator;\n  }\n\n  /**\n   * Sets the label generator and sends a {@link PlotChangeEvent} to all\n   * registered listeners.\n   *\n   * @param generator  the generator (<code>null</code> not permitted).\n   *\n   * @see #getLabelGenerator()\n   */\n  public void setLabelGenerator(PieToolTipGenerator generator) {\n    if (generator == null) {\n      throw new IllegalArgumentException(\"Null 'generator' argument.\");\n    }\n    this.labelGenerator = generator;\n    fireChangeEvent();\n  }\n\n  /**\n   * Returns the legend label generator.\n   *\n   * @return The legend label generator (possibly <code>null</code>).\n   *\n   * @see #setLegendLabelGenerator(PieSectionLabelGenerator)\n   */\n  public PieSectionLabelGenerator getLegendLabelGenerator() {\n    return this.legendLabelGenerator;\n  }\n\n  /**\n   * Sets the legend label generator and sends a {@link PlotChangeEvent} to\n   * all registered listeners.\n   *\n   * @param generator  the generator (<code>null</code> permitted).\n   *\n   ",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset for the plot.\n   *\n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset for the plot.\n   *\n   * @param dataset  the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the label generator.\n   *\n   * @return The label generator (never <code>null</code>).\n   *\n   * @see #setLabelGenerator(PieToolTipGenerator)\n   */\n  public PieToolTipGenerator getLabelGenerator() {\n    return this.labelGenerator;\n  }\n\n  /**\n   * Sets the label generator and sends a {@link PlotChangeEvent} to all\n   * registered listeners.\n   *\n   * @param generator  the generator (<code>null</code> not permitted).\n   *\n   * @see #getLabelGenerator()\n   */\n  public void setLabelGenerator(PieToolTipGenerator generator) {\n    ParamChecks.nullNotPermitted(generator, \"generator\");\n    this.labelGenerator = generator;\n    fireChangeEvent();\n  }\n\n  /**\n   * Returns the legend label generator.\n   *\n   * @return The legend label generator (possibly <code>null</code>).\n   *\n   * @see #setLegendLabelGenerator(PieSectionLabelGenerator)\n   */\n  public PieSectionLabelGenerator getLegendLabelGenerator() {\n    return this.legendLabelGenerator;\n  }\n\n  /**\n   * Sets the legend label generator and sends a {@link PlotChangeEvent} to\n   * all registered listeners.\n   *\n   * @param generator  the generator (<code>null</code> permitted).\n   *\n   * @see #getLegendLabelGenerator()\n   ",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset for the plot.\n   * \n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset for the plot.\n   * \n   * @param dataset\n   *          the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the label generator.\n   * \n   * @return The label generator (never <code>null</code>).\n   * \n   * @see #setLabelGenerator(PieToolTipGenerator)\n   */\n  public PieToolTipGenerator getLabelGenerator() {\n    return this.labelGenerator;\n  }\n\n  /**\n   * Sets the label generator and sends a {@link RendererChangeEvent} to all\n   * registered listeners.\n   * \n   * @param generator\n   *          the generator (<code>null</code> not permitted).\n   * \n   * @see #getLabelGenerator()\n   */\n  public void setLabelGenerator(PieToolTipGenerator generator) {\n    if (generator == null) {\n      throw new IllegalArgumentException(\"Null 'generator' argument.\");\n    }\n    this.labelGenerator = generator;\n    fireChangeEvent();\n  }\n\n  /**\n   * Returns the legend label generator.\n   * \n   * @return The legend label generator (possibly <code>null</code>).\n   * \n   * @see #setLegendLabelGenerator(PieSectionLabelGenerator)\n   */\n  public PieSectionLabelGenerator getLegendLabelGenerator() {\n    return this.legendLabelGenerator;\n  }\n\n  /**\n   * Sets the legend label generator and sends a {@link RendererChangeEvent}\n   * to all registered listeners.\n   * \n   * @param generator",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset for the plot.\n   * \n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset for the plot.\n   * \n   * @param dataset\n   *          the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the label generator.\n   * \n   * @return The label generator (never <code>null</code>).\n   * \n   * @see #setLabelGenerator(PieToolTipGenerator)\n   */\n  public PieToolTipGenerator getLabelGenerator() {\n    return this.labelGenerator;\n  }\n\n  /**\n   * Sets the label generator and sends a {@link RendererChangeEvent} to all\n   * registered listeners.\n   * \n   * @param generator\n   *          the generator (<code>null</code> not permitted).\n   * \n   * @see #getLabelGenerator()\n   */\n  public void setLabelGenerator(PieToolTipGenerator generator) {\n    if (generator == null) {\n      throw new IllegalArgumentException(\"Null 'generator' argument.\");\n    }\n    this.labelGenerator = generator;\n    fireChangeEvent();\n  }\n\n  /**\n   * Returns the legend label generator.\n   * \n   * @return The legend label generator (possibly <code>null</code>).\n   * \n   * @see #setLegendLabelGenerator(PieSectionLabelGenerator)\n   */\n  public PieSectionLabelGenerator getLegendLabelGenerator() {\n    return this.legendLabelGenerator;\n  }\n\n  /**\n   * Sets the legend label generator and sends a {@link RendererChangeEvent} to\n   * all registered listeners.\n   * \n   * @param generator",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset for the plot.\n   *\n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset for the plot.\n   *\n   * @param dataset  the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the label generator.\n   *\n   * @return The label generator (never <code>null</code>).\n   */\n  public PieSectionLabelGenerator getLabelGenerator() {\n    return this.labelGenerator;\n  }\n\n  /**\n   * Sets the label generator.\n   *\n   * @param generator  the generator (<code>null</code> not permitted).\n   */\n  public void setLabelGenerator(PieSectionLabelGenerator generator) {\n    if (generator == null) {\n      throw new IllegalArgumentException(\"Null 'generator' argument.\");\n    }\n    this.labelGenerator = generator;\n  }\n\n  /**\n   * Returns the maximum label width.\n   *\n   * @return The maximum label width.\n   */\n  public float getMaximumLabelWidth() {\n    return this.maximumLabelWidth;\n  }\n\n  /**\n   * Sets the maximum label width.\n   *\n   * @param width  the width.\n   */\n  public void setMaximumLabelWidth(float width) {\n    this.maximumLabelWidth = width;\n  }\n\n  /**\n   * Returns the minimum label width.\n   *\n   * @return The minimum label width.\n   */\n  public float getMinimumLabelWidth() {\n    return this.minimumLabelWidth;\n  }\n\n  /**\n   * Sets the minimum label width.\n   *\n   * @param width  the width.\n   */\n  public void setMinimumLabelWidth(float width) {\n    this.",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset for the plot.\n   * \n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset for the plot.\n   * \n   * @param dataset\n   *          the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the label generator.\n   * \n   * @return The label generator (never <code>null</code>).\n   * \n   * @see #setLabelGenerator(PieToolTipGenerator)\n   */\n  public PieToolTipGenerator getLabelGenerator() {\n    return this.labelGenerator;\n  }\n\n  /**\n   * Sets the label generator and sends a {@link RendererChangeEvent} to all\n   * registered listeners.\n   * \n   * @param generator\n   *          the generator (<code>null</code> not permitted).\n   * \n   * @see #getLabelGenerator()\n   */\n  public void setLabelGenerator(PieToolTipGenerator generator) {\n    if (generator == null) {\n      throw new IllegalArgumentException(\"Null 'generator' argument.\");\n    }\n    this.labelGenerator = generator;\n    fireChangeEvent();\n  }\n\n  /**\n   * Returns the legend label generator.\n   * \n   * @return The legend label generator (possibly <code>null</code>).\n   * \n   * @see #setLegendLabelGenerator(PieSectionLabelGenerator)\n   */\n  public PieSectionLabelGenerator getLegendLabelGenerator() {\n    return this.legendLabelGenerator;\n  }\n\n  /**\n   * Sets the legend label generator and sends a\n   * {@link RendererChangeEvent} to all registered listeners.\n   * \n   * @param generator",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset for the plot.\n   *\n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset for the plot.\n   *\n   * @param dataset  the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the label generator.\n   *\n   * @return The label generator (never <code>null</code>).\n   *\n   * @see #setLabelGenerator(PieToolTipGenerator)\n   */\n  public PieToolTipGenerator getLabelGenerator() {\n    return this.labelGenerator;\n  }\n\n  /**\n   * Sets the label generator and sends a {@link PlotChangeEvent} to all\n   * registered listeners.\n   *\n   * @param generator  the generator (<code>null</code> not permitted).\n   *\n   * @see #getLabelGenerator()\n   */\n  public void setLabelGenerator(PieToolTipGenerator generator) {\n    if (generator == null) {\n      throw new IllegalArgumentException(\"Null 'generator' argument.\");\n    }\n    this.labelGenerator = generator;\n    fireChangeEvent();\n  }\n\n  /**\n   * Returns the legend label generator.\n   *\n   * @return The legend label generator (possibly <code>null</code>).\n   *\n   * @see #setLegendLabelGenerator(PieSectionLabelGenerator)\n   */\n  public PieSectionLabelGenerator getLegendLabelGenerator() {\n    return this.legendLabelGenerator;\n  }\n\n  /**\n   * Sets the legend label generator and sends a {@link PlotChangeEvent} to all\n   * registered listeners.\n   *\n   * @param generator  the generator (<code>null</code> permitted).\n   *\n   ",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset for the plot.\n   * \n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset for the plot.\n   * \n   * @param dataset\n   *          the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the label generator.\n   * \n   * @return The label generator (never <code>null</code>).\n   */\n  public PieSectionLabelGenerator getLabelGenerator() {\n    return this.labelGenerator;\n  }\n\n  /**\n   * Sets the label generator.\n   * \n   * @param generator\n   *          the generator (<code>null</code> not permitted).\n   */\n  public void setLabelGenerator(PieSectionLabelGenerator generator) {\n    if (generator == null) {\n      throw new IllegalArgumentException(\"Null 'generator' argument.\");\n    }\n    this.labelGenerator = generator;\n  }\n\n  /**\n   * Returns the maximum label width.\n   * \n   * @return The maximum label width.\n   */\n  public float getMaximumLabelWidth() {\n    return this.maximumLabelWidth;\n  }\n\n  /**\n   * Sets the maximum label width.\n   * \n   * @param width\n   *          the width.\n   */\n  public void setMaximumLabelWidth(float width) {\n    this.maximumLabelWidth = width;\n  }\n\n  /**\n   * Returns the minimum label width.\n   * \n   * @return The minimum label width.\n   */\n  public float getMinimumLabelWidth() {\n    return this.minimumLabelWidth;\n  }\n\n  /**\n   * Sets the minimum label width.\n   * \n   * @param width\n   *          the width.",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset for the plot.\n   *\n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset for the plot.\n   *\n   * @param dataset  the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the label generator.\n   *\n   * @return The label generator (never <code>null</code>).\n   *\n   * @see #setLabelGenerator(PieToolTipGenerator)\n   */\n  public PieToolTipGenerator getLabelGenerator() {\n    return this.labelGenerator;\n  }\n\n  /**\n   * Sets the label generator and sends a {@link PlotChangeEvent} to all\n   * registered listeners.\n   *\n   * @param generator  the generator (<code>null</code> not permitted).\n   *\n   * @see #getLabelGenerator()\n   */\n  public void setLabelGenerator(PieToolTipGenerator generator) {\n    if (generator == null) {\n      throw new IllegalArgumentException(\"Null 'generator' argument.\");\n    }\n    this.labelGenerator = generator;\n    fireChangeEvent();\n  }\n\n  /**\n   * Returns the legend label generator.\n   *\n   * @return The legend label generator (possibly <code>null</code>).\n   *\n   * @see #setLegendLabelGenerator(PieToolTipGenerator)\n   */\n  public PieToolTipGenerator getLegendLabelGenerator() {\n    return this.legendLabelGenerator;\n  }\n\n  /**\n   * Sets the legend label generator and sends a {@link PlotChangeEvent} to\n   * all registered listeners.\n   *\n   * @param generator  the generator (<code>null</code> permitted).\n   *\n   ",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset for the plot.\n   * \n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset for the plot.\n   * \n   * @param dataset\n   *          the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the label generator.\n   * \n   * @return The label generator (never <code>null</code>).\n   * \n   * @see #setLabelGenerator(PieToolTipGenerator)\n   */\n  public PieToolTipGenerator getLabelGenerator() {\n    return this.labelGenerator;\n  }\n\n  /**\n   * Sets the label generator and sends a {@link RendererChangeEvent} to all\n   * registered listeners.\n   * \n   * @param generator\n   *          the generator (<code>null</code> not permitted).\n   * \n   * @see #getLabelGenerator()\n   */\n  public void setLabelGenerator(PieToolTipGenerator generator) {\n    ParamChecks.nullNotPermitted(generator, \"generator\");\n    this.labelGenerator = generator;\n    fireChangeEvent();\n  }\n\n  /**\n   * Returns the legend label generator.\n   * \n   * @return The legend label generator (possibly <code>null</code>).\n   * \n   * @see #setLegendLabelGenerator(PieSectionLabelGenerator)\n   */\n  public PieSectionLabelGenerator getLegendLabelGenerator() {\n    return this.legendLabelGenerator;\n  }\n\n  /**\n   * Sets the legend label generator and sends a {@link RendererChangeEvent}\n   * to all registered listeners.\n   * \n   * @param generator\n   *          the generator (<code>null</code"
      ],
      "function range": "143,5-158,5"
    },
    "Chart_13_/source/org/jfree/chart/block/BorderArrangement.java_455-456": {
      "loc": "455-456",
      "input": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock != null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock != null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock != null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock != null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,",
      "output": [
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth() - w[2]),\n                LengthConstraintType.RANGE, h[2], null,\n",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0, null,\n                LengthConstraintType.RANGE, h[2], new Range(0.0,\n                constraint.getWidth() - w[2",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstr",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0, null,\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size =",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()\n                - w[2]), LengthConstraintType.RANGE, h[2], null,\n",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0, null,\n                LengthConstraintType.RANGE, h[2], new Range(0.0,\n                constraint.getWidth() - w[0",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0,\n                constraint.getWidth() - w[2]), LengthConstraintType.RANGE,\n                h[2], null",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0, null,\n                LengthConstraintType.RANGE, h[2],\n                new Range(0.0, constraint.getWidth() - w[2]),\n",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0, null,\n                LengthConstraintType.FIXED, h[2], new Range(0.0,\n                constraint.getWidth() - w[2",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                new Range(0.0,\n                constraint.getWidth() - w[2]), LengthConstraintType.RANGE,\n                h[2"
      ],
      "function range": "422,5-489,5"
    },
    "Chart_17_/source/org/jfree/data/time/TimeSeries.java_857-858": {
      "loc": "857-858",
      "input": "public Object clone() throws CloneNotSupportedException {",
      "output": [
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long serial",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class LocalSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long serialVersion",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class MaxAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long serialVersionUID",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\n/**",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org",
        "public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n"
      ],
      "function range": "856,5-859,5"
    },
    "Chart_20_/source/org/jfree/chart/plot/ValueMarker.java_95-96": {
      "loc": "95-96",
      "input": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {",
      "output": [
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (never <code>null</code>).\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke (never <code>null</code>).\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint (possibly <code>null</code>).\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke (possibly <code>null</code>).\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha.\n     *\n     * @return The alpha.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @param value  the value.\n     */\n    public void setValue(double value) {\n        this.value = value;\n    }\n\n    /**\n     * Sets the paint.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     */\n    public void setPaint(Paint paint) {\n        this.paint",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (never <code>null</code>).\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke (never <code>null</code>).\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint (possibly <code>null</code>).\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke (possibly <code>null</code>).\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha.\n     *\n     * @return The alpha.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @param value  the value.\n     */\n    public void setValue(double value) {\n        this.value = value;\n    }\n\n    /**\n     * Sets the paint.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     */\n    public void setPaint(Paint paint) {\n        if (p",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (never <code>null</code>).\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke (never <code>null</code>).\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The paint (possibly <code>null</code>).\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The stroke (possibly <code>null</code>).\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha.\n     *\n     * @return The alpha.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @param value  the value.\n     */\n    public void setValue(double value) {\n        this.value = value;\n    }\n\n    /**\n     * Sets the paint.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     */\n    public void setPaint(Paint paint) {\n        this.paint = paint",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    public double getValue() {\n        return this.value;\n    }\n\n    public void setValue(double value) {\n        this.value = value;\n    }\n\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    public void setPaint(Paint paint) {\n        this.paint = paint;\n    }\n\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    public void setStroke(Stroke stroke) {\n        this.stroke = stroke;\n    }\n\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    public void setOutlinePaint(Paint paint) {\n        this.outlinePaint = paint;\n    }\n\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    public void setOutlineStroke(Stroke stroke) {\n        this.outlineStroke = stroke;\n    }\n\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    public void setAlpha(float alpha) {\n        this.alpha = alpha;\n    }\n\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof ValueMarker)) {\n            return false;\n        }\n        ValueMarker that = (ValueMarker) obj;\n        if (this.value!= that.value) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.paint, that.paint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.stroke, that.",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (never <code>null</code>).\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke (never <code>null</code>).\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint (possibly <code>null</code>).\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke (possibly <code>null</code>).\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha.\n     *\n     * @return The alpha.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Tests this instance for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof ValueMarker)) {\n            return false;\n        }\n        ",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (never <code>null</code>).\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke (never <code>null</code>).\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The paint (possibly <code>null</code>).\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The stroke (possibly <code>null</code>).\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha.\n     *\n     * @return The alpha.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @param value  the value.\n     */\n    public void setValue(double value) {\n        this.value = value;\n    }\n\n    /**\n     * Sets the paint.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     */\n    public void setPaint(Paint paint) {\n        if (paint ==",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (never <code>null</code>).\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke (never <code>null</code>).\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint (possibly <code>null</code>).\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke (possibly <code>null</code>).\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns the alpha.\n     *\n     * @return The alpha.\n     */\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @param value  the value.\n     */\n    public void setValue(double value) {\n        this.value = value;\n    }\n\n    /**\n     * Sets the paint.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     */\n    public void setPaint(Paint paint) {\n        ParamChecks",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n    this.value = value;\n    this.paint = paint;\n    this.stroke = stroke;\n    this.outlinePaint = outlinePaint;\n    this.outlineStroke = outlineStroke;\n    this.alpha = alpha;\n  }\n\n  /**\n   * Returns the value.\n   *\n   * @return The value.\n   */\n  public double getValue() {\n    return this.value;\n  }\n\n  /**\n   * Returns the paint.\n   *\n   * @return The paint (never <code>null</code>).\n   */\n  public Paint getPaint() {\n    return this.paint;\n  }\n\n  /**\n   * Returns the stroke.\n   *\n   * @return The stroke (never <code>null</code>).\n   */\n  public Stroke getStroke() {\n    return this.stroke;\n  }\n\n  /**\n   * Returns the outline paint.\n   *\n   * @return The paint (possibly <code>null</code>).\n   */\n  public Paint getOutlinePaint() {\n    return this.outlinePaint;\n  }\n\n  /**\n   * Returns the outline stroke.\n   *\n   * @return The stroke (possibly <code>null</code>).\n   */\n  public Stroke getOutlineStroke() {\n    return this.outlineStroke;\n  }\n\n  /**\n   * Returns the alpha.\n   *\n   * @return The alpha.\n   */\n  public float getAlpha() {\n    return this.alpha;\n  }\n\n  /**\n   * Sets the value.\n   *\n   * @param value  the value.\n   */\n  public void setValue(double value) {\n    this.value = value;\n  }\n\n  /**\n   * Sets the paint.\n   *\n   * @param paint  the paint (<code>null</code> permitted).\n   */\n  public void setPaint(Paint paint) {\n    this.paint = paint",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n    this.value = value;\n    this.paint = paint;\n    this.stroke = stroke;\n    this.outlinePaint = outlinePaint;\n    this.outlineStroke = outlineStroke;\n    this.alpha = alpha;\n  }\n\n  /**\n   * Returns the value.\n   *\n   * @return The value.\n   */\n  public double getValue() {\n    return this.value;\n  }\n\n  /**\n   * Returns the paint.\n   *\n   * @return The paint (never <code>null</code>).\n   */\n  public Paint getPaint() {\n    return this.paint;\n  }\n\n  /**\n   * Returns the stroke.\n   *\n   * @return The stroke (never <code>null</code>).\n   */\n  public Stroke getStroke() {\n    return this.stroke;\n  }\n\n  /**\n   * Returns the outline paint.\n   *\n   * @return The paint (possibly <code>null</code>).\n   */\n  public Paint getOutlinePaint() {\n    return this.outlinePaint;\n  }\n\n  /**\n   * Returns the outline stroke.\n   *\n   * @return The stroke (possibly <code>null</code>).\n   */\n  public Stroke getOutlineStroke() {\n    return this.outlineStroke;\n  }\n\n  /**\n   * Returns the alpha.\n   *\n   * @return The alpha.\n   */\n  public float getAlpha() {\n    return this.alpha;\n  }\n\n  /**\n   * Sets the value.\n   *\n   * @param value  the value.\n   */\n  public void setValue(double value) {\n    this.value = value;\n  }\n\n  /**\n   * Sets the paint.\n   *\n   * @param paint  the paint (<code>null</code> not permitted).\n   */\n  public void setPaint(Paint paint) {\n    if (paint ==",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    public double getValue() {\n        return this.value;\n    }\n\n    public void setValue(double value) {\n        this.value = value;\n    }\n\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    public void setPaint(Paint paint) {\n        this.paint = paint;\n    }\n\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    public void setStroke(Stroke stroke) {\n        this.stroke = stroke;\n    }\n\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    public void setOutlinePaint(Paint outlinePaint) {\n        this.outlinePaint = outlinePaint;\n    }\n\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    public void setOutlineStroke(Stroke outlineStroke) {\n        this.outlineStroke = outlineStroke;\n    }\n\n    public float getAlpha() {\n        return this.alpha;\n    }\n\n    public void setAlpha(float alpha) {\n        this.alpha = alpha;\n    }\n\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof ValueMarker)) {\n            return false;\n        }\n        ValueMarker that = (ValueMarker) obj;\n        if (this.value!= that.value) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.paint, that.paint)) {\n            return false;\n        }\n        if (!ObjectUt"
      ],
      "function range": "93,5-97,5"
    },
    "Chart_24_/source/org/jfree/chart/renderer/GrayPaintScale.java_126-127": {
      "loc": "126-127",
      "input": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);",
      "output": [
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    if (v == this.lowerBound) {\n      return this.lowerPaint;\n    }\n    else if (v == this.upperBound) {\n      return this.upperPaint;\n    }\n    else {\n      double fraction = (v - this.lowerBound) / (this.upperBound - this.lowerBound);\n      Color c1 = this.lowerPaint.interpolate(this.upperPaint, fraction);\n      Color c2 = this.upperPaint.interpolate(this.lowerPaint, 1 - fraction);\n      return new LinearGradientPaint(new Point2D.Double(0.0, 0.0),\n                                     new Point2D.Double(1.0, 1.0),\n                                     new float[] { 0.0f, 1.0f },\n                                     new Color[] { c1, c2 },\n                                     MultipleGradientPaint.CycleMethod.NO_CYCLE);\n    }\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    if (v == this.lowerBound) {\n      return this.lowerPaint;\n    }\n    else if (v == this.upperBound) {\n      return this.upperPaint;\n    }\n    else {\n      double fraction = (v - this.lowerBound) / (this.upperBound - this.lowerBound);\n      Color c1 = this.lowerPaint.interpolate(this.upperPaint, fraction);\n      Color c2 = this.upperPaint.interpolate(this.lowerPaint, 1 - fraction);\n      return new LinearGradientPaint(new Point2D.Double(0.0, 0.0),\n                                     new Point2D.Double(1.0, 1.0),\n                                     new float[] { 0.0f, 1.0f },\n                                     new Color[] { c1, c2 },\n                                     MultipleGradientPaint.CycleMethod.NO_CYCLE);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.flink.runtime.rest.messages;\n\nimport org.apache.flink.runtime.rest.HttpMethodWrapper;\nimport org.apache",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    if (v == this.lowerBound) {\n      return this.lowerPaint;\n    }\n    else if (v == this.upperBound) {\n      return this.upperPaint;\n    }\n    else {\n      double fraction = (v - this.lowerBound) / (this.upperBound - this.lowerBound);\n      Color c1 = this.lowerPaint.interpolate(this.upperPaint, fraction);\n      Color c2 = this.upperPaint.interpolate(this.lowerPaint, 1 - fraction);\n      return new LinearGradientPaint(new Point2D.Double(0.0, 0.0),\n                                     new Point2D.Double(1.0, 1.0),\n                                     new float[] { 0.0f, 1.0f },\n                                     new Color[] { c1, c2 },\n                                     MultipleGradientPaint.CycleMethod.NO_CYCLE);\n    }\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.flink.runtime.rest.messages;\n\nimport org.apache.flink.runtime.rest.HttpMethodWrapper;\nimport org.",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    if (v == this.lowerBound) {\n      return this.lowerPaint;\n    }\n    else if (v == this.upperBound) {\n      return this.upperPaint;\n    }\n    else {\n      double fraction = (v - this.lowerBound) / (this.upperBound - this.lowerBound);\n      Color c1 = this.lowerPaint.interpolate(this.upperPaint, fraction);\n      Color c2 = this.upperPaint.interpolate(this.lowerPaint, 1 - fraction);\n      return new LinearGradientPaint(new Point2D.Double(0.0, 0.0),\n                                     new Point2D.Double(1.0, 1.0),\n                                     new float[] { 0.0f, 1.0f },\n                                     new Color[] { c1, c2 },\n                                     MultipleGradientPaint.CycleMethod.NO_CYCLE);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.flink.table.planner.plan.nodes.exec.stream;\n\nimport org.apache.flink.api.dag.Transformation",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    if (v == this.lowerBound) {\n      return this.lowerPaint;\n    }\n    else if (v == this.upperBound) {\n      return this.upperPaint;\n    }\n    else {\n      double fraction = (v - this.lowerBound) / (this.upperBound - this.lowerBound);\n      Color c1 = this.lowerPaint.interpolate(this.upperPaint, fraction);\n      Color c2 = this.upperPaint.interpolate(this.lowerPaint, 1 - fraction);\n      return new LinearGradientPaint(new Point2D.Double(0.0, 0.0),\n                                     new Point2D.Double(1.0, 1.0),\n                                     new float[] { 0.0f, 1.0f },\n                                     new Color[] { c1, c2 },\n                                     MultipleGradientPaint.CycleMethod.NO_CYCLE);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.flink.table.planner.plan.nodes.exec.batch;\n\nimport org.apache.flink.api.dag.Transformation",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    if (v == this.lowerBound) {\n      return this.lowerPaint;\n    }\n    else if (v == this.upperBound) {\n      return this.upperPaint;\n    }\n    else {\n      double fraction = (v - this.lowerBound) / (this.upperBound - this.lowerBound);\n      Color c1 = this.lowerPaint.interpolate(this.upperPaint, fraction);\n      Color c2 = this.upperPaint.interpolate(this.lowerPaint, 1 - fraction);\n      return new LinearGradientPaint(new Point2D.Double(0.0, 0.0),\n                                     new Point2D.Double(1.0, 1.0),\n                                     new float[] { 0.0f, 1.0f },\n                                     new Color[] { c1, c2 },\n                                     MultipleGradientPaint.CycleMethod.NO_CYCLE);\n    }\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.flink.table.planner.plan.nodes.exec.stream;\n\nimport org.apache.flink.api.dag.Trans",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    if (v == this.lowerBound) {\n      return this.lowerPaint;\n    }\n    else if (v == this.upperBound) {\n      return this.upperPaint;\n    }\n    else {\n      double fraction = (v - this.lowerBound) / (this.upperBound - this.lowerBound);\n      Color c1 = this.lowerPaint.interpolate(this.upperPaint, fraction);\n      Color c2 = this.upperPaint.interpolate(this.lowerPaint, 1 - fraction);\n      return new LinearGradientPaint(new Point2D.Double(0.0, 0.0),\n                                     new Point2D.Double(1.0, 1.0),\n                                     new float[] { 0.0f, 1.0f },\n                                     new Color[] { c1, c2 },\n                                     MultipleGradientPaint.CycleMethod.NO_CYCLE);\n    }\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.common.type",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    if (v == this.lowerBound) {\n      return this.lowerPaint;\n    }\n    else if (v == this.upperBound) {\n      return this.upperPaint;\n    }\n    else {\n      double fraction = (v - this.lowerBound) / (this.upperBound - this.lowerBound);\n      Color c1 = this.lowerPaint.interpolate(this.upperPaint, fraction);\n      Color c2 = this.upperPaint.interpolate(this.lowerPaint, 1 - fraction);\n      return new LinearGradientPaint(new Point2D.Double(0.0, 0.0),\n                                     new Point2D.Double(1.0, 1.0),\n                                     new float[] { 0.0f, 1.0f },\n                                     new Color[] { c1, c2 },\n                                     MultipleGradientPaint.CycleMethod.NO_CYCLE);\n    }\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.flink.runtime.rest.messages.job.metrics;\n\nimport org.apache.flink.runtime.rest.messages.Message",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    if (v == this.lowerBound) {\n      return this.lowerPaint;\n    }\n    else if (v == this.upperBound) {\n      return this.upperPaint;\n    }\n    else {\n      double fraction = (v - this.lowerBound) / (this.upperBound - this.lowerBound);\n      Color c1 = this.lowerPaint.interpolate(this.upperPaint, fraction);\n      Color c2 = this.upperPaint.interpolate(this.lowerPaint, 1 - fraction);\n      return new LinearGradientPaint(new Point2D.Double(0.0, 0.0),\n                                     new Point2D.Double(1.0, 1.0),\n                                     new float[] { 0.0f, 1.0f },\n                                     new Color[] { c1, c2 },\n                                     MultipleGradientPaint.CycleMethod.NO_CYCLE);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.flink.runtime.rest.messages.job.metrics;\n\nimport org.apache.flink.runtime.rest.messages.RestResponse",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    if (v == this.lowerBound) {\n      return this.lowerPaint;\n    }\n    else if (v == this.upperBound) {\n      return this.upperPaint;\n    }\n    else {\n      double fraction = (v - this.lowerBound) / (this.upperBound - this.lowerBound);\n      Color c1 = this.lowerPaint.interpolate(this.upperPaint, fraction);\n      Color c2 = this.upperPaint.interpolate(this.lowerPaint, 1 - fraction);\n      return new LinearGradientPaint(new Point2D.Double(0.0, 0.0),\n                                     new Point2D.Double(1.0, 1.0),\n                                     new float[] { 0.0f, 1.0f },\n                                     new Color[] { c1, c2 },\n                                     MultipleGradientPaint.CycleMethod.NO_CYCLE);\n    }\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.flink.runtime.rest.messages.job.metrics;\n\nimport org.apache.flink.runtime.rest.messages.Rest"
      ],
      "function range": "123,5-129,5"
    },
    "Cli_4_/src/java/org/apache/commons/cli/Parser.java_298-299": {
      "loc": "298-299",
      "input": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();",
      "output": [
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEval",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateE",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTask",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScal",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalar",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyE",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScal"
      ],
      "function range": "290,5-309,5"
    },
    "Cli_8_/src/java/org/apache/commons/cli/HelpFormatter.java_812-813": {
      "loc": "812-813",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();",
      "output": [
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDesc",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescript",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractSc",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.common.annotations.MissingNullInOutFunction;\nimport org.apache.asterix.om.functions.BuiltinFunctions;\n",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.formats.nontagged.AqlSerializerDeserializerProvider;\nimport org.apache.asterix.om.base.ABoo"
      ],
      "function range": "792,5-823,5"
    },
    "Cli_11_/src/java/org/apache/commons/cli/HelpFormatter.java_632-633": {
      "loc": "632-633",
      "input": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt() != null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }",
      "output": [
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n    buff.append(\" \");\n    if (option.hasArg())\n    {\n        buff.append(\"<\").append(option.getArgName()).append(\">\");\n    }\n    else\n    {\n        buff.append(\"<no value>\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.al",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n    buff.append(\" \");\n    if (option.hasArg())\n    {\n        buff.append(\"<\").append(option.getArgName()).append(\">\");\n    }\n    else\n    {\n        buff.append(\"<no value>\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n    buff.append(\" \");\n    if (option.hasArg())\n    {\n        buff.append(\"<\").append(option.getArgName()).append(\">\");\n    }\n    else\n    {\n        buff.append(\"<no value>\");\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n    buff.append(\" \");\n    if (option.hasArg())\n    {\n        buff.append(\"<\").append(option.getArgName()).append(\">\");\n    }\n    else\n    {\n        buff.append(\"<no value>\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n    buff.append(\" \");\n    if (option.hasArg())\n    {\n        buff.append(\"<\").append(option.getArgName()).append(\">\");\n    }\n    else\n    {\n        buff.append(\"<no value>\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractSc",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n    buff.append(\" \");\n    if (option.hasArg())\n    {\n        buff.append(\"<\").append(option.getArgName()).append(\">\");\n    }\n    else\n    {\n        buff.append(\"<no value>\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.asterix.",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n    buff.append(\" \");\n    if (option.hasArg())\n    {\n        buff.append(\"<\").append(option.getArgName()).append(\">\");\n    }\n    else\n    {\n        buff.append(\"<no value>\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n    buff.append(\" \");\n    if (option.hasArg())\n    {\n        buff.append(\"<\").append(option.getArgName()).append(\">\");\n    }\n    else\n    {\n        buff.append(\"<no value>\");\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScal",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n    buff.append(\" \");\n    if (option.hasArg())\n    {\n        buff.append(\"<\").append(option.getArgName()).append(\">\");\n    }\n    else\n    {\n        buff.append(\"<no value>\");\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.asterix.runtime",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n    buff.append(\" \");\n    if (option.hasArg())\n    {\n        buff.append(\"<\").append(option.getArgName()).append(\">\");\n    }\n    else\n    {\n        buff.append(\"<no value>\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport"
      ],
      "function range": "613,5-642,5"
    },
    "Cli_24_/src/java/org/apache/commons/cli/HelpFormatter.java_825-827": {
      "loc": "825-827",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {",
      "output": [
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.al",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.AsterixBuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evalu",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.AsterixBuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractSc",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.common.annotations.MissingNullInOutFunction;\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescript",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.pointables.nonvis"
      ],
      "function range": "809,5-852,5"
    },
    "Cli_25_/src/java/org/apache/commons/cli/HelpFormatter.java_825-826": {
      "loc": "825-826",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {",
      "output": [
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.al",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.AsterixBuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evalu",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.AsterixBuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractSc",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.common.annotations.MissingNullInOutFunction;\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescript",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        sb.append(defaultNewLine);\n    }\n    else\n    {\n        for (int i = 0; i < nextLineTabStop; i++)\n        {\n            sb.append(' ');\n        }\n        sb.append(defaultNewLine);\n    }\n    return renderWrappedText(sb, width, nextLineTabStop, \n                             text.substring(pos));\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.pointables.nonvis"
      ],
      "function range": "809,5-851,5"
    },
    "Cli_28_/src/java/org/apache/commons/cli/Parser.java_290-291": {
      "loc": "290-291",
      "input": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {",
      "output": [
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.h",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions.records;\n\nimport java.io.DataOutput;\n",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\n\nimport org",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.IOException;\n\nimport org",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.*;\nimport org.apache.ignite.cache",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                try\n                {\n                    opt.addValueForProcessing(value);\n                }\n                catch (RuntimeException exp)\n                {\n                }\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.cache.CacheAtomicityMode;\nimport org"
      ],
      "function range": "252,5-296,5"
    },
    "Cli_32_/src/main/java/org/apache/commons/cli/HelpFormatter.java_937-942": {
      "loc": "937-942",
      "input": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n            && (c != '\\n') && (c != '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;",
      "output": [
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos < text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos < text.length())\n    {\n        return pos;\n    }\n    else\n    {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos < text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos < text.length())\n    {\n        return pos;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos < text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos < text.length())\n    {\n        return pos;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos < text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos < text.length())\n    {\n        return pos;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.agg",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos < text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos < text.length())\n    {\n        return pos;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos < text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos < text.length())\n    {\n        return pos;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache.distributed.",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos < text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos < text.length())\n    {\n        return pos;\n    }\n    return -1;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evalu",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos < text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos < text.length())\n    {\n        return pos;\n    }\n    return -1;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggreg",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos < text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos < text.length())\n    {\n        return pos;\n    }\n    else\n    {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.vfs",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos < text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos < text.length())\n    {\n        return pos;\n    }\n    else\n    {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math3"
      ],
      "function range": "902,5-943,5"
    },
    "Cli_40_/src/main/java/org/apache/commons/cli/TypeHandler.java_103-104": {
      "loc": "103-104",
      "input": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {",
      "output": [
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\"",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\"",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\"",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BAS",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \""
      ],
      "function range": "62,5-105,5"
    },
    "Closure_1_/src/com/google/javascript/jscomp/RemoveUnusedVars.java_379-380": {
      "loc": "379-380",
      "input": "private void removeUnreferencedFunctionArgs(Scope fnScope) {",
      "output": [
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refCollection = fnScope.getReferences(arg);\n      if (refCollection.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refs = fnScope.getReferences(arg);\n      if (refs.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refCollection = fnScope.getReferences(arg);\n      if (refCollection.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalar",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refCollection = fnScope.getReferences(arg);\n      if (refCollection.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\n",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refs = fnScope.getReferences(arg);\n      if (refs.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalar",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refs = fnScope.getReferences(arg);\n      if (refs.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\n",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refCollection = fnScope.getReferences(arg);\n      if (refCollection.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refCollection = fnScope.getReferences(arg);\n      if (refCollection.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refs = fnScope.getReferences(arg);\n      if (refs.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refCollection = fnScope.getReferences(arg);\n      if (refCollection.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEval"
      ],
      "function range": "369,3-406,3"
    },
    "Closure_5_/src/com/google/javascript/jscomp/InlineObjectLiterals.java_176-177": {
      "loc": "176-177",
      "input": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }",
      "output": [
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return ret;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return ret;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  ret = true;\n  return ret;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  ret = true;\n  return ret;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  ret = true;\n  return ret;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  ret = true;\n  return ret;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  ret = true;\n  return ret;\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  ret = true;\n  return ret;\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return ret;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return ret;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You"
      ],
      "function range": "155,5-253,5"
    },
    "Closure_10_/src/com/google/javascript/jscomp/NodeUtil.java_1417-1418": {
      "loc": "1417-1418",
      "input": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {",
      "output": [
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n    case Token.NULL:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS:\n    case Token.NEG:\n      return true;\n    default:\n      return false;\n  }\n}\n\n  /**\n   * Returns true if the operator is associative.\n   * e.g. (a * b) * c = a * (b * c)\n   * Note: \"+\" is not associative because it is also the concatenation\n   * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n   */\n  static boolean isAssociative(int type) {\n    switch (type) {\n      case Token.MUL:\n      case Token.AND:\n      case Token.OR:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Returns true if the operator is commutative.\n   * e.g. (a * b) * c = c * (b * a)\n   * Note 1: \"+\" is not commutative because it is also the concatenation\n   * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n   * Note 2: only operations on literals and pure functions are commutative.\n   */\n  static boolean isCommutative(int type) {\n    switch (type) {\n      case Token.MUL:\n      case Token.BITOR:\n      case",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n    case Token.NULL:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS:\n    case Token.NEG:\n      return true;\n    default:\n      return false;\n  }\n}\n\n  /**\n   * Returns true if the operator is associative.\n   * e.g. (a * b) * c = a * (b * c)\n   * Note: \"+\" is not associative because it is also the concatenation\n   * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n   */\n  static boolean isAssociative(int type) {\n    switch (type) {\n      case Token.MUL:\n      case Token.AND:\n      case Token.OR:\n      case Token.BITOR:\n      case Token.BITAND:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Returns true if the operator is commutative.\n   * e.g. (a * b) * c = c * (b * a)\n   * Note 1: \"+\" is not commutative because it is also the concatenation\n   * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n   * Note 2: only operations on literals and pure functions are commutative.\n   */\n  static boolean isCommutative(int type) {\n    switch (type) {\n      case Token.MUL:\n      case Token.BITOR:\n      case Token.BITAND:\n        return true",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n    case Token.NULL:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS:\n    case Token.NEG:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Returns true if the operator is associative.\n * e.g. (a * b) * c = a * (b * c)\n * Note: \"+\" is not associative because it is also the concatenation\n * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n *\n * @param op The operator.\n * @return Whether the operator is associative.\n */\nstatic boolean isAssociative(int op) {\n  switch (op) {\n    case Token.MUL:\n    case Token.AND:\n    case Token.OR:\n    case Token.BITOR:\n    case Token.BITAND:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Returns true if the operator is commutative.\n * e.g. (a * b) * c = c * (b * a)\n * Note 1: \"+\" is not commutative because it is also the concatenation\n * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n * Note 2: only operations on literals and pure functions are commutative.\n *\n * @param op The operator.\n * @return Whether the operator is commutative.\n */\nstatic boolean isCommutative(int op) {\n  switch (op)",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n    case Token.NULL:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS:\n    case Token.NEG:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * Returns true if the operator is associative.\n * e.g. (a * b) * c = a * (b * c)\n * Note: \"+\" is not associative because it is also the concatenation\n * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n *\n * @param op The operator.\n * @return Whether the operator is associative.\n */\nstatic boolean isAssociative(int op) {\n  switch (op) {\n    case Token.MUL:\n    case Token.AND:\n    case Token.OR:\n    case Token.BITOR:\n    case Token.BITAND:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * Returns true if the operator is commutative.\n * e.g. (a * b) * c = c * (b * a)\n * Note 1: \"+\" is not commutative because it is also the concatenation\n * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n * Note 2: only operations on literals and pure functions are commutative.\n *\n * @param op The operator.\n * @return Whether the operator is commutative.\n */\nstatic boolean isCommutative(int op) {\n  switch (op)",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n    case Token.NULL:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS:\n    case Token.NEG:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Returns true if the operator is associative.\n * e.g. (a * b) * c = a * (b * c)\n * Note: \"+\" is not associative because it is also the concatenation\n * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n *\n * @param op The operator.\n * @return True if the operator is associative.\n */\nstatic boolean isAssociative(int op) {\n  switch (op) {\n    case Token.MUL:\n    case Token.AND:\n    case Token.OR:\n    case Token.BITOR:\n    case Token.BITAND:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Returns true if the operator is commutative.\n * e.g. (a * b) * c = c * (b * a)\n * Note 1: \"+\" is not commutative because it is also the concatenation\n * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n * Note 2: only operations on literals and pure functions are commutative.\n *\n * @param op The operator.\n * @return True if the operator is commutative.\n */\nstatic boolean isCommutative(int op) {\n  switch (",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n    case Token.NULL:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS:\n    case Token.NEG:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Returns true if the operator is associative.\n * e.g. (a * b) * c = a * (b * c)\n * Note: \"+\" is not associative because it is also the concatenation\n * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n *\n * @param op The operator.\n * @return Whether the operator is associative.\n */\nstatic boolean isAssociative(int op) {\n  switch (op) {\n    case Token.MUL:\n    case Token.AND:\n    case Token.OR:\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.BITAND:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Returns true if the operator is commutative.\n * e.g. (a * b) * c = c * (b * a)\n * Note 1: \"+\" is not commutative because it is also the concatenation\n * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n * Note 2: only operations on literals and pure functions are commutative.\n *\n * @param op The operator.\n * @return Whether the operator is commutative.\n */\nstatic boolean isCommutative(int",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n    case Token.NULL:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS:\n    case Token.NEG:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * Returns true if the operator is associative.\n * e.g. (a * b) * c = a * (b * c)\n * Note: \"+\" is not associative because it is also the concatenation\n * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n *\n * @param op The operator.\n * @return Whether the operator is associative.\n */\nstatic boolean isAssociative(int op) {\n  switch (op) {\n    case Token.MUL:\n    case Token.AND:\n    case Token.OR:\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.BITAND:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * Returns true if the operator is commutative.\n * e.g. (a * b) * c = c * (b * a)\n * Note 1: \"+\" is not commutative because it is also the concatenation\n * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n * Note 2: only operations on literals and pure functions are commutative.\n *\n * @param op The operator.\n * @return Whether the operator is commutative.\n */\nstatic boolean isCommutative(int",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n    case Token.NULL:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS:\n    case Token.NEG:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Returns true if the operator is associative.\n * e.g. (a * b) * c = a * (b * c)\n * Note: \"+\" is not associative because it is also the concatenation\n * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n *\n * @param op The operator.\n * @return True if the operator is associative.\n */\nstatic boolean isAssociative(int op) {\n  switch (op) {\n    case Token.MUL:\n    case Token.AND:\n    case Token.OR:\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.BITAND:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Returns true if the operator is commutative.\n * e.g. (a * b) * c = c * (b * a)\n * Note 1: \"+\" is not commutative because it is also the concatenation\n * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n * Note 2: only operations on literals and pure functions are commutative.\n *\n * @param op The operator.\n * @return True if the operator is commutative.\n */\nstatic boolean isCommutative",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n    case Token.NULL:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS:\n    case Token.NEG:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * Returns true if the operator is associative.\n * e.g. (a * b) * c = a * (b * c)\n * Note: \"+\" is not associative because it is also the concatenation\n * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n *\n * @param op The operator.\n * @return True if the operator is associative.\n */\nstatic boolean isAssociative(int op) {\n  switch (op) {\n    case Token.MUL:\n    case Token.AND:\n    case Token.OR:\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.BITAND:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * Returns true if the operator is commutative.\n * e.g. (a * b) * c = c * (b * a)\n * Note 1: \"+\" is not commutative because it is also the concatenation\n * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n * Note 2: only operations on literals and pure functions are commutative.\n *\n * @param op The operator.\n * @return True if the operator is commutative.\n */\nstatic boolean isCommutative",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!mayBeString(c, true)) {\n        return false;\n      }\n    }\n  }\n\n  switch (n.getType()) {\n    case Token.STRING:\n    case Token.STRING_KEY:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n    case Token.NULL:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS:\n    case Token.NEG:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * Returns true if the operator is associative.\n * e.g. (a * b) * c = a * (b * c)\n * Note: \"+\" is not associative because it is also the concatenation\n * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n *\n * @param op The operator.\n * @return Whether the operator is associative.\n */\nstatic boolean isAssociative(int op) {\n  switch (op) {\n    case Token.MUL:\n    case Token.AND:\n    case Token.OR:\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.BITAND:\n      return true;\n    default:\n      return false;\n  }\n}\n\n\n/**\n * Returns true if the operator is commutative.\n * e.g. (a * b) * c = c * (b * a)\n *\n * @param op The operator.\n * @return Whether the operator is commutative.\n */\nstatic boolean isCommutative(int op) {\n  switch (op) {\n    case Token.MUL:\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.BITAND:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**"
      ],
      "function range": "1415,3-1421,3"
    },
    "Closure_11_/src/com/google/javascript/jscomp/TypeCheck.java_1314-1316": {
      "loc": "1314-1316",
      "input": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");",
      "output": [
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  }\n}\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(\n      t, n, getJSType(n.getFirstChild()), getJSType(n.getLastChild()));\n  ensureTyped(t, n);\n}\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitVar(NodeTraversal t, Node n, Node parent) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.hasOneChild()? n.getJSDocInfo() : null;\n  for (Node name : n.children()) {\n    Node value = name.getFirstChild();\n    // A null var would indicate a bug in the scope creation logic.\n    Var var = t.getScope().getVar(name.get",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  }\n}\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(\n      t, n, getJSType(n.getFirstChild()), getJSType(n.getLastChild()));\n  ensureTyped(t, n);\n}\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitVar(NodeTraversal t, Node n, Node parent) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.hasOneChild()? n.getJSDocInfo() : null;\n  for (Node name : n.children()) {\n    Node value = name.getFirstChild();\n    // A null var would indicate a bug in the scope creation logic.\n    Var v = t.getScope().getVar(name.get",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  }\n}\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(\n      t, n, getJSType(parent), getJSType(n.getFirstChild()));\n  ensureTyped(t, n);\n}\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitVar(NodeTraversal t, Node n, Node parent) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.hasOneChild()? n.getJSDocInfo() : null;\n  for (Node name : n.children()) {\n    Node value = name.getFirstChild();\n    // A null var would indicate a bug in the scope creation logic.\n    Var var = t.getScope().getVar(name.getString());\n\n    if",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  }\n}\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(\n      t, n, getJSType(parent), getJSType(n.getFirstChild()));\n  ensureTyped(t, n);\n}\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitVar(NodeTraversal t, Node n, Node parent) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.hasOneChild()? n.getJSDocInfo() : null;\n  for (Node name : n.children()) {\n    Node value = name.getFirstChild();\n    // A null var would indicate a bug in the scope creation logic.\n    Var v = t.getScope().getVar(name.getString());\n\n    if",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  }\n}\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(\n      t, n, getJSType(n.getFirstChild()), getJSType(n.getLastChild()));\n}\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitVar(NodeTraversal t, Node n, Node parent) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.hasOneChild()? n.getJSDocInfo() : null;\n  for (Node name : n.children()) {\n    Node value = name.getFirstChild();\n    // A null var would indicate a bug in the scope creation logic.\n    Var var = t.getScope().getVar(name.getString());\n\n    if (value!= null) {",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  }\n}\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(\n      t, n, getJSType(parent), getJSType(n.getFirstChild()));\n  ensureTyped(t, n);\n}\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitVar(NodeTraversal t, Node n, Node parent) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.hasOneChild()? n.getJSDocInfo() : null;\n  for (Node name : n.children()) {\n    Node value = name.getFirstChild();\n    // A null var would indicate a bug in the scope creation logic.\n    Var v = t.getScope().getVar(name.getString());\n    if",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  }\n}\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(\n      t, n, getJSType(n.getFirstChild()), getJSType(n.getLastChild()));\n  ensureTyped(t, n);\n}\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitVar(NodeTraversal t, Node n, Node parent) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.hasOneChild()? n.getJSDocInfo() : null;\n  for (Node name : n.children()) {\n    Node value = name.getFirstChild();\n    // A null var would indicate a bug in the scope creation logic.\n    TypedVar var = t.getTypedScope().getVar",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  }\n}\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(\n      t, n, getJSType(parent), getJSType(n.getFirstChild()));\n  ensureTyped(t, n);\n}\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitVar(NodeTraversal t, Node n, Node parent) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.hasOneChild()? n.getJSDocInfo() : null;\n  for (Node name : n.children()) {\n    Node value = name.getFirstChild();\n    // A null var would indicate a bug in the scope creation logic.\n    Var var = t.getScope().getVar(name.getString());\n    if",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  }\n}\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(\n      t, n, getJSType(n.getFirstChild()), getJSType(n.getLastChild()));\n  ensureTyped(t, n);\n}\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nprivate void visitVar(NodeTraversal t, Node n) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.hasOneChild()? n.getJSDocInfo() : null;\n  for (Node name : n.children()) {\n    Node value = name.getFirstChild();\n    // A null var would indicate a bug in the scope creation logic.\n    Var var = t.getScope().getVar(name.getString());\n\n    if (value!= null) {\n      JSType",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  }\n}\n\n/**\n * Visits a GETELEM node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitGetElem(NodeTraversal t, Node n, Node parent) {\n  validator.expectIndexMatch(\n      t, n, getJSType(n.getFirstChild()), getJSType(n.getLastChild()));\n}\n\n/**\n * Visits a VAR node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitVar(NodeTraversal t, Node n, Node parent) {\n  // TODO(nicksantos): Fix this so that the doc info always shows up\n  // on the NAME node. We probably want to wait for the parser\n  // merge to fix this.\n  JSDocInfo varInfo = n.hasOneChild()? n.getJSDocInfo() : null;\n  for (Node name : n.children()) {\n    Node value = name.getFirstChild();\n    // A null var would indicate a bug in the scope creation logic.\n    Var v = t.getScope().getVar(name.getString());\n\n    if (value!= null) {"
      ],
      "function range": "1303,3-1321,3"
    },
    "Closure_14_/src/com/google/javascript/jscomp/ControlFlowAnalysis.java_767-768": {
      "loc": "767-768",
      "input": "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa != null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext() != null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa != null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {",
      "output": [
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (computeFollowNode(fromNode,",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (computeFallThrough(finallyNode",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (finallyNode.getNext() ==",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (fromNode == finallyNode) {\n",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (finallyNode.getNext()!=",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (finallyNode == node) {\n",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (node == finallyNode) {\n              ",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (NodeUtil.hasFinally(f",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            if (computeFollowNode(finallyNode",
        "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa!= null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext()!= null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa!= null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            cfa.removeFinally(finallyNode);"
      ],
      "function range": "692,3-789,3"
    },
    "Closure_15_/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java_102-103": {
      "loc": "102-103",
      "input": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }",
      "output": [
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.h",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyr",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.serializable.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractSerializableAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\n",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.serializable.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractSerializableAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\n\npublic class",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\n",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.serializable.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractSerializableAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\n\npublic class N"
      ],
      "function range": "83,7-109,7"
    },
    "Closure_18_/src/com/google/javascript/jscomp/Compiler.java_1288-1289": {
      "loc": "1288-1289",
      "input": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;",
      "output": [
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      if (input.getCode() == null) {\n        staleInputs = true;\n        continue;\n      }\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n      if (options.sourceMapOutputPath!= null ||\n          options.nameReferenceReportPath!= null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnot",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      if (input.getCode() == null) {\n        staleInputs = true;\n        continue;\n      }\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        if (hasErrors()) {\n          return null;\n        }\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (options.sourceMapOutputPath!= null ||\n          options.nameReferenceReportPath!= null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file.",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      if (input.getCode() == null) {\n        staleInputs = true;\n        continue;\n      }\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (options.sourceMapOutputPath!= null ||\n          options.nameReferenceReportPath!= null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file.",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      if (input.getCode() == null) {\n        staleInputs = true;\n        continue;\n      }\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        if (hasErrors()) {\n          return null;\n        }\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n      if (options.sourceMapOutputPath!= null ||\n          options.nameReferenceReportPath!= null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file.",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      if (input.getCode() == null) {\n        staleInputs = true;\n        continue;\n      }\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n      if (options.sourceMapOutputPath!= null ||\n          options.nameReferenceReportPath!= null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnotator",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      if (input.getCode() == null) {\n        staleInputs = true;\n        continue;\n      }\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n      if (options.sourceMapOutputPath!= null ||\n          options.nameReferenceReportPath!= null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceMapInputUt",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      if (input.getCode() == null) {\n        staleInputs = true;\n        continue;\n      }\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        if (hasErrors()) {\n          return null;\n        } else {\n          continue;\n        }\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n      if (options.sourceMapOutputPath!= null ||\n          options.nameReferenceReportPath!= null) {\n\n        // Annotate the nodes in the tree with information from the\n",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      if (input.getCode() == null) {\n        staleInputs = true;\n        continue;\n      }\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n      if (options.sourceMapOutputPath!= null ||\n          options.nameReferenceReportPath!= null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceMapInputUtils",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      if (input.getCode() == null) {\n        staleInputs = true;\n        continue;\n      }\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (options.sourceMapOutputPath!= null ||\n          options.nameReferenceReportPath!= null) {\n\n        // Annotate the nodes in the tree with information from the\n        // sources. This",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      if (input.getCode() == null) {\n        staleInputs = true;\n        continue;\n      }\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n      if (options.sourceMapOutputPath!= null ||\n          options.nameReferenceReportPath!= null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the source map.\n        SourceMapInputUt"
      ],
      "function range": "1240,3-1362,3"
    },
    "Closure_20_/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java_220-221": {
      "loc": "220-221",
      "input": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget != null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();",
      "output": [
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = Node.newString(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\n\npublic",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = Node.newString(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = Node.newString(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = Node.newString(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = Node.newString(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = Node.newString(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.AsterixBuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = Node.newString(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.AsterixBuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = Node.newString(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.AsterixBuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\n",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = Node.newString(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEval",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = Node.newString(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluator;\nimport org.apache"
      ],
      "function range": "208,3-230,3"
    },
    "Closure_31_/src/com/google/javascript/jscomp/Compiler.java_1285-1286": {
      "loc": "1285-1286",
      "input": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&",
      "output": [
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && externs.size() > 0) {\n      for (CompilerInput input : externs) {\n        if (input.isExtern()) {\n          staleInputs = true;\n          break;\n        }\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        if (options.dependencyOptions.needsManagement() && input.isExtern()) {\n          staleInputs = true;\n          break;\n        }\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && externs.size() > 0) {\n      for (CompilerInput input : externs) {\n        if (input.isExtern()) {\n          staleInputs = true;\n          break;\n        }\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        if (options.dependencyOptions.needsManagement() && input.isExtern()) {\n          staleInputs = true;\n          break;\n        }\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && externs.size() > 0) {\n      for (CompilerInput input : externs) {\n        if (input.isExtern()) {\n          staleInputs = true;\n          break;\n        }\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n        if (options.dependencyOptions.needsManagement() && input.isExtern()) {\n          ",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && externs.size() > 0) {\n      for (CompilerInput input : externs) {\n        if (input.isExtern()) {\n          staleInputs = true;\n          break;\n        }\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        input.setCompiler(this);\n        if (staleInputs) {\n          setInputJSDocInfo(input",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && externs.size() > 0) {\n      for (CompilerInput input : externs) {\n        if (input.isExtern()) {\n          staleInputs = true;\n          break;\n        }\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        if (options.dependencyOptions.needsManagement()\n            && input.isExtern()) {\n          staleInputs = true;\n          break;\n        }\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors())",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && externs.size() > 0) {\n      for (CompilerInput input : externs) {\n        if (input.isExtern()) {\n          staleInputs = true;\n          break;\n        }\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        if (options.dependencyOptions.needsManagement()\n            && input.isExtern()) {\n          staleInputs = true;\n          break;\n        }\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null)",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && externs.size() > 0) {\n      for (CompilerInput input : externs) {\n        if (input.isExtern()) {\n          staleInputs = true;\n          break;\n        }\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        input.setCompiler(this);\n        if (staleInputs) {\n          setInputSourcePosition(input);\n",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && externs.size() > 0) {\n      for (CompilerInput input : externs) {\n        if (input.isExtern()) {\n          staleInputs = true;\n          break;\n        }\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        input.setCompiler(this);\n        if (options.dependencyOptions.needsManagement()) {\n          input.setComp",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && externs.size() > 0) {\n      for (CompilerInput input : externs) {\n        if (input.isExtern()) {\n          staleInputs = true;\n          break;\n        }\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n        if (options.dependencyOptions.needsManagement()) {\n          DependencyOptions depOptions =",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && externs.size() > 0) {\n      for (CompilerInput input : externs) {\n        if (input.isExtern()) {\n          staleInputs = true;\n          break;\n        }\n      }\n    }\n    if (!staleInputs) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        input.setCompiler(this);\n        if (staleInputs) {\n          setInputSourcePosition(input, n"
      ],
      "function range": "1236,3-1387,3"
    },
    "Closure_33_/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java_557-558": {
      "loc": "557-558",
      "input": "@Override\npublic void matchConstraint(ObjectType constraintObj) {",
      "output": [
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }\n\n  @Override\n  public ObjectType getConstraintObj() {\n    return this.constraintObj;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }\n\n  @Override\n  public ObjectType getConstraintObj() {\n    return this.constraintObj;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.alge",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }\n\n  @Override\n  public ObjectType getConstraintObj() {\n    return this.constraintObj;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }\n\n  @Override\n  public ObjectType getConstraintObj() {\n    return this.constraintObj;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }\n\n  @Override\n  public ObjectType getConstraintObj() {\n    return this.constraintObj;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.data.std.api.IPointable",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }\n\n  @Override\n  public ObjectType getConstraint() {\n    return this.constraintObj;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.data.std.api.IPointable;",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }\n\n  @Override\n  public ObjectType getConstraintObj() {\n    return this.constraintObj;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.api.exceptions.",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }\n\n  @Override\n  public ObjectType getConstraintObj() {\n    return this.constraintObj;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregate",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }\n\n  @Override\n  public ObjectType getConstraintObj() {\n    return this.constraintObj;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.api.",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }\n\n  @Override\n  public ObjectType getConstraintObj() {\n    return this.constraintObj;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAgg"
      ],
      "function range": "554,3-580,3"
    },
    "Closure_35_/src/com/google/javascript/jscomp/TypeInference.java_1121-1136": {
      "loc": "1121-1136",
      "input": "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());",
      "output": [
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj!= null) {\n    inferPropertyTypesToMatchConstraint(type, constraintObj);\n  }\n\n  FunctionType constraintFun = constraint.restrictByNotNullOrUndefined()\n     .toMaybeFunctionType();\n  if (constraintFun!= null) {\n    FunctionType typeFun = type.restrictByNotNullOrUndefined()\n       .toMaybeFunctionType();\n    if (typeFun!= null) {\n      inferPropertyTypesToMatchConstraint(typeFun.getInstanceType(),\n          constraintFun.getInstanceType());\n      inferPropertyTypesToMatchConstraint(typeFun.getPrototype(),\n          constraintFun.getPrototype());\n\n      if (typeFun.isConstructor()) {\n        FunctionType superCtor = typeFun.getSuperClassConstructor();\n        if (superCtor!= null) {\n          inferPropertyTypesToMatchConstraint(superCtor.getInstanceType(),\n              constraintFun.getSuperClassConstructor().getInstanceType());\n        }\n\n        for (ObjectType interfaceType : typeFun.getExtendedInterfaces()) {\n          inferPropertyTypesToMatchConstraint(interfaceType,\n              constraintFun.getExtendedInterfaces());\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj!= null) {\n    inferPropertyTypesToMatchConstraint(type, constraintObj);\n  }\n\n  FunctionType constraintFun = constraint.restrictByNotNullOrUndefined()\n     .toMaybeFunctionType();\n  if (constraintFun!= null) {\n    FunctionType typeFun = type.restrictByNotNullOrUndefined()\n       .toMaybeFunctionType();\n    if (typeFun!= null) {\n      inferPropertyTypesToMatchConstraint(typeFun.getInstanceType(),\n          constraintFun.getInstanceType());\n      inferPropertyTypesToMatchConstraint(typeFun.getPrototype(),\n          constraintFun.getPrototype());\n\n      if (typeFun.isConstructor()) {\n        FunctionType superCtor = typeFun.getSuperClassConstructor();\n        if (superCtor!= null) {\n          inferPropertyTypesToMatchConstraint(superCtor.getInstanceType(),\n              constraintFun.getSuperClassConstructor().getInstanceType());\n        }\n\n        for (ObjectType interfaceType : typeFun.getExtendedInterfaces()) {\n          inferPropertyTypesToMatchConstraint(interfaceType,\n              constraintFun.getExtendedInterfaces());\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj!= null) {\n    inferPropertyTypesToMatchConstraint(type, constraintObj);\n  }\n\n  FunctionType constraintFun = constraint.restrictByNotNullOrUndefined()\n     .toMaybeFunctionType();\n  if (constraintFun!= null) {\n    FunctionType typeFun = type.restrictByNotNullOrUndefined()\n       .toMaybeFunctionType();\n    if (typeFun!= null) {\n      inferPropertyTypesToMatchConstraint(typeFun.getInstanceType(),\n          constraintFun.getInstanceType());\n      inferPropertyTypesToMatchConstraint(typeFun.getPrototype(),\n          constraintFun.getPrototype());\n\n      if (typeFun.isConstructor()) {\n        FunctionType superCtor = typeFun.getSuperClassConstructor();\n        if (superCtor!= null) {\n          inferPropertyTypesToMatchConstraint(superCtor.getInstanceType(),\n              constraintFun.getSuperClassConstructor().getInstanceType());\n        }\n\n        for (ObjectType interfaceType : typeFun.getExtendedInterfaces()) {\n          inferPropertyTypesToMatchConstraint(interfaceType,\n              constraintFun.getExtendedInterfaces());\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj!= null) {\n    inferPropertyTypesToMatchConstraint(type, constraintObj);\n  }\n\n  FunctionType constraintFun = constraint.restrictByNotNullOrUndefined()\n     .toMaybeFunctionType();\n  if (constraintFun!= null) {\n    FunctionType typeFun = type.restrictByNotNullOrUndefined()\n       .toMaybeFunctionType();\n    if (typeFun!= null) {\n      inferPropertyTypesToMatchConstraint(typeFun.getInstanceType(),\n          constraintFun.getInstanceType());\n      inferPropertyTypesToMatchConstraint(typeFun.getPrototype(),\n          constraintFun.getPrototype());\n\n      if (typeFun.isConstructor()) {\n        FunctionType superCtor = typeFun.getSuperClassConstructor();\n        if (superCtor!= null) {\n          inferPropertyTypesToMatchConstraint(superCtor.getInstanceType(),\n              constraintFun.getSuperClassConstructor().getInstanceType());\n        }\n\n        for (ObjectType interfaceType : typeFun.getExtendedInterfaces()) {\n          inferPropertyTypesToMatchConstraint(interfaceType,\n              constraintFun.getExtendedInterfaces());\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj!= null) {\n    inferPropertyTypesToMatchConstraint(type, constraintObj);\n  }\n\n  FunctionType constraintFun = constraint.restrictByNotNullOrUndefined()\n     .toMaybeFunctionType();\n  if (constraintFun!= null) {\n    FunctionType typeFun = type.restrictByNotNullOrUndefined()\n       .toMaybeFunctionType();\n    if (typeFun!= null) {\n      inferPropertyTypesToMatchConstraint(typeFun.getInstanceType(),\n          constraintFun.getInstanceType());\n      inferPropertyTypesToMatchConstraint(typeFun.getPrototype(),\n          constraintFun.getPrototype());\n\n      if (typeFun.isConstructor()) {\n        FunctionType superCtor = typeFun.getSuperClassConstructor();\n        if (superCtor!= null) {\n          inferPropertyTypesToMatchConstraint(superCtor.getInstanceType(),\n              constraintFun.getSuperClassConstructor().getInstanceType());\n        }\n\n        for (ObjectType interfaceType : typeFun.getAllImplementedInterfaces()) {\n          inferPropertyTypesToMatchConstraint(\n              interfaceType, constraintFun.getAllImplementedInterfaces());\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj!= null) {\n    inferPropertyTypesToMatchConstraint(type, constraintObj);\n  }\n\n  FunctionType constraintFun = constraint.restrictByNotNullOrUndefined()\n     .toMaybeFunctionType();\n  if (constraintFun!= null) {\n    FunctionType typeFun = type.restrictByNotNullOrUndefined()\n       .toMaybeFunctionType();\n    if (typeFun!= null) {\n      inferPropertyTypesToMatchConstraint(typeFun.getInstanceType(),\n          constraintFun.getInstanceType());\n      inferPropertyTypesToMatchConstraint(typeFun.getPrototype(),\n          constraintFun.getPrototype());\n\n      if (typeFun.isConstructor()) {\n        FunctionType superCtor = typeFun.getSuperClassConstructor();\n        if (superCtor!= null) {\n          inferPropertyTypesToMatchConstraint(superCtor.getInstanceType(),\n              constraintFun.getSuperClassConstructor().getInstanceType());\n        }\n\n        for (ObjectType interfaceType : typeFun.getAllImplementedInterfaces()) {\n          inferPropertyTypesToMatchConstraint(\n              interfaceType, constraintFun.getAllImplementedInterfaces());\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj!= null) {\n    inferPropertyTypesToMatchConstraint(type, constraintObj);\n  }\n\n  FunctionType constraintFun = constraint.restrictByNotNullOrUndefined()\n     .toMaybeFunctionType();\n  if (constraintFun!= null) {\n    FunctionType typeFun = type.restrictByNotNullOrUndefined()\n       .toMaybeFunctionType();\n    if (typeFun!= null) {\n      inferPropertyTypesToMatchConstraint(typeFun.getInstanceType(),\n          constraintFun.getInstanceType());\n      inferPropertyTypesToMatchConstraint(typeFun.getPrototype(),\n          constraintFun.getPrototype());\n\n      if (typeFun.isConstructor()) {\n        FunctionType superCtor = typeFun.getSuperClassConstructor();\n        if (superCtor!= null) {\n          inferPropertyTypesToMatchConstraint(superCtor.getInstanceType(),\n              constraintFun.getSuperClassConstructor().getInstanceType());\n        }\n\n        for (ObjectType interfaceType : typeFun.getExtendedInterfaces()) {\n          inferPropertyTypesToMatchConstraint(interfaceType,\n              constraintFun.getExtendedInterfaces());\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj!= null) {\n    inferPropertyTypesToMatchConstraint(type, constraintObj);\n  }\n\n  FunctionType constraintFun = constraint.restrictByNotNullOrUndefined()\n     .toMaybeFunctionType();\n  if (constraintFun!= null) {\n    FunctionType typeFun = type.restrictByNotNullOrUndefined()\n       .toMaybeFunctionType();\n    if (typeFun!= null) {\n      inferPropertyTypesToMatchConstraint(typeFun.getInstanceType(),\n          constraintFun.getInstanceType());\n      inferPropertyTypesToMatchConstraint(typeFun.getPrototype(),\n          constraintFun.getPrototype());\n\n      if (typeFun.isConstructor()) {\n        FunctionType superCtor = typeFun.getSuperClassConstructor();\n        if (superCtor!= null) {\n          inferPropertyTypesToMatchConstraint(superCtor.getInstanceType(),\n              constraintFun.getSuperClassConstructor().getInstanceType());\n        }\n\n        for (ObjectType interfaceType : typeFun.getAllImplementedInterfaces()) {\n          inferPropertyTypesToMatchConstraint(interfaceType,\n              constraintFun.getAllImplementedInterfaces());\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj!= null) {\n    inferPropertyTypesToMatchConstraint(type, constraintObj);\n  }\n\n  FunctionType constraintFun = constraint.restrictByNotNullOrUndefined()\n     .toMaybeFunctionType();\n  if (constraintFun!= null) {\n    FunctionType typeFun = type.restrictByNotNullOrUndefined()\n       .toMaybeFunctionType();\n    if (typeFun!= null) {\n      inferPropertyTypesToMatchConstraint(typeFun.getInstanceType(),\n          constraintFun.getInstanceType());\n      inferPropertyTypesToMatchConstraint(typeFun.getPrototype(),\n          constraintFun.getPrototype());\n\n      if (typeFun.isConstructor()) {\n        FunctionType superCtor = typeFun.getSuperClassConstructor();\n        if (superCtor!= null) {\n          inferPropertyTypesToMatchConstraint(superCtor.getInstanceType(),\n              constraintFun.getSuperClassConstructor().getInstanceType());\n        }\n\n        for (ObjectType interfaceType : typeFun.getAllImplementedInterfaces()) {\n          inferPropertyTypesToMatchConstraint(\n              interfaceType, constraintFun.getAllImplementedInterfaces());\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj!= null) {\n    inferPropertyTypesToMatchConstraint(type, constraintObj);\n  }\n\n  FunctionType constraintFun = constraint.restrictByNotNullOrUndefined()\n     .toMaybeFunctionType();\n  if (constraintFun!= null) {\n    FunctionType typeFun = type.restrictByNotNullOrUndefined()\n       .toMaybeFunctionType();\n    if (typeFun!= null) {\n      inferPropertyTypesToMatchConstraint(typeFun.getInstanceType(),\n          constraintFun.getInstanceType());\n      inferPropertyTypesToMatchConstraint(typeFun.getPrototype(),\n          constraintFun.getPrototype());\n\n      if (typeFun.isConstructor()) {\n        FunctionType superCtor = typeFun.getSuperClassConstructor();\n        if (superCtor!= null) {\n          inferPropertyTypesToMatchConstraint(superCtor.getInstanceType(),\n              constraintFun.getSuperClassConstructor().getInstanceType());\n        }\n\n        for (ObjectType interfaceType : typeFun.getAllImplementedInterfaces()) {\n          inferPropertyTypesToMatchConstraint(interfaceType,\n              constraintFun.getAllImplementedInterfaces());\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless"
      ],
      "function range": "1113,3-1137,3"
    },
    "Closure_36_/src/com/google/javascript/jscomp/InlineVariables.java_575-576": {
      "loc": "575-576",
      "input": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      || !isValidInitialization(initialization)\n      || !isValidReference(reference)) {\n    return false;\n  }\n  if (declaration != initialization &&\n      !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock() != initialization.getBasicBlock()\n      || declaration.getBasicBlock() != reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value != null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship != null) {\n        return false;\n      }",
      "output": [
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      String name = convention.getSingletonGetterClassName(callNode);\n      if (name!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesInitializedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nprivate static boolean isValidDeclaration(Reference declaration) {\n  return declaration.getParent().isExprResult();\n}\n\nprivate static boolean isValidInitialization(Reference initialization) {\n  return initialization.getGrandparent().isExprResult();\n}\n\nprivate static boolean isValidReference(Reference reference) {\n  return reference.getParent().isExprResult();\n",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      String thisClassName = convention.getThisClassName(callNode);\n      if (thisClassName!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nprivate static boolean isValidDeclaration(Reference declaration) {\n  return declaration.getParent().isExprResult();\n}\n\nprivate static boolean isValidInitialization(Reference initialization) {\n  return initialization.getGrandparent().isExprResult();\n}\n\nprivate static boolean isValidReference(Reference reference) {\n  return reference.getParent().isExprResult",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      String thisClassName = convention.getThisClassName(callNode);\n      if (thisClassName!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nprivate static boolean isValidDeclaration(Reference declaration) {\n  return declaration.getParent().isExprResult();\n}\n\nprivate static boolean isValidInitialization(Reference initialization) {\n  return initialization.getGrandparent().isExprResult();\n}\n\nprivate static boolean isValidReference(Reference reference) {\n  Node parent = reference.getParent();\n  ",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      String name = convention.getSingletonGetterClassName(callNode);\n      if (name!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesInitializedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nprivate static boolean isValidDeclaration(Reference declaration) {\n  return declaration.getParent().isExprResult();\n}\n\nprivate static boolean isValidInitialization(Reference initialization) {\n  return initialization.getGrandparent().isExprResult();\n}\n\nprivate static boolean isValidReference(Reference reference) {\n  Node parent = reference.getParent();\n  return parent",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      String thisClassName = convention.getThisClassName(callNode);\n      if (thisClassName!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nprivate static boolean isValidReference(Reference reference) {\n  return reference.getParent().isExprResult();\n}\n\nprivate static boolean isValidDeclaration(Reference declaration) {\n  Node parent = declaration.getParent();\n  return parent.isVar() || parent.isLet() || parent.isConst();\n}\n\nprivate static boolean isValidInitialization(",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      String thisClassName = convention.getThisClassName(callNode);\n      if (thisClassName!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nprivate static boolean isValidReference(Reference reference) {\n  return reference.getParent().isExprResult();\n}\n\nprivate static boolean isValidDeclaration(Reference declaration) {\n  return declaration.getParent().isExprResult();\n}\n\nprivate static boolean isValidInitialization(Reference initialization) {\n  return initialization.getGrandparent().isExprResult",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      String thisClassName = convention.getThisClassName(callNode);\n      if (thisClassName!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nprivate static boolean isValidDeclaration(Reference declaration) {\n  return declaration.getParent().isExprResult();\n}\n\nprivate static boolean isValidInitialization(Reference initialization) {\n  Node parent = initialization.getParent();\n  return parent.isAssign() && parent.getFirstChild() == initialization.getNode();\n}\n\nprivate static boolean isValid",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      String name = convention.getSingletonGetterClassName(callNode);\n      if (name!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesInitializedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nprivate static boolean isValidDeclaration(Reference declaration) {\n  return declaration.getParent().isExprResult();\n}\n\nprivate static boolean isValidInitialization(Reference initialization) {\n  Node parent = initialization.getParent();\n  return parent.isAssign()\n      && parent.getFirstChild() == initialization.getNode();\n}\n\nprivate static boolean isValid",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      String thisClassName = convention.getThisClassName(callNode);\n      if (thisClassName!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nprivate static boolean isValidDeclaration(Reference declaration) {\n  return declaration.getParent().isExprResult();\n}\n\nprivate static boolean isValidInitialization(Reference initialization) {\n  Node parent = initialization.getParent();\n  return parent.isAssign()\n      && parent.getFirstChild() == initialization.getNode();\n}\n\nprivate static boolean",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      String thisClassName = convention.getThisClassName(callNode);\n      if (thisClassName!= null) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByNew(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nprivate static boolean isValidReference(Reference reference) {\n  return reference.getParent().isExprResult();\n}\n\nprivate static boolean isValidDeclaration(Reference declaration) {\n  return declaration.getParent().isExprResult();\n}\n\nprivate static boolean isValidInitialization(Reference initialization) {\n  return initialization.getGrandparent().isName();\n"
      ],
      "function range": "519,5-580,5"
    },
    "Closure_38_/src/com/google/javascript/jscomp/CodeConsumer.java_245-246": {
      "loc": "245-246",
      "input": "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);",
      "output": [
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 0.0) {\n    addChar('0');\n    return;\n  }\n  if (x < 0.0) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 1.0) {\n    addChar('1');\n    return;\n  }\n  if (x == 2.0) {\n    addChar('2');\n    return;\n  }\n  if (x == 3.0) {\n    addChar('3');\n    return;\n  }\n  if (x == 4.0) {\n    addChar('4');\n    return;\n  }\n  if (x == 5.0) {\n    addChar('5');\n    return;\n  }\n  if (x == 6.0) {\n    addChar('6');\n    return;\n  }\n  if (x == 7.0) {\n    addChar('7');\n    return;\n  }\n  if (x == 8.0) {\n    addChar('8');\n    return;\n  }\n  if (x == 9.0) {\n    addChar('9');\n    return;\n  }\n  if (x == 10.0) {\n    addChar('A');\n    return;\n  }\n  if (x == 11.0) {\n    addChar('B');\n    return;\n  }\n  if (x == 12.0) {\n    addChar('C');\n    return;\n  }\n  if (x == 13.0) {\n    addChar('D');\n    return;\n  }\n  if (x == 14.0) {\n    addChar('E');\n    return;\n  }\n  if (x == 15.0) {\n    addChar('F');\n    return;\n  }\n  if (x == 16.0) {\n    addChar('G');\n    return;\n  }\n  if",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 0.0) {\n    addChar('0');\n    return;\n  }\n  if (x < 0.0) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 1.0) {\n    addChar('1');\n    return;\n  }\n  if (x == 2.0) {\n    addChar('2');\n    return;\n  }\n  if (x == 3.0) {\n    addChar('3');\n    return;\n  }\n  if (x == 4.0) {\n    addChar('4');\n    return;\n  }\n  if (x == 5.0) {\n    addChar('5');\n    return;\n  }\n  if (x == 6.0) {\n    addChar('6');\n    return;\n  }\n  if (x == 7.0) {\n    addChar('7');\n    return;\n  }\n  if (x == 8.0) {\n    addChar('8');\n    return;\n  }\n  if (x == 9.0) {\n    addChar('9');\n    return;\n  }\n  if (x == 10.0) {\n    addChar('a');\n    return;\n  }\n  if (x == 11.0) {\n    addChar('b');\n    return;\n  }\n  if (x == 12.0) {\n    addChar('c');\n    return;\n  }\n  if (x == 13.0) {\n    addChar('d');\n    return;\n  }\n  if (x == 14.0) {\n    addChar('e');\n    return;\n  }\n  if (x == 15.0) {\n    addChar('f');\n    return;\n  }\n  if (x == 16.0) {\n    addChar('g');\n    return;\n  }\n  if",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 0.0) {\n    addChar('0');\n    return;\n  }\n  if (x < 0.0) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 1.0) {\n    addChar('1');\n    return;\n  }\n  if (x == 2.0) {\n    addChar('2');\n    return;\n  }\n  if (x == 3.0) {\n    addChar('3');\n    return;\n  }\n  if (x == 4.0) {\n    addChar('4');\n    return;\n  }\n  if (x == 5.0) {\n    addChar('5');\n    return;\n  }\n  if (x == 6.0) {\n    addChar('6');\n    return;\n  }\n  if (x == 7.0) {\n    addChar('7');\n    return;\n  }\n  if (x == 8.0) {\n    addChar('8');\n    return;\n  }\n  if (x == 9.0) {\n    addChar('9');\n    return;\n  }\n  if (x == 10.0) {\n    addChar('a');\n    return;\n  }\n  if (x == 11.0) {\n    addChar('b');\n    return;\n  }\n  if (x == 12.0) {\n    addChar('c');\n    return;\n  }\n  if (x == 13.0) {\n    addChar('d');\n    return;\n  }\n  if (x == 14.0) {\n    addChar('e');\n    return;\n  }\n  if (x == 15.0) {\n    addChar('f');\n    return;\n  }\n  if (x == 16.0) {\n    addChar('h');\n    return;\n  }\n  if",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 0.0) {\n    addChar('0');\n    return;\n  }\n  if (x < 0.0) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 1.0) {\n    addChar('1');\n    return;\n  }\n  if (x == 2.0) {\n    addChar('2');\n    return;\n  }\n  if (x == 3.0) {\n    addChar('3');\n    return;\n  }\n  if (x == 4.0) {\n    addChar('4');\n    return;\n  }\n  if (x == 5.0) {\n    addChar('5');\n    return;\n  }\n  if (x == 6.0) {\n    addChar('6');\n    return;\n  }\n  if (x == 7.0) {\n    addChar('7');\n    return;\n  }\n  if (x == 8.0) {\n    addChar('8');\n    return;\n  }\n  if (x == 9.0) {\n    addChar('9');\n    return;\n  }\n  if (x == 10.0) {\n    addChar('A');\n    return;\n  }\n  if (x == 11.0) {\n    addChar('B');\n    return;\n  }\n  if (x == 12.0) {\n    addChar('C');\n    return;\n  }\n  if (x == 13.0) {\n    addChar('D');\n    return;\n  }\n  if (x == 14.0) {\n    addChar('E');\n    return;\n  }\n  if (x == 15.0) {\n    addChar('F');\n    return;\n  }\n  if (x == 16.0) {\n    addChar('H');\n    return;\n  }\n  if",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 0.0) {\n    addChar('0');\n    return;\n  }\n  if (x < 0.0) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 1.0) {\n    addChar('1');\n    return;\n  }\n  if (x == 2.0) {\n    addChar('2');\n    return;\n  }\n  if (x == 3.0) {\n    addChar('3');\n    return;\n  }\n  if (x == 4.0) {\n    addChar('4');\n    return;\n  }\n  if (x == 5.0) {\n    addChar('5');\n    return;\n  }\n  if (x == 6.0) {\n    addChar('6');\n    return;\n  }\n  if (x == 7.0) {\n    addChar('7');\n    return;\n  }\n  if (x == 8.0) {\n    addChar('8');\n    return;\n  }\n  if (x == 9.0) {\n    addChar('9');\n    return;\n  }\n  if (x == 10.0) {\n    addChar('a');\n    return;\n  }\n  if (x == 11.0) {\n    addChar('b');\n    return;\n  }\n  if (x == 12.0) {\n    addChar('c');\n    return;\n  }\n  if (x == 13.0) {\n    addChar('d');\n    return;\n  }\n  if (x == 14.0) {\n    addChar('e');\n    return;\n  }\n  if (x == 15.0) {\n    addChar('f');\n    return;\n  }\n  if (x == 16.0) {\n    addChar('g');\n    return;\n  }\n  add",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 0.0) {\n    addChar('0');\n    return;\n  }\n  if (x < 0.0) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 1.0) {\n    addChar('1');\n    return;\n  }\n  if (x == 2.0) {\n    addChar('2');\n    return;\n  }\n  if (x == 3.0) {\n    addChar('3');\n    return;\n  }\n  if (x == 4.0) {\n    addChar('4');\n    return;\n  }\n  if (x == 5.0) {\n    addChar('5');\n    return;\n  }\n  if (x == 6.0) {\n    addChar('6');\n    return;\n  }\n  if (x == 7.0) {\n    addChar('7');\n    return;\n  }\n  if (x == 8.0) {\n    addChar('8');\n    return;\n  }\n  if (x == 9.0) {\n    addChar('9');\n    return;\n  }\n  if (x == 10.0) {\n    addChar('a');\n    return;\n  }\n  if (x == 11.0) {\n    addChar('b');\n    return;\n  }\n  if (x == 12.0) {\n    addChar('c');\n    return;\n  }\n  if (x == 13.0) {\n    addChar('d');\n    return;\n  }\n  if (x == 14.0) {\n    addChar('e');\n    return;\n  }\n  if (x == 15.0) {\n    addChar('f');\n    return;\n  }\n  if (x == 16.0) {\n    addChar('g');\n    return;\n  }\n  int",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 0.0) {\n    addChar('0');\n    return;\n  }\n  if (x < 0.0) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 1.0) {\n    addChar('1');\n    return;\n  }\n  if (x == 2.0) {\n    addChar('2');\n    return;\n  }\n  if (x == 3.0) {\n    addChar('3');\n    return;\n  }\n  if (x == 4.0) {\n    addChar('4');\n    return;\n  }\n  if (x == 5.0) {\n    addChar('5');\n    return;\n  }\n  if (x == 6.0) {\n    addChar('6');\n    return;\n  }\n  if (x == 7.0) {\n    addChar('7');\n    return;\n  }\n  if (x == 8.0) {\n    addChar('8');\n    return;\n  }\n  if (x == 9.0) {\n    addChar('9');\n    return;\n  }\n  if (x == 10.0) {\n    addChar('A');\n    return;\n  }\n  if (x == 11.0) {\n    addChar('B');\n    return;\n  }\n  if (x == 12.0) {\n    addChar('C');\n    return;\n  }\n  if (x == 13.0) {\n    addChar('D');\n    return;\n  }\n  if (x == 14.0) {\n    addChar('E');\n    return;\n  }\n  if (x == 15.0) {\n    addChar('F');\n    return;\n  }\n  if (x == 16.0) {\n    addChar('G');\n    return;\n  }\n  add",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 0.0) {\n    addChar('0');\n    return;\n  }\n  if (x < 0.0) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 1.0) {\n    addChar('1');\n    return;\n  }\n  if (x == 2.0) {\n    addChar('2');\n    return;\n  }\n  if (x == 3.0) {\n    addChar('3');\n    return;\n  }\n  if (x == 4.0) {\n    addChar('4');\n    return;\n  }\n  if (x == 5.0) {\n    addChar('5');\n    return;\n  }\n  if (x == 6.0) {\n    addChar('6');\n    return;\n  }\n  if (x == 7.0) {\n    addChar('7');\n    return;\n  }\n  if (x == 8.0) {\n    addChar('8');\n    return;\n  }\n  if (x == 9.0) {\n    addChar('9');\n    return;\n  }\n  if (x == 10.0) {\n    addChar('a');\n    return;\n  }\n  if (x == 11.0) {\n    addChar('b');\n    return;\n  }\n  if (x == 12.0) {\n    addChar('c');\n    return;\n  }\n  if (x == 13.0) {\n    addChar('d');\n    return;\n  }\n  if (x == 14.0) {\n    addChar('e');\n    return;\n  }\n  if (x == 15.0) {\n    addChar('f');\n    return;\n  }\n  if (x == 16.0) {\n    addChar('g');\n    return;\n  }\n\n  if",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 0.0) {\n    addChar('0');\n    return;\n  }\n  if (x < 0.0) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 1.0) {\n    addChar('1');\n    return;\n  }\n  if (x == 2.0) {\n    addChar('2');\n    return;\n  }\n  if (x == 3.0) {\n    addChar('3');\n    return;\n  }\n  if (x == 4.0) {\n    addChar('4');\n    return;\n  }\n  if (x == 5.0) {\n    addChar('5');\n    return;\n  }\n  if (x == 6.0) {\n    addChar('6');\n    return;\n  }\n  if (x == 7.0) {\n    addChar('7');\n    return;\n  }\n  if (x == 8.0) {\n    addChar('8');\n    return;\n  }\n  if (x == 9.0) {\n    addChar('9');\n    return;\n  }\n  if (x == 10.0) {\n    addChar('a');\n    return;\n  }\n  if (x == 11.0) {\n    addChar('b');\n    return;\n  }\n  if (x == 12.0) {\n    addChar('c');\n    return;\n  }\n  if (x == 13.0) {\n    addChar('d');\n    return;\n  }\n  if (x == 14.0) {\n    addChar('e');\n    return;\n  }\n  if (x == 15.0) {\n    addChar('f');\n    return;\n  }\n  if (x == 16.0) {\n    addChar('g');\n    return;\n  }\n  //",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (negativeZero) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 0.0) {\n    addChar('0');\n    return;\n  }\n  if (x < 0.0) {\n    addChar('-');\n    x = -x;\n  }\n  if (x == 1.0) {\n    addChar('1');\n    return;\n  }\n  if (x == 2.0) {\n    addChar('2');\n    return;\n  }\n  if (x == 3.0) {\n    addChar('3');\n    return;\n  }\n  if (x == 4.0) {\n    addChar('4');\n    return;\n  }\n  if (x == 5.0) {\n    addChar('5');\n    return;\n  }\n  if (x == 6.0) {\n    addChar('6');\n    return;\n  }\n  if (x == 7.0) {\n    addChar('7');\n    return;\n  }\n  if (x == 8.0) {\n    addChar('8');\n    return;\n  }\n  if (x == 9.0) {\n    addChar('9');\n    return;\n  }\n  if (x == 10.0) {\n    addChar('a');\n    return;\n  }\n  if (x == 11.0) {\n    addChar('b');\n    return;\n  }\n  if (x == 12.0) {\n    addChar('c');\n    return;\n  }\n  if (x == 13.0) {\n    addChar('d');\n    return;\n  }\n  if (x == 14.0) {\n    addChar('e');\n    return;\n  }\n  if (x == 15.0) {\n    addChar('f');\n    return;\n  }\n  if (x == 16.0) {\n    addChar('0');\n    return;\n  }\n  if"
      ],
      "function range": "240,3-267,3"
    },
    "Closure_52_/src/com/google/javascript/jscomp/CodeGenerator.java_745-746": {
      "loc": "745-746",
      "input": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }",
      "output": [
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IH",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algeb",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context."
      ],
      "function range": "737,3-746,3"
    },
    "Closure_55_/src/com/google/javascript/jscomp/FunctionRewriter.java_117-118": {
      "loc": "117-118",
      "input": "private static boolean isReduceableFunctionExpression(Node n) {",
      "output": [
        "private static boolean isReduceableFunctionExpression(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.Built",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.yarn.api.protocolrecords.impl.pb;\n\n\nimport org.apache.hadoop.",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\n\nimport org.",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode;\n\nimport static org.junit.Assert.assertEquals;",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode;\n\nimport org.apache.hadoop.classification.InterfaceAud",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode;\n\nimport java.io.IOException;\n\nimport org.apache",
        "private static boolean isReduceableFunctionExpression(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode;\n\nimport java.io.IOException;\nimport java.util."
      ],
      "function range": "116,3-118,3"
    },
    "Closure_57_/src/com/google/javascript/jscomp/ClosureCodingConvention.java_197-198": {
      "loc": "197-198",
      "input": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee != null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();",
      "output": [
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.h",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyr",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyr",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory"
      ],
      "function range": "188,3-204,3"
    },
    "Closure_59_/src/com/google/javascript/jscomp/Compiler.java_255-256": {
      "loc": "255-256",
      "input": "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }",
      "output": [
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  } else if (options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.OFF);\n  } else {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.WARNING);\n  }\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  } else if (options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.OFF);\n  } else {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.WARNING);\n  ",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  } else if (options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.OFF);\n  } else {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.WARNING);\n  }\n  if (options.checkMissingGetCssNameLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_GETCSSNAME,\n        options.checkMissingGetCssNameLevel);\n  } else if (options.disables(DiagnosticGroups.MISSING_GETCSSNAME)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_GETCSSNAME,\n        CheckLevel.OFF);\n  } else {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  } else if (options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.OFF);\n  } else {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.WARNING);\n  }\n  if (options.enables(DiagnosticGroups.ES5_STRICT)) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.ERROR);\n  } else if (options.disables(DiagnosticGroups.ES5_STRICT)) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.OFF);\n  } else {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  } else if (options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.OFF);\n  }\n\n  if (options.enables(DiagnosticGroups.ES5_STRICT)) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.ERROR);\n  } else if (options.disables(DiagnosticGroups.ES5_STRICT)) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.OFF);\n  }\n\n  if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.OFF);\n  }\n\n  if (options.",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  } else if (options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.OFF);\n  } else {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.WARNING);\n  }\n  if (options.enables(DiagnosticGroups.ES5_STRICT)) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.ERROR);\n  } else if (options.disables(DiagnosticGroups.ES5_STRICT)) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.OFF);\n  }\n  if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n    options.",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  } else if (options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.OFF);\n  } else {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.WARNING);\n  }\n  if (options.checkMissingGetCssNameLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_GETCSSNAME,\n        options.checkMissingGetCssNameLevel);\n  } else if (options.disables(DiagnosticGroups.MISSING_GETCSSNAME)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_GETCSSNAME,\n        CheckLevel.OFF);\n  }\n  if (options.enables(DiagnosticGroups.ES5_STRICT))",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  } else if (options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.OFF);\n  }\n\n  if (options.enables(DiagnosticGroups.ES5_STRICT)) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.ERROR);\n  } else if (options.disables(DiagnosticGroups.ES5_STRICT)) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.OFF);\n  }\n\n  if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.ERROR);\n  }\n\n  if (options.",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  } else if (options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.OFF);\n  } else {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.WARNING);\n  }\n  if (options.checkMissingGetCssNameLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_GETCSSNAME,\n        options.checkMissingGetCssNameLevel);\n  } else if (options.disables(DiagnosticGroups.MISSING_GETCSSNAME)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_GETCSSNAME,\n        CheckLevel.OFF);\n  }\n  options.closurePass = processClosurePrimitives;\n  options.angularPass = angularPass",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  } else if (options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.OFF);\n  }\n\n  if (options.enables(DiagnosticGroups.ES5_STRICT)) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.ERROR);\n  } else if (options.disables(DiagnosticGroups.ES5_STRICT)) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.OFF);\n  }\n\n  if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.OFF);\n  }\n\n  // All passes must",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  } else if (options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.OFF);\n  } else {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.WARNING);\n  }\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  } else if (options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.OFF);\n  } else {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.WARNING);\n    "
      ],
      "function range": "226,3-288,3"
    },
    "Closure_62_/src/com/google/javascript/jscomp/LightweightMessageFormatter.java_98-99": {
      "loc": "98-99",
      "input": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null ? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName != null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt != null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)",
      "output": [
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno > 0) {\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append(\"^\");\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno > 0) {\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append(\"^\");\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno > 0) {\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append(\"^\");\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno > 0) {\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append(\"^\");\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n *",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno > 0) {\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append(\"^\");\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno > 0) {\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append(\"^\");\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.ge",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno > 0) {\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append(\"^\");\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno > 0) {\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append(\"^\");\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno > 0) {\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append(\"^\");\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE) && charno > 0) {\n      b.append('\\n');\n      for (int i = 0; i < charno; i++) {\n        b.append(' ');\n      }\n      b.append(\"^\");\n    }\n  }\n  return b.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n"
      ],
      "function range": "66,3-111,3"
    },
    "Closure_65_/src/com/google/javascript/jscomp/CodeGenerator.java_1015-1016": {
      "loc": "1015-1016",
      "input": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {",
      "output": [
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\\"':\n        sb.append(doublequoteEscape);\n        break;\n      case '\\'':\n        sb.append(singlequoteEscape);\n        break;\n      case '\\\\':\n        sb.append(backslashEscape);\n        break;\n      case '\\t':\n        sb.append(\"\\\\t\");\n        break;\n      case '\\b':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\n':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\r':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\f':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u00A0':\n        sb.append(\"\\\\u00A0\");\n        break;\n      case '\\u2028':\n        sb.append(\"\\\\u2028\");\n        break;\n      case '\\u2029':\n        sb.append(\"\\\\u2029\");\n        break;\n      case '\\u0008':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\u000c':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u001c':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\u001d':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\u001e':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\u001f':\n        sb.append(\"\\\\n\");\n        break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\\"':\n        sb.append(doublequoteEscape);\n        break;\n      case '\\'':\n        sb.append(singlequoteEscape);\n        break;\n      case '\\\\':\n        sb.append(backslashEscape);\n        break;\n      case '\\t':\n        sb.append(\"\\\\t\");\n        break;\n      case '\\b':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\n':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\r':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\f':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u00A0':\n        sb.append(\"\\\\u00A0\");\n        break;\n      case '\\u2028':\n        sb.append(\"\\\\u2028\");\n        break;\n      case '\\u2029':\n        sb.append(\"\\\\u2029\");\n        break;\n      case '\\u0008':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\u000c':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u001c':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\u001d':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\u001e':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\u001f':\n        sb.append(\"\\\\n\");\n        break;\n      default:\n        // reference: http://www.unicode.org/versions/Unicode5.1",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\\"':\n        sb.append(doublequoteEscape);\n        break;\n      case '\\'':\n        sb.append(singlequoteEscape);\n        break;\n      case '\\\\':\n        sb.append(backslashEscape);\n        break;\n      case '\\t':\n        sb.append(\"\\\\t\");\n        break;\n      case '\\b':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\n':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\r':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\f':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u00A0':\n        sb.append(\"\\\\u00A0\");\n        break;\n      case '\\u2028':\n        sb.append(\"\\\\u2028\");\n        break;\n      case '\\u2029':\n        sb.append(\"\\\\u2029\");\n        break;\n      case '\\u0008':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\u000C':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u001C':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\u001D':\n        sb.append(\"\\\\u000A\");\n        break;\n      case '\\u001E':\n        sb.append(\"\\\\u000B\");\n        break;\n      case '\\u001F':\n        sb.append(\"\\\\u000C\");\n        break;\n      case '\\u007F':\n        sb.append(\"\\\\u007F\");",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\\"':\n        sb.append(doublequoteEscape);\n        break;\n      case '\\'':\n        sb.append(singlequoteEscape);\n        break;\n      case '\\\\':\n        sb.append(backslashEscape);\n        break;\n      case '\\t':\n        sb.append(\"\\\\t\");\n        break;\n      case '\\b':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\n':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\r':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\f':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u00A0':\n        sb.append(\"\\\\u00A0\");\n        break;\n      case '\\u2028':\n        sb.append(\"\\\\u2028\");\n        break;\n      case '\\u2029':\n        sb.append(\"\\\\u2029\");\n        break;\n      case '\\u0008':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\u000C':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u001C':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\u001D':\n        sb.append(\"\\\\u000A\");\n        break;\n      case '\\u001E':\n        sb.append(\"\\\\u000D\");\n        break;\n      case '\\u001F':\n        sb.append(\"\\\\u001F\");\n        break;\n      case '\\u007F':\n        sb.append(\"\\\\u007F\");",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\\"':\n        sb.append(doublequoteEscape);\n        break;\n      case '\\'':\n        sb.append(singlequoteEscape);\n        break;\n      case '\\\\':\n        sb.append(backslashEscape);\n        break;\n      case '\\t':\n        sb.append(\"\\\\t\");\n        break;\n      case '\\b':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\n':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\r':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\f':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u00A0':\n        sb.append(\"\\\\u00A0\");\n        break;\n      case '\\u2028':\n        sb.append(\"\\\\u2028\");\n        break;\n      case '\\u2029':\n        sb.append(\"\\\\u2029\");\n        break;\n      case '\\u0008':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\u000C':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u001C':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\u001D':\n        sb.append(\"\\\\u000A\");\n        break;\n      case '\\u001E':\n        sb.append(\"\\\\u000B\");\n        break;\n      case '\\u001F':\n        sb.append(\"\\\\u000C\");\n        break;\n      default:\n        //Reference: http://www.unicode.org/versions/",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\\"':\n        sb.append(doublequoteEscape);\n        break;\n      case '\\'':\n        sb.append(singlequoteEscape);\n        break;\n      case '\\\\':\n        sb.append(backslashEscape);\n        break;\n      case '\\t':\n        sb.append(\"\\\\t\");\n        break;\n      case '\\b':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\n':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\r':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\f':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u00A0':\n        sb.append(\"\\\\u00A0\");\n        break;\n      case '\\u2028':\n        sb.append(\"\\\\u2028\");\n        break;\n      case '\\u2029':\n        sb.append(\"\\\\u2029\");\n        break;\n      case '\\u0008':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\u000c':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u001c':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\u001d':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\u001e':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\u001f':\n        sb.append(\"\\\\n\");\n        break;\n      default:\n        // reference: http://www.unicode.org/versions/Unicode5.2",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\\"':\n        sb.append(doublequoteEscape);\n        break;\n      case '\\'':\n        sb.append(singlequoteEscape);\n        break;\n      case '\\\\':\n        sb.append(backslashEscape);\n        break;\n      case '\\t':\n        sb.append(\"\\\\t\");\n        break;\n      case '\\b':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\n':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\r':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\f':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u00A0':\n        sb.append(\"\\\\u00A0\");\n        break;\n      case '\\u2028':\n        sb.append(\"\\\\u2028\");\n        break;\n      case '\\u2029':\n        sb.append(\"\\\\u2029\");\n        break;\n      case '\\u0008':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\u000c':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u001c':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\u001d':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\u001e':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\u001f':\n        sb.append(\"\\\\n\");\n        break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.2",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\\"':\n        sb.append(doublequoteEscape);\n        break;\n      case '\\'':\n        sb.append(singlequoteEscape);\n        break;\n      case '\\\\':\n        sb.append(backslashEscape);\n        break;\n      case '\\t':\n        sb.append(\"\\\\t\");\n        break;\n      case '\\b':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\n':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\r':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\f':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u00A0':\n        sb.append(\"\\\\u00A0\");\n        break;\n      case '\\u2028':\n        sb.append(\"\\\\u2028\");\n        break;\n      case '\\u2029':\n        sb.append(\"\\\\u2029\");\n        break;\n      case '\\u0008':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\u000C':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u001C':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\u001D':\n        sb.append(\"\\\\u000A\");\n        break;\n      case '\\u001E':\n        sb.append(\"\\\\u000B\");\n        break;\n      case '\\u001F':\n        sb.append(\"\\\\u000C\");\n        break;\n      default:\n        if (outputCharsetEncoder!= null) {\n          ",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\\"':\n        sb.append(doublequoteEscape);\n        break;\n      case '\\'':\n        sb.append(singlequoteEscape);\n        break;\n      case '\\\\':\n        sb.append(backslashEscape);\n        break;\n      case '\\t':\n        sb.append(\"\\\\t\");\n        break;\n      case '\\b':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\n':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\r':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\f':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u00A0':\n        sb.append(\"\\\\u00A0\");\n        break;\n      case '\\u2028':\n        sb.append(\"\\\\u2028\");\n        break;\n      case '\\u2029':\n        sb.append(\"\\\\u2029\");\n        break;\n      case '\\u0008':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\u000C':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u001C':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\u001D':\n        sb.append(\"\\\\u000A\");\n        break;\n      case '\\u001E':\n        sb.append(\"\\\\u000B\");\n        break;\n      case '\\u001F':\n        sb.append(\"\\\\u000C\");\n        break;\n      default:\n        // Reference: http://www.unicode.org/versions/",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\\"':\n        sb.append(doublequoteEscape);\n        break;\n      case '\\'':\n        sb.append(singlequoteEscape);\n        break;\n      case '\\\\':\n        sb.append(backslashEscape);\n        break;\n      case '\\t':\n        sb.append(\"\\\\t\");\n        break;\n      case '\\b':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\n':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\r':\n        sb.append(\"\\\\r\");\n        break;\n      case '\\f':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u00A0':\n        sb.append(\"\\\\u00A0\");\n        break;\n      case '\\u2028':\n        sb.append(\"\\\\u2028\");\n        break;\n      case '\\u2029':\n        sb.append(\"\\\\u2029\");\n        break;\n      case '\\u0008':\n        sb.append(\"\\\\b\");\n        break;\n      case '\\u000C':\n        sb.append(\"\\\\f\");\n        break;\n      case '\\u001C':\n        sb.append(\"\\\\n\");\n        break;\n      case '\\u001D':\n        sb.append(\"\\\\u000A\");\n        break;\n      case '\\u001E':\n        sb.append(\"\\\\u000B\");\n        break;\n      case '\\u001F':\n        sb.append(\"\\\\u000C\");\n        break;\n      default:\n        if (outputCharsetEncoder.canEncode(c"
      ],
      "function range": "1005,3-1075,3"
    },
    "Closure_67_/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java_318-319": {
      "loc": "318-319",
      "input": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP",
      "output": [
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node obj = n.getFirstChild();\n    Node prop = n.getLastChild();\n    return (obj.getType() == Token.NAME && obj.getString().equals(\"prototype\"))\n        || (prop.getType() == Token.STRING && prop.getString().equals(\"constructor\"));\n  }\n  return false;\n}\n\n  /**\n   * Determines whether this node is testing for the existence of a property.\n   * If true, we will not emit warnings about a missing property.\n   *\n   * @param getProp The GETPROP being tested.\n   */\n  private boolean isPropertyTest(Node getProp) {\n    Node parent = getProp.getParent();\n    switch (parent.getType()) {\n      case Token.CALL:\n        return parent.getFirstChild()!= getProp &&\n            compiler.getCodingConvention().isPropertyTestFunction(parent);\n\n      case Token.IF:\n      case Token.WHILE:\n      case Token.DO:\n      case Token.FOR:\n        return NodeUtil.getConditionExpression(parent) == getProp;\n\n      case Token.INSTANCEOF:\n      case Token.TYPEOF:\n        return true;\n\n      case Token.AND:\n      case Token.HOOK:\n        return parent.getFirstChild() == getProp;\n\n      case Token.NOT:\n        return parent.getParent().isOr()\n            && parent.getParent().getFirstChild() == parent;\n\n      case Token.CAST:\n        return isPropertyTest(parent);\n      default:\n        break;\n    }\n    return false;\n  }\n\n  /**\n   * Determines whether this node is testing for the nonexistence of a\n   * property. If true, we will not emit warnings for a missing property.\n   *\n   * @param getProp The GETPROP being tested.\n   */\n  private boolean isPropertyAbsence",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node obj = n.getFirstChild();\n    Node prop = n.getLastChild();\n    return (obj.getType() == Token.NAME && obj.getString().equals(\"prototype\"))\n        || (prop.getType() == Token.STRING && prop.getString().equals(\"constructor\"));\n  }\n  return false;\n}\n\n  /**\n   * Determines whether this node is testing for the existence of a property.\n   * If true, we will not emit warnings about a missing property.\n   *\n   * @param getProp The GETPROP being tested.\n   */\n  private boolean isPropertyTest(Node getProp) {\n    Node parent = getProp.getParent();\n    switch (parent.getType()) {\n      case Token.CALL:\n        return parent.getFirstChild()!= getProp &&\n            compiler.getCodingConvention().isPropertyTestFunction(parent);\n\n      case Token.IF:\n      case Token.WHILE:\n      case Token.DO:\n      case Token.FOR:\n        return NodeUtil.getConditionExpression(parent) == getProp;\n\n      case Token.INSTANCEOF:\n      case Token.TYPEOF:\n        return true;\n\n      case Token.AND:\n      case Token.HOOK:\n        return parent.getFirstChild() == getProp;\n\n      case Token.NOT:\n        return parent.getParent().isOr()\n            && parent.getParent().getFirstChild() == parent;\n\n      case Token.CAST:\n        return isPropertyTest(parent);\n    }\n    return false;\n  }\n\n  /**\n   * @return The class name part of a qualified prototype name.\n   */\n  private static String getPrototypeClassName(Node qName) {\n    String qNameStr = qName.getQualifiedName();\n    int prototypeIdx = qNameStr.lastIndexOf(\".prototype.\");\n    int",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node obj = n.getFirstChild();\n    Node prop = n.getLastChild();\n    return (obj.getType() == Token.NAME && obj.getString().equals(\"prototype\"))\n        || (prop.getType() == Token.STRING && prop.getString().equals(\"constructor\"));\n  }\n  return false;\n}\n\n  /**\n   * Determines whether this node is testing for the existence of a property.\n   * If true, we will not emit warnings about a missing property.\n   *\n   * @param propAccess The GETPROP or GETELEM being tested.\n   */\n  static boolean isPropertyTest(AbstractCompiler compiler, Node propAccess) {\n    Node parent = propAccess.getParent();\n    switch (parent.getType()) {\n      case Token.CALL:\n        return parent.getFirstChild()!= propAccess\n            && compiler.getCodingConvention().isPropertyTestFunction(parent);\n\n      case Token.IF:\n      case Token.WHILE:\n      case Token.DO:\n      case Token.FOR:\n        return NodeUtil.getConditionExpression(parent) == propAccess;\n\n      case Token.INSTANCEOF:\n      case Token.TYPEOF:\n      case Token.AND:\n      case Token.OR:\n        return true;\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.NOT:\n        return true;\n\n      default:\n        break;\n    }\n    return false;\n  }\n\n  /**\n   * @return The class name part of a qualified prototype name.\n   */\n  static Node getPrototypeClassName(Node qName) {\n    Node cur = qName;\n    while (",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node obj = n.getFirstChild();\n    Node prop = n.getLastChild();\n    return (obj.getType() == Token.NAME && obj.getString().equals(\"prototype\"))\n        || (prop.getType() == Token.STRING && prop.getString().equals(\"constructor\"));\n  }\n  return false;\n}\n\n  /**\n   * Determines whether this node is testing for the existence of a property.\n   * If true, we will not emit warnings about a missing property.\n   *\n   * @param getProp The GETPROP being tested.\n   */\n  private boolean isPropertyTest(Node getProp) {\n    Node parent = getProp.getParent();\n    switch (parent.getType()) {\n      case Token.CALL:\n        return parent.getFirstChild()!= getProp &&\n            compiler.getCodingConvention().isPropertyTestFunction(parent);\n\n      case Token.IF:\n      case Token.WHILE:\n      case Token.DO:\n      case Token.FOR:\n        return NodeUtil.getConditionExpression(parent) == getProp;\n\n      case Token.INSTANCEOF:\n      case Token.TYPEOF:\n        return true;\n\n      case Token.AND:\n      case Token.HOOK:\n        return parent.getFirstChild() == getProp;\n\n      case Token.NOT:\n        return parent.getParent().isOr()\n            && parent.getParent().getFirstChild() == parent;\n\n      case Token.CAST:\n        return isPropertyTest(parent);\n      default:\n        break;\n    }\n    return false;\n  }\n\n  /**\n   * Determines whether this node is testing for the nonexistence of a\n   * property. If true, we will not emit warnings for a missing property.\n   *\n   * @param propAccess The PROPACCESS being tested.\n   */\n  private boolean isPropertyAbs",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node obj = n.getFirstChild();\n    Node prop = n.getLastChild();\n    return (obj.getType() == Token.NAME && obj.getString().equals(\"prototype\"))\n        || (prop.getType() == Token.STRING && prop.getString().equals(\"constructor\"));\n  }\n  return false;\n}\n\n  /**\n   * Determines whether this node is testing for the existence of a property.\n   * If true, we will not emit warnings about a missing property.\n   *\n   * @param propAccess The GETPROP or GETELEM being tested.\n   */\n  static boolean isPropertyTest(AbstractCompiler compiler, Node propAccess) {\n    Node parent = propAccess.getParent();\n    switch (parent.getType()) {\n      case Token.CALL:\n        return parent.getFirstChild()!= propAccess\n            && compiler.getCodingConvention().isPropertyTestFunction(parent);\n\n      case Token.IF:\n      case Token.WHILE:\n      case Token.DO:\n      case Token.FOR:\n        return NodeUtil.getConditionExpression(parent) == propAccess;\n\n      case Token.INSTANCEOF:\n      case Token.TYPEOF:\n      case Token.AND:\n      case Token.OR:\n        return true;\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.NOT:\n        return true;\n\n      default:\n        break;\n    }\n    return false;\n  }\n\n  /**\n   * @return The class name part of a qualified prototype name.\n   */\n  static Node getPrototypeClassName(Node qName) {\n    Node cur = qName;\n    while ((",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node obj = n.getFirstChild();\n    Node prop = n.getLastChild();\n    return (obj.getType() == Token.NAME && obj.getString().equals(\"prototype\"))\n        || (prop.getType() == Token.STRING && prop.getString().equals(\"constructor\"));\n  }\n  return false;\n}\n\n  /**\n   * Determines whether this node is testing for the existence of a property.\n   * If true, we will not emit warnings about a missing property.\n   *\n   * @param getProp The GETPROP being tested.\n   */\n  private boolean isPropertyTest(Node getProp) {\n    Node parent = getProp.getParent();\n    switch (parent.getType()) {\n      case Token.CALL:\n        return parent.getFirstChild()!= getProp &&\n            compiler.getCodingConvention().isPropertyTestFunction(parent);\n\n      case Token.IF:\n      case Token.WHILE:\n      case Token.DO:\n      case Token.FOR:\n        return NodeUtil.getConditionExpression(parent) == getProp;\n\n      case Token.INSTANCEOF:\n      case Token.TYPEOF:\n        return true;\n\n      case Token.AND:\n      case Token.HOOK:\n        return parent.getFirstChild() == getProp;\n\n      case Token.NOT:\n        return parent.getParent().isOr()\n            && parent.getParent().getFirstChild() == parent;\n\n      case Token.CAST:\n        return isPropertyTest(parent);\n      default:\n        break;\n    }\n    return false;\n  }\n\n  /**\n   * Determines whether this node is testing for the nonexistence of a\n   * property. If true, we will not emit warnings for a missing property.\n   *\n   * @param propAccess The PROPACCESS that is being tested.\n   */\n  private boolean is",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node obj = n.getFirstChild();\n    Node prop = n.getLastChild();\n    return (obj.getType() == Token.NAME && obj.getString().equals(\"prototype\"))\n        || (prop.getType() == Token.STRING && prop.getString().equals(\"constructor\"));\n  }\n  return false;\n}\n\n  /**\n   * Determines whether this node is testing for the existence of a property.\n   * If true, we will not emit warnings about a missing property.\n   *\n   * @param propAccess The GETPROP or GETELEM being tested.\n   */\n  private boolean isPropertyTest(AbstractCompiler compiler, Node propAccess) {\n    Node parent = propAccess.getParent();\n    switch (parent.getType()) {\n      case Token.CALL:\n        return parent.getFirstChild()!= propAccess\n            && compiler.getCodingConvention().isPropertyTestFunction(parent);\n\n      case Token.IF:\n      case Token.WHILE:\n      case Token.DO:\n      case Token.FOR:\n        return NodeUtil.getConditionExpression(parent) == propAccess;\n\n      case Token.INSTANCEOF:\n      case Token.TYPEOF:\n      case Token.AND:\n      case Token.OR:\n        return true;\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.NOT:\n        return true;\n\n      case Token.IN:\n        return parent.getFirstChild() == propAccess;\n\n      case Token.AND:\n      case Token.OR:\n        return parent.getFirstChild() == propAccess;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   ",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node obj = n.getFirstChild();\n    Node prop = n.getLastChild();\n    return (obj.getType() == Token.NAME && obj.getString().equals(\"prototype\"))\n        || (prop.getType() == Token.STRING && prop.getString().equals(\"constructor\"));\n  }\n  return false;\n}\n\n  /**\n   * Determines whether this node is testing for the existence of a property.\n   * If true, we will not emit warnings about a missing property.\n   *\n   * @param getProp The GETPROP being tested.\n   */\n  private boolean isPropertyTest(Node getProp) {\n    Node parent = getProp.getParent();\n    switch (parent.getType()) {\n      case Token.CALL:\n        return parent.getFirstChild()!= getProp &&\n            compiler.getCodingConvention().isPropertyTestFunction(parent);\n\n      case Token.IF:\n      case Token.WHILE:\n      case Token.DO:\n      case Token.FOR:\n        return NodeUtil.getConditionExpression(parent) == getProp;\n\n      case Token.INSTANCEOF:\n      case Token.TYPEOF:\n        return true;\n\n      case Token.AND:\n      case Token.HOOK:\n        return parent.getFirstChild() == getProp;\n\n      case Token.NOT:\n        return parent.getParent().isOr()\n            && parent.getParent().getFirstChild() == parent;\n\n      case Token.CAST:\n        return isPropertyTest(parent);\n      default:\n        break;\n    }\n    return false;\n  }\n\n  /**\n   * Determines whether this node is testing for the nonexistence of a\n   * property. If true, we will not emit warnings for a missing property.\n   *\n   * @param getProp The GETPROP being tested.\n   */\n  private boolean isPropertyAbsent",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node obj = n.getFirstChild();\n    Node prop = n.getLastChild();\n    return (obj.getType() == Token.NAME && obj.getString().equals(\"prototype\"))\n        || (prop.getType() == Token.STRING && prop.getString().equals(\"constructor\"));\n  }\n  return false;\n}\n\n  /**\n   * Determines whether this node is testing for the existence of a property.\n   * If true, we will not emit warnings about a missing property.\n   *\n   * @param propAccess The GETPROP or GETELEM being tested.\n   */\n  private boolean isPropertyTest(AbstractCompiler compiler, Node propAccess) {\n    Node parent = propAccess.getParent();\n    switch (parent.getType()) {\n      case Token.CALL:\n        return parent.getFirstChild()!= propAccess\n            && compiler.getCodingConvention().isPropertyTestFunction(parent);\n\n      case Token.IF:\n      case Token.WHILE:\n      case Token.DO:\n      case Token.FOR:\n        return NodeUtil.getConditionExpression(parent) == propAccess;\n\n      case Token.INSTANCEOF:\n      case Token.TYPEOF:\n      case Token.AND:\n      case Token.OR:\n        return true;\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.NOT:\n        return true;\n\n      case Token.IN:\n        return parent.getFirstChild() == propAccess;\n\n      case Token.AND:\n      case Token.OR:\n        return parent.getFirstChild() == propAccess;\n\n      default:\n        break;\n    }\n    return false;\n  }\n\n",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP) {\n    Node obj = n.getFirstChild();\n    Node prop = n.getLastChild();\n    return (obj.getType() == Token.NAME && obj.getString().equals(\"prototype\"))\n        || (prop.getType() == Token.STRING && prop.getString().equals(\"constructor\"));\n  }\n  return false;\n}\n\n  /**\n   * Determines whether this node is testing for the existence of a property.\n   * If true, we will not emit warnings about a missing property.\n   *\n   * @param getProp The GETPROP being tested.\n   */\n  private boolean isPropertyTest(Node getProp) {\n    Node parent = getProp.getParent();\n    switch (parent.getType()) {\n      case Token.CALL:\n        return parent.getFirstChild()!= getProp &&\n            compiler.getCodingConvention().isPropertyTestFunction(parent);\n\n      case Token.IF:\n      case Token.WHILE:\n      case Token.DO:\n      case Token.FOR:\n        return NodeUtil.getConditionExpression(parent) == getProp;\n\n      case Token.INSTANCEOF:\n      case Token.TYPEOF:\n        return true;\n\n      case Token.AND:\n      case Token.HOOK:\n        return parent.getFirstChild() == getProp;\n\n      case Token.NOT:\n        return parent.getParent().isOr()\n            && parent.getParent().getFirstChild() == parent;\n\n      case Token.CAST:\n        return isPropertyTest(parent);\n    }\n    return false;\n  }\n\n  /**\n   * @return The class name part of a qualified prototype name.\n   */\n  private static String getPrototypeClassName(Node qName) {\n    String qNameStr = qName.getQualifiedName();\n    int prototypeIdx = qNameStr.lastIndexOf(\".prototype.\");\n    Node"
      ],
      "function range": "314,5-334,5"
    },
    "Closure_70_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1745-1746": {
      "loc": "1745-1746",
      "input": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType != null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters != null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter != null) {\n          defineSlot(astParameter, functionNode,",
      "output": [
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSDocInfo());\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null);\n        }\n      }\n    }\n  }\n\n  Node block = body.getNext();\n  for (Node child = block.getFirstChild();\n       child!= null; child = child.getNext()) {\n    if (child.isExprResult()) {\n      defineSlot(child.getFirstChild(), functionNode, null);\n    }\n  }\n}\n\n  private void defineSlot(Node node, Node source, JSDocInfo info) {\n    String name = node.getQualifiedName();\n    if (name == null) {\n      return;\n    }\n    int i = name.indexOf('.');\n    String topName = i == -1? name : name.substring(0, i);\n    Var var = scope.getSlot(topName);\n    if (var == null) {\n      var = scope.getParam(topName);\n    }\n    if (var == null) {\n      var = scope.getParamOrVar(topName);\n    }\n    if (var == null) {\n      compiler.report(\n          JSError.make(source, MALFORMED_FUNCTION_DECLARATION));\n      return;\n    }\n    if (info!= null) {\n      var.setJSDocInfo(info);\n    }\n    JSType type = node.getJSType();\n    if (type!= null) {\n",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSDocInfo());\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null);\n        }\n      }\n    }\n  }\n\n  Node block = body.getNext();\n  for (Node child = block.getFirstChild();\n       child!= null; child = child.getNext()) {\n    if (child.isExprResult()) {\n      defineSlot(child.getFirstChild(), functionNode, null);\n    }\n  }\n}\n\n  private void defineSlot(Node node, Node source, JSDocInfo info) {\n    String name = node.getQualifiedName();\n    if (name == null) {\n      return;\n    }\n    int i = name.indexOf('.');\n    String topName = i == -1? name : name.substring(0, i);\n    Var var = scope.getSlot(topName);\n    if (var == null) {\n      var = scope.getParam(topName);\n    }\n    if (var == null) {\n      var = scope.getParamOrVar(topName);\n    }\n    if (var == null) {\n      compiler.report(\n          JSError.make(source, UNDEFINED_NAME_WARNING, name));\n      return;\n    }\n    if (info!= null) {\n      var.setJSDocInfo(info);\n    }\n    JSType type = node.getJSType();\n    if (type!= null) {\n      var.",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSDocInfo());\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null);\n        }\n      }\n    }\n  }\n\n  Node block = body.getNext();\n  for (Node child = block.getFirstChild();\n       child!= null; child = child.getNext()) {\n    if (child.isExprResult()) {\n      defineSlot(child.getFirstChild(), functionNode, null);\n    }\n  }\n}\n\n  private void defineSlot(Node node, Node source, JSDocInfo info) {\n    String name = node.getQualifiedName();\n    if (name == null) {\n      return;\n    }\n    int i = name.indexOf('.');\n    String topName = i == -1? name : name.substring(0, i);\n    Var var = scope.getSlot(topName);\n    if (var == null) {\n      var = scope.getParam(topName);\n    }\n    if (var == null) {\n      var = scope.getParamOrVar(topName);\n    }\n    if (var == null) {\n      compiler.report(\n          JSError.make(source, MALFORMED_FUNCTION_DECLARATION));\n      return;\n    }\n    if (info!= null) {\n      var.getScope().setJSDocInfo(info);\n    }\n    JSType type = node.getJSType();\n    if (type!= null",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSDocInfo());\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null);\n        }\n      }\n    }\n  }\n\n  Node block = body.getNext();\n  for (Node child = block.getFirstChild();\n       child!= null; child = child.getNext()) {\n    if (child.isExprResult()) {\n      defineSlot(child.getFirstChild(), functionNode, null);\n    }\n  }\n}\n\n  private void defineSlot(Node node, Node source, JSDocInfo info) {\n    String name = node.getQualifiedName();\n    if (name == null) {\n      return;\n    }\n    int i = name.indexOf('.');\n    String topName = i == -1? name : name.substring(0, i);\n    Var var = scope.getSlot(topName);\n    if (var == null) {\n      var = scope.getParam(topName);\n    }\n    if (var == null) {\n      var = scope.getParamOrVar(topName);\n    }\n    if (var == null) {\n      compiler.report(\n          JSError.make(source, MALFORMED_SIGNATURE_ERROR, name));\n      return;\n    }\n    if (info!= null) {\n      var.setJSDocInfo(info);\n    }\n    JSType type = node.getJSType();\n    if (type!= null) {\n      var",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSDocInfo());\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null);\n        }\n      }\n    }\n  }\n\n  Node block = body.getNext();\n  for (Node child = block.getFirstChild();\n       child!= null; child = child.getNext()) {\n    if (child.isExprResult()) {\n      defineSlot(child.getFirstChild(), functionNode, null);\n    }\n  }\n}\n\n  private void defineSlot(Node node, Node source, JSDocInfo info) {\n    String name = node.getQualifiedName();\n    if (name == null) {\n      return;\n    }\n    int i = name.indexOf('.');\n    String topName = i == -1? name : name.substring(0, i);\n    Var var = scope.getSlot(topName);\n    if (var == null) {\n      var = scope.getParam(topName);\n    }\n    if (var == null) {\n      var = scope.getParamOrVar(topName);\n    }\n    if (var == null) {\n      compiler.report(\n          JSError.make(source, MALFORMED_FUNCTION_DECLARATION));\n      return;\n    }\n    if (info!= null) {\n      var.setJSDocInfo(info);\n    }\n    defineSlot(node, var, source);\n  }\n\n  private void defineSlot(Node node,",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSDocInfo());\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null);\n        }\n      }\n    }\n  }\n\n  Node block = body.getNext();\n  for (Node child = block.getFirstChild();\n       child!= null; child = child.getNext()) {\n    if (child.isExprResult()) {\n      defineSlot(child.getFirstChild(), functionNode, null);\n    }\n  }\n}\n\n  private void defineSlot(Node node, Node source, JSDocInfo info) {\n    String name = node.getQualifiedName();\n    if (name == null) {\n      return;\n    }\n    int i = name.indexOf('.');\n    String topName = i == -1? name : name.substring(0, i);\n    Var var = scope.getSlot(topName);\n    if (var == null) {\n      var = scope.getParam(topName);\n    }\n    if (var == null) {\n      var = scope.getParamOrVar(topName);\n    }\n    if (var == null) {\n      compiler.report(\n          JSError.make(source, UNDEFINED_NAME_WARNING, name));\n      return;\n    }\n    if (info!= null) {\n      var.setJSDocInfo(info);\n    }\n    defineSlot(node, var, source);\n  }\n\n  private void defineSlot(Node node, Var var,",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSDocInfo());\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null);\n        }\n      }\n    }\n  }\n\n  Node block = body.getNext();\n  for (Node child = block.getFirstChild();\n       child!= null; child = child.getNext()) {\n    if (child.isExprResult()) {\n      defineSlot(child.getFirstChild(), functionNode, null);\n    }\n  }\n}\n\n  private void defineSlot(Node node, Node source, JSDocInfo info) {\n    String name = node.getQualifiedName();\n    if (name == null) {\n      return;\n    }\n    int i = name.indexOf('.');\n    String topName = i == -1? name : name.substring(0, i);\n    Var var = scope.getSlot(topName);\n    if (var == null) {\n      var = scope.getParam(topName);\n    }\n    if (var == null) {\n      var = scope.getParamOrVar(topName);\n    }\n    if (var == null) {\n      compiler.report(\n          JSError.make(source, MALFORMED_SIGNATURE_ERROR, name));\n      return;\n    }\n    if (info!= null) {\n      var.setJSDocInfo(info);\n    }\n    JSType type = node.getJSType();\n    if (type!= null) {\n      node",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSDocInfo());\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null);\n        }\n      }\n    }\n  }\n\n  Node block = body.getNext();\n  for (Node child = block.getFirstChild();\n       child!= null; child = child.getNext()) {\n    if (child.isExprResult()) {\n      defineSlot(child.getFirstChild(), functionNode, null);\n    }\n  }\n}\n\n  private void defineSlot(Node node, Node source, JSDocInfo info) {\n    String name = node.getQualifiedName();\n    if (name == null) {\n      return;\n    }\n    int i = name.indexOf('.');\n    String topName = i == -1? name : name.substring(0, i);\n    Var var = scope.getSlot(topName);\n    if (var == null) {\n      var = scope.getParam(topName);\n    }\n    if (var == null) {\n      var = scope.getParamOrVar(topName);\n    }\n    if (var == null) {\n      compiler.report(\n          JSError.make(source, UNDEFINED_NAME_WARNING, name));\n      return;\n    }\n    if (info!= null) {\n      var.setJSDocInfo(info);\n    }\n    JSType type = node.getJSType();\n    if (type!= null) {\n      node.",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSDocInfo());\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null);\n        }\n      }\n    }\n  }\n\n  Node block = body.getNext();\n  for (Node child = block.getFirstChild();\n       child!= null; child = child.getNext()) {\n    if (child.isExprResult()) {\n      defineSlot(child.getFirstChild(), functionNode, null);\n    }\n  }\n}\n\n  private void defineSlot(Node node, Node source, JSDocInfo info) {\n    String name = node.getQualifiedName();\n    if (name == null) {\n      return;\n    }\n    int i = name.indexOf('.');\n    String topName = i == -1? name : name.substring(0, i);\n    Var var = scope.getSlot(topName);\n    if (var == null) {\n      var = scope.getParam(topName);\n    }\n    if (var == null) {\n      var = scope.getParamOrVar(topName);\n    }\n    if (var == null) {\n      compiler.report(\n          JSError.make(source, MALFORMED_FUNCTION_DECLARATION));\n      return;\n    }\n    if (info!= null) {\n      var.setJSDocInfo(info);\n    }\n    JSType type = node.getJSType();\n    if (type == null) {\n",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSDocInfo());\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null);\n        }\n      }\n    }\n  }\n\n  Node block = body.getNext();\n  for (Node child = block.getFirstChild();\n       child!= null; child = child.getNext()) {\n    if (child.isExprResult()) {\n      defineSlot(child.getFirstChild(), functionNode, null);\n    }\n  }\n}\n\n  private void defineSlot(Node node, Node source, JSDocInfo info) {\n    String name = node.getQualifiedName();\n    if (name == null) {\n      return;\n    }\n    int i = name.indexOf('.');\n    String topName = i == -1? name : name.substring(0, i);\n    Var var = scope.getSlot(topName);\n    if (var == null) {\n      var = scope.getParam(topName);\n    }\n    if (var == null) {\n      var = scope.getParamOrVar(topName);\n    }\n    if (var == null) {\n      compiler.report(\n          JSError.make(source, MALFORMED_FUNCTION_DECLARATION));\n      return;\n    }\n    if (info!= null) {\n      var.setJSDocInfo(info);\n    }\n    defineSlot(node, var, source);\n  }\n\n  /**\n   * Defines a property"
      ],
      "function range": "1734,5-1753,5"
    },
    "Closure_71_/src/com/google/javascript/jscomp/CheckAccessControls.java_416-417": {
      "loc": "416-417",
      "input": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType != null) {",
      "output": [
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSDocInfo docInfo = parent.getJSDocInfo();\n    if (docInfo!= null && docInfo.getVisibility()!= Visibility.INHERITED) {\n      objectType.setPropertyVisibility(propertyName, docInfo.getVisibility());\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSDocInfo docInfo = parent.getJSDocInfo();\n    if (docInfo!= null && docInfo.getVisibility()!= Visibility.PRIVATE) {\n      objectType.setPropertyVisibility(propertyName, docInfo.getVisibility());\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSDocInfo docInfo = parent.getJSDocInfo();\n    if (docInfo!= null && docInfo.getVisibility()!= Visibility.INHERITED) {\n      objectType.setPropertyVisibility(propertyName, docInfo.getVisibility());\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IA",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSDocInfo docInfo = parent.getJSDocInfo();\n    if (docInfo!= null && docInfo.getVisibility()!= Visibility.INHERITED) {\n      objectType.setPropertyVisibility(propertyName, docInfo.getVisibility());\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvalu",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSDocInfo docInfo = parent.getJSDocInfo();\n    if (docInfo!= null && docInfo.getVisibility()!= Visibility.PRIVATE) {\n      objectType.setPropertyVisibility(propertyName, docInfo.getVisibility());\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IA",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSDocInfo docInfo = parent.getJSDocInfo();\n    if (docInfo!= null && docInfo.getVisibility()!= Visibility.PRIVATE) {\n      objectType.setPropertyVisibility(propertyName, docInfo.getVisibility());\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvalu",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSDocInfo docInfo = parent.getJSDocInfo();\n    if (docInfo!= null && docInfo.getVisibility()!= Visibility.INHERITED) {\n      objectType.setPropertyVisibility(propertyName, docInfo.getVisibility());\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\n",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSDocInfo docInfo = parent.getJSDocInfo();\n    if (docInfo!= null && docInfo.getVisibility()!= Visibility.PRIVATE) {\n      objectType.setPropertyVisibility(propertyName, docInfo.getVisibility());\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\n",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSDocInfo docInfo = parent.getJSDocInfo();\n    if (docInfo!= null && docInfo.getVisibility()!= Visibility.INHERITED) {\n      objectType.setPropertyVisibility(propertyName, docInfo.getVisibility());\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    JSDocInfo docInfo = parent.getJSDocInfo();\n    if (docInfo!= null && docInfo.getVisibility()!= Visibility.PRIVATE) {\n      objectType.setPropertyVisibility(propertyName, docInfo.getVisibility());\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;"
      ],
      "function range": "407,3-500,3"
    },
    "Closure_82_/src/com/google/javascript/rhino/jstype/JSType.java_163-164": {
      "loc": "163-164",
      "input": "public final boolean isEmptyType() {",
      "output": [
        "public final boolean isEmptyType() {\n        return this == EMPTY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is an array type.\n     *\n     * @return {@code true} if this type is an array type.\n     */\n    public final boolean isArrayType() {\n        return this == ARRAY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a class type.\n     *\n     * @return {@code true} if this type is a class type.\n     */\n    public final boolean isClassType() {\n        return this == CLASS_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a parameterized type.\n     *\n     * @return {@code true} if this type is a parameterized type.\n     */\n    public final boolean isParameterizedType() {\n        return this == PARAMETERIZED_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a raw type.\n     *\n     * @return {@code true} if this type is a raw type.\n     */\n    public final boolean isRawType() {\n        return this == RAW_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a type variable.\n     *\n     * @return {@code true} if this type is a type variable.\n     */\n    public final boolean isTypeVariable() {\n        return this == TYPE_VARIABLE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a wildcard type.\n     *\n     * @return {@code true} if this type is a wildcard type.\n     */\n    public final boolean isWildcardType() {\n        return this == WILDCARD_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a primitive type.\n     *\n     * @return {@code true} if this type is a primitive type.\n     */\n    public final boolean isPrimitiveType() {\n        return this == PRIMITIVE_TYPE;\n    }\n\n    /**\n     * Returns",
        "public final boolean isEmptyType() {\n        return this == EMPTY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is an array type.\n     *\n     * @return {@code true} if this type is an array type.\n     */\n    public final boolean isArrayType() {\n        return this == ARRAY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a class type.\n     *\n     * @return {@code true} if this type is a class type.\n     */\n    public final boolean isClassType() {\n        return this == CLASS_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a parameterized type.\n     *\n     * @return {@code true} if this type is a parameterized type.\n     */\n    public final boolean isParameterizedType() {\n        return this == PARAMETERIZED_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a type variable.\n     *\n     * @return {@code true} if this type is a type variable.\n     */\n    public final boolean isTypeVariable() {\n        return this == TYPE_VARIABLE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a wildcard type.\n     *\n     * @return {@code true} if this type is a wildcard type.\n     */\n    public final boolean isWildcardType() {\n        return this == WILDCARD_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a primitive type.\n     *\n     * @return {@code true} if this type is a primitive type.\n     */\n    public final boolean isPrimitiveType() {\n        return this == PRIMITIVE_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a void type.\n     *\n     * @return {@code true} if this type is a void type.\n     */\n    public final boolean isVoidType() {\n        return this == VOID_TYPE;\n    }\n\n    /**\n     ",
        "public final boolean isEmptyType() {\n        return this == EMPTY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is an array type.\n     *\n     * @return {@code true} if this type is an array type.\n     */\n    public final boolean isArrayType() {\n        return this == ARRAY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a class type.\n     *\n     * @return {@code true} if this type is a class type.\n     */\n    public final boolean isClassType() {\n        return this == CLASS_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a parameterized type.\n     *\n     * @return {@code true} if this type is a parameterized type.\n     */\n    public final boolean isParameterizedType() {\n        return this == PARAMETERIZED_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a raw type.\n     *\n     * @return {@code true} if this type is a raw type.\n     */\n    public final boolean isRawType() {\n        return this == RAW_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a type variable.\n     *\n     * @return {@code true} if this type is a type variable.\n     */\n    public final boolean isTypeVariable() {\n        return this == TYPE_VARIABLE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a wildcard type.\n     *\n     * @return {@code true} if this type is a wildcard type.\n     */\n    public final boolean isWildcardType() {\n        return this == WILDCARD_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a functional interface.\n     *\n     * @return {@code true} if this type is a functional interface.\n     */\n    public final boolean isFunctionalInterface() {\n        return this == FUNCTIONAL_INTERFACE;\n    }\n\n    /**\n     *",
        "public final boolean isEmptyType() {\n        return this == EMPTY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is an array type.\n     *\n     * @return {@code true} if this type is an array type.\n     */\n    public final boolean isArrayType() {\n        return this == ARRAY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a class type.\n     *\n     * @return {@code true} if this type is a class type.\n     */\n    public final boolean isClassType() {\n        return this == CLASS_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a parameterized type.\n     *\n     * @return {@code true} if this type is a parameterized type.\n     */\n    public final boolean isParameterizedType() {\n        return this == PARAMETERIZED_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a type variable.\n     *\n     * @return {@code true} if this type is a type variable.\n     */\n    public final boolean isTypeVariable() {\n        return this == TYPE_VARIABLE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a wildcard type.\n     *\n     * @return {@code true} if this type is a wildcard type.\n     */\n    public final boolean isWildcardType() {\n        return this == WILDCARD_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a primitive type.\n     *\n     * @return {@code true} if this type is a primitive type.\n     */\n    public final boolean isPrimitiveType() {\n        return this == PRIMITIVE_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is void.\n     *\n     * @return {@code true} if this type is void.\n     */\n    public final boolean isVoidType() {\n        return this == VOID_TYPE;\n    }\n\n    /**\n     * Returns {@",
        "public final boolean isEmptyType() {\n        return this == EMPTY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is an array type.\n     *\n     * @return {@code true} if this type is an array type.\n     */\n    public final boolean isArrayType() {\n        return this == ARRAY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a class type.\n     *\n     * @return {@code true} if this type is a class type.\n     */\n    public final boolean isClassType() {\n        return this == CLASS_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a parameterized type.\n     *\n     * @return {@code true} if this type is a parameterized type.\n     */\n    public final boolean isParameterizedType() {\n        return this == PARAMETERIZED_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a raw type.\n     *\n     * @return {@code true} if this type is a raw type.\n     */\n    public final boolean isRawType() {\n        return this == RAW_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a type variable.\n     *\n     * @return {@code true} if this type is a type variable.\n     */\n    public final boolean isTypeVariable() {\n        return this == TYPE_VARIABLE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a wildcard type.\n     *\n     * @return {@code true} if this type is a wildcard type.\n     */\n    public final boolean isWildcardType() {\n        return this == WILDCARD_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a primitive type.\n     *\n     * @return {@code true} if this type is a primitive type.\n     */\n    public final boolean isPrimitiveType() {\n        return this == PRIMITIVE_TYPE;\n    }\n\n    @Override\n    public",
        "public final boolean isEmptyType() {\n        return this == EMPTY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is an array type.\n     *\n     * @return {@code true} if this type is an array type.\n     */\n    public final boolean isArrayType() {\n        return this == ARRAY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a class type.\n     *\n     * @return {@code true} if this type is a class type.\n     */\n    public final boolean isClassType() {\n        return this == CLASS_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a parameterized type.\n     *\n     * @return {@code true} if this type is a parameterized type.\n     */\n    public final boolean isParameterizedType() {\n        return this == PARAMETERIZED_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a raw type.\n     *\n     * @return {@code true} if this type is a raw type.\n     */\n    public final boolean isRawType() {\n        return this == RAW_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a type variable.\n     *\n     * @return {@code true} if this type is a type variable.\n     */\n    public final boolean isTypeVariable() {\n        return this == TYPE_VARIABLE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a wildcard type.\n     *\n     * @return {@code true} if this type is a wildcard type.\n     */\n    public final boolean isWildcardType() {\n        return this == WILDCARD_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a primitive type.\n     *\n     * @return {@code true} if this type is a primitive type.\n     */\n    public final boolean isPrimitiveType() {\n        return this == PRIMITIVE_TYPE;\n    }\n}\n<|java",
        "public final boolean isEmptyType() {\n        return this == EMPTY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is an array type.\n     *\n     * @return {@code true} if this type is an array type.\n     */\n    public final boolean isArrayType() {\n        return this == ARRAY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a class type.\n     *\n     * @return {@code true} if this type is a class type.\n     */\n    public final boolean isClassType() {\n        return this == CLASS_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a parameterized type.\n     *\n     * @return {@code true} if this type is a parameterized type.\n     */\n    public final boolean isParameterizedType() {\n        return this == PARAMETERIZED_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a type variable.\n     *\n     * @return {@code true} if this type is a type variable.\n     */\n    public final boolean isTypeVariable() {\n        return this == TYPE_VARIABLE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a wildcard type.\n     *\n     * @return {@code true} if this type is a wildcard type.\n     */\n    public final boolean isWildcardType() {\n        return this == WILDCARD_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a primitive type.\n     *\n     * @return {@code true} if this type is a primitive type.\n     */\n    public final boolean isPrimitiveType() {\n        return this == PRIMITIVE_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is {@code void}.\n     *\n     * @return {@code true} if this type is {@code void}.\n     */\n    public final boolean isVoidType() {\n        return this == VOID_TYPE;\n    }\n\n    /**",
        "public final boolean isEmptyType() {\n        return this == EMPTY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is an array type.\n     *\n     * @return {@code true} if this type is an array type.\n     */\n    public final boolean isArrayType() {\n        return this == ARRAY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a class type.\n     *\n     * @return {@code true} if this type is a class type.\n     */\n    public final boolean isClassType() {\n        return this == CLASS_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a parameterized type.\n     *\n     * @return {@code true} if this type is a parameterized type.\n     */\n    public final boolean isParameterizedType() {\n        return this == PARAMETERIZED_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a type variable.\n     *\n     * @return {@code true} if this type is a type variable.\n     */\n    public final boolean isTypeVariable() {\n        return this == TYPE_VARIABLE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a wildcard type.\n     *\n     * @return {@code true} if this type is a wildcard type.\n     */\n    public final boolean isWildcardType() {\n        return this == WILDCARD_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a primitive type.\n     *\n     * @return {@code true} if this type is a primitive type.\n     */\n    public final boolean isPrimitiveType() {\n        return this == PRIMITIVE_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a void type.\n     *\n     * @return {@code true} if this type is a void type.\n     */\n    public final boolean isVoidType() {\n        return this == VOID_TYPE;\n    }\n}\n<",
        "public final boolean isEmptyType() {\n        return this == EMPTY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is an array type.\n     *\n     * @return {@code true} if this type is an array type.\n     */\n    public final boolean isArrayType() {\n        return this == ARRAY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a class type.\n     *\n     * @return {@code true} if this type is a class type.\n     */\n    public final boolean isClassType() {\n        return this == CLASS_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a parameterized type.\n     *\n     * @return {@code true} if this type is a parameterized type.\n     */\n    public final boolean isParameterizedType() {\n        return this == PARAMETERIZED_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a raw type.\n     *\n     * @return {@code true} if this type is a raw type.\n     */\n    public final boolean isRawType() {\n        return this == RAW_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a type variable.\n     *\n     * @return {@code true} if this type is a type variable.\n     */\n    public final boolean isTypeVariable() {\n        return this == TYPE_VARIABLE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a wildcard type.\n     *\n     * @return {@code true} if this type is a wildcard type.\n     */\n    public final boolean isWildcardType() {\n        return this == WILDCARD_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a primitive type.\n     *\n     * @return {@code true} if this type is a primitive type.\n     */\n    public final boolean isPrimitive() {\n        return this == PRIMITIVE_TYPE;\n    }\n\n    /**\n     * Returns {",
        "public final boolean isEmptyType() {\n        return this == EMPTY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is an array type.\n     *\n     * @return {@code true} if this type is an array type.\n     */\n    public final boolean isArrayType() {\n        return this == ARRAY_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a class type.\n     *\n     * @return {@code true} if this type is a class type.\n     */\n    public final boolean isClassType() {\n        return this == CLASS_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a parameterized type.\n     *\n     * @return {@code true} if this type is a parameterized type.\n     */\n    public final boolean isParameterizedType() {\n        return this == PARAMETERIZED_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a type variable.\n     *\n     * @return {@code true} if this type is a type variable.\n     */\n    public final boolean isTypeVariable() {\n        return this == TYPE_VARIABLE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a wildcard type.\n     *\n     * @return {@code true} if this type is a wildcard type.\n     */\n    public final boolean isWildcardType() {\n        return this == WILDCARD_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a primitive type.\n     *\n     * @return {@code true} if this type is a primitive type.\n     */\n    public final boolean isPrimitiveType() {\n        return this == PRIMITIVE_TYPE;\n    }\n\n    /**\n     * Returns {@code true} if this type is a void type.\n     *\n     * @return {@code true} if this type is a void type.\n     */\n    public final boolean isVoidType() {\n        return this == VOID_TYPE;\n    }\n\n    @Override\n"
      ],
      "function range": "162,3-164,3"
    },
    "Closure_83_/src/com/google/javascript/jscomp/CommandLineRunner.java_334-335": {
      "loc": "334-335",
      "input": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {",
      "output": [
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n\n  @Override\n  public String getCommandName() {\n    return COMMAND_NAME;\n  }\n\n  @Override\n  public String getCommandUsage() {\n    return COMMAND_USAGE;\n  }\n\n  @Override\n  public String getCommandDescription() {\n    return COMMAND_DESCRIPTION;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheAtomicityMode;\nimport org.apache.ignite.cache.CacheMode;\nimport org.apache.ignite.configuration.CacheConfiguration;\nimport org.apache.ignite.configuration.IgniteConfiguration;\nimport org.apache.ignite.configuration.NearCacheConfiguration;\nimport org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.TcpDiscoveryIpFinder;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.vm.TcpDiscoveryVmIpFinder;\nimport org.apache",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n\n  @Override\n  public String getCommandName() {\n    return COMMAND_NAME;\n  }\n\n  @Override\n  public String getCommandUsage() {\n    return COMMAND_USAGE;\n  }\n\n  @Override\n  public String getCommandDescription() {\n    return COMMAND_DESCRIPTION;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheAtomicityMode;\nimport org.apache.ignite.cache.CacheMode;\nimport org.apache.ignite.configuration.CacheConfiguration;\nimport org.apache.ignite.configuration.IgniteConfiguration;\nimport org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.TcpDiscoveryIpFinder;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.vm.TcpDiscoveryVmIpFinder;\nimport org.apache.ignite.testframework.junits.common.GridCommonAbstractTest",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n\n  @Override\n  public String getCommandName() {\n    return COMMAND_NAME;\n  }\n\n  @Override\n  public String getCommandUsage() {\n    return COMMAND_USAGE;\n  }\n\n  @Override\n  public String getCommandDescription() {\n    return COMMAND_DESCRIPTION;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheAtomicityMode;\nimport org.apache.ignite.cache.CacheMode;\nimport org.apache.ignite.configuration.CacheConfiguration;\nimport org.apache.ignite.configuration.IgniteConfiguration;\nimport org.apache.ignite.configuration.NearCacheConfiguration;\nimport org.apache.ignite.internal.util.typedef.internal.U;\nimport org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.TcpDiscoveryIpFinder;\nimport org.apache.ignite.spi.discovery.tcp.",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n\n  @Override\n  public String getCommandName() {\n    return COMMAND_NAME;\n  }\n\n  @Override\n  public String getCommandUsage() {\n    return COMMAND_USAGE;\n  }\n\n  @Override\n  public String getCommandDescription() {\n    return COMMAND_DESCRIPTION;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheAtomicityMode;\nimport org.apache.ignite.cache.CacheMode;\nimport org.apache.ignite.configuration.CacheConfiguration;\nimport org.apache.ignite.configuration.IgniteConfiguration;\nimport org.apache.ignite.configuration.NearCacheConfiguration;\nimport org.apache.ignite.internal.IgniteKernal;\nimport org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.TcpDiscoveryIpFinder;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.vm.",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n\n  @Override\n  public String getCommandName() {\n    return COMMAND_NAME;\n  }\n\n  @Override\n  public String getCommandUsage() {\n    return COMMAND_USAGE;\n  }\n\n  @Override\n  public String getCommandDescription() {\n    return COMMAND_DESCRIPTION;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheAtomicityMode;\nimport org.apache.ignite.cache.CacheMode;\nimport org.apache.ignite.configuration.CacheConfiguration;\nimport org.apache.ignite.configuration.IgniteConfiguration;\nimport org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.TcpDiscoveryIpFinder;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.vm.TcpDiscoveryVmIpFinder;\nimport org.apache.ignite.testframework.GridTestUtils;\nimport org.",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n\n  @Override\n  public String getCommandName() {\n    return COMMAND_NAME;\n  }\n\n  @Override\n  public String getCommandUsage() {\n    return COMMAND_USAGE;\n  }\n\n  @Override\n  public String getCommandDescription() {\n    return COMMAND_DESCRIPTION;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheAtomicityMode;\nimport org.apache.ignite.cache.CacheMode;\nimport org.apache.ignite.configuration.CacheConfiguration;\nimport org.apache.ignite.configuration.IgniteConfiguration;\nimport org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.TcpDiscoveryIpFinder;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.vm.TcpDiscoveryVmIpFinder;\nimport org.apache.ignite.spi.swapspace.file.FileSwap",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n\n  @Override\n  public String getCommandName() {\n    return COMMAND_NAME;\n  }\n\n  @Override\n  public String getCommandUsage() {\n    return COMMAND_USAGE;\n  }\n\n  @Override\n  public String getCommandDescription() {\n    return COMMAND_DESCRIPTION;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheAtomicityMode;\nimport org.apache.ignite.cache.CacheMode;\nimport org.apache.ignite.configuration.CacheConfiguration;\nimport org.apache.ignite.configuration.IgniteConfiguration;\nimport org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.TcpDiscoveryIpFinder;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.vm.TcpDiscoveryVmIpFinder;\nimport org.apache.ignite.testframework.MvccFeatureChecker;\nimport",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n\n  @Override\n  public String getCommandName() {\n    return COMMAND_NAME;\n  }\n\n  @Override\n  public String getCommandUsage() {\n    return COMMAND_USAGE;\n  }\n\n  @Override\n  public String getCommandDescription() {\n    return COMMAND_DESCRIPTION;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheAtomicityMode;\nimport org.apache.ignite.cache.CacheMode;\nimport org.apache.ignite.configuration.CacheConfiguration;\nimport org.apache.ignite.configuration.IgniteConfiguration;\nimport org.apache.ignite.configuration.NearCacheConfiguration;\nimport org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.TcpDiscoveryIpFinder;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.vm.TcpDiscoveryVmIpFinder;\n\nimport static org",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n\n  @Override\n  public String getDefaultMetaVariable() {\n    return null;\n  }\n\n  @Override\n  public String getShortDescription() {\n    return null;\n  }\n\n  @Override\n  public String getUsageFooter() {\n    return null;\n  }\n\n  @Override\n  public String getDescription() {\n    return null;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\n\n/**\n * Compute IF(expr1, expr2, expr3) for 3 input column expressions.\n * The first is always a boolean (LongColumnVector).\n * The second is a string (BytesColumnVector).\n * The third is a string (BytesColumn",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    return 0;\n  }\n\n  @Override\n  public String getCommandName() {\n    return COMMAND_NAME;\n  }\n\n  @Override\n  public String getCommandUsage() {\n    return COMMAND_USAGE;\n  }\n\n  @Override\n  public String getCommandDescription() {\n    return COMMAND_DESCRIPTION;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheAtomicityMode;\nimport org.apache.ignite.cache.CacheMode;\nimport org.apache.ignite.configuration.CacheConfiguration;\nimport org.apache.ignite.configuration.IgniteConfiguration;\nimport org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.TcpDiscoveryIpFinder;\nimport org.apache.ignite.spi.discovery.tcp.ipfinder.vm.TcpDiscoveryVmIpFinder;\nimport org.apache.ignite.testframework.GridTestUtils;\n\nimport static"
      ],
      "function range": "332,7-351,7"
    },
    "Closure_86_/src/com/google/javascript/jscomp/NodeUtil.java_2465-2466": {
      "loc": "2465-2466",
      "input": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:",
      "output": [
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n    case Token.TAGGED_TEMPLATELIT:\n    case Token.TEMPLATELIT:\n      break;\n    default:\n      return true;\n    }\n    for (Node c = value.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!locals.apply(c)) {\n        return",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.DELPROP:\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x =",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n    case Token.TAGGED_TEMPLATELIT:\n    case Token.TEMPLATELIT:\n    case Token.TEMPLATELIT_STRING:\n      break;\n    default:\n      return true;\n    }\n    for (Node c = value.getFirstChild(); c!= null; c = c.getNext()) {",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n    case Token.TAGGED_TEMPLATELIT:\n    case Token.TEMPLATELIT:\n      break;\n    default:\n      return true;\n    }\n    for (Node c = value.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!evaluatesToLocalValue(c, locals)) {",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n    case Token.TAGGED_TEMPLATELIT:\n    case Token.TEMPLATELIT:\n    case Token.TEMPLATELIT_STRING:\n    case Token.TEMPLATELIT_SUB:\n      break;\n    default:\n      return true;\n    }\n    for (Node c = value.get",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n    case Token.TAGGED_TEMPLATELIT:\n    case Token.TEMPLATELIT:\n    case Token.TEMPLATELIT_STRING:\n    case Token.TEMPLATELIT_SUB:\n      return true;\n    case Token.STRING:\n      return isToStringMethodCall(value);\n    ",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n    case Token.TAGGED_TEMPLATELIT:\n    case Token.TEMPLATELIT:\n    case Token.TEMPLATELIT_STRING:\n    case Token.TEMPLATELIT_SUB:\n      return true;\n    case Token.STRING:\n      return isImmutableValue(value);\n    case",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      break;\n    default:\n      break;\n    }\n    for (Node c = value.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!locals.apply(c)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether a value is callable",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      break;\n    default:\n      break;\n    }\n    for (Node c = value.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!locals.apply(c)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns true if calls to this function",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n    case Token.TAGGED_TEMPLATELIT:\n    case Token.TEMPLATELIT:\n    case Token.TEMPLATELIT_STRING:\n    case Token.TEMPLATELIT_SUB:\n      return true;\n    case Token.STRING:\n      return isImmutableValue(value);\n    default"
      ],
      "function range": "2424,3-2489,3"
    },
    "Closure_92_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_789-790": {
      "loc": "789-790",
      "input": "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition != null && explicitNode != null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {",
      "output": [
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      Node scriptNode = NodeUtil.getEnclosingScript(firstNode);\n      Node insertionPoint = scriptNode.getFirstChild();\n      if (insertionPoint.getType()!= Token.SCRIPT &&\n          insertionPoint.getType()!= Token.BLOCK) {\n        insertionPoint = scriptNode;\n      }\n      scriptNode.addChildBefore(replacementNode, insertionPoint);\n    }\n    if (explicitNode!= null) {\n      explicitNode.detachFromParent();\n      explicitNode.getParent().replaceChild(explicitNode, replacementNode);\n      replacementNode.setJSDocInfo(explicitNode.getJSDocInfo());",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      Node scriptNode = NodeUtil.getEnclosingScript(firstNode);\n      Node insertionPoint = scriptNode.getFirstChild();\n      if (insertionPoint.getType()!= Token.SCRIPT &&\n          insertionPoint.getType()!= Token.BLOCK) {\n        insertionPoint = scriptNode;\n      }\n      scriptNode.addChildBefore(replacementNode, insertionPoint);\n    }\n    if (explicitNode!= null) {\n      explicitNode.detachFromParent();\n      explicitNode.getParent().replaceChild(explicitNode, replacementNode);\n      compiler.reportCodeChange();\n    }\n  }\n}\n\n/**\n *",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      Node scriptNode = NodeUtil.getEnclosingScript(firstNode);\n      Node insertionPoint = scriptNode.getFirstChild();\n      if (insertionPoint.getType()!= Token.SCRIPT &&\n          insertionPoint.getType()!= Token.BLOCK) {\n        insertionPoint = scriptNode;\n      }\n      scriptNode.addChildBefore(replacementNode, insertionPoint);\n    }\n    if (explicitNode!= null) {\n      explicitNode.detachFromParent();\n      explicitNode.getParent().replaceChild(explicitNode, replacementNode);\n      compiler.reportCodeChange();\n    }\n  }\n}\n\n}\n",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      Node scriptNode = NodeUtil.getEnclosingScript(firstNode);\n      Node insertionPoint = scriptNode.getFirstChild();\n      if (insertionPoint.getType()!= Token.SCRIPT &&\n          insertionPoint.getType()!= Token.BLOCK) {\n        insertionPoint = scriptNode;\n      }\n      scriptNode.addChildBefore(replacementNode, insertionPoint);\n    }\n    if (explicitNode!= null) {\n      explicitNode.detachFromParent();\n      explicitNode.getParent().replaceChild(explicitNode, replacementNode);\n    }\n    compiler.reportCodeChange();\n  }\n}\n\n/**\n *",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      Node scriptNode = NodeUtil.getEnclosingScript(firstNode);\n      Node insertionPoint = scriptNode.getFirstChild();\n      if (insertionPoint.getType()!= Token.SCRIPT &&\n          insertionPoint.getType()!= Token.BLOCK) {\n        insertionPoint = scriptNode;\n      }\n      scriptNode.addChildBefore(replacementNode, insertionPoint);\n    }\n    if (explicitNode!= null) {\n      explicitNode.detachFromParent();\n      explicitNode.getParent().replaceChild(explicitNode, replacementNode);\n      replacementNode.addChildToFront(explicitNode);\n      compiler.reportCode",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      Node scriptNode = NodeUtil.getEnclosingScript(firstNode);\n      Node insertionPoint = scriptNode.getFirstChild();\n      if (insertionPoint.getType()!= Token.SCRIPT &&\n          insertionPoint.getType()!= Token.BLOCK) {\n        insertionPoint = scriptNode;\n      }\n      scriptNode.addChildBefore(replacementNode, insertionPoint);\n    }\n    if (explicitNode!= null) {\n      explicitNode.detachFromParent();\n      explicitNode.getParent().replaceChild(explicitNode, replacementNode);\n      replacementNode.addChildToFront(explicitNode);\n    }\n  }\n",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      Node scriptNode = NodeUtil.getEnclosingScript(firstNode);\n      Node insertionPoint = scriptNode.getFirstChild();\n      if (insertionPoint.getType()!= Token.SCRIPT &&\n          insertionPoint.getType()!= Token.BLOCK) {\n        insertionPoint = scriptNode;\n      }\n      scriptNode.addChildBefore(replacementNode, insertionPoint);\n    }\n    if (explicitNode!= null) {\n      explicitNode.detachFromParent();\n      explicitNode.insertAfter(replacementNode);\n      compiler.reportCodeChange();\n    }\n  }\n}\n\n}\n<|java|>/*",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      Node scriptNode = NodeUtil.getEnclosingScript(firstNode);\n      Node insertionPoint = scriptNode.getFirstChild();\n      if (insertionPoint.getType()!= Token.SCRIPT &&\n          insertionPoint.getType()!= Token.BLOCK) {\n        insertionPoint = scriptNode;\n      }\n      scriptNode.addChildBefore(replacementNode, insertionPoint);\n    }\n    if (explicitNode!= null) {\n      explicitNode.detachFromParent();\n      explicitNode.getParent().replaceChild(explicitNode, replacementNode);\n      compiler.reportCodeChange();\n    }\n  }\n}\n\n  /**\n   ",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      Node scriptNode = NodeUtil.getEnclosingScript(firstNode);\n      Node insertionPoint = scriptNode.getFirstChild();\n      if (insertionPoint.getType()!= Token.SCRIPT &&\n          insertionPoint.getType()!= Token.BLOCK) {\n        insertionPoint = scriptNode;\n      }\n      scriptNode.addChildBefore(replacementNode, insertionPoint);\n    }\n    if (explicitNode!= null) {\n      explicitNode.detachFromParent();\n      explicitNode.insertAfter(replacementNode);\n      compiler.reportCodeChange();\n    }\n  }\n}\n\n}\n<|java|>package",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      Node scriptNode = NodeUtil.getEnclosingScript(firstNode);\n      Node insertionPoint = scriptNode.getFirstChild();\n      if (insertionPoint.getType()!= Token.SCRIPT &&\n          insertionPoint.getType()!= Token.BLOCK) {\n        insertionPoint = scriptNode;\n      }\n      scriptNode.addChildBefore(replacementNode, insertionPoint);\n    }\n    if (explicitNode!= null) {\n      explicitNode.detachFromParent();\n      explicitNode.getParent().replaceChild(explicitNode, replacementNode);\n      compiler.reportCodeChange();\n    }\n  }\n}\n\nprivate Node create"
      ],
      "function range": "747,5-809,5"
    },
    "Closure_97_/src/com/google/javascript/jscomp/PeepholeFoldConstants.java_698-699": {
      "loc": "698-699",
      "input": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt != lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt != rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:",
      "output": [
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n                                 Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n\n    return newNumber;\n  }\n  return n;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n                                 Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n\n    return newNumber;\n  }\n  return n;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        // JavaScript handles zero shifts on signed numbers differently than\n        // Java as an Java int can not represent the unsigned 32-bit number\n        // where JavaScript can so use a long here.\n        long lvalLong = lvalInt & 0xffffffffL;\n        long rvalLong = rvalInt & 0xffffffffL;\n        result = lvalLong >>> rvalLong;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n                                 Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n\n    return newNumber;\n  }\n  return n;\n}\n",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        // JavaScript handles zero shifts on signed numbers differently than\n        // Java as an Java int can not represent the unsigned 32-bit number\n        // where JavaScript can so use a long here.\n        long lvalLong = lvalInt & 0xffffffffL;\n        long rvalLong = rvalInt & 0xffffffffL;\n        result = lvalLong >>> rvalLong;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n                                 Token.name(n.getType()));\n    }\n    Node newNumber = IR.number(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n\n    return newNumber;\n  }\n  return n;\n}\n",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        // JavaScript handles zero shifts on signed numbers differently than\n        // Java as an Java int can not represent the unsigned 32-bit number\n        // where JavaScript can so use a long here.\n        long lvalLong = lvalInt & 0xffffffffL;\n        long rvalLong = rvalInt & 0xffffffffL;\n        result = lvalLong >>> rvalLong;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" + n.getType());\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n<|java|>/*\n",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        // JavaScript handles zero shifts on signed numbers differently than\n        // Java as an Java int can not represent the unsigned 32-bit number\n        // where JavaScript can so use a long here.\n        long lvalLong = lvalInt & 0xffffffffL;\n        long rvalLong = rvalInt & 0xffffffffL;\n        result = lvalLong >>> rvalLong;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n                                 Token.name(n.getType()));\n    }\n    Node newNumber = IR.number(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n\n    return newNumber;\n  }\n  return n;\n}\n\n",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        // JavaScript handles zero shifts on signed numbers differently than\n        // Java as an Java int can not represent the unsigned 32-bit number\n        // where JavaScript can so use a long here.\n        long lvalLong = lvalInt & 0xffffffffL;\n        long rvalLong = rvalInt & 0xffffffffL;\n        result = lvalLong >>> rvalLong;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" + n.getType());\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Warn the user of",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        // JavaScript handles zero shifts on signed numbers differently than\n        // Java as an Java int can not represent the unsigned 32-bit number\n        // where JavaScript can so use a long here.\n        long lvalLong = lvalInt & 0xffffffffL;\n        long rvalLong = rvalInt & 0xffffffffL;\n        result = lvalLong >>> rvalLong;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" + n.getType());\n    }\n    Node newNumber = IR.number(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n<|java|>/*\n *",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        // JavaScript handles zero shifts on signed numbers differently than\n        // Java as an Java int can not represent the unsigned 32-bit number\n        // where JavaScript can so use a long here.\n        long lvalLong = lvalInt & 0xffffffffL;\n        long rvalLong = rvalInt & 0xffffffffL;\n        result = lvalLong >>> rvalLong;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" + n.getType());\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n\n  return n;\n}\n<|java|>/*\n",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        // JavaScript handles zero shifts on signed numbers differently than\n        // Java as an Java int can not represent the unsigned 32-bit number\n        // where JavaScript can so use a long here.\n        long lvalLong = lvalInt & 0xffffffffL;\n        long rvalLong = rvalInt & 0xffffffffL;\n        result = lvalLong >>> rvalLong;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" + n.getType());\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n<|java|>package com"
      ],
      "function range": "652,3-713,3"
    },
    "Closure_104_/src/com/google/javascript/rhino/jstype/UnionType.java_291-292": {
      "loc": "291-292",
      "input": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();",
      "output": [
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.addAlternate(otherAlternate);\n        }\n      }\n    } else if (that.isSubtype(this)) {\n      builder.addAlternate(that);\n    }\n    return builder.build().isSubtype(this);\n  }\n\n  @Override\n  public JSType getLeastSupertype(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.add",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.addAlternate(otherAlternate);\n        }\n      }\n    } else if (that.isSubtype(this)) {\n      builder.addAlternate(that);\n    }\n    return builder.build().isSubtype(this);\n  }\n\n  @Override\n  public boolean isEquivalentTo(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isEquivalentTo(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isEquivalentTo(this)) {\n          builder.addAltern",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  if (result.isBottom()) {\n    return this;\n  } else {\n    return result;\n  }\n}\n\n@Override\npublic boolean isSubtype(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  return builder.build().isSubtype(this);\n}\n\n@Override\npublic JSType getLeastSupertype(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  if (result.isBottom()) {\n    return this;\n  } else {\n    return result;\n  }\n}\n\n@Override\npublic boolean isSubtype(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  return builder.build().isSubtype(this);\n}\n\n@Override\npublic boolean isEquivalentTo(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isEquivalentTo(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isEquivalentTo(this",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.addAlternate(otherAlternate);\n        }\n      }\n    } else if (that.isSubtype(this)) {\n      builder.addAlternate(that);\n    }\n    return builder.build().isSubtype(this);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnionType(this);\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnionType(this, that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    for (JSType alternate : alternates) {\n      alternate = alternate.resolve(t, scope);\n      if",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.addAlternate(otherAlternate);\n        }\n      }\n    } else if (that.isSubtype(this)) {\n      builder.addAlternate(that);\n    }\n    return builder.build().isSubtype(this);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnionType(this);\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnionType(this, that);\n  }\n\n  @Override <T> T visit(Visitor<T> visitor, JSType that, JSType that2) {\n    return visitor.caseUnionType(this, that, that2);\n  }\n\n  @Override <T> T visit",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.addAlternate(otherAlternate);\n        }\n      }\n    } else if (that.isSubtype(this)) {\n      builder.addAlternate(that);\n    }\n    return builder.build().isSubtype(this);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnionType(this);\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnionType(this, that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    List<JSType> resolvedTypes = Lists.newArrayList();\n    for (JSType alternate : alternates) {",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.addAlternate(otherAlternate);\n        }\n      }\n    } else if (that.isSubtype(this)) {\n      builder.addAlternate(that);\n    }\n    return builder.build().isSubtype(this);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnionType(this);\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnionType(this, that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter reporter) {\n    for (JSType alternate : alternates) {\n      alternate = alternate.resolve(reporter);\n      if (alternate.isUnknownType()) {\n",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.addAlternate(otherAlternate);\n        }\n      }\n    } else if (that.isSubtype(this)) {\n      builder.addAlternate(that);\n    }\n    return builder.build().isSubtype(this);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnionType(this);\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnionType(this, that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    for (JSType alternate : alternates) {\n      alternate = alternate.resolve(t, scope);\n    }",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  Preconditions.checkNotNull(result);\n  return result;\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.addAlternate(otherAlternate);\n        }\n      }\n    } else if (that.isSubtype(this)) {\n      builder.addAlternate(that);\n    }\n    return builder.build().isSubtype(this);\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnionType(this);\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnionType(this, that);\n  }\n\n  @Override <T> T visit(Visitor<T> visitor, JSType that, JSType that2) {\n    return visitor.caseUnionType(this, that, that2);\n  }\n}\n<|java|>"
      ],
      "function range": "273,3-298,3"
    },
    "Closure_109_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_1908-1909": {
      "loc": "1908-1909",
      "input": "private Node parseContextTypeExpression(JsDocToken token) {",
      "output": [
        "private Node parseContextTypeExpression(JsDocToken token) {\n    if (token!= JsDocToken.LEFT_CURLY) {\n      parser.addParserWarning(\"msg.jsdoc.missing.brace\",\n          stream.getLineno(), stream.getCharno());\n    } else {\n      next();\n      Node typeNode = parseContextTypeExpression(token);\n      if (typeNode == null) {\n        parser.addTypeWarning(\"msg.jsdoc.missing.brace\",\n            stream.getLineno(), stream.getCharno());\n      }\n      skipEOLs();\n      if (match(JsDocToken.RIGHT_CURLY)) {\n        next();\n      } else {\n        parser.addParserWarning(\"msg.jsdoc.missing.brace\",\n            stream.getLineno(), stream.getCharno());\n      }\n    }\n\n    return typeNode;\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        token == JsDocToken.LEFT_CURLY, false);\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @param matchingRC Whether the type expression ends with a \"}\".\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean matching",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    if (token!= JsDocToken.LEFT_CURLY) {\n      parser.addParserWarning(\"msg.jsdoc.missing.brace\",\n          stream.getLineno(), stream.getCharno());\n    } else {\n      next();\n      Node typeNode = parseTypeExpression(token);\n      if (typeNode!= null) {\n        skipEOLs();\n        next();\n        if (token!= JsDocToken.RIGHT_CURLY) {\n          parser.addTypeWarning(\"msg.jsdoc.missing.rcurl\",\n              stream.getLineno(), stream.getCharno());\n        } else {\n          next();\n        }\n      }\n    }\n    return typeNode;\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        token == JsDocToken.LEFT_CURLY, false);\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @param matchingRC Whether the type expression ends with a \"}\".\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean matchingRC) {\n    Node typeNode = null;\n\n    if (token == JsDocToken.LEFT_CUR",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    if (token!= JsDocToken.LEFT_CURLY) {\n      parser.addParserWarning(\"msg.jsdoc.missing.brace\",\n          stream.getLineno(), stream.getCharno());\n    } else {\n      next();\n      Node typeNode = parseTypeExpression(token);\n      if (typeNode!= null) {\n        skipEOLs();\n        next();\n        if (token!= JsDocToken.RIGHT_CURLY) {\n          parser.addTypeWarning(\"msg.jsdoc.missing.right.curly\",\n              stream.getLineno(), stream.getCharno());\n        } else {\n          next();\n        }\n      }\n    }\n    return typeNode;\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        token == JsDocToken.LEFT_CURLY, false);\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @param matchingRC Whether the type expression ends with a \"}\".\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean matchingRC) {\n    Node typeNode = null;\n\n    if (token == JsDocToken.LEFT_",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    if (token!= JsDocToken.LEFT_CURLY) {\n      parser.addParserWarning(\"msg.jsdoc.missing.brace\",\n          stream.getLineno(), stream.getCharno());\n    } else {\n      next();\n      Node typeNode = parseTypeExpression(token);\n      if (typeNode!= null) {\n        skipEOLs();\n        next();\n        if (token!= JsDocToken.RIGHT_CURLY) {\n          parser.addTypeWarning(\"msg.jsdoc.missing.rcurl\",\n              stream.getLineno(), stream.getCharno());\n        } else {\n          next();\n        }\n      }\n    }\n    return typeNode;\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   */\n  Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        token == JsDocToken.LEFT_CURLY, false);\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @param matchingRC Whether the type expression ends with a \"}\".\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean matchingRC) {\n    Node typeNode = null;\n\n    if (token == JsDocToken.LEFT_CURLY",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    if (token!= JsDocToken.LEFT_CURLY) {\n      parser.addParserWarning(\"msg.jsdoc.missing.brace\",\n          stream.getLineno(), stream.getCharno());\n    } else {\n      next();\n      Node typeNode = parseTypeExpression(token);\n      if (typeNode!= null) {\n        skipEOLs();\n        next();\n        if (token!= JsDocToken.RIGHT_CURLY) {\n          parser.addTypeWarning(\"msg.jsdoc.missing.rcurl\",\n              stream.getLineno(), stream.getCharno());\n        } else {\n          next();\n        }\n      }\n    }\n    return typeNode;\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        token == JsDocToken.LEFT_CURLY, false);\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @param matchingRC Whether the type expression ends with a \"}\".\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean matchingRC) {\n    Node typeNode = null;\n\n    switch (token) {\n      case STRING:\n        String",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    if (token!= JsDocToken.LEFT_CURLY) {\n      parser.addParserWarning(\"msg.jsdoc.missing.brace\",\n          stream.getLineno(), stream.getCharno());\n    } else {\n      next();\n      Node typeNode = parseTypeExpression(token);\n      if (typeNode!= null) {\n        skipEOLs();\n        next();\n        if (token!= JsDocToken.RIGHT_CURLY) {\n          parser.addTypeWarning(\"msg.jsdoc.missing.rcurl\",\n              stream.getLineno(), stream.getCharno());\n        } else {\n          next();\n        }\n      }\n    }\n    return typeNode;\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        token == JsDocToken.LEFT_CURLY, false);\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @param matchingRC Whether the type expression ends with a \"}\".\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno, boolean matchingLC,\n                                      boolean matchingRC) {\n    Node typeNode = null;\n\n    if (token == JsDocToken.LEFT_CURLY) {\n      int",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    if (token!= JsDocToken.LEFT_CURLY) {\n      parser.addParserWarning(\"msg.jsdoc.missing.brace\",\n          stream.getLineno(), stream.getCharno());\n    } else {\n      next();\n      Node typeNode = parseTypeExpression(token);\n      if (typeNode!= null) {\n        skipEOLs();\n        next();\n        if (token!= JsDocToken.RIGHT_CURLY) {\n          parser.addTypeWarning(\"msg.jsdoc.missing.right.curly\",\n              stream.getLineno(), stream.getCharno());\n        } else {\n          next();\n        }\n      }\n    }\n    return typeNode;\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        token == JsDocToken.LEFT_CURLY, false);\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @param matchingRC Whether the type expression ends with a \"}\".\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean matchingRC) {\n    Node typeNode = null;\n\n    switch (token) {\n      case STRING:\n",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    if (token!= JsDocToken.LEFT_CURLY) {\n      parser.addParserWarning(\"msg.jsdoc.missing.brace\",\n          stream.getLineno(), stream.getCharno());\n    } else {\n      next();\n      Node typeNode = parseTypeExpression(token);\n      if (typeNode!= null) {\n        skipEOLs();\n        next();\n        if (token!= JsDocToken.RIGHT_CURLY) {\n          parser.addTypeWarning(\"msg.jsdoc.missing.right.curly\",\n              stream.getLineno(), stream.getCharno());\n        } else {\n          next();\n        }\n      }\n    }\n    return typeNode;\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   */\n  Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        token == JsDocToken.LEFT_CURLY, false);\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @param matchingRC Whether the type expression ends with a \"}\".\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean matchingRC) {\n    Node typeNode = null;\n\n    if (token == JsDocToken.LEFT_C",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    if (token!= JsDocToken.LEFT_CURLY) {\n      parser.addParserWarning(\"msg.jsdoc.missing.brace\",\n          stream.getLineno(), stream.getCharno());\n    } else {\n      next();\n      Node typeNode = parseTypeExpression(token);\n      if (typeNode!= null) {\n        skipEOLs();\n        next();\n        if (token!= JsDocToken.RIGHT_CURLY) {\n          parser.addParserWarning(\"msg.jsdoc.missing.brace\",\n              stream.getLineno(), stream.getCharno());\n        } else {\n          next();\n        }\n      }\n    }\n    return typeNode;\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   */\n  Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        token == JsDocToken.LEFT_CURLY, false);\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @param matchingRC Whether the type expression ends with a \"}\".\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean matchingRC) {\n    Node typeNode = null;\n\n    if (token == JsDocToken.LEFT_CURLY)",
        "private Node parseContextTypeExpression(JsDocToken token) {\n    if (token!= JsDocToken.LEFT_CURLY) {\n      parser.addParserWarning(\"msg.jsdoc.missing.brace\",\n          stream.getLineno(), stream.getCharno());\n    } else {\n      next();\n      Node typeNode = parseTypeExpression(token);\n      if (typeNode!= null) {\n        skipEOLs();\n        next();\n        if (token!= JsDocToken.RIGHT_CURLY) {\n          parser.addTypeWarning(\"msg.jsdoc.missing.rcurl\",\n              stream.getLineno(), stream.getCharno());\n        } else {\n          next();\n        }\n      }\n    }\n    return typeNode;\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   */\n  Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        token == JsDocToken.LEFT_CURLY, false);\n  }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @param matchingRC Whether the type expression ends with a \"}\".\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno, boolean matchingLC,\n                                      boolean matchingRC) {\n    Node typeNode = null;\n\n    if (token == JsDocToken.LEFT_CURLY) {\n      int token"
      ],
      "function range": "1907,3-1909,3"
    },
    "Closure_111_/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java_54-55": {
      "loc": "54-55",
      "input": "@Override\nprotected JSType caseTopType(JSType topType) {",
      "output": [
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  public JSType caseNoObjectType() {\n    return getNativeType(NO_OBJECT_TYPE);\n  }\n\n  @Override\n  public JSType caseNoType() {\n    return getNativeType(NO_TYPE);\n  }\n\n  @Override\n  public JSType caseBooleanType() {\n    return getNativeType(BOOLEAN_TYPE);\n  }\n\n  @Override\n  public JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseNullType() {\n    return getNativeType(NULL_TYPE);\n  }\n\n  @Override\n  public JSType caseNumberType() {\n    return getNativeType(NUMBER_TYPE);\n  }\n\n  @Override\n  public JSType caseObjectType(ObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseStringType() {\n    return getNativeType(STRING_TYPE);\n  }\n\n  @Override\n  public JSType caseVoidType() {\n    return getNativeType(VOID_TYPE);\n  }\n\n  @Override\n  public JSType caseUnionType(UnionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseAllType() {\n    return getNativeType(ALL_TYPE);\n  }\n\n  @Override\n  public JSType caseUnknownType() {\n    return getNativeType(UNKNOWN_TYPE);\n  }\n\n  @Override\n  public JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  public JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseEnumElementType(EnumElementType type) {\n    return type;\n  }\n\n  @Override\n  public J",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  public JSType caseNoObjectType() {\n    return getNativeType(NO_OBJECT_TYPE);\n  }\n\n  @Override\n  public JSType caseNoType() {\n    return getNativeType(NO_TYPE);\n  }\n\n  @Override\n  public JSType caseBooleanType() {\n    return getNativeType(BOOLEAN_TYPE);\n  }\n\n  @Override\n  public JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseNullType() {\n    return getNativeType(NULL_TYPE);\n  }\n\n  @Override\n  public JSType caseNumberType() {\n    return getNativeType(NUMBER_TYPE);\n  }\n\n  @Override\n  public JSType caseObjectType(ObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseStringType() {\n    return getNativeType(STRING_TYPE);\n  }\n\n  @Override\n  public JSType caseVoidType() {\n    return getNativeType(VOID_TYPE);\n  }\n\n  @Override\n  public JSType caseUnionType(UnionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseAllType() {\n    return getNativeType(ALL_TYPE);\n  }\n\n  @Override\n  public JSType caseUnknownType() {\n    return getNativeType(UNKNOWN_TYPE);\n  }\n\n  @Override\n  public JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  public JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseNullableType(NullableType type) {\n    return type;\n  }\n\n  @Override\n  public JSType",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  public JSType caseNoObjectType() {\n    return getNativeType(NO_OBJECT_TYPE);\n  }\n\n  @Override\n  public JSType caseNoType() {\n    return getNativeType(NO_TYPE);\n  }\n\n  @Override\n  public JSType caseBooleanType() {\n    return getNativeType(BOOLEAN_TYPE);\n  }\n\n  @Override\n  public JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseNullType() {\n    return getNativeType(NULL_TYPE);\n  }\n\n  @Override\n  public JSType caseNumberType() {\n    return getNativeType(NUMBER_TYPE);\n  }\n\n  @Override\n  public JSType caseObjectType(ObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseStringType() {\n    return getNativeType(STRING_TYPE);\n  }\n\n  @Override\n  public JSType caseVoidType() {\n    return getNativeType(VOID_TYPE);\n  }\n\n  @Override\n  public JSType caseUnionType(UnionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseAllType() {\n    return getNativeType(ALL_TYPE);\n  }\n\n  @Override\n  public JSType caseUnknownType() {\n    return getNativeType(UNKNOWN_TYPE);\n  }\n\n  @Override\n  public JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  public JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  public JSType caseNoObjectType() {\n    return getNativeType(NO_OBJECT_TYPE);\n  }\n\n  @Override\n  public JSType caseNoType() {\n    return getNativeType(NO_TYPE);\n  }\n\n  @Override\n  public JSType caseBooleanType() {\n    return getNativeType(BOOLEAN_TYPE);\n  }\n\n  @Override\n  public JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseNullType() {\n    return getNativeType(NULL_TYPE);\n  }\n\n  @Override\n  public JSType caseNumberType() {\n    return getNativeType(NUMBER_TYPE);\n  }\n\n  @Override\n  public JSType caseObjectType(ObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseStringType() {\n    return getNativeType(STRING_TYPE);\n  }\n\n  @Override\n  public JSType caseVoidType() {\n    return getNativeType(VOID_TYPE);\n  }\n\n  @Override\n  public JSType caseUnknownType() {\n    return getNativeType(UNKNOWN_TYPE);\n  }\n\n  @Override\n  public JSType caseUnionType(UnionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseAllType() {\n    return getNativeType(ALL_TYPE);\n  }\n\n  @Override\n  public JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  public JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseEnumElementType(EnumElementType type) {\n    return type;\n  }\n\n  @Override\n  public J",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  public JSType caseNoObjectType() {\n    return getNativeType(NO_OBJECT_TYPE);\n  }\n\n  @Override\n  public JSType caseNoType() {\n    return getNativeType(NO_TYPE);\n  }\n\n  @Override\n  public JSType caseBooleanType() {\n    return getNativeType(BOOLEAN_TYPE);\n  }\n\n  @Override\n  public JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseNullType() {\n    return getNativeType(NULL_TYPE);\n  }\n\n  @Override\n  public JSType caseNumberType() {\n    return getNativeType(NUMBER_TYPE);\n  }\n\n  @Override\n  public JSType caseObjectType(ObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseStringType() {\n    return getNativeType(STRING_TYPE);\n  }\n\n  @Override\n  public JSType caseVoidType() {\n    return getNativeType(VOID_TYPE);\n  }\n\n  @Override\n  public JSType caseUnionType(UnionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseAllType() {\n    return getNativeType(ALL_TYPE);\n  }\n\n  @Override\n  public JSType caseUnknownType() {\n    return getNativeType(UNKNOWN_TYPE);\n  }\n\n  @Override\n  public JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  public JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseEnumElementType(EnumElementType type) {\n    return type;\n  }\n}\n<|java|",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  public JSType caseNoObjectType() {\n    return getNativeType(NO_OBJECT_TYPE);\n  }\n\n  @Override\n  public JSType caseNoType() {\n    return getNativeType(NO_TYPE);\n  }\n\n  @Override\n  public JSType caseBooleanType() {\n    return getNativeType(BOOLEAN_TYPE);\n  }\n\n  @Override\n  public JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseNullType() {\n    return getNativeType(NULL_TYPE);\n  }\n\n  @Override\n  public JSType caseNumberType() {\n    return getNativeType(NUMBER_TYPE);\n  }\n\n  @Override\n  public JSType caseObjectType(ObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseStringType() {\n    return getNativeType(STRING_TYPE);\n  }\n\n  @Override\n  public JSType caseVoidType() {\n    return getNativeType(VOID_TYPE);\n  }\n\n  @Override\n  public JSType caseUnknownType() {\n    return getNativeType(UNKNOWN_TYPE);\n  }\n\n  @Override\n  public JSType caseUnionType(UnionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseAllType() {\n    return getNativeType(ALL_TYPE);\n  }\n\n  @Override\n  public JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  public JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseNullableType(NullableType type) {\n    return type;\n  }\n\n  @Override\n  public JSType",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  public JSType caseNoObjectType() {\n    return getNativeType(NO_OBJECT_TYPE);\n  }\n\n  @Override\n  public JSType caseNoType() {\n    return getNativeType(NO_TYPE);\n  }\n\n  @Override\n  public JSType caseBooleanType() {\n    return getNativeType(BOOLEAN_TYPE);\n  }\n\n  @Override\n  public JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseNullType() {\n    return getNativeType(NULL_TYPE);\n  }\n\n  @Override\n  public JSType caseNumberType() {\n    return getNativeType(NUMBER_TYPE);\n  }\n\n  @Override\n  public JSType caseObjectType(ObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseStringType() {\n    return getNativeType(STRING_TYPE);\n  }\n\n  @Override\n  public JSType caseVoidType() {\n    return getNativeType(VOID_TYPE);\n  }\n\n  @Override\n  public JSType caseUnionType(UnionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseAllType() {\n    return getNativeType(ALL_TYPE);\n  }\n\n  @Override\n  public JSType caseUndefinedType() {\n    return getNativeType(VOID_TYPE);\n  }\n\n  @Override\n  public JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  public JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseEnumElementType(EnumElementType type) {\n    return type;\n  }\n\n  @Override\n  public",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  public JSType caseNoObjectType() {\n    return getNativeType(NO_OBJECT_TYPE);\n  }\n\n  @Override\n  public JSType caseNoType() {\n    return getNativeType(NO_TYPE);\n  }\n\n  @Override\n  public JSType caseBooleanType() {\n    return getNativeType(BOOLEAN_TYPE);\n  }\n\n  @Override\n  public JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseNullType() {\n    return getNativeType(NULL_TYPE);\n  }\n\n  @Override\n  public JSType caseNumberType() {\n    return getNativeType(NUMBER_TYPE);\n  }\n\n  @Override\n  public JSType caseObjectType(ObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseStringType() {\n    return getNativeType(STRING_TYPE);\n  }\n\n  @Override\n  public JSType caseVoidType() {\n    return getNativeType(VOID_TYPE);\n  }\n\n  @Override\n  public JSType caseUnionType(UnionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseUnknownType() {\n    return getNativeType(UNKNOWN_TYPE);\n  }\n\n  @Override\n  public JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseEnumElementType(EnumElementType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseAllType() {\n    return getNativeType(ALL_TYPE);\n  }\n\n  @Override\n  public J",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  public JSType caseNoObjectType() {\n    return getNativeType(NO_OBJECT_TYPE);\n  }\n\n  @Override\n  public JSType caseNoType() {\n    return getNativeType(NO_TYPE);\n  }\n\n  @Override\n  public JSType caseBooleanType() {\n    return getNativeType(BOOLEAN_TYPE);\n  }\n\n  @Override\n  public JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseNullType() {\n    return getNativeType(NULL_TYPE);\n  }\n\n  @Override\n  public JSType caseNumberType() {\n    return getNativeType(NUMBER_TYPE);\n  }\n\n  @Override\n  public JSType caseObjectType(ObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseStringType() {\n    return getNativeType(STRING_TYPE);\n  }\n\n  @Override\n  public JSType caseVoidType() {\n    return getNativeType(VOID_TYPE);\n  }\n\n  @Override\n  public JSType caseUnionType(UnionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseUnknownType() {\n    return getNativeType(UNKNOWN_TYPE);\n  }\n\n  @Override\n  public JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  public JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseEnumElementType(EnumElementType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseAllType() {\n    return getNativeType(ALL_TYPE);\n  }\n\n  @Override\n  public J",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n    return topType;\n  }\n\n  @Override\n  public JSType caseNoObjectType() {\n    return getNativeType(NO_OBJECT_TYPE);\n  }\n\n  @Override\n  public JSType caseNoType() {\n    return getNativeType(NO_TYPE);\n  }\n\n  @Override\n  public JSType caseBooleanType() {\n    return getNativeType(BOOLEAN_TYPE);\n  }\n\n  @Override\n  public JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseNullType() {\n    return getNativeType(NULL_TYPE);\n  }\n\n  @Override\n  public JSType caseNumberType() {\n    return getNativeType(NUMBER_TYPE);\n  }\n\n  @Override\n  public JSType caseObjectType(ObjectType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseStringType() {\n    return getNativeType(STRING_TYPE);\n  }\n\n  @Override\n  public JSType caseVoidType() {\n    return getNativeType(VOID_TYPE);\n  }\n\n  @Override\n  public JSType caseUnknownType() {\n    return getNativeType(UNKNOWN_TYPE);\n  }\n\n  @Override\n  public JSType caseUnionType(UnionType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseAllType() {\n    return getNativeType(ALL_TYPE);\n  }\n\n  @Override\n  public JSType caseProxyObjectType() {\n    return getNativeType(PROXY_OBJECT_TYPE);\n  }\n\n  @Override\n  public JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  public JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  public JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n"
      ],
      "function range": "52,9-55,9"
    },
    "Closure_113_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_329-330": {
      "loc": "329-330",
      "input": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null || !provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph != null &&\n          module != providedModule &&\n          !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);",
      "output": [
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, null, t.getSourceName()));\n  }\n}\n\n  private void maybeAddToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    String name = n.getString();\n    if (!name.isEmpty()) {\n      symbolTable.addReference(name, n);\n    }\n  }\n\n  private void maybeAddStringNodeToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    if (!n.isString()) {\n      return;\n    }\n\n    String value = n.getString();\n    if (!value.isEmpty()) {\n      symbolTable.addReference(value, n);\n    }\n  }\n\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node call, Node arg) {\n    // Be len",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, null, t.getSourceName()));\n  }\n}\n\n  private void maybeAddToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    String name = n.getString();\n    if (!name.isEmpty()) {\n      symbolTable.addReference(name, n);\n    }\n  }\n\n  private void maybeAddStringNodeToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    if (!n.isString()) {\n      return;\n    }\n\n    String value = n.getString();\n    if (!value.isEmpty()) {\n      symbolTable.addReference(value, n);\n    }\n  }\n\n  private boolean verifyLastArgumentIsString(NodeTraversal t,\n      Node call, Node arg) {\n    // Be len",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, null, t.getSourceName()));\n  }\n}\n\n  private void maybeAddToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    String name = n.getString();\n    if (!name.isEmpty()) {\n      symbolTable.addReference(name, n);\n    }\n  }\n\n  private void maybeAddStringNodeToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    if (!n.isString()) {\n      return;\n    }\n\n    String value = n.getString();\n    if (!value.isEmpty()) {\n      symbolTable.addReference(value, n);\n    }\n  }\n\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node left, Node arg) {\n    // Check for",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, null, t.getSourceName()));\n  }\n}\n\n  private void maybeAddToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    String name = n.getString();\n    if (!name.isEmpty()) {\n      symbolTable.addReference(name, n);\n    }\n  }\n\n  private void maybeAddStringNodeToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    if (!n.isString()) {\n      return;\n    }\n\n    String value = n.getString();\n    if (!value.isEmpty()) {\n      symbolTable.addReference(value, n);\n    }\n  }\n\n  private boolean verifyLastArgumentIsString(NodeTraversal t, Node left,\n      Node arg) {\n    // Be len",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, null, t.getSourceName()));\n  }\n}\n\n  private void maybeAddToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    String name = n.getString();\n    if (!name.isEmpty()) {\n      symbolTable.addReference(name, n);\n    }\n  }\n\n  private void maybeAddStringNodeToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    if (!n.isString()) {\n      return;\n    }\n\n    String value = n.getString();\n    if (!value.isEmpty()) {\n      symbolTable.addReference(value, n);\n    }\n  }\n\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node left, Node arg) {\n    // Be len",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, null, t.getSourceName()));\n  }\n}\n\n  private void maybeAddToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    String name = n.getString();\n    if (!name.isEmpty()) {\n      symbolTable.addReference(name, n);\n    }\n  }\n\n  private void maybeAddStringNodeToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    if (!n.isString()) {\n      return;\n    }\n\n    String value = n.getString();\n    if (!value.isEmpty()) {\n      symbolTable.addReference(value, n);\n    }\n  }\n\n  private boolean verifyLastArgumentIsString(NodeTraversal t,\n      Node call, Node lastArg) {\n    // Check",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, null, t.getSourceName()));\n  }\n}\n\n  private void maybeAddToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    String name = n.getString();\n    if (!name.isEmpty()) {\n      symbolTable.addReference(name, n);\n    }\n  }\n\n  private void maybeAddStringNodeToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    if (!n.isString()) {\n      return;\n    }\n\n    String value = n.getString();\n    if (!value.isEmpty()) {\n      symbolTable.addReference(value, n);\n    }\n  }\n\n  private boolean verifyLastArgumentIsString(NodeTraversal t, Node left,\n      Node arg) {\n    // Check for",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, null, t.getSourceName()));\n  }\n}\n\n  private void maybeAddToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    String name = n.getString();\n    if (!name.isEmpty()) {\n      symbolTable.addReference(name, n);\n    }\n  }\n\n  private void maybeAddStringNodeToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    if (!n.isString()) {\n      return;\n    }\n\n    String value = n.getString();\n    if (!value.isEmpty()) {\n      symbolTable.addReference(value, n);\n    }\n  }\n\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node left, Node right) {\n    return right!=",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, null, t.getSourceName()));\n  }\n}\n\n  private void maybeAddToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    String name = n.getString();\n    if (!name.isEmpty()) {\n      symbolTable.addReference(name, n);\n    }\n  }\n\n  private void maybeAddStringNodeToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    if (!n.isString()) {\n      return;\n    }\n\n    String value = n.getString();\n    if (!value.isEmpty()) {\n      symbolTable.addReference(value, n);\n    }\n  }\n\n  private boolean verifyLastArgumentIsString(NodeTraversal t,\n      Node left, Node arg) {\n    // Be len",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, null, t.getSourceName()));\n  }\n}\n\n  private void maybeAddToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    String name = n.getString();\n    if (!name.isEmpty()) {\n      symbolTable.addReference(name, n);\n    }\n  }\n\n  private void maybeAddStringNodeToSymbolTable(Node n) {\n    if (symbolTable == null) {\n      return;\n    }\n\n    if (!n.isString()) {\n      return;\n    }\n\n    String value = n.getString();\n    if (!value.isEmpty()) {\n      symbolTable.addReference(value, n);\n    }\n  }\n\n  private boolean verifyLastArgumentIsString(NodeTraversal t,\n      Node call, Node lastArg) {\n    // Be"
      ],
      "function range": "295,3-334,3"
    },
    "Closure_114_/src/com/google/javascript/jscomp/NameAnalyzer.java_578-579": {
      "loc": "578-579",
      "input": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns != null) {\n    if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext() != n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }",
      "output": [
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isLet() || parent.isConst()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isFunction()) {\n      if (NodeUtil.isFunctionDeclaration(parent)) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(nameNode, ns);\n    } else if (parent.isCatch()) {\n      recordDepScope(nameNode, ns);\n    } else if (NodeUtil.isObjectLitKey(nameNode)) {\n      if (parent.isObjectLit()) {\n        recordDepScope(nameNode, ns);\n      } else if (parent.isAssign()) {\n        if (parent.getParent().isExprResult()) {\n          recordDepScope(nameNode, ns);\n        }\n      } else if (parent.isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isParamList()) {\n      if (parent.getParent().isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImport()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImportSpec()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isExportSpec()) {",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isLet() || parent.isConst()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isFunction()) {\n      if (NodeUtil.isFunctionDeclaration(parent)) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(nameNode, ns);\n    } else if (parent.isCatch()) {\n      recordDepScope(nameNode, ns);\n    } else if (NodeUtil.isObjectLitKey(nameNode)) {\n      if (parent.isObjectLit()) {\n        recordDepScope(nameNode, ns);\n      } else if (parent.isAssign()) {\n        if (parent.getParent().isExprResult()) {\n          recordDepScope(nameNode, ns);\n        }\n      } else if (parent.isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isParamList()) {\n      if (parent.getParent().isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImport()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImportSpec() || parent.isImportDefaultSpec()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isLet() || parent.isConst()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isFunction()) {\n      if (NodeUtil.isFunctionDeclaration(parent)) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(nameNode, ns);\n    } else if (parent.isCatch()) {\n      recordDepScope(nameNode, ns);\n    } else if (NodeUtil.isObjectLitKey(nameNode)) {\n      if (parent.isObjectLit()) {\n        recordDepScope(nameNode, ns);\n      } else if (parent.isAssign()) {\n        if (parent.getParent().isExprResult()) {\n          recordDepScope(nameNode, ns);\n        }\n      } else if (parent.isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isParamList()) {\n      if (parent.getParent().isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImport()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImportSpec() && parent.getGrandparent()!= null) {\n      if (parent.getGrandparent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    ",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isLet() || parent.isConst()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isFunction()) {\n      if (NodeUtil.isFunctionDeclaration(parent)) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(nameNode, ns);\n    } else if (parent.isCatch()) {\n      recordDepScope(nameNode, ns);\n    } else if (NodeUtil.isObjectLitKey(nameNode)) {\n      if (parent.isObjectLit()) {\n        recordDepScope(nameNode, ns);\n      } else if (parent.isAssign()) {\n        if (parent.getParent().isExprResult()) {\n          recordDepScope(nameNode, ns);\n        }\n      } else if (parent.isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isParamList()) {\n      if (parent.getParent().isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImport()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImportSpec()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isDebugger()) {",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isLet() || parent.isConst()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isFunction()) {\n      if (NodeUtil.isFunctionDeclaration(parent)) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(nameNode, ns);\n    } else if (parent.isCatch()) {\n      recordDepScope(nameNode, ns);\n    } else if (NodeUtil.isObjectLitKey(nameNode)) {\n      if (parent.isObjectLit()) {\n        recordDepScope(nameNode, ns);\n      } else if (parent.isAssign()) {\n        if (parent.getParent().isExprResult()) {\n          recordDepScope(nameNode, ns);\n        }\n      } else if (parent.isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isParamList()) {\n      if (parent.getParent().isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImport()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImportSpec() && parent.getGrandparent()!= null) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    }",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isLet() || parent.isConst()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isFunction()) {\n      if (NodeUtil.isFunctionDeclaration(parent)) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(nameNode, ns);\n    } else if (parent.isCatch()) {\n      recordDepScope(nameNode, ns);\n    } else if (NodeUtil.isObjectLitKey(nameNode)) {\n      if (parent.isObjectLit()) {\n        recordDepScope(nameNode, ns);\n      } else if (parent.isAssign()) {\n        if (parent.getParent().isExprResult()) {\n          recordDepScope(nameNode, ns);\n        }\n      } else if (parent.isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isParamList()) {\n      if (parent.getParent().isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImport()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImportSpec()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isExprResult())",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isLet() || parent.isConst()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isFunction()) {\n      if (NodeUtil.isFunctionDeclaration(parent)) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(nameNode, ns);\n    } else if (parent.isCatch()) {\n      recordDepScope(nameNode, ns);\n    } else if (NodeUtil.isObjectLitKey(nameNode)) {\n      if (parent.isObjectLit()) {\n        recordDepScope(nameNode, ns);\n      } else if (parent.isAssign()) {\n        if (parent.getParent().isExprResult()) {\n          recordDepScope(nameNode, ns);\n        }\n      } else if (parent.isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isParamList()) {\n      if (parent.getParent().isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImport()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImportSpec()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isDebuggerStatement())",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isLet() || parent.isConst()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isFunction()) {\n      if (NodeUtil.isFunctionDeclaration(parent)) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(nameNode, ns);\n    } else if (parent.isCatch()) {\n      recordDepScope(nameNode, ns);\n    } else if (NodeUtil.isObjectLitKey(nameNode)) {\n      if (parent.isObjectLit()) {\n        recordDepScope(nameNode, ns);\n      } else if (parent.isAssign()) {\n        if (parent.getParent().isExprResult()) {\n          recordDepScope(nameNode, ns);\n        }\n      } else if (parent.isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isParamList()) {\n      if (parent.getParent().isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImport()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImportSpec() || parent.isImportDefaultSpec()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    }\n  ",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isLet() || parent.isConst()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isFunction()) {\n      if (NodeUtil.isFunctionDeclaration(parent)) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(nameNode, ns);\n    } else if (parent.isCatch()) {\n      recordDepScope(nameNode, ns);\n    } else if (NodeUtil.isObjectLitKey(nameNode)) {\n      if (parent.isObjectLit()) {\n        recordDepScope(nameNode, ns);\n      } else if (parent.isAssign()) {\n        if (parent.getParent().isExprResult()) {\n          recordDepScope(nameNode, ns);\n        }\n      } else if (parent.isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isParamList()) {\n      if (parent.getParent().isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isDefaultValue()) {\n      if (parent.getParent().isCatch()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImport()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImportSpec()",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isLet() || parent.isConst()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isFunction()) {\n      if (NodeUtil.isFunctionDeclaration(parent)) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isVar()) {\n      recordDepScope(nameNode, ns);\n    } else if (parent.isCatch()) {\n      recordDepScope(nameNode, ns);\n    } else if (NodeUtil.isObjectLitKey(nameNode)) {\n      if (parent.isObjectLit()) {\n        recordDepScope(nameNode, ns);\n      } else if (parent.isAssign()) {\n        if (parent.getParent().isExprResult()) {\n          recordDepScope(nameNode, ns);\n        }\n      } else if (parent.isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isParamList()) {\n      if (parent.getParent().isFunction()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImport()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImportSpec()) {\n      if (parent.getParent().isScript()) {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isImportNamespace())"
      ],
      "function range": "558,5-588,5"
    },
    "Closure_118_/src/com/google/javascript/jscomp/DisambiguateProperties.java_495-496": {
      "loc": "495-496",
      "input": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child != null;\n      child = child.getNext()) {",
      "output": [
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}\n\n  private void handleObjectLit(NodeTraversal t, Node objectLit) {\n    for (Node child = objectLit.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGet(NodeTraversal t, Node get) {\n    for (Node child = get.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleSet(NodeTraversal t, Node set) {\n    for (Node child = set.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleString",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}\n\n  private void handleObjectLit(NodeTraversal t, Node objectLit) {\n    for (Node child = objectLit.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGet(NodeTraversal t, Node get) {\n    for (Node child = get.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GETPROP:\n          handleGetProp(t, child);\n          break;\n        case Token.GETELEM:\n          handleGetElem(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGetProp(NodeTraversal t, Node getProp) {\n    for (Node child = getProp.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGetElem(NodeTraversal t, Node getElem) {\n    for (Node child = getElem.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}\n\n  private void handleObjectLit(NodeTraversal t, Node objectLit) {\n    for (Node child = objectLit.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGet(NodeTraversal t, Node get) {\n    for (Node child = get.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleSet(NodeTraversal t, Node set) {\n    for (Node child = set.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}\n\n  private void handleObjectLit(NodeTraversal t, Node objectLit) {\n    for (Node child = objectLit.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGet(NodeTraversal t, Node get) {\n    for (Node child = get.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleSet(NodeTraversal t, Node set) {\n    for (Node child = set.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n}\n<|",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}\n\n  private void handleObjectLit(NodeTraversal t, Node objectLit) {\n    for (Node child = objectLit.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGet(NodeTraversal t, Node get) {\n    for (Node child = get.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GETPROP:\n          handleGetProp(t, child);\n          break;\n        case Token.GETELEM:\n          handleGetElem(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGetProp(NodeTraversal t, Node getProp) {\n    for (Node child = getProp.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GETPROP:\n          handleGetProp(t, child);\n          break;\n        case Token.GETELEM:\n          handleGetElem(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGetElem(NodeTraversal t, Node getElem) {\n    for (Node child = getE",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}\n\n  private void handleObjectLit(NodeTraversal t, Node objectLit) {\n    for (Node child = objectLit.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGet(NodeTraversal t, Node get) {\n    for (Node child = get.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleSet(NodeTraversal t, Node set) {\n    for (Node child = set.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.OBJECTLIT:\n          handleObjectLit(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}\n\n  private void handleObjectLit(NodeTraversal t, Node objectLit) {\n    for (Node child = objectLit.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGet(NodeTraversal t, Node get) {\n    for (Node child = get.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GETPROP:\n          handleGetProp(t, child);\n          break;\n        case Token.GETELEM:\n          handleGetElem(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGetElem(NodeTraversal t, Node getElem) {\n    for (Node child = getElem.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GETPROP:\n          handleGetProp(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGetProp(NodeTraversal t, Node getProp) {\n    for (Node child = getProp.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}\n\n  private void handleObjectLit(NodeTraversal t, Node objectLit) {\n    for (Node child = objectLit.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGet(NodeTraversal t, Node get) {\n    for (Node child = get.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleSet(NodeTraversal t, Node set) {\n    for (Node child = set.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleString(NodeTraversal t, Node string) {\n    for (Node child = string.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      ",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}\n\n  private void handleObjectLit(NodeTraversal t, Node objectLit) {\n    for (Node child = objectLit.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGet(NodeTraversal t, Node get) {\n    for (Node child = get.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleSet(NodeTraversal t, Node set) {\n    for (Node child = set.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.OBJECTLIT:\n          handleObjectLit(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          ",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}\n\n  private void handleObjectLit(NodeTraversal t, Node objectLit) {\n    for (Node child = objectLit.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleGet(NodeTraversal t, Node get) {\n    for (Node child = get.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.SET:\n          handleSet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  private void handleSet(NodeTraversal t, Node set) {\n    for (Node child = set.getFirstChild();\n        child!= null;\n        child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.GET:\n          handleGet(t, child);\n          break;\n        case Token.STRING:\n          handleString(t, child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  /**\n   *"
      ],
      "function range": "490,5-513,5"
    },
    "Closure_120_/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java_431-432": {
      "loc": "431-432",
      "input": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block != null; block = block.getParent()) {\n    if (block.isFunction) {",
      "output": [
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarE",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvalu",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\n",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluatorFactory;\nimport",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext"
      ],
      "function range": "421,5-438,5"
    },
    "Closure_122_/src/com/google/javascript/jscomp/parsing/IRFactory.java_252-253": {
      "loc": "252-253",
      "input": "private void handleBlockComment(Comment comment) {",
      "output": [
        "private void handleBlockComment(Comment comment) {\n        String text = comment.getText();\n        if (text.startsWith(\"/*\")) {\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(2, text.length() - 2);\n            } else {\n                text = text.substring(2);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(4, text.length() - 3);\n            } else {\n                text = text.substring(4);\n            }\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            } else {\n                text = text.substring(0, text.length() - 1);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            text = text.substring(4);\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(0, text.length() - 3);\n            } else {\n                text = text.substring(0, text.length() - 2);\n            }\n        } else {\n            return;\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            } else {\n                text = text.substring(0, text.length() - 1);",
        "private void handleBlockComment(Comment comment) {\n        String text = comment.getText();\n        if (text.startsWith(\"/*\")) {\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(2, text.length() - 2);\n            } else {\n                text = text.substring(2);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(4, text.length() - 3);\n            } else {\n                text = text.substring(4);\n            }\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            } else {\n                text = text.substring(0, text.length() - 1);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            text = text.substring(4);\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(0, text.length() - 3);\n            } else {\n                text = text.substring(0, text.length() - 2);\n            }\n        } else {\n            return;\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            text =",
        "private void handleBlockComment(Comment comment) {\n        String text = comment.getText();\n        if (text.startsWith(\"/*\")) {\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(2, text.length() - 2);\n            } else {\n                text = text.substring(2);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(4, text.length() - 3);\n            } else {\n                text = text.substring(4);\n            }\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            } else {\n                text = text.substring(0, text.length() - 1);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            text = text.substring(4);\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(0, text.length() - 3);\n            } else {\n                text = text.substring(0, text.length() - 2);\n            }\n        } else {\n            return;\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 3);\n            } else {\n                text = text.substring(0, text.length() - 2);",
        "private void handleBlockComment(Comment comment) {\n        String text = comment.getText();\n        if (text.startsWith(\"/*\")) {\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(2, text.length() - 2);\n            } else {\n                text = text.substring(2);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(4, text.length() - 3);\n            } else {\n                text = text.substring(4);\n            }\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            } else {\n                text = text.substring(0, text.length() - 1);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            text = text.substring(4);\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(0, text.length() - 3);\n            } else {\n                text = text.substring(0, text.length() - 2);\n            }\n        } else {\n            return;\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            } else {\n                text = text.substring(0, text.length() - 3);",
        "private void handleBlockComment(Comment comment) {\n        String text = comment.getText();\n        if (text.startsWith(\"/*\")) {\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(2, text.length() - 2);\n            } else {\n                text = text.substring(2);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(4, text.length() - 3);\n            } else {\n                text = text.substring(4);\n            }\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            } else {\n                text = text.substring(0, text.length() - 1);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            text = text.substring(4);\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(0, text.length() - 3);\n            } else {\n                text = text.substring(0, text.length() - 2);\n            }\n        } else {\n            return;\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 3);\n            } else {\n                text = text.substring(0, text.length() - 1);",
        "private void handleBlockComment(Comment comment) {\n        String text = comment.getText();\n        if (text.startsWith(\"/*\")) {\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(2, text.length() - 2);\n            } else {\n                text = text.substring(2);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(4, text.length() - 3);\n            } else {\n                text = text.substring(4);\n            }\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            } else {\n                text = text.substring(0, text.length() - 1);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            text = text.substring(4);\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(0, text.length() - 3);\n            } else {\n                text = text.substring(0, text.length() - 2);\n            }\n        }\n        if (text.endsWith(\"*/\")) {\n            text = text.substring(0, text.length() - 2);\n        } else if (text.endsWith(\"<!--\")) {\n            text = text.substring(0, text.length() - 3);\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.sub",
        "private void handleBlockComment(Comment comment) {\n        String text = comment.getText();\n        if (text.startsWith(\"/*\")) {\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(2, text.length() - 2);\n            } else {\n                text = text.substring(2);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(4, text.length() - 3);\n            } else {\n                text = text.substring(4);\n            }\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            } else {\n                text = text.substring(0, text.length() - 1);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            text = text.substring(4);\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(0, text.length() - 3);\n            } else {\n                text = text.substring(0, text.length() - 2);\n            }\n        } else {\n            return;\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            } else {\n                text = text.substring(0, text.length() - 2);",
        "private void handleBlockComment(Comment comment) {\n        String text = comment.getText();\n        if (text.startsWith(\"/*\")) {\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(2, text.length() - 2);\n            } else {\n                text = text.substring(2);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(4, text.length() - 3);\n            } else {\n                text = text.substring(4);\n            }\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            } else {\n                text = text.substring(0, text.length() - 1);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            text = text.substring(4);\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(0, text.length() - 3);\n            } else {\n                text = text.substring(0, text.length() - 2);\n            }\n        } else {\n            return;\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            } else {\n                return;\n            }\n        } else if (text.startsWith",
        "private void handleBlockComment(Comment comment) {\n        String text = comment.getText();\n        if (text.startsWith(\"/*\")) {\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(2, text.length() - 2);\n            } else {\n                text = text.substring(2);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(4, text.length() - 3);\n            } else {\n                text = text.substring(4);\n            }\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            } else {\n                text = text.substring(0, text.length() - 1);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            text = text.substring(4);\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(0, text.length() - 3);\n            } else {\n                text = text.substring(0, text.length() - 2);\n            }\n        }\n        if (text.endsWith(\"*/\")) {\n            text = text.substring(0, text.length() - 2);\n        }\n        if (text.endsWith(\" \")) {\n            text = text.substring(0, text.length() - 1);\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.sub",
        "private void handleBlockComment(Comment comment) {\n        String text = comment.getText();\n        if (text.startsWith(\"/*\")) {\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(2, text.length() - 2);\n            } else {\n                text = text.substring(2);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(4, text.length() - 3);\n            } else {\n                text = text.substring(4);\n            }\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            } else {\n                text = text.substring(0, text.length() - 1);\n            }\n        } else if (text.startsWith(\"<!--\")) {\n            text = text.substring(4);\n            if (text.endsWith(\"-->\")) {\n                text = text.substring(0, text.length() - 3);\n            } else {\n                text = text.substring(0, text.length() - 2);\n            }\n        } else {\n            return;\n        }\n        text = text.trim();\n        if (text.length() == 0) {\n            return;\n        }\n        if (text.startsWith(\"//\")) {\n            text = text.substring(2);\n        } else if (text.startsWith(\"/*\")) {\n            text = text.substring(2);\n            if (text.endsWith(\"*/\")) {\n                text = text.substring(0, text.length() - 2);\n            } else {\n                text = text.substring(1);\n            }\n        } else"
      ],
      "function range": "251,3-258,3"
    },
    "Closure_125_/src/com/google/javascript/jscomp/TypeCheck.java_1661-1662": {
      "loc": "1661-1662",
      "input": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();",
      "output": [
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}\n\n/**\n * Visits a CALL node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitCall(NodeTraversal t, Node n, Node parent) {\n  Node child = n.getFirstChild();\n  JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n  if (!childType.canBeCalled()) {\n    report(t, n, NOT_CALLABLE, childType.toString());\n    ensureTyped(t, n);\n    return;\n  }\n\n  // A couple of types can be called as if they were functions.\n  // If it is a function type, then validate parameters.\n  if (childType.isFunctionType()) {\n    FunctionType functionType = childType.toMaybeFunctionType();\n\n    // Non-native constructors should not be called directly\n    // unless they specify a return type\n    if (functionType.isConstructor() &&\n       !functionType.isNativeObjectType() &&\n        (functionType.getReturnType().isUnknownType() ||\n            functionType.getReturnType().isVoidType())) {\n      report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}\n\n/**\n * Visits a CALL node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitCall(NodeTraversal t, Node n, Node parent) {\n  Node child = n.getFirstChild();\n  JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n  if (!childType.canBeCalled()) {\n    report(t, n, NOT_CALLABLE, childType.toString());\n    ensureTyped(t, n);\n    return;\n  }\n\n  // A couple of types can be called as if they were functions.\n  // If it is a function type, then validate parameters.\n  if (childType.isFunctionType()) {\n    FunctionType functionType = childType.toMaybeFunctionType();\n\n    // Non-native constructors should not be called directly\n    // unless they specify a return type\n    if (functionType.isConstructor() &&\n       !functionType.isNativeObjectType() &&\n        (functionType.getReturnType().isUnknownType() ||\n         functionType.getReturnType().isVoidType())) {\n      report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}\n\n/**\n * Visits a CALL node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitCall(NodeTraversal t, Node n, Node parent) {\n  Node child = n.getFirstChild();\n  JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n  if (!childType.canBeCalled()) {\n    report(t, n, NOT_CALLABLE, childType.toString());\n    ensureTyped(t, n);\n    return;\n  }\n\n  // A couple of types can be called as if they were functions.\n  // If it is a function type, then validate parameters.\n  if (childType instanceof FunctionType) {\n    FunctionType functionType = (FunctionType) childType;\n\n    // Non-native constructors should not be called directly\n    // unless they specify a return type\n    if (functionType.isConstructor() &&\n       !functionType.isNativeObjectType() &&\n        (functionType.getReturnType().isUnknownType() ||\n            functionType.getReturnType().isVoidType())) {\n      report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.to",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}\n\n/**\n * Visits a CALL node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitCall(NodeTraversal t, Node n, Node parent) {\n  Node child = n.getFirstChild();\n  JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n  if (!childType.canBeCalled()) {\n    report(t, n, NOT_CALLABLE, childType.toString());\n    ensureTyped(t, n);\n    return;\n  }\n\n  // A couple of types can be called as if they were functions.\n  // If it is a function type, then validate parameters.\n  if (childType instanceof FunctionType) {\n    FunctionType functionType = (FunctionType) childType;\n\n    // Non-native constructors should not be called directly\n    // unless they specify a return type\n    if (functionType.isConstructor() &&\n       !functionType.isNativeObjectType() &&\n        (functionType.getReturnType().isUnknownType() ||\n         functionType.getReturnType().isVoidType())) {\n      report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.to",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}\n\n/**\n * Visits a CALL node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitCall(NodeTraversal t, Node n, Node parent) {\n  Node child = n.getFirstChild();\n  JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n  if (!childType.canBeCalled()) {\n    report(t, n, NOT_CALLABLE, childType.toString());\n    ensureTyped(t, n);\n    return;\n  }\n\n  // A couple of types can be called as if they were functions.\n  // If it is a function type, then validate parameters.\n  if (childType.isFunctionType()) {\n    FunctionType fnType = childType.toMaybeFunctionType();\n\n    // Non-native constructors should not be called directly\n    // unless they specify a return type\n    if (fnType.isConstructor() &&\n       !fnType.isNativeObjectType() &&\n        (fnType.getReturnType().isUnknownType() || fnType.getReturnType().isVoidType())) {\n      report(t, n, CONSTRUCTOR_NOT_CALLABLE, fnType.getReturn",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}\n\n/**\n * Visits a CALL node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitCall(NodeTraversal t, Node n, Node parent) {\n  Node child = n.getFirstChild();\n  JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n  if (!childType.canBeCalled()) {\n    report(t, n, NOT_CALLABLE, childType.toString());\n    ensureTyped(t, n);\n    return;\n  }\n\n  // A couple of types can be called as if they were functions.\n  // If it is a function type, then validate parameters.\n  if (childType.isFunctionType()) {\n    FunctionType functionType = childType.toMaybeFunctionType();\n\n    boolean isExtern = false;\n    JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n    if (functionJSDocInfo!= null) {\n      isExtern = functionJSDocInfo.isExtern();\n    }\n\n    // Non-native constructors should not be called directly\n    // unless they specify a return type and are defined\n    // in an extern.\n    ",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}\n\n/**\n * Visits a CALL node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitCall(NodeTraversal t, Node n, Node parent) {\n  Node child = n.getFirstChild();\n  JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n  if (!childType.canBeCalled()) {\n    report(t, n, NOT_CALLABLE, childType.toString());\n    ensureTyped(t, n);\n    return;\n  }\n\n  // A couple of types can be called as if they were functions.\n  // If it is a function type, then validate parameters.\n  if (childType.isFunctionType()) {\n    FunctionType fnType = childType.toMaybeFunctionType();\n\n    // Non-native constructors should not be called directly\n    // unless they specify a return type\n    if (fnType.isConstructor() &&\n       !fnType.isNativeObjectType() &&\n        (fnType.getReturnType().isUnknownType() || fnType.getReturnType().isVoidType())) {\n      report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}\n\n/**\n * Visits a CALL node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitCall(NodeTraversal t, Node n, Node parent) {\n  Node child = n.getFirstChild();\n  JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n  if (!childType.canBeCalled()) {\n    report(t, n, NOT_CALLABLE, childType.toString());\n    ensureTyped(t, n);\n    return;\n  }\n\n  // A couple of types can be called as if they were functions.\n  // If it is a function type, then validate parameters.\n  if (childType.isFunctionType()) {\n    FunctionType functionType = childType.toMaybeFunctionType();\n\n    boolean isExtern = false;\n    JSDocInfo functionJSDocInfo = child.getJSDocInfo();\n    if (functionJSDocInfo!= null) {\n      isExtern = functionJSDocInfo.isExtern();\n    }\n\n    // Non-native constructors should not be called directly\n    // unless they specify a return type and are defined\n    // in an extern.\n    if",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}\n\n/**\n * Visits a CALL node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitCall(NodeTraversal t, Node n, Node parent) {\n  Node child = n.getFirstChild();\n  JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n  if (!childType.canBeCalled()) {\n    report(t, n, NOT_CALLABLE, childType.toString());\n    ensureTyped(t, n);\n    return;\n  }\n\n  // A couple of types can be called as if they were functions.\n  // If it is a function type, then validate parameters.\n  if (childType.isFunctionType()) {\n    FunctionType fnType = childType.toMaybeFunctionType();\n\n    // Non-native constructors should not be called directly\n    // unless they specify a return type\n    if (fnType.isConstructor() &&\n       !fnType.isNativeObjectType() &&\n        (fnType.getReturnType().isUnknownType() || fnType.getReturnType().isVoidType())) {\n      report(t, n, CONSTRUCTOR_NOT_CALLABLE, fnType.toString",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}\n\n/**\n * Visits a CALL node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n * @param parent The parent of {@code n}.\n */\nprivate void visitCall(NodeTraversal t, Node n, Node parent) {\n  Node child = n.getFirstChild();\n  JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n  if (!childType.canBeCalled()) {\n    report(t, n, NOT_CALLABLE, childType.toString());\n    ensureTyped(t, n);\n    return;\n  }\n\n  // A couple of types can be called as if they were functions.\n  // If it is a function type, then validate parameters.\n  if (childType.isFunctionType()) {\n    FunctionType functionType = childType.toMaybeFunctionType();\n\n    boolean isExtern = false;\n    JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n    if (functionJSDocInfo!= null) {\n      isExtern = functionJSDocInfo.isExtern();\n    }\n\n    // Non-native constructors should not be called directly\n    // unless they specify a return type.\n    if (functionType.isConstructor() &&"
      ],
      "function range": "1656,3-1671,3"
    },
    "Closure_126_/src/com/google/javascript/jscomp/MinimizeExitPoints.java_141-145": {
      "loc": "141-145",
      "input": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock != null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }",
      "output": [
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    Node finallyBlock = tryBlock.getNext();\n    if (finallyBlock!= null) {\n      tryMinimizeExits(finallyBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    Node whileBody = n.getLastChild();\n    tryMinimizeExits(whileBody, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    Node doBody = n.getFirstChild();\n    tryMinimizeExits(doBody, exitType, labelName);\n    Node whileBody = doBody.getNext();\n    if (whileBody!= null) {\n      tryMinimizeExits(whileBody, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isFor()) {\n    Node forBody = n.",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    Node finallyBlock = tryBlock.getNext();\n    if (finallyBlock!= null) {\n      tryMinimizeExits(finallyBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    Node whileBody = n.getLastChild();\n    tryMinimizeExits(whileBody, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    Node doBody = n.getFirstChild();\n    tryMinimizeExits(doBody, exitType, labelName);\n    Node whileBody = doBody.getNext();\n    if (whileBody.isBlock()) {\n      tryMinimizeExits(whileBody, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isFor()) {\n    Node forBody = n",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    Node finallyBlock = tryBlock.getNext();\n    if (finallyBlock!= null) {\n      tryMinimizeExits(finallyBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    Node whileBody = n.getFirstChild().getNext();\n    tryMinimizeExits(whileBody, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    Node doBody = n.getFirstChild();\n    tryMinimizeExits(doBody, exitType, labelName);\n    Node whileBody = doBody.getNext();\n    if (whileBody!= null) {\n      tryMinimizeExits(whileBody, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isFor()) {\n    Node forBody",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    Node finallyBlock = tryBlock.getNext();\n    if (finallyBlock!= null) {\n      tryMinimizeExits(finallyBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isSwitch()) {\n    Node defaultCase = n.getLastChild();\n    tryMinimizeExits(defaultCase, exitType, labelName);\n    for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n      if (c.isDefaultCase()) {\n        continue;\n      }\n      tryMinimizeExits(c, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isDo()) {\n    Node cond = n.getFirstChild();\n    tryMinimizeExits(cond, exitType, labelName);\n    Node body = cond.",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    Node finallyBlock = tryBlock.getNext();\n    if (finallyBlock!= null) {\n      tryMinimizeExits(finallyBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    Node whileBody = n.getFirstChild().getNext();\n    tryMinimizeExits(whileBody, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    Node doBody = n.getFirstChild();\n    tryMinimizeExits(doBody, exitType, labelName);\n    Node whileBody = doBody.getNext();\n    if (whileBody.isBlock()) {\n      tryMinimizeExits(whileBody.getFirstChild(), exitType, labelName);\n    }\n    return;\n  }\n  if (n.isFor()) {",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    Node finallyBlock = tryBlock.getNext();\n    if (finallyBlock!= null) {\n      tryMinimizeExits(finallyBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    Node whileBody = n.getFirstChild().getNext();\n    tryMinimizeExits(whileBody, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    Node doBody = n.getFirstChild();\n    tryMinimizeExits(doBody, exitType, labelName);\n    Node whileBody = doBody.getNext();\n    if (whileBody.isBlock()) {\n      tryMinimizeExits(whileBody, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isFor()) {\n    Node for",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    Node finallyBlock = tryBlock.getNext();\n    if (finallyBlock!= null) {\n      tryMinimizeExits(finallyBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    Node whileBlock = n.getFirstChild();\n    tryMinimizeExits(whileBlock, exitType, labelName);\n    Node cond = whileBlock.getNext();\n    if (cond == null) {\n      return;\n    }\n    Node body = cond.getNext();\n    if (body!= null) {\n      tryMinimizeExits(body, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isDo()) {\n    Node whileBlock = n.getFirstChild();\n    tryMinimizeExits(whileBlock, exitType, labelName);\n    ",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    Node finallyBlock = tryBlock.getNext();\n    if (finallyBlock!= null) {\n      tryMinimizeExits(finallyBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    Node whileBlock = n.getFirstChild();\n    tryMinimizeExits(whileBlock, exitType, labelName);\n    Node cond = whileBlock.getNext();\n    if (cond!= null) {\n      tryMinimizeExits(cond, exitType, labelName);\n    }\n    Node body = whileBlock.getNext();\n    if (body!= null) {\n      tryMinimizeExits(body, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isDo()) {\n    Node doBlock = n.getFirstChild();\n    tryMinimizeEx",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    Node finallyBlock = tryBlock.getNext();\n    if (finallyBlock!= null) {\n      tryMinimizeExits(finallyBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    Node whileBlock = n.getFirstChild();\n    tryMinimizeExits(whileBlock, exitType, labelName);\n    Node cond = whileBlock.getNext();\n    if (cond!= null) {\n      tryMinimizeExits(cond, exitType, labelName);\n    }\n    Node body = whileBlock.getNext();\n    if (body!= null) {\n      tryMinimizeExits(body, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isDo()) {\n    Node doBlock = n.getFirstChild();\n    Node cond = do",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    Node finallyBlock = tryBlock.getNext();\n    if (finallyBlock!= null) {\n      tryMinimizeExits(finallyBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isWhile()) {\n    Node whileBody = n.getFirstChild().getNext();\n    tryMinimizeExits(whileBody, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    Node doBody = n.getFirstChild();\n    tryMinimizeExits(doBody, exitType, labelName);\n    Node whileBody = doBody.getNext();\n    if (whileBody!= null) {\n      tryMinimizeExits(whileBody, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isFor() || n.isForIn"
      ],
      "function range": "106,3-201,3"
    },
    "Closure_129_/src/com/google/javascript/jscomp/PrepareAst.java_166-167": {
      "loc": "166-167",
      "input": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();",
      "output": [
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSTypeRegistry.getType(info.getTypedefType()).toMaybeFunctionType();\n    if (methodType == null ||!methodType.isInterface()) {\n      continue;\n    }\n    String interfaceName = methodType.getInstanceType().getReferenceName();\n    if (interfaceName == null) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    compiler.reportChangeToEnclosingScope(n);\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSTypeRegistry.getType(info.getTypedefType()).toMaybeFunctionType();\n    if (methodType == null ||!methodType.isInterface()) {\n      continue;\n    }\n    String interfaceName = methodType.getInstanceType().getReferenceName();\n    if (interfaceName == null) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    compiler.reportChangeToEnclosingScope(n);\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSTypeRegistry.getType(info.getTypedefType()).toMaybeFunctionType();\n    if (methodType == null ||!methodType.isInterface()) {\n      continue;\n    }\n    String interfaceName = methodType.getInstanceType().getReferenceName();\n    if (interfaceName == null) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    compiler.reportChangeToEnclosingScope(n);\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSTypeRegistry.getType(info.getTypedefType()).toMaybeFunctionType();\n    if (methodType == null ||!methodType.isInterface()) {\n      continue;\n    }\n    String interfaceName = methodType.getInstanceType().getReferenceName();\n    if (interfaceName == null) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    compiler.reportChangeToEnclosingScope(n);\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.h",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSType.toMaybeFunctionType(c.getFirstChild().getJSType());\n    if (methodType == null\n        || methodType.isAbstract()\n        || methodType.isInterface()\n        || methodType.isConstructor()\n        || methodType.isEnumType()) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n    builder.recordConstructor();\n    c.setJSDocInfo(builder.build());\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\n",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSTypeRegistry.getType(info.getTypedefType()).toMaybeFunctionType();\n    if (methodType == null ||!methodType.isInterface()) {\n      continue;\n    }\n    String interfaceName = methodType.getInstanceType().getReferenceName();\n    if (interfaceName == null) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    compiler.reportChangeToEnclosingScope(n);\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\n\nimport org",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSType.toMaybeFunctionType(c.getFirstChild().getJSType());\n    if (methodType == null\n        || methodType.isAbstract()\n        || methodType.isInterface()\n        || methodType.isConstructor()\n        || methodType.isEnumType()) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n    builder.recordConstructor();\n    c.setJSDocInfo(builder.build());\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache.distributed",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSTypeRegistry.getType(info.getTypedefType()).toMaybeFunctionType();\n    if (methodType == null ||!methodType.isInterface()) {\n      continue;\n    }\n    String interfaceName = methodType.getInstanceType().getReferenceName();\n    if (interfaceName == null) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    compiler.reportChangeToEnclosingScope(n);\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.IOException;\n\nimport org",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSType.toMaybeFunctionType(c.getFirstChild().getJSType());\n    if (methodType == null\n        || methodType.isAbstract()\n        || methodType.isInterface()\n        || methodType.isConstructor()\n        || methodType.isEnumType()) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n    builder.recordConstructor();\n    c.setJSDocInfo(builder.build());\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jackrabbit.oak.spi.security.authentication",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSType.toMaybeFunctionType(c.getFirstChild().getJSType());\n    if (methodType == null\n        || methodType.isAbstract()\n        || methodType.isInterface()\n        || methodType.isConstructor()\n        || methodType.isEnumType()) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n    builder.recordConstructor();\n    c.setJSDocInfo(builder.build());\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java"
      ],
      "function range": "158,5-177,5"
    },
    "Closure_130_/src/com/google/javascript/jscomp/CollapseProperties.java_172-173": {
      "loc": "172-173",
      "input": "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }",
      "output": [
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.type == Name.Type.ALIASING_GET || name.type == Name.Type.ALIASING_SET) {\n      if (name.type == Name.Type.ALIASING_GET) {\n        name.type = Name.Type.GET;\n      } else if (name.type == Name.Type.ALIASING_SET) {\n        name.type = Name.Type.SET;\n      }\n      workList.push(name);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.type == Name.Type.ALIASING_GET || name.type == Name.Type.ALIASING_SET) {\n      if (name.type == Name.Type.ALIASING_GET) {\n        name.type = Name.Type.GET;\n      } else if (name.type == Name.Type.ALIASING_SET) {\n        name.type = Name.Type.SET;\n      }\n      workList.push(name);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDesc",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.type == Name.Type.ALIASING_GET || name.type == Name.Type.ALIASING_SET) {\n      if (name.type == Name.Type.ALIASING_GET) {\n        name.type = Name.Type.GET;\n      } else if (name.type == Name.Type.ALIASING_SET) {\n        name.type = Name.Type.SET;\n      }\n      workList.push(name);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.type == Name.Type.ALIASING_GET || name.type == Name.Type.ALIASING_SET) {\n      if (name.type == Name.Type.ALIASING_GET) {\n        name.type = Name.Type.GET;\n      } else if (name.type == Name.Type.ALIASING_SET) {\n        name.type = Name.Type.SET;\n      }\n      workList.push(name);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.aster",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.type == Name.Type.ALIASING_GET || name.type == Name.Type.ALIASING_SET) {\n      if (name.type == Name.Type.ALIASING_GET) {\n        name.type = Name.Type.GET;\n      } else if (name.type == Name.Type.ALIASING_SET) {\n        name.type = Name.Type.SET;\n      }\n      workList.push(name);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.type == Name.Type.ALIASING_GET || name.type == Name.Type.ALIASING_SET) {\n      if (name.type == Name.Type.ALIASING_GET) {\n        name.type = Name.Type.GET;\n      } else if (name.type == Name.Type.ALIASING_SET) {\n        name.type = Name.Type.SET;\n      }\n      workList.push(name);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.type == Name.Type.ALIASING_GET || name.type == Name.Type.ALIASING_SET) {\n      if (name.type == Name.Type.ALIASING_GET) {\n        name.type = Name.Type.GET;\n      } else if (name.type == Name.Type.ALIASING_SET) {\n        name.type = Name.Type.SET;\n      }\n      workList.push(name);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.type == Name.Type.ALIASING_GET || name.type == Name.Type.ALIASING_SET) {\n      if (name.type == Name.Type.ALIASING_GET) {\n        name.type = Name.Type.GET;\n      } else if (name.type == Name.Type.ALIASING_SET) {\n        name.type = Name.Type.SET;\n      }\n      workList.push(name);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.type == Name.Type.ALIASING_GET || name.type == Name.Type.ALIASING_SET) {\n      if (name.type == Name.Type.ALIASING_GET) {\n        name.type = Name.Type.GET;\n      } else if (name.type == Name.Type.ALIASING_SET) {\n        name.type = Name.Type.SET;\n      }\n      workList.push(name);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.type == Name.Type.ALIASING_GET || name.type == Name.Type.ALIASING_SET) {\n      if (name.type == Name.Type.ALIASING_GET) {\n        name.type = Name.Type.GET;\n      } else if (name.type == Name.Type.ALIASING_SET) {\n        name.type = Name.Type.SET;\n      }\n      workList.push(name);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.functions.IFunctionTypeInferer;\nimport org."
      ],
      "function range": "161,3-197,3"
    },
    "Closure_133_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_2401-2402": {
      "loc": "2401-2402",
      "input": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();",
      "output": [
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result!= null) {\n    return result;\n  } else {\n    return \"\";\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result!= null) {\n    return result;\n  } else {\n    return \"\";\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result!= null) {\n    return result;\n  } else {\n    return \"\";\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksData",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result!= null) {\n    return result;\n  } else {\n    return \"\";\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result!= null) {\n    return result;\n  } else {\n    return \"\";\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result!= null) {\n    return result;\n  } else {\n    return \"\";\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksData",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result!= null) {\n    return result;\n  } else {\n    return \"\";\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.data.std.api.IPointable;\nimport org.",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result!= null) {\n    return result;\n  } else {\n    return \"\";\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.data.std.api.IPointable;\n\npublic class",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result!= null) {\n    return result;\n  } else {\n    return \"\";\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends Abstract",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result!= null) {\n    return result;\n  } else {\n    return \"\";\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.api.exceptions.Hyr"
      ],
      "function range": "2399,3-2402,3"
    },
    "Closure_146_/src/com/google/javascript/rhino/jstype/JSType.java_706-707": {
      "loc": "706-707",
      "input": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:",
      "output": [
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(registry.getNativeType(JSTypeNative.UNKNOWN_TYPE),\n          that);\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(registry.getNativeType(JSTypeNative.VOID_TYPE),\n          that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    return isSubtype(that, ImplCache.create());\n  }\n\n  @Override\n  protected boolean isSubtype(JSType that,\n      ImplCache implicitImplCache) {\n    if (JSType.isSubtypeHelper(this, that, implicitImplCache)) {\n      return true;\n    } else {\n      return that.isSubtype(this, implicitImplCache);\n    }\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnknownType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnknownType(that);\n  }\n\n  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return forAnnotations? \"?\" : \"?\";\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.BOTH;\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(Visitor<",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(registry.getNativeType(JSTypeNative.UNKNOWN_TYPE),\n          that);\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(registry.getNativeType(JSTypeNative.VOID_TYPE),\n          that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    return isSubtype(that, ImplCache.create());\n  }\n\n  @Override\n  protected boolean isSubtype(JSType that,\n      ImplCache implicitImplCache) {\n    if (JSType.isSubtypeHelper(this, that, implicitImplCache)) {\n      return true;\n    } else {\n      return that.isSubtype(this, implicitImplCache);\n    }\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnknownType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnknownType(that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public FunctionType getFunTypeIfSingletonObj() {\n    return null;\n  }\n\n  @Override\n  public boolean canBeCalled() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseAllType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseAllType(",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(registry.getNativeType(JSTypeNative.UNKNOWN_TYPE),\n          that);\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(registry.getNativeType(JSTypeNative.VOID_TYPE),\n          that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    return isSubtype(that, ImplCache.create());\n  }\n\n  @Override\n  protected boolean isSubtype(JSType that,\n      ImplCache implicitImplCache) {\n    if (JSType.isSubtypeHelper(this, that, implicitImplCache)) {\n      return true;\n    } else {\n      return that.isSubtype(this, implicitImplCache);\n    }\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnknownType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnknownType(that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public FunctionType getFunTypeIfSingletonObj() {\n    return null;\n  }\n\n  @Override\n  public boolean canBeCalled() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(registry.getNativeType(JSTypeNative.UNKNOWN_TYPE),\n          that);\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(registry.getNativeType(JSTypeNative.VOID_TYPE),\n          that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    return isSubtype(that, ImplCache.create());\n  }\n\n  @Override\n  protected boolean isSubtype(JSType that,\n      ImplCache implicitImplCache) {\n    if (JSType.isSubtypeHelper(this, that, implicitImplCache)) {\n      return true;\n    } else {\n      return that.isSubtype(this, implicitImplCache);\n    }\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnknownType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnknownType(that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public FunctionType getFunTypeIfSingletonObj() {\n    return null;\n  }\n\n  @Override\n  public boolean canBeCalled() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnknownType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnknownType(",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(registry.getNativeType(JSTypeNative.UNKNOWN_TYPE),\n          that);\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(registry.getNativeType(JSTypeNative.VOID_TYPE),\n          that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    return isSubtype(that, ImplCache.create());\n  }\n\n  @Override\n  protected boolean isSubtype(JSType that,\n      ImplCache implicitImplCache) {\n    if (JSType.isSubtypeHelper(this, that, implicitImplCache)) {\n      return true;\n    } else {\n      return that.isSubtype(this, implicitImplCache);\n    }\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnknownType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnknownType(that);\n  }\n\n  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return forAnnotations? \"?\" : \"?\";\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.EMPTY;\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(Visitor<",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(registry.getNativeType(JSTypeNative.UNKNOWN_TYPE),\n          that);\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(registry.getNativeType(JSTypeNative.VOID_TYPE),\n          that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    return isSubtype(that, ImplCache.create());\n  }\n\n  @Override\n  protected boolean isSubtype(JSType that,\n      ImplCache implicitImplCache) {\n    if (JSType.isSubtypeHelper(this, that, implicitImplCache)) {\n      return true;\n    } else {\n      return that.isSubtype(this, implicitImplCache);\n    }\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnknownType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnknownType(that);\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n\n  @Override\n  public FunctionType getFunTypeIfSingletonObj() {\n    return null;\n  }\n\n  @Override\n  public boolean canBeCalled() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNoObjectType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseNoObject",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(registry.getNativeType(JSTypeNative.UNKNOWN_TYPE),\n          that);\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(registry.getNativeType(JSTypeNative.VOID_TYPE),\n          that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    return isSubtype(that, ImplCache.create());\n  }\n\n  @Override\n  protected boolean isSubtype(JSType that,\n      ImplCache implicitImplCache) {\n    if (JSType.isSubtypeHelper(this, that, implicitImplCache)) {\n      return true;\n    } else {\n      return that.isSubtype(this, implicitImplCache);\n    }\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnknownType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnknownType(that);\n  }\n\n  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return forAnnotations? \"?\" : \"?\";\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.BOTH;\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesSymbolContext() {\n    ",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(registry.getNativeType(JSTypeNative.UNKNOWN_TYPE),\n          that);\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(registry.getNativeType(JSTypeNative.VOID_TYPE),\n          that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    return isSubtype(that, ImplCache.create());\n  }\n\n  @Override\n  protected boolean isSubtype(JSType that,\n      ImplCache implicitImplCache) {\n    if (JSType.isSubtypeHelper(this, that, implicitImplCache)) {\n      return true;\n    } else {\n      return that.isSubtype(this, implicitImplCache);\n    }\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnknownType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnknownType(that);\n  }\n\n  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return forAnnotations? \"?\" : \"?\";\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.EMPTY;\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesSymbolContext() {\n    ",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(registry.getNativeType(JSTypeNative.UNKNOWN_TYPE),\n          that);\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(registry.getNativeType(JSTypeNative.VOID_TYPE),\n          that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    return isSubtype(that, ImplCache.create());\n  }\n\n  @Override\n  protected boolean isSubtype(JSType that,\n      ImplCache implicitImplCache) {\n    if (JSType.isSubtypeHelper(this, that, implicitImplCache)) {\n      return true;\n    } else {\n      return that.isSubtype(this, implicitImplCache);\n    }\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnknownType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnknownType(that);\n  }\n\n  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return forAnnotations? \"?\" : \"?\";\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.BOTH;\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(registry.getNativeType(JSTypeNative.UNKNOWN_TYPE),\n          that);\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(registry.getNativeType(JSTypeNative.VOID_TYPE),\n          that);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    return isSubtype(that, ImplCache.create());\n  }\n\n  @Override\n  protected boolean isSubtype(JSType that,\n      ImplCache implicitImplCache) {\n    if (JSType.isSubtypeHelper(this, that, implicitImplCache)) {\n      return true;\n    } else {\n      return that.isSubtype(this, implicitImplCache);\n    }\n  }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnknownType();\n  }\n\n  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnknownType(that);\n  }\n\n  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return forAnnotations? \"?\" : \"?\";\n  }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n    return BooleanLiteralSet.BOTH;\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return true;\n  }\n\n  @Override\n  public <T> T visit(NonNullable"
      ],
      "function range": "696,3-715,3"
    },
    "Closure_150_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1451-1466": {
      "loc": "1451-1466",
      "input": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }",
      "output": [
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    c.accept(this);\n  }\n}\n\n  /**\n   * Handle bleeding functions and function parameters.\n   */\n  private void handleFunctionInputs(Node fnNode) {\n    // Handle bleeding functions.\n    Node fnNameNode = fnNode.getFirstChild();\n    String fnName = fnNameNode.getString();\n    if (!fnName.isEmpty()) {\n      Scope.Var fnVar = scope.getVar(fnName);\n      if (fnVar == null ||\n          // Make sure we're not touching a native function. Native\n          // functions aren't bleeding, but may not have a declaration\n          // node.\n          (fnVar.getNameNode()!= null &&\n           // Make sure that the function is actually bleeding by checking\n           // if has already been declared.\n           fnVar.getInitialValue()!= fnNode)) {\n        defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n      }\n    }\n\n    declareArguments(fnNode);\n  }\n\n  /**\n   * Declares all of a function's arguments.\n   */\n  private void declareArguments(Node functionNode) {\n    Node astParameters = functionNode.getFirstChild().getNext();\n    Node iifeArgumentNode = null;\n\n    if (NodeUtil.isCallOrNewTarget(functionNode)) {\n      iifeArgumentNode = functionNode.getNext();\n    }\n\n    FunctionType functionType =\n        JSType.toMaybeFunctionType(functionNode.getJSType());\n    if (functionType!= null) {\n      Node jsDocParameters = functionType.getParametersNode();\n      if (jsDocParameters!= null) {\n        Node jsDocParameter = jsDocParameters.getFirstChild();\n        for (Node astParameter : astParameters",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    c.accept(this);\n  }\n}\n\n  /**\n   * Handle bleeding functions and function parameters.\n   */\n  private void handleFunctionInputs(Node fnNode) {\n    // Handle bleeding functions.\n    Node fnNameNode = fnNode.getFirstChild();\n    String fnName = fnNameNode.getString();\n    if (!fnName.isEmpty()) {\n      Scope.Var fnVar = scope.getVar(fnName);\n      if (fnVar == null ||\n          // Make sure we're not touching a native function. Native\n          // functions aren't bleeding, but may not have a declaration\n          // node.\n          (fnVar.getNameNode()!= null &&\n           // Make sure that the function is actually bleeding by checking\n           // if has already been declared.\n           fnVar.getInitialValue()!= fnNode)) {\n        defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n      }\n    }\n\n    declareArguments(fnNode);\n  }\n\n  /**\n   * Declares all of a function's arguments.\n   */\n  private void declareArguments(Node functionNode) {\n    Node astParameters = functionNode.getSecondChild();\n    Node iifeArgumentNode = null;\n\n    if (NodeUtil.isCallOrNewTarget(functionNode)) {\n      iifeArgumentNode = functionNode.getNext();\n    }\n\n    FunctionType functionType =\n        JSType.toMaybeFunctionType(functionNode.getJSType());\n    if (functionType!= null) {\n      Node jsDocParameters = functionType.getParametersNode();\n      if (jsDocParameters!= null) {\n        Node jsDocParameter = jsDocParameters.getFirstChild();\n        for (Node astParameter : astParameters.children())",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    c.accept(this);\n  }\n}\n\n  /**\n   * Handle bleeding functions and function parameters.\n   */\n  private void handleFunctionInputs(Node fnNode) {\n    // Handle bleeding functions.\n    Node fnNameNode = fnNode.getFirstChild();\n    String fnName = fnNameNode.getString();\n    if (!fnName.isEmpty()) {\n      Scope.Var fnVar = scope.getVar(fnName);\n      if (fnVar == null ||\n          // Make sure we're not touching a native function. Native\n          // functions aren't bleeding, but may not have a declaration\n          // node.\n          (fnVar.getNameNode()!= null &&\n           // Make sure that the function is actually bleeding by checking\n           // if has already been declared.\n           fnVar.getInitialValue()!= fnNode)) {\n        defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n      }\n    }\n\n    declareArguments(fnNode);\n  }\n\n  /**\n   * Declares all of a function's arguments.\n   */\n  private void declareArguments(Node functionNode) {\n    Node astParameters = functionNode.getFirstChild().getNext();\n    Node iifeArgNode = null;\n\n    if (NodeUtil.isCallOrNewTarget(functionNode)) {\n      iifeArgNode = functionNode.getNext();\n    }\n\n    FunctionType functionType =\n        JSType.toMaybeFunctionType(functionNode.getJSType());\n    if (functionType!= null) {\n      Node jsDocParameters = functionType.getParametersNode();\n      if (jsDocParameters!= null) {\n        Node jsDocParameter = jsDocParameters.getFirstChild();\n        for (Node astParameter : astParameters.children",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    c.accept(this);\n  }\n}\n\n  /**\n   * Handle bleeding functions and function parameters.\n   */\n  private void handleFunctionInputs(Node fnNode) {\n    // Handle bleeding functions.\n    Node fnNameNode = fnNode.getFirstChild();\n    String fnName = fnNameNode.getString();\n    if (!fnName.isEmpty()) {\n      Scope.Var fnVar = scope.getVar(fnName);\n      if (fnVar == null ||\n          // Make sure we're not touching a native function. Native\n          // functions aren't bleeding, but may not have a declaration\n          // node.\n          (fnVar.getNameNode()!= null &&\n           // Make sure that the function is actually bleeding by checking\n           // if has already been declared.\n           fnVar.getInitialValue()!= fnNode)) {\n        defineSlot(fnNameNode, fnNode, fnNode.getJSType());\n      }\n    }\n\n    declareArguments(fnNode);\n  }\n\n  /**\n   * Declares all of a function's arguments.\n   */\n  private void declareArguments(Node functionNode) {\n    Node astParameters = functionNode.getFirstChild().getNext();\n    Node iifeArgumentNode = null;\n\n    if (NodeUtil.isCallOrNewTarget(functionNode)) {\n      iifeArgumentNode = functionNode.getNext();\n    }\n\n    FunctionType functionType =\n        JSType.toMaybeFunctionType(functionNode.getJSType());\n    if (functionType!= null) {\n      Node jsDocParameters = functionType.getParametersNode();\n      if (jsDocParameters!= null) {\n        Node jsDocParameter = jsDocParameters.getFirstChild();\n        for (Node astParameter : astParameters.children",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    c.accept(this);\n  }\n}\n\n  /**\n   * Handle bleeding functions and function parameters.\n   */\n  private void handleFunctionInputs(Node fnNode) {\n    // Handle bleeding functions.\n    Node fnNameNode = fnNode.getFirstChild();\n    String fnName = fnNameNode.getString();\n    if (!fnName.isEmpty()) {\n      Scope.Var fnVar = scope.getVar(fnName);\n      if (fnVar == null ||\n          // Make sure we're not touching a native function. Native\n          // functions aren't bleeding, but may not have a declaration\n          // node.\n          (fnVar.getNameNode()!= null &&\n            // Make sure that the function is actually bleeding by checking\n            // if has already been declared.\n            fnVar.getInitialValue()!= fnNode)) {\n        defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n      }\n    }\n\n    declareArguments(fnNode);\n  }\n\n  /**\n   * Declares all of a function's arguments.\n   */\n  private void declareArguments(Node functionNode) {\n    Node astParameters = functionNode.getFirstChild().getNext();\n    Node iifeArgumentNode = null;\n\n    if (NodeUtil.isCallOrNewTarget(functionNode)) {\n      iifeArgumentNode = functionNode.getNext();\n    }\n\n    FunctionType functionType =\n        JSType.toMaybeFunctionType(functionNode.getJSType());\n    if (functionType!= null) {\n      Node jsDocParameters = functionType.getParametersNode();\n      if (jsDocParameters!= null) {\n        Node jsDocParameter = jsDocParameters.getFirstChild();\n        for (Node astParameter : astParameters",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    c.accept(this);\n  }\n}\n\n  /**\n   * Handle bleeding functions and function parameters.\n   */\n  private void handleFunctionInputs(Node fnNode) {\n    // Handle bleeding functions.\n    Node fnNameNode = fnNode.getFirstChild();\n    String fnName = fnNameNode.getString();\n    if (!fnName.isEmpty()) {\n      Scope.Var fnVar = scope.getVar(fnName);\n      if (fnVar == null ||\n          // Make sure we're not touching a native function. Native\n          // functions aren't bleeding, but may not have a declaration\n          // node.\n          (fnVar.getNameNode()!= null &&\n           // Make sure that the function is actually bleeding by checking\n           // if has already been declared.\n           fnVar.getInitialValue()!= fnNode)) {\n        defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n      }\n    }\n\n    declareArguments(fnNode);\n  }\n\n  /**\n   * Declares all of a function's arguments.\n   */\n  private void declareArguments(Node functionNode) {\n    Node astParameters = functionNode.getFirstChild().getNext();\n    Node body = astParameters.getNext();\n    FunctionType functionType = (FunctionType) functionNode.getJSType();\n    if (functionType!= null) {\n      Node jsDocParameters = functionType.getParametersNode();\n      if (jsDocParameters!= null) {\n        Node jsDocParameter = jsDocParameters.getFirstChild();\n        for (Node astParameter : astParameters.children()) {\n          if (jsDocParameter!= null) {\n            defineSlot(astParameter, functionNode,\n                jsDocParameter.getJSType(), true);\n            js",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    c.accept(this);\n  }\n}\n\n  /**\n   * Handle bleeding functions and function parameters.\n   */\n  private void handleFunctionInputs(Node fnNode) {\n    // Handle bleeding functions.\n    Node fnNameNode = fnNode.getFirstChild();\n    String fnName = fnNameNode.getString();\n    if (!fnName.isEmpty()) {\n      Scope.Var fnVar = scope.getVar(fnName);\n      if (fnVar == null ||\n          // Make sure we're not touching a native function. Native\n          // functions aren't bleeding, but may not have a declaration\n          // node.\n          (fnVar.getNameNode()!= null &&\n           // Make sure that the function is actually bleeding by checking\n           // if has already been declared.\n           fnVar.getInitialValue()!= fnNode)) {\n        defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n      }\n    }\n\n    declareArguments(fnNode);\n  }\n\n  /**\n   * Declares all of a function's arguments.\n   */\n  private void declareArguments(Node functionNode) {\n    Node astParameters = functionNode.getFirstChild().getNext();\n    Node iifeArgumentNode = null;\n\n    if (NodeUtil.isCallOrNewTarget(functionNode)) {\n      iifeArgumentNode = functionNode.getNext();\n    }\n\n    FunctionType functionType =\n        (FunctionType) functionNode.getJSType();\n    if (functionType!= null) {\n      Node jsDocParameters = functionType.getParametersNode();\n      if (jsDocParameters!= null) {\n        Node jsDocParameter = jsDocParameters.getFirstChild();\n        for (Node astParameter : astParameters.children()) {\n",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    c.accept(this);\n  }\n}\n\n  /**\n   * Handle bleeding functions and function parameters.\n   */\n  private void handleFunctionInputs(Node fnNode) {\n    // Handle bleeding functions.\n    Node fnNameNode = fnNode.getFirstChild();\n    String fnName = fnNameNode.getString();\n    if (!fnName.isEmpty()) {\n      Scope.Var fnVar = scope.getVar(fnName);\n      if (fnVar == null ||\n          // Make sure we're not touching a native function. Native\n          // functions aren't bleeding, but may not have a declaration\n          // node.\n          (fnVar.getNameNode()!= null &&\n           // Make sure that the function is actually bleeding by checking\n           // if has already been declared.\n           fnVar.getInitialValue()!= fnNode)) {\n        defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n      }\n    }\n\n    declareArguments(fnNode);\n  }\n\n  /**\n   * Declares all of a function's arguments.\n   */\n  private void declareArguments(Node functionNode) {\n    Node astParameters = functionNode.getFirstChild().getNext();\n    Node body = astParameters.getNext();\n    FunctionType functionType = (FunctionType) functionNode.getJSType();\n    if (functionType!= null) {\n      Node jsDocParameters = functionType.getParametersNode();\n      if (jsDocParameters!= null) {\n        Node jsDocParameter = jsDocParameters.getFirstChild();\n        for (Node astParameter : astParameters.children()) {\n          JSType paramType = jsDocParameter == null?\n              unknownType : jsDocParameter.getJSType();\n          boolean inferred = paramType == null",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    c.accept(this);\n  }\n}\n\n  /**\n   * Handle bleeding functions and function parameters.\n   */\n  private void handleFunctionInputs(Node fnNode) {\n    // Handle bleeding functions.\n    Node fnNameNode = fnNode.getFirstChild();\n    String fnName = fnNameNode.getString();\n    if (!fnName.isEmpty()) {\n      Scope.Var fnVar = scope.getVar(fnName);\n      if (fnVar == null ||\n          // Make sure we're not touching a native function. Native\n          // functions aren't bleeding, but may not have a declaration\n          // node.\n          (fnVar.getNameNode()!= null &&\n           // Make sure that the function is actually bleeding by checking\n           // if has already been declared.\n           fnVar.getInitialValue()!= fnNode)) {\n        defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n      }\n    }\n\n    declareArguments(fnNode);\n  }\n\n  /**\n   * Declares all of a function's arguments.\n   */\n  private void declareArguments(Node functionNode) {\n    Node astParameters = functionNode.getFirstChild().getNext();\n    Node iifeArgumentNode = null;\n\n    if (NodeUtil.isCallOrNewTarget(functionNode)) {\n      iifeArgumentNode = NodeUtil.getArgumentForCallOrNew(functionNode);\n      if (iifeArgumentNode!= null) {\n        astParameters = iifeArgumentNode;\n      }\n    }\n\n    FunctionType functionType =\n        JSType.toMaybeFunctionType(functionNode.getJSType());\n    if (functionType!= null) {\n      Node jsDocParameters = functionType.getParametersNode();",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    c.accept(this);\n  }\n}\n\n  /**\n   * Handle bleeding functions and function parameters.\n   */\n  private void handleFunctionInputs(Node fnNode) {\n    // Handle bleeding functions.\n    Node fnNameNode = fnNode.getFirstChild();\n    String fnName = fnNameNode.getString();\n    if (!fnName.isEmpty()) {\n      Scope.Var fnVar = scope.getVar(fnName);\n      if (fnVar == null ||\n          // Make sure we're not touching a native function. Native\n          // functions aren't bleeding, but may not have a declaration\n          // node.\n          (fnVar.getNameNode()!= null &&\n           // Make sure that the function is actually bleeding by checking\n           // if has already been declared.\n           fnVar.getInitialValue()!= fnNode)) {\n        defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n      }\n    }\n\n    declareArguments(fnNode);\n  }\n\n  /**\n   * Declares all of a function's arguments.\n   */\n  private void declareArguments(Node functionNode) {\n    Node astParameters = functionNode.getFirstChild().getNext();\n    Node body = astParameters.getNext();\n    FunctionType functionType = (FunctionType) functionNode.getJSType();\n    if (functionType!= null) {\n      Node jsDocParameters = functionType.getParametersNode();\n      if (jsDocParameters!= null) {\n        Node jsDocParameter = jsDocParameters.getFirstChild();\n        for (Node astParameter : astParameters.children()) {\n          if (jsDocParameter!= null) {\n            defineSlot(astParameter, functionNode,\n                jsDocParameter.getJSType(), false);\n            js"
      ],
      "function range": "1443,5-1466,5"
    },
    "Closure_152_/src/com/google/javascript/rhino/jstype/FunctionType.java_871-872": {
      "loc": "871-872",
      "input": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);",
      "output": [
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}\n\n@Override\n<T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.al",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}\n\n@Override\n<T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}\n\n@Override\n<T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algeb",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}\n\n@Override\n<T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}\n\n@Override\n<T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}\n\n@Override\n<T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.alge",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}\n\n@Override\n<T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}\n\n@Override\n<T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluator;\nimport org.apache.hyracks.alge",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}\n\n@Override\n<T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.al",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}\n\n@Override\n<T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IS"
      ],
      "function range": "861,3-892,3"
    },
    "Closure_159_/src/com/google/javascript/jscomp/InlineFunctions.java_777-781": {
      "loc": "777-781",
      "input": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed != null);",
      "output": [
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n\n  if (NodeUtil.isFunctionDeclaration(node)) {\n    changed.add(node.getFirstChild().getString());\n  }\n\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n\n  if (NodeUtil.isFunctionDeclaration(node)) {\n    changed.add(node.getFirstChild().getString());\n  }\n\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n\n  if (NodeUtil.isFunctionDeclaration(node)) {\n    changed.add(node.getFirstChild().getString());\n  }\n\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluator;\nimport org.apache.hyracks.algebricks",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n\n  if (NodeUtil.isFunctionDeclaration(node)) {\n    changed.add(node.getFirstChild().getString());\n  }\n\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algeb",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n\n  if (NodeUtil.isFunctionDeclaration(node)) {\n    changed.add(node.getFirstChild().getString());\n  }\n\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalar",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n\n  if (NodeUtil.isFunctionDeclaration(node)) {\n    changed.add(node.getFirstChild().getString());\n  }\n\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n\n  if (NodeUtil.isFunctionDeclaration(node)) {\n    changed.add(node.getFirstChild().getString());\n  }\n\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n\n  if (NodeUtil.isFunctionDeclaration(node)) {\n    changed.add(node.getFirstChild().getString());\n  }\n\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n\n  if (NodeUtil.isFunctionDeclaration(node)) {\n    changed.add(node.getFirstChild().getString());\n  }\n\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarE",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n\n  if (NodeUtil.isFunctionDeclaration(node)) {\n    changed.add(node.getFirstChild().getString());\n  }\n\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluatorFactory;\nimport org.apache.hyracks.api.ex"
      ],
      "function range": "773,3-787,3"
    },
    "Closure_168_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1996-1997": {
      "loc": "1996-1997",
      "input": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild() != null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }",
      "output": [
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to test noop option.\n */\npublic class FromFtpNoopTest extends FtpServerTestSupport {\n\n    protected String getFtpUrl() {\n        return \"ftp://admin@localhost:\" + getPort() + \"/noop?password=admin&binary=false&noop=true\";\n    }\n\n    @Override\n    @BeforeEach\n    public void set",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to test noop option.\n */\npublic class FromFtpNoopTest extends FtpServerTestSupport {\n\n    private String getFtpUrl() {\n        return \"ftp://admin@localhost:\" + getPort() + \"/noop?password=admin&binary=false&noop=true\";\n    }\n\n    @Override\n    @BeforeEach\n    public void set",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to test noop option.\n */\npublic class FromFtpNoopTest extends FtpServerTestSupport {\n\n    protected String getFtpUrl() {\n        return \"ftp://admin@localhost:\" + getPort() + \"/noop?password=admin&binary=false&no",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to test noop option.\n */\npublic class FromFtpNoopTest extends FtpServerTestSupport {\n\n    protected String getFtpUrl() {\n        return \"ftp://admin@localhost:{{ftp.server.port}}/noop?password=admin&binary=false&noop=true\";\n    }\n\n    @Override\n    @BeforeEach\n    ",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to test noop option.\n */\npublic class FromFtpNoopTest extends FtpServerTestSupport {\n\n    protected String getFtpUrl() {\n        return \"ftp://admin@localhost:\" + getPort() + \"/noop?password=admin&binary=false&noop",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to test noop option.\n */\npublic class FromFtpNoopTest extends FtpServerTestSupport {\n\n    private String getFtpUrl() {\n        return \"ftp://admin@localhost:\" + getPort() + \"/noop?password=admin&binary=false&no",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to test noop option.\n */\npublic class FromFtpNoopTest extends FtpServerTestSupport {\n\n    private String getFtpUrl() {\n        return \"ftp://admin@localhost:{{ftp.server.port}}/noop?password=admin&binary=false&noop=true\";\n    }\n\n    @Override\n    @BeforeEach\n    ",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to test noop option.\n */\npublic class FromFtpNoopTest extends FtpServerTestSupport {\n\n    private String getFtpUrl() {\n        return \"ftp://admin@localhost:\" + getPort() + \"/noop?password=admin&binary=false&noop",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to test noop option.\n */\npublic class FromFtpNoopTest extends FtpServerTestSupport {\n\n    protected String getFtpUrl() {\n        return \"ftp://admin@localhost:\" + getPort() + \"?password=admin&binary=false&noop=true\";\n    }\n\n    @Override\n    @BeforeEach\n    public void setUp()",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  } else if (n.isThrow()) {\n    data.get(t.getScopeRoot()).recordThrow();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to test noop option.\n */\npublic class FromFtpNoopTest extends FtpServerTestSupport {\n\n    protected String getFtpUrl() {\n        return \"ftp://admin@localhost:\" + getPort() + \"/noop?password="
      ],
      "function range": "1987,5-2038,5"
    },
    "Codec_2_/src/java/org/apache/commons/codec/binary/Base64.java_446-447": {
      "loc": "446-447",
      "input": "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }",
      "output": [
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        if (lineLength > 0 && pos > 0) {\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n            pos += lineSeparator.length;\n        }\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus) % 3;\n            int b = in[inPos++];\n            if (b < 0) {\n                b += 256;\n            }\n            x = (x << 8) + b;\n            if (0 == modulus) {\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 12) & MASK_",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        return;\n    }\n    if (inAvail < encodeSize) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encode",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        return;\n    }\n    if (inAvail < encodeSize) {\n        eof = true;\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        if (lineLength > 0) {\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n            pos += lineSeparator.length;\n        }\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus) % 3;\n            int b = in[inPos++];\n            if (b < 0) {\n                b += 256;\n            }\n            x = (x << 8) + b;\n            if (0 == modulus) {\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        currentLinePos += modulus;\n        this.eof = true;\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus) % 3;\n            int b = in[inPos++];\n            if (b < 0) {\n                b += 256;\n            }\n            x = (x << 8) + b;\n            if (0 == modulus) {\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                buf[pos++]",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        if (lineLength > 0 && pos > lineLength) {\n            lineSeparator();\n        }\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus) % 3;\n            int b = in[inPos++];\n            if (b < 0) {\n                b += 256;\n            }\n            x = (x << 8) + b;\n            if (0 == modulus) {\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        if (lineLength > 0 && pos > 0) {\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n            pos += lineSeparator.length;\n        }\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus % 3) == 0? 0 : 3 - modulus % 3;\n            int b = in[inPos++];\n            if (b < 0) {\n                b += 256;\n            }\n            x = (x << 8) + b;\n            if (0 == modulus) {\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf[pos++] = encode",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        return;\n    }\n    if (inAvail < 3) {\n        eof = true;\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        if (lineLength > 0 && pos > 0) {\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n            pos += lineSeparator.length;\n        }\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus % 3) == 0? 0 : 3 - modulus;\n            int b = in[inPos++];\n            if (b < 0) {\n                b += 256;\n            }\n            x = (x << 8) + b;\n            if (0 == modulus) {\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf[pos++] = encodeTable[",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        return;\n    }\n    if (inAvail < encodeSize) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                encodeSize = encodeSize - 1;\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                encodeSize = encodeSize - 2;\n                break;\n        }\n        return;\n    }\n    int i = 0;\n    for (i = 0; i < inAvail; i++) {\n        x ="
      ],
      "function range": "414,5-473,5"
    },
    "Codec_4_/src/java/org/apache/commons/codec/binary/Base64.java_225-226": {
      "loc": "225-226",
      "input": "public Base64() {",
      "output": [
        "public Base64() {\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param s\n     *            A Base64 String to be decoded.\n     * @return A byte array that is the decoded Base64 value.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(String s) {\n        return decode(s.toCharArray());\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param in\n     *            A character array containing the Base64 encoded data.\n     * @return A byte array that is the decoded Base64 value.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(char[] in) {\n        return decode(in, 0, in.length);\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param in\n     *            A character array containing the Base64 encoded data.\n     * @param iOff\n     *            Offset of the first character in <code>in</code> to be\n     *            processed.\n     * @param iLen\n     *            Number of characters to process in <code>in</code>, starting\n     *            at <code>iOff</code>.\n     * @return A byte array that is the decoded Base64 value.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(char[] in, int iOff, int iLen) {\n        if (iLen % 4!= 0) {\n            throw new IllegalArgumentException(\n                    \"Length of Base64 encoded input string is not a multiple of 4.\");\n        }\n        while (",
        "public Base64() {\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param s\n     *            A Base64 String to be decoded.\n     * @return An array containing the decoded data bytes.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(String s) {\n        return decode(s.toCharArray());\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param in\n     *            A character array containing the Base64 encoded data.\n     * @return An array containing the decoded data bytes.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(char[] in) {\n        return decode(in, 0, in.length);\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param in\n     *            A character array containing the Base64 encoded data.\n     * @param iOff\n     *            Offset of the first character in <code>in</code> to be\n     *            processed.\n     * @param iLen\n     *            Number of characters to process in <code>in</code>, starting\n     *            at <code>iOff</code>.\n     * @return An array containing the decoded data bytes.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(char[] in, int iOff, int iLen) {\n        if (iLen % 4!= 0) {\n            throw new IllegalArgumentException(\n                    \"Length of Base64 encoded input string is not a multiple of 4.\");\n        }\n        while (iLen > 0 && in[iOff",
        "public Base64() {\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\r\n     * allowed within the Base64 encoded input data.\r\n     * \r\n     * @param s\r\n     *            A Base64 String to be decoded.\r\n     * @return A byte array containing the decoded data.\r\n     * @throws IllegalArgumentException\r\n     *             If the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        return decode(s.toCharArray());\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\r\n     * allowed within the Base64 encoded input data.\r\n     * \r\n     * @param in\r\n     *            A character array containing the Base64 encoded data.\r\n     * @return A byte array containing the decoded data.\r\n     * @throws IllegalArgumentException\r\n     *             If the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in) {\r\n        return decode(in, 0, in.length);\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\r\n     * allowed within the Base64 encoded input data.\r\n     * \r\n     * @param in\r\n     *            A character array containing the Base64 encoded data.\r\n     * @param iOff\r\n     *            Offset of the first character in <code>in</code> to be\r\n     *            processed.\r\n     * @param iLen\r\n     *            Number of characters to process in <code>in</code>, starting\r\n     *            at <code>iOff</code>.\r\n     * @return A byte array containing the decoded data.\r\n     * @throws IllegalArgumentException\r\n     *             If the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in, int iOff, int iLen) {\r\n        if (",
        "public Base64() {\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\r\n     * allowed within the Base64 encoded input data.\r\n     * \r\n     * @param s\r\n     *            A Base64 String to be decoded.\r\n     * @return An array containing the decoded data bytes.\r\n     * @throws IllegalArgumentException\r\n     *             If the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        return decode(s.toCharArray());\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\r\n     * allowed within the Base64 encoded input data.\r\n     * \r\n     * @param in\r\n     *            A character array containing the Base64 encoded data.\r\n     * @return An array containing the decoded data bytes.\r\n     * @throws IllegalArgumentException\r\n     *             If the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in) {\r\n        return decode(in, 0, in.length);\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\r\n     * allowed within the Base64 encoded input data.\r\n     * \r\n     * @param in\r\n     *            A character array containing the Base64 encoded data.\r\n     * @param iOff\r\n     *            Offset of the first character in <code>in</code> to be\r\n     *            processed.\r\n     * @param iLen\r\n     *            Number of characters to process in <code>in</code>, starting\r\n     *            at <code>iOff</code>.\r\n     * @return An array containing the decoded data bytes.\r\n     * @throws IllegalArgumentException\r\n     *             If the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in, int iOff, int iLen) {\r\n        if (",
        "public Base64() {\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param s\n     *            A Base64 String to be decoded.\n     * @return A byte array that is the decoded Base64 value.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(String s) {\n        return decode(s.toCharArray());\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param in\n     *            A character array containing the Base64 encoded data.\n     * @return A byte array that is the decoded Base64 value.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(char[] in) {\n        return decode(in, 0, in.length);\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param in\n     *            A character array containing the Base64 encoded data.\n     * @param iOff\n     *            Offset of the first character in <code>in</code> to be\n     *            processed.\n     * @param iLen\n     *            Number of characters to process in <code>in</code>, starting\n     *            at <code>iOff</code>.\n     * @return A byte array that is the decoded Base64 value.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(char[] in, int iOff, int iLen) {\n        if (iLen % 4!= 0)\n            throw new IllegalArgumentException(\n                    \"Length of Base64 encoded input string is not a multiple of 4.\");\n        while (iLen > 0",
        "public Base64() {\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param s\n     *            A Base64 String to be decoded.\n     * @return A byte array that is the decoded Base64 value.\n     * @throws IllegalArgumentException\n     *             if the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(String s) {\n        return decode(s.toCharArray());\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param in\n     *            A character array containing the Base64 encoded data.\n     * @return A byte array that is the decoded Base64 value.\n     * @throws IllegalArgumentException\n     *             if the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(char[] in) {\n        return decode(in, 0, in.length);\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param in\n     *            A character array containing the Base64 encoded data.\n     * @param iOff\n     *            Offset of the first character in <code>in</code> to be\n     *            processed.\n     * @param iLen\n     *            Number of characters to process in <code>in</code>, starting\n     *            at <code>iOff</code>.\n     * @return A byte array that is the decoded Base64 value.\n     * @throws IllegalArgumentException\n     *             if the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(char[] in, int iOff, int iLen) {\n        if (iLen % 4!= 0) {\n            throw new IllegalArgumentException(\n                    \"Length of Base64 encoded input string is not a multiple of 4.\");\n        }\n        while (",
        "public Base64() {\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param s\n     *            A Base64 String to be decoded.\n     * @return An array containing the decoded data bytes.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(String s) {\n        return decode(s.toCharArray());\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param in\n     *            A character array containing the Base64 encoded data.\n     * @return An array containing the decoded data bytes.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(char[] in) {\n        return decode(in, 0, in.length);\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param in\n     *            A character array containing the Base64 encoded data.\n     * @param iOff\n     *            Offset of the first character in <code>in</code> to be\n     *            processed.\n     * @param iLen\n     *            Number of characters to process in <code>in</code>, starting\n     *            at <code>iOff</code>.\n     * @return An array containing the decoded data bytes.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(char[] in, int iOff, int iLen) {\n        if (iLen % 4!= 0)\n            throw new IllegalArgumentException(\n                    \"Length of Base64 encoded input string is not a multiple of 4.\");\n        while (iLen > 0 && in[iOff + iLen -",
        "public Base64() {\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     *\n     * @param s A Base64 String to be decoded.\n     * @return An array containing the decoded data bytes.\n     * @throws IllegalArgumentException If the input is not valid Base64 encoded\n     *                                  data.\n     */\n    public static byte[] decode(String s) {\n        return decode(s.toCharArray());\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     *\n     * @param in A character array containing the Base64 encoded data.\n     * @return An array containing the decoded data bytes.\n     * @throws IllegalArgumentException If the input is not valid Base64 encoded\n     *                                  data.\n     */\n    public static byte[] decode(char[] in) {\n        return decode(in, 0, in.length);\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     *\n     * @param in   A character array containing the Base64 encoded data.\n     * @param iOff Offset of the first character in <code>in</code> to be\n     *             processed.\n     * @param iLen Number of characters to process in <code>in</code>, starting\n     *             at <code>iOff</code>.\n     * @return An array containing the decoded data bytes.\n     * @throws IllegalArgumentException If the input is not valid Base64 encoded\n     *                                  data.\n     */\n    public static byte[] decode(char[] in, int iOff, int iLen) {\n        if (iLen % 4!= 0) {\n            throw new IllegalArgumentException(\n                    \"Length of Base64 encoded input string is not a multiple of 4.\");\n        }\n        while (iLen > 0 && in[iOff + iLen - 1] == '=') {\n            iLen",
        "public Base64() {\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param s\n     *            A Base64 String to be decoded.\n     * @return A byte array that is the decoded Base64 value.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(String s) {\n        return decode(s.toCharArray());\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param in\n     *            A character array containing the Base64 encoded data.\n     * @return A byte array that is the decoded Base64 value.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(char[] in) {\n        return decode(in, 0, in.length);\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are\n     * allowed within the Base64 encoded input data.\n     * \n     * @param in\n     *            A character array containing the Base64 encoded data.\n     * @param iOff\n     *            Offset of the first character in <code>in</code> to be\n     *            processed.\n     * @param iLen\n     *            Number of characters to process in <code>in</code>, starting\n     *            at <code>iOff</code>.\n     * @return A byte array that is the decoded Base64 value.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(char[] in, int iOff, int iLen) {\n        if (iLen % 4!= 0) {\n            throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\n        }\n        while (iLen >",
        "public Base64() {\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are allowed within the Base64\n     * encoded input data.\n     * \n     * @param s\n     *            A Base64 String to be decoded.\n     * @return A byte array that is the decoded Base64 value.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(String s) {\n        return decode(s.toCharArray());\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are allowed within the Base64\n     * encoded input data.\n     * \n     * @param in\n     *            A character array containing the Base64 encoded data.\n     * @return A byte array that is the decoded Base64 value.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(char[] in) {\n        return decode(in, 0, in.length);\n    }\n\n    /**\n     * Decodes a byte array from Base64 format. No blanks or line breaks are allowed within the Base64\n     * encoded input data.\n     * \n     * @param in\n     *            A character array containing the Base64 encoded data.\n     * @param iOff\n     *            Offset of the first character in <code>in</code> to be processed.\n     * @param iLen\n     *            Number of characters to process in <code>in</code>, starting at <code>iOff</code>.\n     * @return A byte array that is the decoded Base64 value.\n     * @throws IllegalArgumentException\n     *             If the input is not valid Base64 encoded data.\n     */\n    public static byte[] decode(char[] in, int iOff, int iLen) {\n        if (iLen % 4!= 0) {\n            throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\n        }\n        while (iLen > 0 && in[iOff + iLen"
      ],
      "function range": "224,5-226,5"
    },
    "Codec_7_/src/java/org/apache/commons/codec/binary/Base64.java_670-671": {
      "loc": "670-671",
      "input": "public static String encodeBase64String(byte[] binaryData) {",
      "output": [
        "public static String encodeBase64String(byte[] binaryData) {\n        int iLen = binaryData.length;\n        int oDataLen = (iLen * 4 + 2) / 3; // output length without padding\n        int oLen = ((iLen + 2) / 3) * 4; // output length including padding\n        char[] out = new char[oLen];\n        int ip = 0;\n        int op = 0;\n        while (ip < iLen) {\n            int i0 = binaryData[ip++] & 0xff;\n            int i1 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int i2 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int o0 = i0 >>> 2;\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\n            int o3 = i2 & 0x3F;\n            out[op++] = BASE64_CHARS[o0];\n            out[op++] = BASE64_CHARS[o1];\n            out[op] = op < oDataLen? BASE64_CHARS[o2] : '=';\n            op++;\n            out[op] = op < oDataLen? BASE64_CHARS[o3] : '=';\n            op++;\n        }\n        return new String(out);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDIT",
        "public static String encodeBase64String(byte[] binaryData) {\n        int iLen = binaryData.length;\n        int oDataLen = (iLen * 4 + 2) / 3; // output length without padding\n        int oLen = ((iLen + 2) / 3) * 4; // output length including padding\n        char[] out = new char[oLen];\n        int ip = 0;\n        int op = 0;\n        while (ip < iLen) {\n            int i0 = binaryData[ip++] & 0xff;\n            int i1 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int i2 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int o0 = i0 >>> 2;\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\n            int o3 = i2 & 0x3F;\n            out[op++] = BASE64_CHARS[o0];\n            out[op++] = BASE64_CHARS[o1];\n            out[op] = op < oDataLen? BASE64_CHARS[o2] : '=';\n            op++;\n            out[op] = op < oDataLen? BASE64_CHARS[o3] : '=';\n            op++;\n        }\n        return new String(out);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES",
        "public static String encodeBase64String(byte[] binaryData) {\n        int iLen = binaryData.length;\n        int oDataLen = (iLen * 4 + 2) / 3; // output length without padding\n        int oLen = ((iLen + 2) / 3) * 4; // output length including padding\n        char[] out = new char[oLen];\n        int ip = 0;\n        int op = 0;\n        while (ip < iLen) {\n            int i0 = binaryData[ip++] & 0xff;\n            int i1 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int i2 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int o0 = i0 >>> 2;\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\n            int o3 = i2 & 0x3F;\n            out[op++] = BASE64_CHARS[o0];\n            out[op++] = BASE64_CHARS[o1];\n            out[op] = op < oDataLen? BASE64_CHARS[o2] : '=';\n            op++;\n            out[op] = op < oDataLen? BASE64_CHARS[o3] : '=';\n            op++;\n        }\n        return new String(out);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDIT",
        "public static String encodeBase64String(byte[] binaryData) {\n        int iLen = binaryData.length;\n        int oDataLen = (iLen * 4 + 2) / 3; // output length without padding\n        int oLen = ((iLen + 2) / 3) * 4; // output length including padding\n        char[] out = new char[oLen];\n        int ip = 0;\n        int op = 0;\n        while (ip < iLen) {\n            int i0 = binaryData[ip++] & 0xff;\n            int i1 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int i2 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int o0 = i0 >>> 2;\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\n            int o3 = i2 & 0x3F;\n            out[op++] = BASE64_CHARS[o0];\n            out[op++] = BASE64_CHARS[o1];\n            out[op] = op < oDataLen? BASE64_CHARS[o2] : '=';\n            op++;\n            out[op] = op < oDataLen? BASE64_CHARS[o3] : '=';\n            op++;\n        }\n        return new String(out);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES",
        "public static String encodeBase64String(byte[] binaryData) {\n        int iLen = binaryData.length;\n        int oDataLen = (iLen * 4 + 2) / 3; // output length without padding\n        int oLen = ((iLen + 2) / 3) * 4; // output length including padding\n        char[] out = new char[oLen];\n        int ip = 0;\n        int op = 0;\n        while (ip < iLen) {\n            int i0 = binaryData[ip++] & 0xff;\n            int i1 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int i2 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int o0 = i0 >>> 2;\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\n            int o3 = i2 & 0x3F;\n            out[op++] = BASE64_CHARS[o0];\n            out[op++] = BASE64_CHARS[o1];\n            out[op] = op < oDataLen? BASE64_CHARS[o2] : '=';\n            op++;\n            out[op] = op < oDataLen? BASE64_CHARS[o3] : '=';\n            op++;\n        }\n        return new String(out);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDIT",
        "public static String encodeBase64String(byte[] binaryData) {\n        int iLen = binaryData.length;\n        int oDataLen = (iLen * 4 + 2) / 3; // output length without padding\n        int oLen = ((iLen + 2) / 3) * 4; // output length including padding\n        char[] out = new char[oLen];\n        int ip = 0;\n        int op = 0;\n        while (ip < iLen) {\n            int i0 = binaryData[ip++] & 0xff;\n            int i1 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int i2 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int o0 = i0 >>> 2;\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\n            int o3 = i2 & 0x3F;\n            out[op++] = BASE64_CHARS[o0];\n            out[op++] = BASE64_CHARS[o1];\n            out[op] = op < oDataLen? BASE64_CHARS[o2] : '=';\n            op++;\n            out[op] = op < oDataLen? BASE64_CHARS[o3] : '=';\n            op++;\n        }\n        return new String(out);\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return decodeBase64(base64String.toCharArray());\n    }\n\n    public static byte[] decodeBase64(char[] base64Data) {\n        int iLen = base64Data.length;\n        if (iLen % 4!= 0) {\n            throw new IllegalArgumentException(\n                    \"Length of Base64 encoded input string is not a multiple of 4.\");\n        }\n        while (iLen > 0 && base64Data[iLen - 1] == '=') {\n            iLen--;\n        }\n        int oLen = (iLen * 3) / 4;\n        byte[] out = new byte[oLen];\n",
        "public static String encodeBase64String(byte[] binaryData) {\n        int iLen = binaryData.length;\n        int oDataLen = (iLen * 4 + 2) / 3; // output length without padding\n        int oLen = ((iLen + 2) / 3) * 4; // output length including padding\n        char[] out = new char[oLen];\n        int ip = 0;\n        int op = 0;\n        while (ip < iLen) {\n            int i0 = binaryData[ip++] & 0xff;\n            int i1 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int i2 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int o0 = i0 >>> 2;\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\n            int o3 = i2 & 0x3F;\n            out[op++] = BASE64_CHARS[o0];\n            out[op++] = BASE64_CHARS[o1];\n            out[op] = op < oDataLen? BASE64_CHARS[o2] : '=';\n            op++;\n            out[op] = op < oDataLen? BASE64_CHARS[o3] : '=';\n            op++;\n        }\n        return new String(out);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR",
        "public static String encodeBase64String(byte[] binaryData) {\n        int iLen = binaryData.length;\n        int oDataLen = (iLen * 4 + 2) / 3; // output length without padding\n        int oLen = ((iLen + 2) / 3) * 4; // output length including padding\n        char[] out = new char[oLen];\n        int ip = 0;\n        int op = 0;\n        while (ip < iLen) {\n            int i0 = binaryData[ip++] & 0xff;\n            int i1 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int i2 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int o0 = i0 >>> 2;\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\n            int o3 = i2 & 0x3F;\n            out[op++] = BASE64_CHARS[o0];\n            out[op++] = BASE64_CHARS[o1];\n            out[op] = op < oDataLen? BASE64_CHARS[o2] : '=';\n            op++;\n            out[op] = op < oDataLen? BASE64_CHARS[o3] : '=';\n            op++;\n        }\n        return new String(out);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT",
        "public static String encodeBase64String(byte[] binaryData) {\n        int iLen = binaryData.length;\n        int oDataLen = (iLen * 4 + 2) / 3; // output length without padding\n        int oLen = ((iLen + 2) / 3) * 4; // output length including padding\n        char[] out = new char[oLen];\n        int ip = 0;\n        int op = 0;\n        while (ip < iLen) {\n            int i0 = binaryData[ip++] & 0xff;\n            int i1 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int i2 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int o0 = i0 >>> 2;\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\n            int o3 = i2 & 0x3F;\n            out[op++] = BASE64_CHARS[o0];\n            out[op++] = BASE64_CHARS[o1];\n            out[op] = op < oDataLen? BASE64_CHARS[o2] : '=';\n            op++;\n            out[op] = op < oDataLen? BASE64_CHARS[o3] : '=';\n            op++;\n        }\n        return new String(out);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR",
        "public static String encodeBase64String(byte[] binaryData) {\n        int iLen = binaryData.length;\n        int oDataLen = (iLen * 4 + 2) / 3; // output length without padding\n        int oLen = ((iLen + 2) / 3) * 4; // output length including padding\n        char[] out = new char[oLen];\n        int ip = 0;\n        int op = 0;\n        while (ip < iLen) {\n            int i0 = binaryData[ip++] & 0xff;\n            int i1 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int i2 = ip < iLen? binaryData[ip++] & 0xff : 0;\n            int o0 = i0 >>> 2;\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\n            int o3 = i2 & 0x3F;\n            out[op++] = BASE64_CHARS[o0];\n            out[op++] = BASE64_CHARS[o1];\n            out[op] = op < oDataLen? BASE64_CHARS[o2] : '=';\n            op++;\n            out[op] = op < oDataLen? BASE64_CHARS[o3] : '=';\n            op++;\n        }\n        return new String(out);\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return decodeBase64(base64String.toCharArray());\n    }\n\n    public static byte[] decodeBase64(char[] base64Chars) {\n        int iLen = base64Chars.length;\n        if (iLen % 4!= 0) {\n            throw new IllegalArgumentException(\n                    \"Length of Base64 encoded input string is not a multiple of 4.\");\n        }\n        while (iLen > 0 && base64Chars[iLen - 1] == '=') {\n            iLen--;\n        }\n        int oLen = (iLen * 3) / 4;\n        byte[] out = new byte[o"
      ],
      "function range": "669,5-671,5"
    },
    "Codec_9_/src/java/org/apache/commons/codec/binary/Base64.java_827-828": {
      "loc": "827-828",
      "input": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }",
      "output": [
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    long len = b64.getEncodedLength(binaryData);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maximum size of \" +\n                maxResultSize);\n    }\n    return b64.encode(binaryData);\n}\n\n/**\n * Decodes a Base64 String into octets\n *\n * @param base64String\n *            String containing Base64 data\n * @return Array containing decoded data.\n * @since 1.4\n */\npublic static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n}\n\n/**\n * Decodes Base64 data into octets\n *\n * @param base64Data\n *            Byte array containing Base64 data\n * @return Array containing decoded data.\n */\npublic static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n}\n\n/**\n * Discards any whitespace from a base-64 encoded block.\n *\n * @param data\n *            The base-64 encoded data to discard the whitespace from.\n * @return The data, less whitespace (see RFC 2045).\n */\nstatic byte[] discardWhitespace(byte[] data) {\n    byte groomedData[] = new byte[data.length];\n    int bytesCopied = 0;\n\n    for (int i = 0; i < data.length; i++) {\n        switch (data[i]) {\n        case (byte)'' :\n        case (byte) '\\n' :\n        case (byte) '\\r' :\n        case (byte) '\\t' :\n            break;\n        default:\n            g",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    long len = b64.getEncodedLength(binaryData);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n    }\n    return b64.encode(binaryData);\n}\n\n/**\n * Decodes a Base64 String into octets\n *\n * @param base64String\n *            String containing Base64 data\n * @return Array containing decoded data.\n * @since 1.4\n */\npublic static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n}\n\n/**\n * Decodes Base64 data into octets\n *\n * @param base64Data\n *            Byte array containing Base64 data\n * @return Array containing decoded data.\n */\npublic static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n}\n\n/**\n * Discards any whitespace from a base-64 encoded block.\n *\n * @param data\n *            The base-64 encoded data to discard the whitespace from.\n * @return The data, less whitespace (see RFC 2045).\n */\nstatic byte[] discardWhitespace(byte[] data) {\n    byte groomedData[] = new byte[data.length];\n    int bytesCopied = 0;\n\n    for (int i = 0; i < data.length; i++) {\n        switch (data[i]) {\n        case (byte)'' :\n        case (byte) '\\n' :\n        case (byte) '\\r' :\n        case (byte) '\\t' :\n            break;\n        default:\n            ",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    long len = b64.getEncodedLength(binaryData);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len +\n            \") than the specified maximum size of \" +\n            maxResultSize);\n    }\n    return b64.encode(binaryData);\n}\n\n/**\n * Decodes a Base64 String into octets\n *\n * @param base64String\n *            String containing Base64 data\n * @return Array containing decoded data.\n * @since 1.4\n */\npublic static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n}\n\n/**\n * Decodes Base64 data into octets\n *\n * @param base64Data\n *            Byte array containing Base64 data\n * @return Array containing decoded data.\n */\npublic static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n}\n\n/**\n * Discards any whitespace from a base-64 encoded block.\n *\n * @param data\n *            The base-64 encoded data to discard the whitespace from.\n * @return The data, less whitespace (see RFC 2045).\n */\nstatic byte[] discardWhitespace(byte[] data) {\n    byte groomedData[] = new byte[data.length];\n    int bytesCopied = 0;\n\n    for (int i = 0; i < data.length; i++) {\n        switch (data[i]) {\n        case (byte)'' :\n        case (byte) '\\n' :\n        case (byte) '\\r' :\n        case (byte) '\\t' :\n            break;\n        default:\n            g",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    long len = b64.getEncodedLength(binaryData);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len +\n            \") than the specified maxium size of \" +\n            maxResultSize);\n    }\n    return b64.encode(binaryData);\n}\n\n/**\n * Decodes a Base64 String into octets\n *\n * @param base64String\n *            String containing Base64 data\n * @return Array containing decoded data.\n * @since 1.4\n */\npublic static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n}\n\n/**\n * Decodes Base64 data into octets\n *\n * @param base64Data\n *            Byte array containing Base64 data\n * @return Array containing decoded data.\n */\npublic static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n}\n\n/**\n * Discards any whitespace from a base-64 encoded block.\n *\n * @param data\n *            The base-64 encoded data to discard the whitespace from.\n * @return The data, less whitespace (see RFC 2045).\n */\nstatic byte[] discardWhitespace(byte[] data) {\n    byte groomedData[] = new byte[data.length];\n    int bytesCopied = 0;\n\n    for (int i = 0; i < data.length; i++) {\n        switch (data[i]) {\n        case (byte)'' :\n        case (byte) '\\n' :\n        case (byte) '\\r' :\n        case (byte) '\\t' :\n            break;\n        default:\n            ",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    long len = b64.getEncodedLength(binaryData);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maximum size of \" +\n                maxResultSize);\n    }\n    return b64.encode(binaryData);\n}\n\n/**\n * Decodes a Base64 String into octets\n *\n * @param base64String\n *            String containing Base64 data\n * @return Array containing decoded data.\n * @since 1.4\n */\npublic static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n}\n\n/**\n * Decodes Base64 data into octets\n *\n * @param base64Data\n *            Byte array containing Base64 data\n * @return Array containing decoded data.\n */\npublic static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n}\n\n/**\n * Discards any whitespace from a base-64 encoded block.\n *\n * @param data\n *            The base-64 encoded data to discard the whitespace from.\n * @return The data, less whitespace (see RFC 2045).\n */\nstatic byte[] discardWhitespace(byte[] data) {\n    byte groomedData[] = new byte[data.length];\n    int bytesCopied = 0;\n\n    for (int i = 0; i < data.length; i++) {\n        switch (data[i]) {\n        case'' :\n        case '\\n' :\n        case '\\r' :\n        case '\\t' :\n            break;\n        default :\n            groomedData[bytesCopied++] = data[",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    long len = b64.getEncodedLength(binaryData);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maximum size of \" +\n                maxResultSize);\n    }\n    return b64.encode(binaryData);\n}\n\n/**\n * Decodes a Base64 String into octets\n *\n * @param base64String\n *            String containing Base64 data\n * @return Array containing decoded data.\n * @since 1.4\n */\npublic static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n}\n\n/**\n * Decodes Base64 data into octets\n *\n * @param base64Data\n *            Byte array containing Base64 data\n * @return Array containing decoded data.\n */\npublic static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n}\n\n/**\n * Discards any whitespace from a base-64 encoded block.\n *\n * @param data\n *            The base-64 encoded data to discard the whitespace from.\n * @return The data, less whitespace (see RFC 2045).\n */\nstatic byte[] discardWhitespace(byte[] data) {\n    byte groomedData[] = new byte[data.length];\n    int bytesCopied = 0;\n\n    for (int i = 0; i < data.length; i++) {\n        switch (data[i]) {\n            case (byte)'' :\n            case (byte) '\\n' :\n            case (byte) '\\r' :\n            case (byte) '\\t' :\n                break;\n            default:\n                g",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    long len = b64.getEncodedLength(binaryData);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maximum size of \" +\n                maxResultSize);\n    }\n    return b64.encode(binaryData);\n}\n\n/**\n * Decodes a Base64 String into octets\n *\n * @param base64String\n *            String containing Base64 data\n * @return Array containing decoded data.\n * @since 1.4\n */\npublic static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n}\n\n/**\n * Decodes Base64 data into octets\n *\n * @param base64Data\n *            Byte array containing Base64 data\n * @return Array containing decoded data.\n */\npublic static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n}\n\n/**\n * Discards any whitespace from a base-64 encoded block.\n *\n * @param data\n *            The base-64 encoded data to discard the whitespace from.\n * @return The data, less whitespace (see RFC 2045).\n */\nstatic byte[] discardWhitespace(byte[] data) {\n    byte groomedData[] = new byte[data.length];\n    int bytesCopied = 0;\n\n    for (int i = 0; i < data.length; i++) {\n        switch (data[i]) {\n            case'' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                break;\n            default :\n                groomedData[bytesCopied++] = data[",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    long len = b64.getEncodedLength(binaryData);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n    }\n    return b64.encode(binaryData);\n}\n\n/**\n * Decodes a Base64 String into octets\n *\n * @param base64String\n *            String containing Base64 data\n * @return Array containing decoded data.\n * @since 1.4\n */\npublic static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n}\n\n/**\n * Decodes Base64 data into octets\n *\n * @param base64Data\n *            Byte array containing Base64 data\n * @return Array containing decoded data.\n */\npublic static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n}\n\n/**\n * Discards any whitespace from a base-64 encoded block.\n *\n * @param data\n *            The base-64 encoded data to discard the whitespace from.\n * @return The data, less whitespace (see RFC 2045).\n */\nstatic byte[] discardWhitespace(byte[] data) {\n    byte groomedData[] = new byte[data.length];\n    int bytesCopied = 0;\n\n    for (int i = 0; i < data.length; i++) {\n        switch (data[i]) {\n        case'' :\n        case '\\n' :\n        case '\\r' :\n        case '\\t' :\n            break;\n        default :\n            groomedData[bytesCopied++] = data",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    long len = b64.getEncodedLength(binaryData);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n    }\n    return b64.encode(binaryData);\n}\n\n/**\n * Decodes a Base64 String into octets\n *\n * @param base64String\n *            String containing Base64 data\n * @return Array containing decoded data.\n * @since 1.4\n */\npublic static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n}\n\n/**\n * Decodes Base64 data into octets\n *\n * @param base64Data\n *            Byte array containing Base64 data\n * @return Array containing decoded data.\n */\npublic static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n}\n\n/**\n * Discards any whitespace from a base-64 encoded block.\n *\n * @param data\n *            The base-64 encoded data to discard the whitespace from.\n * @return The data, less whitespace (see RFC 2045).\n */\nstatic byte[] discardWhitespace(byte[] data) {\n    byte groomedData[] = new byte[data.length];\n    int bytesCopied = 0;\n\n    for (int i = 0; i < data.length; i++) {\n        switch (data[i]) {\n            case (byte)'' :\n            case (byte) '\\n' :\n            case (byte) '\\r' :\n            case (byte) '\\t' :\n                break;\n            default:\n                ",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    long len = b64.getEncodedLength(binaryData);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maximum size of \" +\n                maxResultSize);\n    }\n    return b64.encode(binaryData);\n}\n\n/**\n * Decodes a Base64 String into octets\n *\n * @param base64String\n *            String containing Base64 data\n * @return Array containing decoded data.\n * @since 1.4\n */\npublic static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n}\n\n/**\n * Decodes Base64 data into octets\n *\n * @param base64Data\n *            Byte array containing Base64 data\n * @return Array containing decoded data.\n */\npublic static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n}\n\n/**\n * Discards any whitespace from a base-64 encoded block.\n *\n * @param data\n *            The base-64 encoded data to discard the whitespace from.\n * @return The data, less whitespace (see RFC 2045).\n */\nstatic byte[] discardWhitespace(byte[] data) {\n    byte groomedData[] = new byte[data.length];\n    int bytesCopied = 0;\n\n    for (int i = 0; i < data.length; i++) {\n        switch (data[i]) {\n            case (byte)'' :\n            case (byte) '\\n' :\n            case (byte) '\\r' :\n            case (byte) '\\t' :\n                    break;\n            default:\n                    g"
      ],
      "function range": "822,5-837,5"
    },
    "Codec_10_/src/java/org/apache/commons/codec/language/Caverphone.java_76-77": {
      "loc": "76-77",
      "input": "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");",
      "output": [
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^rn\", \"2r\");\n    txt = txt.replaceAll(\"^wn\", \"2w\");\n    txt = txt.replaceAll(\"^th\", \"2th\");\n    txt = txt.replaceAll(\"^gh\", \"2g\");\n    txt = txt.replaceAll(\"^ph\", \"2f\");\n    txt = txt.replaceAll(\"^sh\", \"2sh\");\n    txt = txt.replaceAll(\"^ch\", \"2ch\");\n    txt = txt.replaceAll(\"^ss\", \"2ss\");\n    txt = txt.replaceAll(\"^x\", \"2x\");\n    txt = txt.replaceAll(\"^m\", \"2m\");\n    txt = txt.replaceAll(\"^l\", \"2l\");\n    txt = txt.replaceAll(\"^s\", \"2s\");\n    txt = txt.replaceAll(\"^z\", \"2z\");\n    txt = txt.replaceAll(\"^v\", \"2v\");\n    txt = txt.replaceAll(\"^k\", \"2k\");\n    txt = txt.replaceAll(\"^j\", \"2j\");\n    txt = txt.replaceAll(\"^q\", \"2q\");\n    txt = txt.replaceAll(\"",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^rn\", \"2r\");\n    txt = txt.replaceAll(\"^wn\", \"2w\");\n    txt = txt.replaceAll(\"^th\", \"2th\");\n    txt = txt.replaceAll(\"^gh\", \"2g\");\n    txt = txt.replaceAll(\"^ph\", \"2f\");\n    txt = txt.replaceAll(\"^sh\", \"2sh\");\n    txt = txt.replaceAll(\"^ch\", \"2ch\");\n    txt = txt.replaceAll(\"^ss\", \"2ss\");\n    txt = txt.replaceAll(\"^x\", \"2x\");\n    txt = txt.replaceAll(\"^m\", \"2m\");\n    txt = txt.replaceAll(\"^l\", \"2l\");\n    txt = txt.replaceAll(\"^s\", \"2s\");\n    txt = txt.replaceAll(\"^z\", \"2z\");\n    txt = txt.replaceAll(\"^i\", \"2i\");\n    txt = txt.replaceAll(\"^o\", \"2o\");\n    txt = txt.replaceAll(\"^u\", \"2u\");\n    txt = txt.replaceAll(\"^v\", \"2v\");\n    txt = txt.replaceAll(\"",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");  \n    txt = txt.replaceAll(\"^rn\", \"2r\");  \n    txt = txt.replaceAll(\"^wn\", \"2w\");  \n    txt = txt.replaceAll(\"^th\", \"2th\");  \n    txt = txt.replaceAll(\"^gh\", \"2g\");  \n    txt = txt.replaceAll(\"^ph\", \"2f\");  \n    txt = txt.replaceAll(\"^sh\", \"2sh\");  \n    txt = txt.replaceAll(\"^ch\", \"2ch\");  \n    txt = txt.replaceAll(\"^ss\", \"2ss\");  \n    txt = txt.replaceAll(\"^x\", \"2x\");  \n    txt = txt.replaceAll(\"^m\", \"2m\");  \n    txt = txt.replaceAll(\"^l\", \"2l\");  \n    txt = txt.replaceAll(\"^s\", \"2s\");  \n    txt = txt.replaceAll(\"^z\", \"2z\");  \n    txt = txt.replaceAll(\"^j\", \"2j\");  \n    txt = txt.replaceAll(\"^q\", \"2q\");  \n    txt = txt.replaceAll(\"^v\", \"2v\");  \n    txt = txt.replaceAll(\"",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^rn\", \"2r\");\n    txt = txt.replaceAll(\"^wn\", \"2w\");\n    txt = txt.replaceAll(\"^th\", \"2th\");\n    txt = txt.replaceAll(\"^gh\", \"2g\");\n    txt = txt.replaceAll(\"^ph\", \"2f\");\n    txt = txt.replaceAll(\"^sh\", \"2sh\");\n    txt = txt.replaceAll(\"^ch\", \"2ch\");\n    txt = txt.replaceAll(\"^ss\", \"2ss\");\n    txt = txt.replaceAll(\"^x\", \"2x\");\n    txt = txt.replaceAll(\"^m\", \"2m\");\n    txt = txt.replaceAll(\"^l\", \"2l\");\n    txt = txt.replaceAll(\"^s\", \"2s\");\n    txt = txt.replaceAll(\"^z\", \"2z\");\n    txt = txt.replaceAll(\"^j\", \"2j\");\n    txt = txt.replaceAll(\"^q\", \"2q\");\n    txt = txt.replaceAll(\"^v\", \"2v\");\n    txt = txt.replaceAll(\"^k\", \"2k\");\n    txt = txt.replaceAll(\"",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^rn\", \"2r\");\n    txt = txt.replaceAll(\"^wn\", \"2w\");\n    txt = txt.replaceAll(\"^th\", \"2th\");\n    txt = txt.replaceAll(\"^gh\", \"2g\");\n    txt = txt.replaceAll(\"^ph\", \"2f\");\n    txt = txt.replaceAll(\"^sh\", \"2sh\");\n    txt = txt.replaceAll(\"^ch\", \"2ch\");\n    txt = txt.replaceAll(\"^ss\", \"2ss\");\n    txt = txt.replaceAll(\"^x\", \"2x\");\n    txt = txt.replaceAll(\"^m\", \"2m\");\n    txt = txt.replaceAll(\"^l\", \"2l\");\n    txt = txt.replaceAll(\"^s\", \"2s\");\n    txt = txt.replaceAll(\"^z\", \"2z\");\n    txt = txt.replaceAll(\"^j\", \"2j\");\n    txt = txt.replaceAll(\"^q\", \"2q\");\n    txt = txt.replaceAll(\"^k\", \"2k\");\n    txt = txt.replaceAll(\"^h\", \"2h\");\n    txt = txt.replaceAll(\"",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^rn\", \"2r\");\n    txt = txt.replaceAll(\"^wn\", \"2w\");\n    txt = txt.replaceAll(\"^th\", \"2th\");\n    txt = txt.replaceAll(\"^gh\", \"2g\");\n    txt = txt.replaceAll(\"^ph\", \"2f\");\n    txt = txt.replaceAll(\"^sh\", \"2sh\");\n    txt = txt.replaceAll(\"^ch\", \"2ch\");\n    txt = txt.replaceAll(\"^ss\", \"2ss\");\n    txt = txt.replaceAll(\"^x\", \"2x\");\n    txt = txt.replaceAll(\"^m\", \"2m\");\n    txt = txt.replaceAll(\"^l\", \"2l\");\n    txt = txt.replaceAll(\"^s\", \"2s\");\n    txt = txt.replaceAll(\"^z\", \"2z\");\n    txt = txt.replaceAll(\"^j\", \"2j\");\n    txt = txt.replaceAll(\"^y\", \"2y\");\n    txt = txt.replaceAll(\"^k\", \"2k\");\n    txt = txt.replaceAll(\"^h\", \"2h\");\n    txt = txt.replaceAll(\"",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");  \n    txt = txt.replaceAll(\"^rn\", \"2r\");  \n    txt = txt.replaceAll(\"^wn\", \"2w\");  \n    txt = txt.replaceAll(\"^th\", \"2th\");  \n    txt = txt.replaceAll(\"^gh\", \"2g\");  \n    txt = txt.replaceAll(\"^ph\", \"2f\");  \n    txt = txt.replaceAll(\"^sh\", \"2sh\");  \n    txt = txt.replaceAll(\"^ch\", \"2ch\");  \n    txt = txt.replaceAll(\"^ss\", \"2ss\");  \n    txt = txt.replaceAll(\"^x\", \"2x\");  \n    txt = txt.replaceAll(\"^m\", \"2m\");  \n    txt = txt.replaceAll(\"^l\", \"2l\");  \n    txt = txt.replaceAll(\"^s\", \"2s\");  \n    txt = txt.replaceAll(\"^z\", \"2z\");  \n    txt = txt.replaceAll(\"^j\", \"2j\");  \n    txt = txt.replaceAll(\"^q\", \"2q\");  \n    txt = txt.replaceAll(\"^k\", \"2k\");  \n    txt = txt.replaceAll(\"",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^rn\", \"2r\");\n    txt = txt.replaceAll(\"^wn\", \"2w\");\n    txt = txt.replaceAll(\"^th\", \"2th\");\n    txt = txt.replaceAll(\"^gh\", \"2g\");\n    txt = txt.replaceAll(\"^ph\", \"2f\");\n    txt = txt.replaceAll(\"^sh\", \"2sh\");\n    txt = txt.replaceAll(\"^ch\", \"2ch\");\n    txt = txt.replaceAll(\"^ss\", \"2ss\");\n    txt = txt.replaceAll(\"^x\", \"2x\");\n    txt = txt.replaceAll(\"^m\", \"2m\");\n    txt = txt.replaceAll(\"^l\", \"2l\");\n    txt = txt.replaceAll(\"^s\", \"2s\");\n    txt = txt.replaceAll(\"^z\", \"2z\");\n    txt = txt.replaceAll(\"^i\", \"2i\");\n    txt = txt.replaceAll(\"^o\", \"2o\");\n    txt = txt.replaceAll(\"^u\", \"2u\");\n    txt = txt.replaceAll(\"^y\", \"2y\");\n    txt = txt.replaceAll(\"",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^rn\", \"2r\");\n    txt = txt.replaceAll(\"^wn\", \"2w\");\n    txt = txt.replaceAll(\"^th\", \"2th\");\n    txt = txt.replaceAll(\"^gh\", \"2g\");\n    txt = txt.replaceAll(\"^ph\", \"2f\");\n    txt = txt.replaceAll(\"^sh\", \"2sh\");\n    txt = txt.replaceAll(\"^ch\", \"2ch\");\n    txt = txt.replaceAll(\"^ss\", \"2ss\");\n    txt = txt.replaceAll(\"^x\", \"2x\");\n    txt = txt.replaceAll(\"^m\", \"2m\");\n    txt = txt.replaceAll(\"^l\", \"2l\");\n    txt = txt.replaceAll(\"^s\", \"2s\");\n    txt = txt.replaceAll(\"^z\", \"2z\");\n    txt = txt.replaceAll(\"^i\", \"2i\");\n    txt = txt.replaceAll(\"^o\", \"2o\");\n    txt = txt.replaceAll(\"^n\", \"2n\");\n    txt = txt.replaceAll(\"^h\", \"2h\");\n    txt = txt.replaceAll(\"",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^rn\", \"2r\");\n    txt = txt.replaceAll(\"^wn\", \"2w\");\n    txt = txt.replaceAll(\"^th\", \"2th\");\n    txt = txt.replaceAll(\"^gh\", \"2g\");\n    txt = txt.replaceAll(\"^ph\", \"2f\");\n    txt = txt.replaceAll(\"^sh\", \"2sh\");\n    txt = txt.replaceAll(\"^ch\", \"2ch\");\n    txt = txt.replaceAll(\"^ss\", \"2ss\");\n    txt = txt.replaceAll(\"^x\", \"2x\");\n    txt = txt.replaceAll(\"^m\", \"2m\");\n    txt = txt.replaceAll(\"^l\", \"2l\");\n    txt = txt.replaceAll(\"^s\", \"2s\");\n    txt = txt.replaceAll(\"^z\", \"2z\");\n    txt = txt.replaceAll(\"^j\", \"2j\");\n    txt = txt.replaceAll(\"^y\", \"2y\");\n    txt = txt.replaceAll(\"^k\", \"2k\");\n    txt = txt.replaceAll(\"^q\", \"2q\");\n    txt = txt.replaceAll(\""
      ],
      "function range": "50,5-142,5"
    },
    "Codec_17_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_339-340": {
      "loc": "339-340",
      "input": "public static String newStringIso8859_1(final byte[] bytes) {",
      "output": [
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.ISO_8859_1);\n    }\n\n    public static String newStringUTF8(final byte[] bytes) {\n        return newStringUTF8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_8);\n    }\n\n    public static String newStringUTF16(final byte[] bytes) {\n        return newStringUTF16(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16);\n    }\n\n    public static String newStringUTF16LE(final byte[] bytes) {\n        return newStringUTF16LE(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16LE(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16LE);\n    }\n\n    public static String newStringUTF32(final byte[] bytes) {\n        return newStringUTF32(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF32(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_32);\n    }\n\n    public static String newStringUTF32LE(final byte[] bytes) {\n        return newStringUTF32LE(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF32LE(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.ISO_8859_1);\n    }\n\n    public static String newStringUTF8(final byte[] bytes) {\n        return newStringUTF8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_8);\n    }\n\n    public static String newStringUTF16(final byte[] bytes) {\n        return newStringUTF16(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16);\n    }\n\n    public static String newStringUTF16BE(final byte[] bytes) {\n        return newStringUTF16BE(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16BE(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16BE);\n    }\n\n    public static String newStringUTF16LE(final byte[] bytes) {\n        return newStringUTF16LE(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16LE(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16LE);\n    }\n\n    public static String newStringUTF32(final byte[] bytes) {\n        return newStringUTF32(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF32(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"ISO-8859-1\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return newStringUtf8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return newStringUtf16(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-16\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf16be(final byte[] bytes) {\n        return newStringUtf16be(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf16be(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-16BE\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf16le(final byte[] bytes) {\n        return newStringUtf16le(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf16le(final byte[]",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.ISO_8859_1);\n    }\n\n    public static String newStringUTF8(final byte[] bytes) {\n        return newStringUTF8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_8);\n    }\n\n    public static String newStringUTF16(final byte[] bytes) {\n        return newStringUTF16(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16);\n    }\n\n    public static String newStringUTF16LE(final byte[] bytes) {\n        return newStringUTF16LE(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16LE(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16LE);\n    }\n\n    public static String newStringUTF16BE(final byte[] bytes) {\n        return newStringUTF16BE(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16BE(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16BE);\n    }\n\n    public static String newStringUTF32(final byte[] bytes) {\n        return newStringUTF32(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF32(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"ISO-8859-1\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return newStringUtf8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return newStringUtf16(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-16\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf32(final byte[] bytes) {\n        return newStringUtf32(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf32(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-32\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.ISO_8859_1);\n    }\n\n    public static String newStringUTF8(final byte[] bytes) {\n        return newStringUTF8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_8);\n    }\n\n    public static String newStringUTF16(final byte[] bytes) {\n        return newStringUTF16(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16);\n    }\n\n    public static String newStringUTF16LE(final byte[] bytes) {\n        return newStringUTF16LE(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16LE(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16LE);\n    }\n\n    public static String newStringUTF16BE(final byte[] bytes) {\n        return newStringUTF16BE(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16BE(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16BE);\n    }\n\n    public static String newStringUTF32(final byte[] bytes) {\n        return newStringUTF32(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF32LE(final byte[] bytes) {\n        return newStringUTF32LE(bytes, 0, bytes.length);\n    }\n\n    public static",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"ISO-8859-1\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return newStringUtf8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return newStringUtf16(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-16\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf32(final byte[] bytes) {\n        return newStringUtf32(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf32(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-32\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"ISO-8859-1\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return newStringUtf8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return newStringUtf16(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-16\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String newStringUtf32(final byte[] bytes) {\n        return newStringUtf32(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUtf32(final byte[] bytes, final int offset, final int length) {\n        try {\n            return new String(bytes, offset, length, \"UTF-32\");\n        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The AS",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.ISO_8859_1);\n    }\n\n    public static String newStringUTF8(final byte[] bytes) {\n        return newStringUTF8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_8);\n    }\n\n    public static String newStringUTF16(final byte[] bytes) {\n        return newStringUTF16(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16);\n    }\n\n    public static String newStringUTF16BE(final byte[] bytes) {\n        return newStringUTF16BE(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16BE(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16BE);\n    }\n\n    public static String newStringUTF16LE(final byte[] bytes) {\n        return newStringUTF16LE(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16LE(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16LE);\n    }\n\n    public static String newStringUTF32(final byte[] bytes) {\n        return newStringUTF32(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF32BE(final byte[] bytes) {\n        return newStringUTF32BE(bytes, 0, bytes.length);\n    }\n\n    public static",
        "public static String newStringIso8859_1(final byte[] bytes) {\n        return newStringIso8859_1(bytes, 0, bytes.length);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.ISO_8859_1);\n    }\n\n    public static String newStringUTF8(final byte[] bytes) {\n        return newStringUTF8(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_8);\n    }\n\n    public static String newStringUTF16(final byte[] bytes) {\n        return newStringUTF16(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16);\n    }\n\n    public static String newStringUTF16BE(final byte[] bytes) {\n        return newStringUTF16BE(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16BE(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16BE);\n    }\n\n    public static String newStringUTF16LE(final byte[] bytes) {\n        return newStringUTF16LE(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF16LE(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, StandardCharsets.UTF_16LE);\n    }\n\n    public static String newStringUTF32(final byte[] bytes) {\n        return newStringUTF32(bytes, 0, bytes.length);\n    }\n\n    public static String newStringUTF32(final byte[] bytes, final int offset, final int length) {\n        return newStringUTF32(bytes, offset, length, StandardChars"
      ],
      "function range": "338,5-340,5"
    },
    "Codec_18_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_81-82": {
      "loc": "81-82",
      "input": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }",
      "output": [
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\n",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAgg",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.AsterixBuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.asterix.",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks"
      ],
      "function range": "71,5-82,5"
    },
    "Compress_5_/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java_239-241": {
      "loc": "239-241",
      "input": "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n                ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }",
      "output": [
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            readBytesOfEntry += read;\n            crc.update(buffer, start, read);\n            bytesReadFromStream += read;\n        }\n        return read;\n    } else {\n        return -1;\n    }\n}\n\n/**\n *",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            readBytesOfEntry += read;\n            crc.update(buffer, start, read);\n            bytesReadFromStream += read;\n        }\n        return read;\n    } else {\n        return -1;\n    }\n}\n}\n<",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            readBytesOfEntry += read;\n            crc.update(buffer, start, read);\n            bytesReadFromStream += read;\n        }\n        return read;\n    }\n    return -1;\n}\n}\n<|java|>/*",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            readBytesOfEntry += read;\n            crc.update(buffer, start, read);\n            bytesReadFromStream += read;\n        }\n        return read;\n    }\n    return -1;\n}\n}\n<|java|>package",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            readBytesOfEntry += read;\n            crc.update(buffer, start, read);\n        }\n        return read;\n    }\n    throw new IndexOutOfBoundsException();\n  }\n\n  @Override\n  public long skip(long n)",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            readBytesOfEntry += read;\n            crc.update(buffer, start, read);\n        }\n        return read;\n    }\n    throw new IndexOutOfBoundsException();\n  }\n\n  @Override\n  public int read() throws IOException",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            readBytesOfEntry += read;\n            crc.update(buffer, start, read);\n            bytesReadFromStream += read;\n        }\n        return read;\n    } else {\n        return -1;\n    }\n}\n\n}\n",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            readBytesOfEntry += read;\n            crc.update(buffer, start, read);\n        }\n        return read;\n    } else {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Copyright (",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            readBytesOfEntry += read;\n            crc.update(buffer, start, read);\n            bytesReadFromStream += read;\n        }\n        return read;\n    } else {\n        return -1;\n    }\n  }\n\n  /**\n",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read > 0) {\n            readBytesOfEntry += read;\n            crc.update(buffer, start, read);\n        }\n        return read;\n    } else {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to"
      ],
      "function range": "191,5-246,5"
    },
    "Compress_12_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java_198-199": {
      "loc": "198-199",
      "input": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }",
      "output": [
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    if (headerBuf == null) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    TarArchiveEntry entry;\n    try {\n        entry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    entryOffset = 0;\n    entrySize = entry.getSize();\n    currEntry = entry;\n    return entry;\n  }\n\n  @Override\n  public int available() throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      hasHitEOF = true;\n      return 0;\n    }\n    return readBuf.length;\n  }\n\n  @Override\n  public int read() throws IOException {\n    if (hasHitEOF) {\n      return -1;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      hasHitEOF = true;\n      return -1;\n    }\n    return readBuf[0] & 0xff;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    if (headerBuf == null) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    TarArchiveEntry entry;\n    try {\n        entry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    entryOffset = 0;\n    entrySize = entry.getSize();\n    currEntry = entry;\n    return entry;\n  }\n\n  @Override\n  public int available() throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      hasHitEOF = true;\n      return 0;\n    }\n    return readBuf.length;\n  }\n\n  @Override\n  public int read() throws IOException {\n    if (hasHitEOF) {\n      return -1;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      hasHitEOF = true;\n      return -1;\n    }\n    return readBuf[0] & 0xFF;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    if (headerBuf == null) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    TarArchiveEntry entry;\n    try {\n        entry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    entryOffset = 0;\n    entrySize = entry.getSize();\n    currEntry = entry;\n    return entry;\n  }\n\n  @Override\n  public int available() throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      return 0;\n    }\n    return readBuf.length;\n  }\n\n  @Override\n  public int read() throws IOException {\n    if (hasHitEOF) {\n      return -1;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      return -1;\n    }\n    return readBuf[0] & 0xff;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    if (hasHitEOF) {\n      return",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    if (headerBuf == null) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    TarArchiveEntry entry;\n    try {\n        entry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    entryOffset = 0;\n    entrySize = entry.getSize();\n    currEntry = entry;\n    return entry;\n  }\n\n  @Override\n  public int available() throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n      if (readBuf == null) {\n        hasHitEOF = true;\n        return 0;\n      }\n    }\n    return readBuf.length - entryOffset;\n  }\n\n  @Override\n  public int read() throws IOException {\n    if (hasHitEOF) {\n      return -1;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n      if (readBuf == null) {\n        hasHitEOF = true;\n        return -1;\n      }\n    }\n    if (entryOffset >= readBuf.length) {\n      readBuf = getRecord();\n      if (readBuf == null",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    if (headerBuf == null) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    TarArchiveEntry entry;\n    try {\n        entry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    entryOffset = 0;\n    entrySize = entry.getSize();\n    currEntry = entry;\n    return entry;\n  }\n\n  @Override\n  public int available() throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      return 0;\n    }\n    return readBuf.length;\n  }\n\n  @Override\n  public int read() throws IOException {\n    if (hasHitEOF) {\n      return -1;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      return -1;\n    }\n    return readBuf[0] & 0xFF;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    if (hasHitEOF) {\n      ",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    if (headerBuf == null) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    TarArchiveEntry entry;\n    try {\n        entry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    entryOffset = 0;\n    entrySize = entry.getSize();\n    currEntry = entry;\n    return entry;\n  }\n\n  @Override\n  public int available() throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      hasHitEOF = true;\n      return 0;\n    }\n    return readBuf.length;\n  }\n\n  @Override\n  public int read() throws IOException {\n    if (hasHitEOF) {\n      return -1;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      hasHitEOF = true;\n      return -1;\n    }\n    return readBuf[0] & 0xff;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    if (headerBuf == null) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    TarArchiveEntry entry;\n    try {\n        entry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    entryOffset = 0;\n    entrySize = entry.getSize();\n    currEntry = entry;\n    return entry;\n  }\n\n  @Override\n  public int available() throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      hasHitEOF = true;\n      return 0;\n    }\n    return readBuf.length;\n  }\n\n  @Override\n  public int read() throws IOException {\n    if (hasHitEOF) {\n      return -1;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      hasHitEOF = true;\n      return -1;\n    }\n    return readBuf[0] & 0xFF;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    if (headerBuf == null) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    TarArchiveEntry entry;\n    try {\n        entry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    entryOffset = 0;\n    entrySize = entry.getSize();\n    currEntry = entry;\n    return entry;\n  }\n\n  @Override\n  public int available() throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      hasHitEOF = true;\n      return 0;\n    }\n    return readBuf.length;\n  }\n\n  @Override\n  public int read() throws IOException {\n    if (hasHitEOF) {\n      return -1;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      hasHitEOF = true;\n      return -1;\n    }\n    int ret = readBuf[0] & 0xff;\n    readBuf = null;\n    return ret;\n  }\n\n  @Override",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    if (headerBuf == null) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    TarArchiveEntry entry;\n    try {\n        entry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    entryOffset = 0;\n    entrySize = entry.getSize();\n    currEntry = entry;\n    return entry;\n  }\n\n  @Override\n  public int available() throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n      if (readBuf == null) {\n        hasHitEOF = true;\n        return 0;\n      }\n    }\n    return readBuf.length;\n  }\n\n  @Override\n  public int read() throws IOException {\n    if (hasHitEOF) {\n      return -1;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n      if (readBuf == null) {\n        hasHitEOF = true;\n        return -1;\n      }\n    }\n    if (readBuf.length == 0) {\n      return -1;\n    }\n    return readBuf[0] & 0xFF",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    if (headerBuf == null) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    TarArchiveEntry entry;\n    try {\n        entry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n    entryOffset = 0;\n    entrySize = entry.getSize();\n    currEntry = entry;\n    return entry;\n  }\n\n  @Override\n  public int available() throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      hasHitEOF = true;\n      return 0;\n    }\n    return readBuf.length;\n  }\n\n  @Override\n  public int read() throws IOException {\n    if (hasHitEOF) {\n      return -1;\n    }\n    if (readBuf == null) {\n      readBuf = getRecord();\n    }\n    if (readBuf == null) {\n      hasHitEOF = true;\n      return -1;\n    }\n    if (readBuf.length == 0) {\n      return -1;\n    }\n    return readBuf[0] & 0xFF"
      ],
      "function range": "172,5-238,5"
    },
    "Compress_14_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_65-73": {
      "loc": "65-73",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }",
      "output": [
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    while (start < end) {\n        final byte b = buffer[start++];\n        if (b < '0' || b > '7') {\n            break;\n        }\n        result = (result << 3) + (b - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    while (start < end) {\n        final byte b = buffer[start++];\n        if (b < '0' || b > '7') {\n            break;\n        }\n        result = (result << 3) + (b - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEval",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    while (start < end) {\n        final byte b = buffer[start++];\n        if (b < '0' || b > '7') {\n            break;\n        }\n        result = (result << 3) + (b - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    while (start < end) {\n        final byte b = buffer[start++];\n        if (b < '0' || b > '7') {\n            break;\n        }\n        result = (result << 3) + (b - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\n",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    while (start < end) {\n        final byte b = buffer[start++];\n        if (b < '0' || b > '7') {\n            break;\n        }\n        result = (result << 3) + (b - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    while (start < end) {\n        final byte b = buffer[start++];\n        if (b < '0' || b > '7') {\n            break;\n        }\n        result = (result << 3) + (b - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvalu",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    while (start < end) {\n        final byte b = buffer[start++];\n        if (b < '0' || b > '7') {\n            break;\n        }\n        result = (result << 3) + (b - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    while (start < end) {\n        final byte b = buffer[start++];\n        if (b < '0' || b > '7') {\n            break;\n        }\n        result = (result << 3) + (b - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    while (start < end) {\n        final byte b = buffer[start++];\n        if (b < '0' || b > '7') {\n            break;\n        }\n        result = (result << 3) + (b - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.alge",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    while (start < end) {\n        final byte b = buffer[start++];\n        if (b < '0' || b > '7') {\n            break;\n        }\n        result = (result << 3) + (b - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org"
      ],
      "function range": "56,5-112,5"
    },
    "Compress_19_/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java_259-260": {
      "loc": "259-260",
      "input": "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData != null) {\n        int expectedLength = (hasUncompressedSize ? DWORD : 0)\n            + (hasCompressedSize ? DWORD : 0)\n            + (hasRelativeHeaderOffset ? DWORD : 0)\n            + (hasDiskStart ? WORD : 0);",
      "output": [
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Expected \" + expectedLength\n                                   + \" bytes of central directory data, \"\n                                   + \"but got \" + rawCentralDirectoryData.length);\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algeb",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Expected \" + expectedLength\n                                   + \" bytes of central directory data, \"\n                                   + \"but got \" + rawCentralDirectoryData.length);\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.al",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Expected \" + expectedLength\n                                   + \" bytes of central directory data, \"\n                                   + \"but got \" + rawCentralDirectoryData.length);\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Expected \" + expectedLength\n                                   + \" bytes of central directory data, \"\n                                   + \"but got \" + rawCentralDirectoryData.length);\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.h",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Expected \" + expectedLength\n                                   + \" bytes of central directory data, \"\n                                   + \"but got \" + rawCentralDirectoryData.length);\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalar",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Expected \" + expectedLength\n                                   + \" bytes of central directory data, \"\n                                   + \"but got \" + rawCentralDirectoryData.length);\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.asterix.runtime.",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Expected \" + expectedLength\n                                   + \" bytes of central directory data, \"\n                                   + \"but got \" + rawCentralDirectoryData.length);\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Expected \" + expectedLength\n                                   + \" bytes of central directory data, \"\n                                   + \"but got \" + rawCentralDirectoryData.length);\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Expected \" + expectedLength\n                                   + \" bytes of central directory data, \"\n                                   + \"but got \" + rawCentralDirectoryData.length);\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.common.annotations.MissingNullInOutFunction;\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n        if (rawCentralDirectoryData.length!= expectedLength) {\n            throw new ZipException(\"Expected \" + expectedLength\n                                   + \" bytes of central directory data, \"\n                                   + \"but got \" + rawCentralDirectoryData.length);\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport"
      ],
      "function range": "249,5-287,5"
    },
    "Compress_23_/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java_112-113": {
      "loc": "112-113",
      "input": "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {",
      "output": [
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        propsByte <<= 8;\n        propsByte |= coder.properties[i] & 0xFF;\n    }\n    coder.properties[0] = propsByte;\n    coder.properties[1] = (byte) (dictSize >>> 56);\n    coder.properties[2] = (byte) (dictSize >>> 48);\n    coder.properties[3] = (byte) (dictSize >>> 40);\n    coder.properties[4] = (byte) (dictSize >>> 32);\n    coder.properties[5] = (byte) (dictSize >>> 24);\n    coder.properties[6] = (byte) (dictSize >>> 16);\n    coder.properties[7] = (byte) (dictSize >>> 8);\n    coder.properties[8] = (byte) dictSize;\n    coder.properties[9] = (byte) (dictSize >>> 24);\n    coder.properties[10] = (byte) (dictSize >>> 16);\n    coder.properties[11] = (byte) (dictSize >>> 8);\n    coder.properties[12] = (byte) dictSize;\n    coder.properties[13] = (byte) (dictSize >>> 24);\n    coder.properties[14] = (byte) (dictSize >>> 16);\n    coder.properties[15] = (byte) (dictSize >>> 8);\n    coder.properties[16] = (byte) dictSize;\n    coder.properties[17] = (byte) (dictSize >>> 24);\n    coder.properties[18] = (byte) (dictSize >>> 16);\n    coder.properties[19] = (byte) (dictSize >>> 8);\n    coder.properties[20] = (byte) dictSize;\n    coder.properties[21] = (byte) (dictSize >>> 24);\n    coder.properties[22] = (",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        propsByte <<= 8;\n        propsByte |= coder.properties[i] & 0xFF;\n    }\n    coder.properties[0] = propsByte;\n    coder.properties[1] = (byte) (dictSize >>> 56);\n    coder.properties[2] = (byte) (dictSize >>> 48);\n    coder.properties[3] = (byte) (dictSize >>> 40);\n    coder.properties[4] = (byte) (dictSize >>> 32);\n    coder.properties[5] = (byte) (dictSize >>> 24);\n    coder.properties[6] = (byte) (dictSize >>> 16);\n    coder.properties[7] = (byte) (dictSize >>> 8);\n    coder.properties[8] = (byte) dictSize;\n    coder.properties[9] = (byte) (dictSize >>> 56);\n    coder.properties[10] = (byte) (dictSize >>> 48);\n    coder.properties[11] = (byte) (dictSize >>> 40);\n    coder.properties[12] = (byte) (dictSize >>> 32);\n    coder.properties[13] = (byte) (dictSize >>> 24);\n    coder.properties[14] = (byte) (dictSize >>> 16);\n    coder.properties[15] = (byte) (dictSize >>> 8);\n    coder.properties[16] = (byte) dictSize;\n    coder.properties[17] = (byte) (dictSize >>> 56);\n    coder.properties[18] = (byte) (dictSize >>> 48);\n    coder.properties[19] = (byte) (dictSize >>> 40);\n    coder.properties[20] = (byte) (dictSize >>> 32);\n    coder.properties[21] = (byte) (dictSize >>> 24);\n    coder.",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        propsByte <<= 8;\n        propsByte |= coder.properties[i] & 0xFF;\n    }\n    coder.properties[0] = propsByte;\n    coder.properties[1] = (byte) (dictSize >>> 24);\n    coder.properties[2] = (byte) (dictSize >>> 16);\n    coder.properties[3] = (byte) (dictSize >>> 8);\n    coder.properties[4] = (byte) dictSize;\n    coder.properties[5] = (byte) (dictSize >>> 24);\n    coder.properties[6] = (byte) (dictSize >>> 16);\n    coder.properties[7] = (byte) (dictSize >>> 8);\n    coder.properties[8] = (byte) dictSize;\n    coder.properties[9] = (byte) (dictSize >>> 24);\n    coder.properties[10] = (byte) (dictSize >>> 16);\n    coder.properties[11] = (byte) (dictSize >>> 8);\n    coder.properties[12] = (byte) dictSize;\n    coder.properties[13] = (byte) (dictSize >>> 24);\n    coder.properties[14] = (byte) (dictSize >>> 16);\n    coder.properties[15] = (byte) (dictSize >>> 8);\n    coder.properties[16] = (byte) dictSize;\n    coder.properties[17] = (byte) (dictSize >>> 24);\n    coder.properties[18] = (byte) (dictSize >>> 16);\n    coder.properties[19] = (byte) (dictSize >>> 8);\n    coder.properties[20] = (byte) dictSize;\n    coder.properties[21] = (byte) (dictSize >>> 24);\n    coder.properties[22] = (byte) (",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        propsByte <<= 8;\n        propsByte |= coder.properties[i] & 0xFF;\n    }\n    coder.properties[0] = propsByte;\n    coder.properties[1] = (byte) (dictSize & 0xFF);\n    coder.properties[2] = (byte) ((dictSize >>> 8) & 0xFF);\n    coder.properties[3] = (byte) ((dictSize >>> 16) & 0xFF);\n    coder.properties[4] = (byte) ((dictSize >>> 24) & 0xFF);\n    coder.properties[5] = (byte) ((dictSize >>> 32) & 0xFF);\n    coder.properties[6] = (byte) ((dictSize >>> 40) & 0xFF);\n    coder.properties[7] = (byte) ((dictSize >>> 48) & 0xFF);\n    coder.properties[8] = (byte) ((dictSize >>> 56) & 0xFF);\n    coder.properties[9] = (byte) ((dictSize >>> 64) & 0xFF);\n    coder.properties[10] = (byte) ((dictSize >>> 72) & 0xFF);\n    coder.properties[11] = (byte) ((dictSize >>> 80) & 0xFF);\n    coder.properties[12] = (byte) ((dictSize >>> 88) & 0xFF);\n    coder.properties[13] = (byte) ((dictSize >>> 96) & 0xFF);\n    coder.properties[14] = (byte) ((dictSize >>> 104) & 0xFF);\n    coder.properties[15] = (byte) ((dictSize >>> 112) & 0xFF);\n    coder.properties[16] = (byte) ((dictSize >>> 120) & 0xFF);\n    coder.properties[17] = (byte) ((dictSize >>>",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        propsByte <<= 8;\n        propsByte |= coder.properties[i] & 0xFF;\n    }\n    coder.properties[0] = propsByte;\n    coder.properties[1] = (byte) (dictSize >>> 56);\n    coder.properties[2] = (byte) (dictSize >>> 48);\n    coder.properties[3] = (byte) (dictSize >>> 40);\n    coder.properties[4] = (byte) (dictSize >>> 32);\n    coder.properties[5] = (byte) (dictSize >>> 24);\n    coder.properties[6] = (byte) (dictSize >>> 16);\n    coder.properties[7] = (byte) (dictSize >>> 8);\n    coder.properties[8] = (byte) (dictSize);\n    coder.properties[9] = (byte) (dictSize >>> 24);\n    coder.properties[10] = (byte) (dictSize >>> 16);\n    coder.properties[11] = (byte) (dictSize >>> 8);\n    coder.properties[12] = (byte) (dictSize);\n    coder.properties[13] = (byte) (dictSize >>> 24);\n    coder.properties[14] = (byte) (dictSize >>> 16);\n    coder.properties[15] = (byte) (dictSize >>> 8);\n    coder.properties[16] = (byte) (dictSize);\n    coder.properties[17] = (byte) (dictSize >>> 24);\n    coder.properties[18] = (byte) (dictSize >>> 16);\n    coder.properties[19] = (byte) (dictSize >>> 8);\n    coder.properties[20] = (byte) (dictSize);\n    coder.properties[21] = (byte) (dictSize >>> 24);\n    coder.properties[",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        propsByte <<= 8;\n        propsByte |= coder.properties[i] & 0xFF;\n    }\n    coder.properties[0] = propsByte;\n    coder.properties[1] = (byte) (dictSize >>> 56);\n    coder.properties[2] = (byte) (dictSize >>> 48);\n    coder.properties[3] = (byte) (dictSize >>> 40);\n    coder.properties[4] = (byte) (dictSize >>> 32);\n    coder.properties[5] = (byte) (dictSize >>> 24);\n    coder.properties[6] = (byte) (dictSize >>> 16);\n    coder.properties[7] = (byte) (dictSize >>> 8);\n    coder.properties[8] = (byte) (dictSize);\n    coder.properties[9] = (byte) (dictSize >>> 56);\n    coder.properties[10] = (byte) (dictSize >>> 48);\n    coder.properties[11] = (byte) (dictSize >>> 40);\n    coder.properties[12] = (byte) (dictSize >>> 32);\n    coder.properties[13] = (byte) (dictSize >>> 24);\n    coder.properties[14] = (byte) (dictSize >>> 16);\n    coder.properties[15] = (byte) (dictSize >>> 8);\n    coder.properties[16] = (byte) (dictSize);\n    coder.properties[17] = (byte) (dictSize >>> 56);\n    coder.properties[18] = (byte) (dictSize >>> 48);\n    coder.properties[19] = (byte) (dictSize >>> 40);\n    coder.properties[20] = (byte) (dictSize >>> 32);\n    coder.properties[21] = (byte) (dictSize >>> 24);\n    c",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        propsByte <<= 8;\n        propsByte |= coder.properties[i] & 0xFF;\n    }\n    coder.properties[0] = propsByte;\n    coder.properties[1] = (byte) (dictSize & 0xFF);\n    coder.properties[2] = (byte) ((dictSize >> 8) & 0xFF);\n    coder.properties[3] = (byte) ((dictSize >> 16) & 0xFF);\n    coder.properties[4] = (byte) ((dictSize >> 24) & 0xFF);\n    coder.properties[5] = (byte) ((dictSize >> 32) & 0xFF);\n    coder.properties[6] = (byte) ((dictSize >> 40) & 0xFF);\n    coder.properties[7] = (byte) ((dictSize >> 48) & 0xFF);\n    coder.properties[8] = (byte) ((dictSize >> 56) & 0xFF);\n    coder.properties[9] = (byte) ((dictSize >> 64) & 0xFF);\n    coder.properties[10] = (byte) ((dictSize >> 72) & 0xFF);\n    coder.properties[11] = (byte) ((dictSize >> 80) & 0xFF);\n    coder.properties[12] = (byte) ((dictSize >> 88) & 0xFF);\n    coder.properties[13] = (byte) ((dictSize >> 96) & 0xFF);\n    coder.properties[14] = (byte) ((dictSize >> 104) & 0xFF);\n    coder.properties[15] = (byte) ((dictSize >> 112) & 0xFF);\n    coder.properties[16] = (byte) ((dictSize >> 120) & 0xFF);\n    coder.properties[17] = (byte) ((dictSize >>",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        propsByte <<= 8;\n        propsByte |= coder.properties[i] & 0xFF;\n    }\n    coder.properties[0] = propsByte;\n    coder.properties[1] = (byte) (dictSize >>> 56);\n    coder.properties[2] = (byte) (dictSize >>> 48);\n    coder.properties[3] = (byte) (dictSize >>> 40);\n    coder.properties[4] = (byte) (dictSize >>> 32);\n    coder.properties[5] = (byte) (dictSize >>> 24);\n    coder.properties[6] = (byte) (dictSize >>> 16);\n    coder.properties[7] = (byte) (dictSize >>> 8);\n    coder.properties[8] = (byte) dictSize;\n    coder.properties[9] = (byte) (dictSize >>> 24);\n    coder.properties[10] = (byte) (dictSize >>> 16);\n    coder.properties[11] = (byte) (dictSize >>> 8);\n    coder.properties[12] = (byte) dictSize;\n    coder.properties[13] = (byte) (dictSize >>> 24);\n    coder.properties[14] = (byte) (dictSize >>> 16);\n    coder.properties[15] = (byte) (dictSize >>> 8);\n    coder.properties[16] = (byte) dictSize;\n    coder.properties[17] = (byte) (dictSize >>> 24);\n    coder.properties[18] = (byte) (dictSize >>> 16);\n    coder.properties[19] = (byte) (dictSize >>> 8);\n    coder.properties[20] = (byte) dictSize;\n    return super.decode(in, coder, password);\n  }\n}\n<|java|>/*\n *",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        propsByte <<= 8;\n        propsByte |= coder.properties[i] & 0xFF;\n    }\n    coder.properties[0] = propsByte;\n    coder.properties[1] = (byte) (dictSize & 0xFF);\n    coder.properties[2] = (byte) ((dictSize >>> 8) & 0xFF);\n    coder.properties[3] = (byte) ((dictSize >>> 16) & 0xFF);\n    coder.properties[4] = (byte) ((dictSize >>> 24) & 0xFF);\n    coder.properties[5] = (byte) ((dictSize >>> 32) & 0xFF);\n    coder.properties[6] = (byte) ((dictSize >>> 40) & 0xFF);\n    coder.properties[7] = (byte) ((dictSize >>> 48) & 0xFF);\n    coder.properties[8] = (byte) ((dictSize >>> 56) & 0xFF);\n    coder.properties[9] = (byte) ((dictSize >>> 64) & 0xFF);\n    coder.properties[10] = (byte) ((dictSize >>> 72) & 0xFF);\n    coder.properties[11] = (byte) ((dictSize >>> 80) & 0xFF);\n    coder.properties[12] = (byte) ((dictSize >>> 88) & 0xFF);\n    coder.properties[13] = (byte) ((dictSize >>> 96) & 0xFF);\n    coder.properties[14] = (byte) ((dictSize >>> 104) & 0xFF);\n    coder.properties[15] = (byte) ((dictSize >>> 112) & 0xFF);\n    coder.properties[16] = (byte) ((dictSize >>> 120) & 0xFF);\n    coder.properties[17] = (byte) (password.length",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        propsByte <<= 8;\n        propsByte |= coder.properties[i] & 0xFF;\n    }\n    coder.properties[0] = propsByte;\n    coder.properties[1] = (byte) (dictSize >>> 56);\n    coder.properties[2] = (byte) (dictSize >>> 48);\n    coder.properties[3] = (byte) (dictSize >>> 40);\n    coder.properties[4] = (byte) (dictSize >>> 32);\n    coder.properties[5] = (byte) (dictSize >>> 24);\n    coder.properties[6] = (byte) (dictSize >>> 16);\n    coder.properties[7] = (byte) (dictSize >>> 8);\n    coder.properties[8] = (byte) dictSize;\n    coder.properties[9] = (byte) (dictSize >>> 24);\n    coder.properties[10] = (byte) (dictSize >>> 16);\n    coder.properties[11] = (byte) (dictSize >>> 8);\n    coder.properties[12] = (byte) dictSize;\n    coder.properties[13] = (byte) (dictSize >>> 24);\n    coder.properties[14] = (byte) (dictSize >>> 16);\n    coder.properties[15] = (byte) (dictSize >>> 8);\n    coder.properties[16] = (byte) dictSize;\n    coder.properties[17] = (byte) (dictSize >>> 24);\n    coder.properties[18] = (byte) (dictSize >>> 16);\n    coder.properties[19] = (byte) (dictSize >>> 8);\n    coder.properties[20] = (byte) dictSize;\n    return super.decode(in, coder, password);\n  }\n}\n<|java|>package com."
      ],
      "function range": "106,9-118,9"
    },
    "Compress_27_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_133-137": {
      "loc": "133-137",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }",
      "output": [
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptor",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescript",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.Abstract",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.formats.nontagged.AqlSerializerDeserializerProvider;\nimport org.apache.asterix.om.base.",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.common.annotations.MissingNullInOutFunction;\nimport org.apache.asterix.dataflow.data.nontagged.",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache."
      ],
      "function range": "102,5-150,5"
    },
    "Compress_31_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_135-138": {
      "loc": "135-138",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];",
      "output": [
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        result <<= 3;\n        if (currentByte >= '0' && currentByte <= '7') {\n            result |= currentByte - '0';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result |= currentByte - 'A' + 10;\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        result <<= 3;\n        if (currentByte >= '0' && currentByte <= '7') {\n            result |= currentByte - '0';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result |= currentByte - 'A' + 10;\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        result <<= 3;\n        if (currentByte >= '0' && currentByte <= '7') {\n            result |= currentByte - '0';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result |= currentByte - 'A' + 10;\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        result <<= 3;\n        if (currentByte >= '0' && currentByte <= '7') {\n            result |= currentByte - '0';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result |= currentByte - 'A' + 10;\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        result <<= 3;\n        if (currentByte >= '0' && currentByte <= '7') {\n            result |= currentByte - '0';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result |= currentByte - 'A' + 10;\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        result <<= 3;\n        if (currentByte >= '0' && currentByte <= '7') {\n            result |= currentByte - '0';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result |= currentByte - 'A' + 10;\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        result <<= 3;\n        if (currentByte >= '0' && currentByte <= '7') {\n            result |= currentByte - '0';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result |= currentByte - 'A' + 10;\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        result <<= 3;\n        if (currentByte >= '0' && currentByte <= '7') {\n            result |= currentByte - '0';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result |= currentByte - 'A' + 10;\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        result <<= 3;\n        if (currentByte >= '0' && currentByte <= '7') {\n            result |= currentByte - '0';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result |= currentByte - 'A' + 10;\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        result <<= 3;\n        if (currentByte >= '0' && currentByte <= '7') {\n            result |= currentByte - '0';\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result |= currentByte - 'a' + 10;\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result |= currentByte - 'A' + 10;\n        } else {\n            throw new IllegalArgumentException(\"Malformed octal number\");\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CON"
      ],
      "function range": "101,5-148,5"
    },
    "Compress_38_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java_859-860": {
      "loc": "859-860",
      "input": "@Override\npublic boolean isDirectory() {\n    if (file != null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }",
      "output": [
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_REG) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isSymbolicLink() {\n    if (file!= null) {\n        return file.isSymbolicLink();\n    }\n    if (linkFlag == LF_SYMLINK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isOther() {\n    if (file!= null) {\n        return file.isOther();\n    }\n    if (linkFlag == LF_CHR) {\n        return true;\n    }\n    if (linkFlag == LF_BLK) {\n        return true;\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (linkFlag == LF_FIFO) {\n        return true;\n    }\n    if (linkFlag == LF_SOCK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModifiedTime() {\n    if (file!= null) {\n        return file.lastModifiedTime();\n    }\n    if (linkFlag == LF_CHR) {\n        return 0;\n    }\n    if (linkFlag == LF_BLK) {\n        return 0;\n    }\n    if (linkFlag == LF_DIR) {\n        return 0;\n    }\n    if (linkFlag == LF_FIFO) {\n        return 0;\n    }\n    if (linkFlag == LF_SOCK) {\n        return 0;\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    if (linkFlag == LF_CHR) {\n        return",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_REG) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isSymbolicLink() {\n    if (file!= null) {\n        return file.isSymbolicLink();\n    }\n    if (linkFlag == LF_SYMLINK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isOther() {\n    if (file!= null) {\n        return file.isOther();\n    }\n    if (linkFlag == LF_CHR) {\n        return true;\n    }\n    if (linkFlag == LF_BLK) {\n        return true;\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (linkFlag == LF_FIFO) {\n        return true;\n    }\n    if (linkFlag == LF_SOCK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModifiedTime() {\n    if (file!= null) {\n        return file.lastModifiedTime();\n    }\n    return 0;\n}\n\n@Override\npublic long lastAccessTime() {\n    if (file!= null) {\n        return file.lastAccessTime();\n    }\n    return 0;\n}\n\n@Override\npublic long creationTime() {\n    if (file!= null) {\n        return file.creationTime();\n    }\n    return 0;\n}\n\n@Override\npublic boolean setLastModified(long time) {\n    if (file!= null) {\n        return file.setLastModified(time);\n    }\n    return false;\n}\n\n@Override\npublic boolean setReadOnly() {\n    if (file!= null) {\n        ",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_REG) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isSymbolicLink() {\n    if (file!= null) {\n        return file.isSymbolicLink();\n    }\n    if (linkFlag == LF_SYMLINK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isOther() {\n    if (file!= null) {\n        return file.isOther();\n    }\n    if (linkFlag == LF_CHR) {\n        return true;\n    }\n    if (linkFlag == LF_BLK) {\n        return true;\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (linkFlag == LF_FIFO) {\n        return true;\n    }\n    if (linkFlag == LF_SOCK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModifiedTime() {\n    if (file!= null) {\n        return file.lastModifiedTime();\n    }\n    if (linkFlag == LF_CHR) {\n        return 0;\n    }\n    if (linkFlag == LF_BLK) {\n        return 0;\n    }\n    if (linkFlag == LF_DIR) {\n        return 0;\n    }\n    if (linkFlag == LF_FIFO) {\n        return 0;\n    }\n    if (linkFlag == LF_SOCK) {\n        return 0;\n    }\n    return 0;\n}\n\n@Override\npublic long size() {\n    if (file!= null) {\n        return file.size();\n    }\n    if (linkFlag == LF_CHR) {\n        return",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_REG) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isSymbolicLink() {\n    if (file!= null) {\n        return file.isSymbolicLink();\n    }\n    if (linkFlag == LF_SYMLINK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isOther() {\n    if (file!= null) {\n        return file.isOther();\n    }\n    if (linkFlag == LF_CHR) {\n        return true;\n    }\n    if (linkFlag == LF_BLK) {\n        return true;\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (linkFlag == LF_FIFO) {\n        return true;\n    }\n    if (linkFlag == LF_SOCK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModifiedTime() {\n    if (file!= null) {\n        return file.lastModifiedTime();\n    }\n    if (linkFlag == LF_CHR) {\n        return 0;\n    }\n    if (linkFlag == LF_BLK) {\n        return 0;\n    }\n    if (linkFlag == LF_DIR) {\n        return 0;\n    }\n    if (linkFlag == LF_FIFO) {\n        return 0;\n    }\n    if (linkFlag == LF_SOCK) {\n        return 0;\n    }\n    return 0;\n}\n\n@Override\npublic long lastAccessTime() {\n    if (file!= null) {\n        return file.lastAccessTime();\n    }\n    if (linkFlag == LF_CHR)",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_REG) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isSymbolicLink() {\n    if (file!= null) {\n        return file.isSymbolicLink();\n    }\n    if (linkFlag == LF_SYMLINK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isOther() {\n    if (file!= null) {\n        return file.isOther();\n    }\n    if (linkFlag == LF_CHR) {\n        return true;\n    }\n    if (linkFlag == LF_BLK) {\n        return true;\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (linkFlag == LF_FIFO) {\n        return true;\n    }\n    if (linkFlag == LF_SOCK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModifiedTime() {\n    if (file!= null) {\n        return file.lastModifiedTime();\n    }\n    return 0;\n}\n\n@Override\npublic long lastAccessTime() {\n    if (file!= null) {\n        return file.lastAccessTime();\n    }\n    return 0;\n}\n\n@Override\npublic long creationTime() {\n    if (file!= null) {\n        return file.creationTime();\n    }\n    return 0;\n}\n\n@Override\npublic boolean setLastModifiedTime(long time) {\n    if (file!= null) {\n        return file.setLastModifiedTime(time);\n    }\n    return false;\n}\n\n@Override\npublic boolean setLastAccessTime(long time) {\n    if (file",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_REG) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isSymbolicLink() {\n    if (file!= null) {\n        return file.isSymbolicLink();\n    }\n    if (linkFlag == LF_SYMLINK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isOther() {\n    if (file!= null) {\n        return file.isOther();\n    }\n    if (linkFlag == LF_CHR) {\n        return true;\n    }\n    if (linkFlag == LF_BLK) {\n        return true;\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (linkFlag == LF_FIFO) {\n        return true;\n    }\n    if (linkFlag == LF_SOCK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModifiedTime() {\n    if (file!= null) {\n        return file.lastModifiedTime();\n    }\n    return 0;\n}\n\n@Override\npublic long lastReadTime() {\n    if (file!= null) {\n        return file.lastReadTime();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic boolean setLastModifiedTime(long time) {\n    if (file!= null) {\n        return file.setLastModifiedTime(time);\n    }\n    return false;\n}\n\n@Override\npublic boolean setReadOnly() {\n    if (file!= null) {\n        ",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_REG) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isSymbolicLink() {\n    if (file!= null) {\n        return file.isSymbolicLink();\n    }\n    if (linkFlag == LF_SYMLINK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isOther() {\n    if (file!= null) {\n        return file.isOther();\n    }\n    if (linkFlag == LF_CHR) {\n        return true;\n    }\n    if (linkFlag == LF_BLK) {\n        return true;\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (linkFlag == LF_FIFO) {\n        return true;\n    }\n    if (linkFlag == LF_SOCK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModifiedTime() {\n    if (file!= null) {\n        return file.lastModifiedTime();\n    }\n    return 0;\n}\n\n@Override\npublic long lastAccessTime() {\n    if (file!= null) {\n        return file.lastAccessTime();\n    }\n    return 0;\n}\n\n@Override\npublic long creationTime() {\n    if (file!= null) {\n        return file.creationTime();\n    }\n    return 0;\n}\n\n@Override\npublic boolean canRead() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    return false;\n}\n\n@Override\npublic boolean canWrite() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_REG) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isSymbolicLink() {\n    if (file!= null) {\n        return file.isSymbolicLink();\n    }\n    if (linkFlag == LF_SYMLINK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isOther() {\n    if (file!= null) {\n        return file.isOther();\n    }\n    if (linkFlag == LF_CHR) {\n        return true;\n    }\n    if (linkFlag == LF_BLK) {\n        return true;\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (linkFlag == LF_FIFO) {\n        return true;\n    }\n    if (linkFlag == LF_SOCK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModifiedTime() {\n    if (file!= null) {\n        return file.lastModifiedTime();\n    }\n    return 0;\n}\n\n@Override\npublic long lastAccessTime() {\n    if (file!= null) {\n        return file.lastAccessTime();\n    }\n    return 0;\n}\n\n@Override\npublic long creationTime() {\n    if (file!= null) {\n        return file.creationTime();\n    }\n    return 0;\n}\n\n@Override\npublic boolean setLastModified(long time) {\n    if (file!= null) {\n        return file.setLastModified(time);\n    }\n    return false;\n}\n\n@Override\npublic boolean setLastAccessed(long time) {\n    if (file!= null",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_REG) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isSymbolicLink() {\n    if (file!= null) {\n        return file.isSymbolicLink();\n    }\n    if (linkFlag == LF_SYMLINK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isOther() {\n    if (file!= null) {\n        return file.isOther();\n    }\n    if (linkFlag == LF_CHR) {\n        return true;\n    }\n    if (linkFlag == LF_BLK) {\n        return true;\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (linkFlag == LF_FIFO) {\n        return true;\n    }\n    if (linkFlag == LF_SOCK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModifiedTime() {\n    if (file!= null) {\n        return file.lastModifiedTime();\n    }\n    return 0;\n}\n\n@Override\npublic long lastAccessTime() {\n    if (file!= null) {\n        return file.lastAccessTime();\n    }\n    return 0;\n}\n\n@Override\npublic long creationTime() {\n    if (file!= null) {\n        return file.creationTime();\n    }\n    return 0;\n}\n\n@Override\npublic boolean setLastModifiedTime(long time) {\n    if (file!= null) {\n        return file.setLastModifiedTime(time);\n    }\n    return false;\n}\n\n@Override\npublic boolean setReadOnly() {\n    if (file!= null) {",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_REG) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isSymbolicLink() {\n    if (file!= null) {\n        return file.isSymbolicLink();\n    }\n    if (linkFlag == LF_SYMLINK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isOther() {\n    if (file!= null) {\n        return file.isOther();\n    }\n    if (linkFlag == LF_CHR) {\n        return true;\n    }\n    if (linkFlag == LF_BLK) {\n        return true;\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (linkFlag == LF_FIFO) {\n        return true;\n    }\n    if (linkFlag == LF_SOCK) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModifiedTime() {\n    if (file!= null) {\n        return file.lastModifiedTime();\n    }\n    if (linkFlag == LF_CHR) {\n        return 0;\n    }\n    if (linkFlag == LF_BLK) {\n        return 0;\n    }\n    if (linkFlag == LF_DIR) {\n        return 0;\n    }\n    if (linkFlag == LF_FIFO) {\n        return 0;\n    }\n    if (linkFlag == LF_SOCK) {\n        return 0;\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String name"
      ],
      "function range": "849,5-864,5"
    },
    "Compress_46_/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java_529-531": {
      "loc": "529-531",
      "input": "private static ZipLong unixTimeToZipLong(long l) {",
      "output": [
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.Hyr",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class MaxAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    ",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class LocalSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregate",
        "private static ZipLong unixTimeToZipLong(long l) {\n        return new ZipLong(l);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAggregateDescriptor extends AbstractAgg"
      ],
      "function range": "528,5-534,5"
    },
    "Csv_1_/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java_58-59": {
      "loc": "58-59",
      "input": "@Override\npublic int read() throws IOException {\n    int current = super.read();",
      "output": [
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    return super.available();\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    return super.available();\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BAS",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    return super.available();\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    return super.available();\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BAS",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    return super.available();\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    return super.available();\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    return super.available();\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\"",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    return super.available();\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    return super.available();\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b) throws IOException {\n    int current = super.read(b);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    int current = super.read(b, off, len);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public long skip(long n) throws IOException {\n    long current = super.skip(n);\n    if (current == -1) {\n      throw new EOFException();\n    }\n    return current;\n  }\n\n  @Override\n  public int available() throws IOException {\n    return super.available();\n  }\n\n  @Override\n  public void close() throws IOException {\n    super.close();\n  }\n\n  @Override\n  public synchronized void mark(int readlimit) {\n    super.mark(readlimit);\n  }\n\n  @Override\n  public synchronized void reset() throws IOException {\n    super.reset();\n  }\n\n  @Override\n  public boolean markSupported() {\n    return super.markSupported();\n  }\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS"
      ],
      "function range": "55,5-63,5"
    },
    "Csv_4_/src/main/java/org/apache/commons/csv/CSVParser.java_288-289": {
      "loc": "288-289",
      "input": "public Map<String, Integer> getHeaderMap() {",
      "output": [
        "public Map<String, Integer> getHeaderMap() {\n        return headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n",
        "public Map<String, Integer> getHeaderMap() {\n        return headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.",
        "public Map<String, Integer> getHeaderMap() {\n        return headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.data.std.api.IPointable;\nimport org.apache.h",
        "public Map<String, Integer> getHeaderMap() {\n        return headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.common.annotations.MissingNullInOutFunction;\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\n@MissingNullInOut",
        "public Map<String, Integer> getHeaderMap() {\n        return headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.api.exceptions.SourceLocation;\nimport org.apache",
        "public Map<String, Integer> getHeaderMap() {\n        return headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.",
        "public Map<String, Integer> getHeaderMap() {\n        return headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.common.annotations.MissingNullInOutFunction;\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.h",
        "public Map<String, Integer> getHeaderMap() {\n        return headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.data.std.api.IPointable;\nimport org.apache.hyracks.",
        "public Map<String, Integer> getHeaderMap() {\n        return headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.data.std.api.IPointable;\nimport org",
        "public Map<String, Integer> getHeaderMap() {\n        return headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.data.std.api.IPointable;\n\npublic class NumericAdd"
      ],
      "function range": "287,5-289,5"
    },
    "Csv_11_/src/main/java/org/apache/commons/csv/CSVParser.java_384-385": {
      "loc": "384-385",
      "input": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);",
      "output": [
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, Integer.valueOf(hdrMap.get(header).intValue() + 1));\n                } else {\n                    hdrMap.put(header, Integer.valueOf(1));\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, Integer.valueOf(hdrMap.get(header).intValue() + 1));\n                } else {\n                    hdrMap.put(header, Integer.valueOf(1));\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, Integer.valueOf(hdrMap.get(header).intValue() + 1));\n                } else {\n                    hdrMap.put(header, Integer.valueOf(1));\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, Integer.valueOf(hdrMap.get(header).intValue() + 1));\n                } else {\n                    hdrMap.put(header, Integer.valueOf(1));\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, Integer.valueOf(hdrMap.get(header).intValue() + 1));\n                } else {\n                    hdrMap.put(header, Integer.valueOf(1));\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, Integer.valueOf(hdrMap.get(header).intValue() + 1));\n                } else {\n                    hdrMap.put(header, Integer.valueOf(1));\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, Integer.valueOf(hdrMap.get(header).intValue() + 1));\n                } else {\n                    hdrMap.put(header, Integer.valueOf(1));\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, Integer.valueOf(hdrMap.get(header).intValue() + 1));\n                } else {\n                    hdrMap.put(header, Integer.valueOf(1));\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, Integer.valueOf(hdrMap.get(header).intValue() + 1));\n                } else {\n                    hdrMap.put(header, Integer.valueOf(1));\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader) {\n                    hdrMap.put(header, Integer.valueOf(hdrMap.get(header).intValue() + 1));\n                } else {\n                    hdrMap.put(header, Integer.valueOf(1));\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons."
      ],
      "function range": "359,5-394,5"
    },
    "Csv_14_/src/main/java/org/apache/commons/csv/CSVFormat.java_1039-1040": {
      "loc": "1039-1040",
      "input": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);",
      "output": [
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    case MINIMAL_NON_NUMERIC:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            } else if (!(object instanceof Number)) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n}",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    case MINIMAL_NON_NUMERIC:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            } else if (!(object instanceof Number)) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, pos);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n}",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    case MINIMAL_NON_NUMERIC:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            } else if (!(object instanceof Number)) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, start, end - start, out);\n    }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    case MINIMAL_NON_NUMERIC:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            } else if (!(object instanceof Number)) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, pos);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, start, end - start, out);\n    }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    case MINIMAL_NON_NUMERIC:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            } else if (!(object instanceof Number)) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, pos);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, start, pos - start, out);\n    }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    case MINIMAL_NON_NUMERIC:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            } else if (!(object instanceof Number)) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, pos);\n        if (newRecord) {\n            out.append(quoteChar);\n        } else {\n            out.append(delimChar);\n        }\n    } else {\n        printAndE",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    case MINIMAL_NON_NUMERIC:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            } else if (!(object instanceof Number)) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, start, end, out);\n    }\n}",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    case MINIMAL_NON_NUMERIC:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            } else if (!(object instanceof Number)) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, pos);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n    ",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    case MINIMAL_NON_NUMERIC:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            } else if (!(object instanceof Number)) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n    ",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            }\n        }\n        break;\n    case MINIMAL_NON_NUMERIC:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar) {\n                quote = true;\n            } else if (c == quoteChar) {\n                quote = true;\n            } else if (!(object instanceof Number)) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, pos);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, start, end, out);\n    }\n}"
      ],
      "function range": "1001,5-1106,5"
    },
    "Csv_15_/src/main/java/org/apache/commons/csv/CSVFormat.java_1189-1192": {
      "loc": "1189-1192",
      "input": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);",
      "output": [
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    case MINIMAL_NON_NULL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    out.append(value, start, end);\n    if (quote) {\n        out.append(quoteChar);\n    }\n}\n}\n<|java|>/*\n",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    case MINIMAL_NON_NULL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    out.append(value, start, end);\n    if (quote) {\n        out.append(quoteChar);\n    }\n}\n\n    private void printAndEscape(final Char",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    case MINIMAL_NON_NULL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    out.append(value, start, end);\n    if (quote) {\n        out.append(quoteChar);\n    }\n}\n\n}\n<|java|>/*",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    case MINIMAL_NON_NULL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    out.append(value, start, end);\n    if (quote) {\n        out.append(quoteChar);\n    }\n}\n\n}\n<|java|>package",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    case MINIMAL_NON_NULL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    out.append(value, start, end);\n    if (quote) {\n        out.append(quoteChar);\n    }\n}\n}\n<|java|>package com",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    case MINIMAL_NON_NULL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    out.append(value, start, end);\n    if (quote) {\n        out.append(quoteChar);\n    }\n}\n}\n<|java|>/**\n",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    case MINIMAL_NON_NULL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    out.append(value, start, end);\n    if (quote) {\n        out.append(quoteChar);\n    }\n}\n\n    @Override\n    public String toString()",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    case MINIMAL_NON_NULL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    out.append(value, start, end);\n    if (quote) {\n        out.append(quoteChar);\n    }\n}\n}\n<|java|>package org",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    case MINIMAL_NON_NULL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    out.append(value, start, end);\n    if (quote) {\n        out.append(quoteChar);\n    }\n}\n\n    private void printAndEscape(final Object",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    case MINIMAL_NON_NULL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c == delimChar || c == quoteChar) {\n                quote = true;\n            }\n        }\n        if (!quote) {\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    out.append(value, start, end);\n    if (quote) {\n        out.append(quoteChar);\n    }\n}\n\n}\n<|java|>/**"
      ],
      "function range": "1151,5-1256,5"
    },
    "Gson_10_/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java_122-124": {
      "loc": "122-124",
      "input": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);",
      "output": [
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue!= null) {\n    writer.write(fieldValue.toString());\n  } else {\n    writer.writeNull();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue!= null) {\n    writer.write(fieldValue.toString());\n  } else {\n    writer.writeNull();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue!= null) {\n    writer.write(fieldValue.toString());\n  } else {\n    writer.writeNull();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvalu",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue!= null) {\n    writer.write(fieldValue.toString());\n  } else {\n    writer.writeNull();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.serializable.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractSerializableAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAgg",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue!= null) {\n    writer.write(fieldValue.toString());\n  } else {\n    writer.writeNull();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.h",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue!= null) {\n    writer.write(fieldValue.toString());\n  } else {\n    writer.writeNull();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue!= null) {\n    writer.write(fieldValue.toString());\n  } else {\n    writer.writeNull();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.serializable.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractSerializableAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAggregateEvalu",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue!= null) {\n    writer.write(fieldValue.toString());\n  } else {\n    writer.writeNull();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue!= null) {\n    writer.write(fieldValue.toString());\n  } else {\n    writer.writeNull();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  if (fieldValue!= null) {\n    writer.write(fieldValue.toString());\n  } else {\n    writer.writeNull();\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.serializable.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractSerializableAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAggregateEval"
      ],
      "function range": "118,7-125,7"
    },
    "Gson_15_/gson/src/main/java/com/google/gson/stream/JsonWriter.java_495-496": {
      "loc": "495-496",
      "input": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();",
      "output": [
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.nullValue();\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.object();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.name(name);\n  out.object();\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.array();\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endObject();\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endArray();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  if (name!= null) {\n    writeDeferredName();\n  }\n  beforeValue(false);\n  out.name(name);\n  return this;\n}\n\npublic void flush() throws IOException {\n  out.flush();\n}\n\npublic void close() throws IOException {",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.nullValue();\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.object();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.name(name);\n  out.object();\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.array();\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endObject();\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endArray();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  writeDeferredName();\n  out.name(name);\n  return this;\n}\n\npublic JsonWriter value(Object value) throws IOException {\n  if (value == null) {\n    return nullValue();\n  }\n\n  beforeValue(false);\n  JsonWriter w =",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.nullValue();\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.object();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.name(name);\n  out.object();\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.array();\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endObject();\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endArray();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  if (name!= null) {\n    writeDeferredName();\n  }\n  beforeValue(false);\n  out.name(name);\n  return this;\n}\n\nvoid writeDeferredName() throws IOException {\n  if (deferredName!= null) {\n    out.name",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.nullValue();\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.object();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.name(name);\n  out.object();\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.array();\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endObject();\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endArray();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  if (name!= null) {\n    writeDeferredName();\n  }\n  beforeValue(false);\n  out.name(name);\n  return this;\n}\n\npublic JsonWriter value(Object value) throws IOException {\n  if (value == null) {\n    return null",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.nullValue();\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.object();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.name(name);\n  out.object();\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.array();\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endObject();\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endArray();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  if (name!= null) {\n    writeDeferredName();\n  }\n  beforeValue(false);\n  out.name(name);\n  return this;\n}\n\npublic void close() throws IOException {\n  out.close();\n}\n\npublic void flush() throws IOException {",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.nullValue();\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.object();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.name(name);\n  out.object();\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.array();\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endObject();\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endArray();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  writeDeferredName();\n  out.name(name);\n  return this;\n}\n\npublic JsonWriter value(Object value) throws IOException {\n  if (value == null) {\n    return nullValue();\n  }\n\n  beforeValue(false);\n  JsonWriter writer =",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.nullValue();\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.object();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.name(name);\n  out.object();\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.array();\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endObject();\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endArray();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  writeDeferredName();\n  out.name(name);\n  return this;\n}\n\npublic JsonWriter value(Object value) throws IOException {\n  if (value == null) {\n    return nullValue();\n  }\n  return value(value.toString());\n}\n\n",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.nullValue();\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.object();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.name(name);\n  out.object();\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.array();\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endObject();\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endArray();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  if (name == null) {\n    throw new NullPointerException(\"name\");\n  }\n  writeDeferredName();\n  beforeValue(false);\n  out.name(name);\n  return this;\n}\n\npublic JsonWriter string(String value) throws IOException {\n  ",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.nullValue();\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.object();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.name(name);\n  out.object();\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.array();\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endObject();\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endArray();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  writeDeferredName();\n  beforeValue(false);\n  out.name(name);\n  return this;\n}\n\npublic JsonWriter string(String value) throws IOException {",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.value(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue(false);\n  out.nullValue();\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.object();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.name(name);\n  out.object();\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  beforeValue(true);\n  out.array();\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endObject();\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  deferredName = null;\n  beforeValue(false);\n  out.endArray();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  writeDeferredName();\n  out.name(name);\n  return this;\n}\n\npublic JsonWriter value(Object value) throws IOException {\n  if (value == null) {\n    return nullValue();\n  }\n\n  beforeValue(false);\n  JsonWriter w;"
      ],
      "function range": "493,3-501,3"
    },
    "Gson_17_/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java_99-101": {
      "loc": "99-101",
      "input": "@Override\npublic Date read(JsonReader in) throws IOException {",
      "output": [
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyr",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.data.std",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.Hyr",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n    return new Date(in.nextLong());\n  }\n\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    out.value(value.getTime());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\n/**"
      ],
      "function range": "97,3-113,3"
    },
    "JacksonCore_5_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-194": {
      "loc": "193-194",
      "input": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {",
      "output": [
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        switch (str.charAt(i)) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        switch (str.charAt(i)) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'J':\n            case 'K':\n            case 'L':\n",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        switch (str.charAt(i)) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case '_':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n                return i;\n            default:\n                return -1;\n        }\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        switch (str.charAt(i)) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case '_':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n                return i;\n            default:\n                return -1;\n        }\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        switch (str.charAt(i)) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'K':\n            case 'L':\n",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        switch (str.charAt(i)) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'J':\n            case 'K':\n            case 'M':\n",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        switch (str.charAt(i)) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case '_':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n                return i;\n            default:\n                return -1;\n        }\n    }\n    return -1;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        switch (str.charAt(i)) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case '_':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n                return i;\n            default:\n                return -1;\n        }\n    }\n    return -1;\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        switch (str.charAt(i)) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case '_':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n                return i;\n            default:\n                return -1;\n        }\n    }\n    return -1;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        switch (str.charAt(i)) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case '_':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n                return i;\n            default:\n                return -1;\n        }\n    }\n    return -1;\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements."
      ],
      "function range": "185,5-205,5"
    },
    "JacksonCore_6_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-195": {
      "loc": "193-195",
      "input": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }",
      "output": [
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.alge",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyr",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluator;\nimport org.apache.hyracks.al",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.al"
      ],
      "function range": "185,5-206,5"
    },
    "JacksonCore_8_/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java_307-308": {
      "loc": "307-308",
      "input": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray != null)  return _resultArray;\n    if (_resultString != null) {\n        return (_resultArray = _resultString.toCharArray());\n    }",
      "output": [
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic String getText()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray);\n    return null;\n}\n\npublic String getText(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, 0, length);\n    return null;\n}\n\npublic String getText(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, start, length);\n    return null;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\");",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic String getText()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray);\n    return null;\n}\n\npublic String getText(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, 0, length);\n    return null;\n}\n\npublic String getText(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, start, length);\n    return null;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n *",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic String getText()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray);\n    return null;\n}\n\npublic String getText(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, 0, length);\n    return null;\n}\n\npublic String getText(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, start, length);\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic String getText()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray);\n    return null;\n}\n\npublic String getText(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, 0, length);\n    return null;\n}\n\npublic String getText(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, start, length);\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic String getText()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray);\n    return null;\n}\n\npublic String getText(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, 0, length);\n    return null;\n}\n\npublic String getText(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, start, length);\n    return null;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic String getText()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray);\n    return null;\n}\n\npublic String getText(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, 0, length);\n    return null;\n}\n\npublic String getText(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, start, length);\n    return null;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\");",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic String getText()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray);\n    return null;\n}\n\npublic String getText(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, 0, length);\n    return null;\n}\n\npublic String getText(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, start, length);\n    return null;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic String getText()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray);\n    return null;\n}\n\npublic String getText(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, 0, length);\n    return null;\n}\n\npublic String getText(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, start, length);\n    return null;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic String getText()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray);\n    return null;\n}\n\npublic String getText(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, 0, length);\n    return null;\n}\n\npublic String getText(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, start, length);\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic char[] getTextBuffer(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}\n\npublic String getText()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray);\n    return null;\n}\n\npublic String getText(int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, 0, length);\n    return null;\n}\n\npublic String getText(int start, int length)\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultString!= null)  return _resultString;\n    if (_resultArray!= null)  return new String(_resultArray, start, length);\n    return null;\n}\n\npublic int getIndex()\n{\n    return _index;\n}\n\npublic void setIndex(int index)\n{\n    _index = index;\n}\n\npublic int getLine()\n{\n    return _line;\n}\n\npublic void setLine(int line)\n{\n    _line = line;\n}\n"
      ],
      "function range": "298,5-310,5"
    },
    "JacksonCore_20_/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java_1330-1331": {
      "loc": "1330-1331",
      "input": "public void writeEmbeddedObject(Object object) throws IOException {",
      "output": [
        "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Boolean) {\n            writeBoolean((Boolean) object);\n        } else if (object instanceof Integer) {\n            writeInt((Integer) object);\n        } else if (object instanceof Long) {\n            writeLong((Long) object);\n        } else if (object instanceof Float) {\n            writeFloat((Float) object);\n        } else if (object instanceof Double) {\n            writeDouble((Double) object);\n        } else if (object instanceof byte[]) {\n            writeBytes((byte[]) object);\n        } else if (object instanceof ByteBuffer) {\n            writeBytes((ByteBuffer) object);\n        } else if (object instanceof BigInteger) {\n            writeBigInteger((BigInteger) object);\n        } else if (object instanceof BigDecimal) {\n            writeBigDecimal((BigDecimal) object);\n        } else if (object instanceof Date) {\n            writeDate((Date) object);\n        } else if (object instanceof UUID) {\n            writeUUID((UUID) object);\n        } else if (object instanceof Timestamp) {\n            writeTimestamp((Timestamp) object);\n        } else if (object instanceof InetAddress) {\n            writeInetAddress((InetAddress) object);\n        } else if (object instanceof GeoPoint) {\n            writeGeoPoint((GeoPoint) object);\n        } else if (object instanceof short[]) {\n            writeShorts((short[]) object);\n        } else if (object instanceof int[]) {\n            writeInts((int[]) object);\n        } else if (object instanceof long[]) {\n            writeLongs((long[]) object);\n        } else if (object instanceof float[]) {\n            writeFloats((float[]) object);\n        } else if (object instanceof double[]) {\n            writeDoubles((double[]) object);\n        } else if (object instanceof boolean[]) {\n            writeBooleans((boolean[]) object);\n        } else if (object instance",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Boolean) {\n            writeBoolean((Boolean) object);\n        } else if (object instanceof Integer) {\n            writeInt((Integer) object);\n        } else if (object instanceof Long) {\n            writeLong((Long) object);\n        } else if (object instanceof Float) {\n            writeFloat((Float) object);\n        } else if (object instanceof Double) {\n            writeDouble((Double) object);\n        } else if (object instanceof byte[]) {\n            writeBytes((byte[]) object);\n        } else if (object instanceof ByteBuffer) {\n            writeBytes((ByteBuffer) object);\n        } else if (object instanceof BigInteger) {\n            writeBigInteger((BigInteger) object);\n        } else if (object instanceof BigDecimal) {\n            writeBigDecimal((BigDecimal) object);\n        } else if (object instanceof Date) {\n            writeDate((Date) object);\n        } else if (object instanceof UUID) {\n            writeUUID((UUID) object);\n        } else if (object instanceof Timestamp) {\n            writeTimestamp((Timestamp) object);\n        } else if (object instanceof InetAddress) {\n            writeInetAddress((InetAddress) object);\n        } else if (object instanceof GeoPoint) {\n            writeGeoPoint((GeoPoint) object);\n        } else if (object instanceof short[]) {\n            writeShorts((short[]) object);\n        } else if (object instanceof int[]) {\n            writeInts((int[]) object);\n        } else if (object instanceof long[]) {\n            writeLongs((long[]) object);\n        } else if (object instanceof float[]) {\n            writeFloats((float[]) object);\n        } else if (object instanceof double[]) {\n            writeDoubles((double[]) object);\n        } else if (object instanceof String[]) {\n            writeStrings((String[]) object);\n        } else if (object instanceof",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Boolean) {\n            writeBoolean((Boolean) object);\n        } else if (object instanceof Integer) {\n            writeInt((Integer) object);\n        } else if (object instanceof Long) {\n            writeLong((Long) object);\n        } else if (object instanceof Float) {\n            writeFloat((Float) object);\n        } else if (object instanceof Double) {\n            writeDouble((Double) object);\n        } else if (object instanceof byte[]) {\n            writeBytes((byte[]) object);\n        } else if (object instanceof ByteBuffer) {\n            writeBytes((ByteBuffer) object);\n        } else if (object instanceof BigInteger) {\n            writeBigInteger((BigInteger) object);\n        } else if (object instanceof BigDecimal) {\n            writeBigDecimal((BigDecimal) object);\n        } else if (object instanceof Date) {\n            writeDate((Date) object);\n        } else if (object instanceof UUID) {\n            writeUUID((UUID) object);\n        } else if (object instanceof Timestamp) {\n            writeTimestamp((Timestamp) object);\n        } else if (object instanceof InetAddress) {\n            writeInetAddress((InetAddress) object);\n        } else if (object instanceof GeoPoint) {\n            writeGeoPoint((GeoPoint) object);\n        } else if (object instanceof short[]) {\n            writeShorts((short[]) object);\n        } else if (object instanceof int[]) {\n            writeInts((int[]) object);\n        } else if (object instanceof long[]) {\n            writeLongs((long[]) object);\n        } else if (object instanceof float[]) {\n            writeFloats((float[]) object);\n        } else if (object instanceof double[]) {\n            writeDoubles((double[]) object);\n        } else if (object instanceof Map) {\n            writeMap((Map<String, Object>) object);\n        } else if (object instance",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Boolean) {\n            writeBoolean((Boolean) object);\n        } else if (object instanceof Integer) {\n            writeInt((Integer) object);\n        } else if (object instanceof Long) {\n            writeLong((Long) object);\n        } else if (object instanceof Float) {\n            writeFloat((Float) object);\n        } else if (object instanceof Double) {\n            writeDouble((Double) object);\n        } else if (object instanceof byte[]) {\n            writeBytes((byte[]) object);\n        } else if (object instanceof ByteBuffer) {\n            writeBytes((ByteBuffer) object);\n        } else if (object instanceof BigInteger) {\n            writeBigInteger((BigInteger) object);\n        } else if (object instanceof BigDecimal) {\n            writeBigDecimal((BigDecimal) object);\n        } else if (object instanceof Date) {\n            writeDate((Date) object);\n        } else if (object instanceof UUID) {\n            writeUUID((UUID) object);\n        } else if (object instanceof InetAddress) {\n            writeInetAddress((InetAddress) object);\n        } else if (object instanceof OffsetDateTime) {\n            writeOffsetDateTime((OffsetDateTime) object);\n        } else if (object instanceof LocalDate) {\n            writeLocalDate((LocalDate) object);\n        } else if (object instanceof LocalTime) {\n            writeLocalTime((LocalTime) object);\n        } else if (object instanceof LocalDateTime) {\n            writeLocalDateTime((LocalDateTime) object);\n        } else if (object instanceof OffsetTime) {\n            writeOffsetTime((OffsetTime) object);\n        } else if (object instanceof ZonedDateTime) {\n            writeZonedDateTime((ZonedDateTime) object);\n        } else if (object instanceof Duration) {\n            writeDuration((Duration) object);\n        } else if (object instanceof Period) {\n            writePeriod((Period) object);\n",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Boolean) {\n            writeBoolean((Boolean) object);\n        } else if (object instanceof Integer) {\n            writeInt((Integer) object);\n        } else if (object instanceof Long) {\n            writeLong((Long) object);\n        } else if (object instanceof Float) {\n            writeFloat((Float) object);\n        } else if (object instanceof Double) {\n            writeDouble((Double) object);\n        } else if (object instanceof byte[]) {\n            writeBytes((byte[]) object);\n        } else if (object instanceof ByteBuffer) {\n            writeBytes((ByteBuffer) object);\n        } else if (object instanceof BigInteger) {\n            writeBigInteger((BigInteger) object);\n        } else if (object instanceof BigDecimal) {\n            writeBigDecimal((BigDecimal) object);\n        } else if (object instanceof Date) {\n            writeDate((Date) object);\n        } else if (object instanceof UUID) {\n            writeUUID((UUID) object);\n        } else if (object instanceof Timestamp) {\n            writeTimestamp((Timestamp) object);\n        } else if (object instanceof InetAddress) {\n            writeInetAddress((InetAddress) object);\n        } else if (object instanceof GeoPoint) {\n            writeGeoPoint((GeoPoint) object);\n        } else if (object instanceof short[]) {\n            writeShorts((short[]) object);\n        } else if (object instanceof int[]) {\n            writeInts((int[]) object);\n        } else if (object instanceof long[]) {\n            writeLongs((long[]) object);\n        } else if (object instanceof float[]) {\n            writeFloats((float[]) object);\n        } else if (object instanceof double[]) {\n            writeDoubles((double[]) object);\n        } else if (object instanceof byte[][]) {\n            writeBytes((byte[][]) object);\n        } else if (object instance",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Boolean) {\n            writeBoolean((Boolean) object);\n        } else if (object instanceof Integer) {\n            writeInt((Integer) object);\n        } else if (object instanceof Long) {\n            writeLong((Long) object);\n        } else if (object instanceof Float) {\n            writeFloat((Float) object);\n        } else if (object instanceof Double) {\n            writeDouble((Double) object);\n        } else if (object instanceof byte[]) {\n            writeBytes((byte[]) object);\n        } else if (object instanceof ByteBuffer) {\n            writeBytes((ByteBuffer) object);\n        } else if (object instanceof BigInteger) {\n            writeBigInteger((BigInteger) object);\n        } else if (object instanceof BigDecimal) {\n            writeBigDecimal((BigDecimal) object);\n        } else if (object instanceof Date) {\n            writeDate((Date) object);\n        } else if (object instanceof UUID) {\n            writeUUID((UUID) object);\n        } else if (object instanceof Timestamp) {\n            writeTimestamp((Timestamp) object);\n        } else if (object instanceof InetAddress) {\n            writeInetAddress((InetAddress) object);\n        } else if (object instanceof GeoPoint) {\n            writeGeoPoint((GeoPoint) object);\n        } else if (object instanceof short[]) {\n            writeShorts((short[]) object);\n        } else if (object instanceof int[]) {\n            writeInts((int[]) object);\n        } else if (object instanceof long[]) {\n            writeLongs((long[]) object);\n        } else if (object instanceof float[]) {\n            writeFloats((float[]) object);\n        } else if (object instanceof double[]) {\n            writeDoubles((double[]) object);\n        } else if (object instanceof byte[][]) {\n            writeArray((byte[][]) object);\n        } else if (object instance",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Boolean) {\n            writeBoolean((Boolean) object);\n        } else if (object instanceof Integer) {\n            writeInt((Integer) object);\n        } else if (object instanceof Long) {\n            writeLong((Long) object);\n        } else if (object instanceof Float) {\n            writeFloat((Float) object);\n        } else if (object instanceof Double) {\n            writeDouble((Double) object);\n        } else if (object instanceof byte[]) {\n            writeBytes((byte[]) object);\n        } else if (object instanceof ByteBuffer) {\n            writeBytes((ByteBuffer) object);\n        } else if (object instanceof BigInteger) {\n            writeBigInteger((BigInteger) object);\n        } else if (object instanceof BigDecimal) {\n            writeBigDecimal((BigDecimal) object);\n        } else if (object instanceof Date) {\n            writeDate((Date) object);\n        } else if (object instanceof UUID) {\n            writeUUID((UUID) object);\n        } else if (object instanceof Timestamp) {\n            writeTimestamp((Timestamp) object);\n        } else if (object instanceof InetAddress) {\n            writeInetAddress((InetAddress) object);\n        } else if (object instanceof GeoPoint) {\n            writeGeoPoint((GeoPoint) object);\n        } else if (object instanceof short[]) {\n            writeShorts((short[]) object);\n        } else if (object instanceof int[]) {\n            writeInts((int[]) object);\n        } else if (object instanceof long[]) {\n            writeLongs((long[]) object);\n        } else if (object instanceof float[]) {\n            writeFloats((float[]) object);\n        } else if (object instanceof double[]) {\n            writeDoubles((double[]) object);\n        } else if (object instanceof boolean[]) {\n            writeBooleans((boolean[]) object);\n        } else {\n            throw",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Boolean) {\n            writeBoolean((Boolean) object);\n        } else if (object instanceof Integer) {\n            writeInt((Integer) object);\n        } else if (object instanceof Long) {\n            writeLong((Long) object);\n        } else if (object instanceof Float) {\n            writeFloat((Float) object);\n        } else if (object instanceof Double) {\n            writeDouble((Double) object);\n        } else if (object instanceof byte[]) {\n            writeBytes((byte[]) object);\n        } else if (object instanceof ByteBuffer) {\n            writeBytes((ByteBuffer) object);\n        } else if (object instanceof BigInteger) {\n            writeBigInteger((BigInteger) object);\n        } else if (object instanceof BigDecimal) {\n            writeBigDecimal((BigDecimal) object);\n        } else if (object instanceof Date) {\n            writeDate((Date) object);\n        } else if (object instanceof UUID) {\n            writeUUID((UUID) object);\n        } else if (object instanceof Timestamp) {\n            writeTimestamp((Timestamp) object);\n        } else if (object instanceof InetAddress) {\n            writeInetAddress((InetAddress) object);\n        } else if (object instanceof GeoPoint) {\n            writeGeoPoint((GeoPoint) object);\n        } else if (object instanceof short[]) {\n            writeShorts((short[]) object);\n        } else if (object instanceof int[]) {\n            writeInts((int[]) object);\n        } else if (object instanceof long[]) {\n            writeLongs((long[]) object);\n        } else if (object instanceof float[]) {\n            writeFloats((float[]) object);\n        } else if (object instanceof double[]) {\n            writeDoubles((double[]) object);\n        } else if (object instanceof Map) {\n            writeMap((Map<String,?>) object);\n        } else if (object instance",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Boolean) {\n            writeBoolean((Boolean) object);\n        } else if (object instanceof Integer) {\n            writeInt((Integer) object);\n        } else if (object instanceof Long) {\n            writeLong((Long) object);\n        } else if (object instanceof Float) {\n            writeFloat((Float) object);\n        } else if (object instanceof Double) {\n            writeDouble((Double) object);\n        } else if (object instanceof byte[]) {\n            writeBytes((byte[]) object);\n        } else if (object instanceof ByteBuffer) {\n            writeBytes((ByteBuffer) object);\n        } else if (object instanceof BigInteger) {\n            writeBigInteger((BigInteger) object);\n        } else if (object instanceof BigDecimal) {\n            writeBigDecimal((BigDecimal) object);\n        } else if (object instanceof Date) {\n            writeDate((Date) object);\n        } else if (object instanceof UUID) {\n            writeUUID((UUID) object);\n        } else if (object instanceof Timestamp) {\n            writeTimestamp((Timestamp) object);\n        } else if (object instanceof InetAddress) {\n            writeInetAddress((InetAddress) object);\n        } else if (object instanceof GeoPoint) {\n            writeGeoPoint((GeoPoint) object);\n        } else if (object instanceof short[]) {\n            writeShorts((short[]) object);\n        } else if (object instanceof int[]) {\n            writeInts((int[]) object);\n        } else if (object instanceof long[]) {\n            writeLongs((long[]) object);\n        } else if (object instanceof float[]) {\n            writeShorts((float[]) object);\n        } else if (object instanceof double[]) {\n            writeDoubles((double[]) object);\n        } else if (object instanceof boolean[]) {\n            writeBooleans((boolean[]) object);\n        } else if (object instance",
        "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Boolean) {\n            writeBoolean((Boolean) object);\n        } else if (object instanceof Integer) {\n            writeInt((Integer) object);\n        } else if (object instanceof Long) {\n            writeLong((Long) object);\n        } else if (object instanceof Float) {\n            writeFloat((Float) object);\n        } else if (object instanceof Double) {\n            writeDouble((Double) object);\n        } else if (object instanceof byte[]) {\n            writeBytes((byte[]) object);\n        } else if (object instanceof ByteBuffer) {\n            writeBytes((ByteBuffer) object);\n        } else if (object instanceof BigInteger) {\n            writeBigInteger((BigInteger) object);\n        } else if (object instanceof BigDecimal) {\n            writeBigDecimal((BigDecimal) object);\n        } else if (object instanceof Date) {\n            writeDate((Date) object);\n        } else if (object instanceof UUID) {\n            writeUUID((UUID) object);\n        } else if (object instanceof Timestamp) {\n            writeTimestamp((Timestamp) object);\n        } else if (object instanceof InetAddress) {\n            writeInetAddress((InetAddress) object);\n        } else if (object instanceof GeoPoint) {\n            writeGeoPoint((GeoPoint) object);\n        } else if (object instanceof short[]) {\n            writeShorts((short[]) object);\n        } else if (object instanceof int[]) {\n            writeInts((int[]) object);\n        } else if (object instanceof long[]) {\n            writeLongs((long[]) object);\n        } else if (object instanceof float[]) {\n            writeShorts((float[]) object);\n        } else if (object instanceof double[]) {\n            writeDoubles((double[]) object);\n        } else if (object instanceof boolean[]) {\n            writeShorts((boolean[]) object);\n        } else if (object instance"
      ],
      "function range": "1328,5-1332,5"
    },
    "JacksonCore_25_/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java_1963-1964": {
      "loc": "1963-1964",
      "input": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;",
      "output": [
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _handleOddName(outBuf, outPtr);\n}\n\nprotected String _handleOddName3(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _handleOddName",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _handleOddName(startPtr, hash, outBuf, outPtr);\n}\n\nprotected String _handleOddName3(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _handleOddName(startPtr, hash, outBuf, outPtr);\n}\n\nprivate String _handleOddName3(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _handleOddName(outBuf, outPtr);\n}\n\nprotected String _handleOddName3(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    return _handleOddName(outBuf, outPtr);\n}\n\nprotected",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _handleOddName(startPtr, hash, outBuf, outPtr);\n}\n\nprotected String _handleOddName3(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    return _handleOddName(startPtr, hash, outB",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _handleOddName(startPtr, hash, outBuf, outPtr);\n}\n\nprivate String _handleOddName3(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    return _handleOddName(startPtr, hash, outB",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _handleOddName(startPtr, hash, outBuf, outPtr);\n}\n\nprotected String _handleOddName3(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    if",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _handleOddName(outBuf, outPtr);\n}\n\nprotected String _handleOddName3(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    if (outPtr == 0",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _handleOddName(startPtr, hash, outBuf, outPtr);\n}\n\nprivate String _handleOddName3(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    if",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _handleOddName(outBuf, outPtr);\n}\n\nprotected String _handleOddName3(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        else {\n            break;\n        }\n        ++_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    if (_inputPtr < _"
      ],
      "function range": "1948,5-1990,5"
    },
    "JacksonDatabind_12_/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java_303-304": {
      "loc": "303-304",
      "input": "@Override\npublic boolean isCachable() {",
      "output": [
        "@Override\npublic boolean isCachable() {\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class Global",
        "@Override\npublic boolean isCachable() {\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long serialVersionUID",
        "@Override\npublic boolean isCachable() {\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class LocalSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long serialVersionUID =",
        "@Override\npublic boolean isCachable() {\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class Local",
        "@Override\npublic boolean isCachable() {\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class MaxAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long serialVersionUID = 1",
        "@Override\npublic boolean isCachable() {\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class S",
        "@Override\npublic boolean isCachable() {\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long serialVersion",
        "@Override\npublic boolean isCachable() {\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.serializable.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractSerializableAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAggregateEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;",
        "@Override\npublic boolean isCachable() {\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class Max",
        "@Override\npublic boolean isCachable() {\n    return true;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class Intermediate"
      ],
      "function range": "298,5-305,5"
    },
    "JacksonDatabind_16_/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java_112-113": {
      "loc": "112-113",
      "input": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);",
      "output": [
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous == null) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarE",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous == null) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarE",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous == null) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous == null) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    if (previous!= null) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvalu"
      ],
      "function range": "107,5-113,5"
    },
    "JacksonDatabind_17_/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java_180-181": {
      "loc": "180-181",
      "input": "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()",
      "output": [
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evalu",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyr",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IF",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.functions",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    case NON_CONCRETE_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete() &&!t.isArrayType());\n    default:\n        return false;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRow"
      ],
      "function range": "167,9-193,9"
    },
    "JacksonDatabind_27_/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java_794-795": {
      "loc": "794-795",
      "input": "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {",
      "output": [
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            tokens.writeFieldName(propName);\n            creatorProp.deserializeAndSet(p, ctxt, buffer);\n        } else {\n            tokens.writeString(propName);\n            tokens.writeString(p.getText());\n        }\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    tokens.writeEndObject();\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            tokens.writeFieldName(propName);\n            creatorProp.deserializeAndSet(p, ctxt, buffer);\n        } else {\n            tokens.writeString(propName);\n            tokens.writeString(p.getText());\n        }\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \"expected closing END_ARRAY\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \"expected closing END_ARRAY\");\n    }\n    t = p.nextToken();\n    ",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            tokens.writeFieldName(propName);\n            creatorProp.deserializeAndSet(p, ctxt, buffer);\n        } else {\n            tokens.writeString(propName);\n            tokens.writeString(p.getText());\n        }\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    ",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            tokens.writeFieldName(propName);\n            creatorProp.deserializeAndSet(p, ctxt, buffer);\n        } else {\n            tokens.writeString(propName);\n            tokens.writeString(p.getText());\n        }\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    tokens.writeEndObject();\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \"expected closing END_ARRAY\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \"expected closing END_ARRAY\");\n    }\n",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            tokens.writeFieldName(propName);\n            creatorProp.deserializeAndSet(p, ctxt, buffer);\n        } else {\n            tokens.writeString(propName);\n            tokens.writeString(p.getText());\n        }\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \"expected closing END_ARRAY\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \"expected closing END_ARRAY\");\n    }\n    t = p.nextToken();\n    ",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            tokens.writeFieldName(propName);\n            creatorProp.deserializeAndSet(p, ctxt, buffer);\n        } else {\n            tokens.writeString(propName);\n            tokens.writeString(p.getText());\n        }\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \"expected closing END_ARRAY\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \"expected closing END_ARRAY\");\n    }\n    _externalTypeIdHandler.end(ext",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            tokens.writeFieldName(propName);\n            creatorProp.deserializeAndSet(p, ctxt, buffer);\n        } else {\n            tokens.writeString(propName);\n            tokens.writeString(p.getText());\n        }\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    _externalTypeIdHandler.end(ext",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            tokens.writeFieldName(propName);\n            creatorProp.deserializeAndSet(p, ctxt, buffer);\n        } else {\n            tokens.writeString(propName);\n            tokens.writeString(p.getText());\n        }\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \"expected closing END_ARRAY\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \"expected closing END_ARRAY\");\n    }\n    _externalTypeIdHandler.finish(",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            tokens.writeFieldName(propName);\n            creatorProp.deserializeAndSet(p, ctxt, buffer);\n        } else {\n            tokens.writeString(propName);\n            tokens.writeString(p.getText());\n        }\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    _externalTypeIdHandler.finish(",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            tokens.writeFieldName(propName);\n            creatorProp.deserializeAndSet(p, ctxt, buffer);\n        } else {\n            tokens.writeString(propName);\n            tokens.writeString(p.getText());\n        }\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \"expected closing END_OBJECT\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \"expected closing END_ARRAY\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \"expected closing END_ARRAY\");\n    }\n    _externalTypeIdHandler.end(ext"
      ],
      "function range": "773,5-857,5"
    },
    "JacksonDatabind_33_/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java_748-749": {
      "loc": "748-749",
      "input": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg != null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann != null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)",
      "output": [
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return new PropertyName(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return new PropertyName(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForDeserialization(AnnotatedMember a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return new PropertyName(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonDeserialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return new PropertyName(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForDeserialization(AnnotatedMember a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return new PropertyName(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return new PropertyName(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForDeserialization(AnnotatedMember am)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(am, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(am, JsonProperty.class",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return new PropertyName(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return new PropertyName(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForDeserialization(AnnotatedMember am)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(am, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(am",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(AnnotatedMember a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(AnnotatedMember a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty p",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonDeserialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(AnnotatedMember a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAn",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(AnnotatedMember am)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(am, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty p",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(AnnotatedMember am)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(am, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonIgnore.class)) {\n            name = a.getName();\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(AnnotatedClass ac)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(ac, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty p"
      ],
      "function range": "730,5-755,5"
    },
    "JacksonDatabind_34_/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java_81-82": {
      "loc": "81-82",
      "input": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {",
      "output": [
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Byte.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == Short.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Integer.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INTEGER);\n        } else if (h == Long.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Float.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Double.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Number.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Byte.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == Short.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Integer.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Long.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Float.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Double.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Number.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.NUM",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Long.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Integer.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Short.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Byte.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == Double.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Number.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.NUM",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Byte.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == Short.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Integer.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INTEGER);\n        } else if (h == Long.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Float.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Double.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Byte.TYPE) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Byte.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == Short.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Integer.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INTEGER);\n        } else if (h == Long.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Float.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Double.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Double.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Integer.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INTEGER);\n        } else if (h == Short.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INTEGER);\n        } else if (h == Byte.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INTEGER);\n        } else if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Byte.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == Short.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Integer.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INTEGER);\n        } else if (h == Long.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Float.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Double.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Double.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == Float.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Long.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Integer.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INTEGER);\n        } else if (h == Short.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INTEGER);\n        } else if (h == Byte.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INTEGER);\n        } else if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Number.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Byte.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == Short.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Integer.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INTEGER);\n        } else if (h == Long.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Float.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Double.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INTEGER);\n        }",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Byte.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == Short.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Integer.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INTEGER);\n        } else if (h == Long.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Float.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Double.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.NUMBER);\n        }\n"
      ],
      "function range": "73,5-87,5"
    },
    "JacksonDatabind_37_/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java_135-136": {
      "loc": "135-136",
      "input": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }",
      "output": [
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    else {\n        return super._narrow(subclass);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.H",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    else {\n        return super._narrow(subclass);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    else {\n        return super._narrow(subclass);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    else {\n        return super._narrow(subclass);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    else {\n        return super._narrow(subclass);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.I",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    else {\n        return super._narrow(subclass);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    else {\n        return super._narrow(subclass);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.data.std.api.IPointable;\nimport org.apache",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    else {\n        return super._narrow(subclass);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAgg",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    else {\n        return super._narrow(subclass);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.api.exceptions.Hyracks",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    else {\n        return super._narrow(subclass);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.data.std.api.IPointable;\n\npublic class N"
      ],
      "function range": "119,5-137,5"
    },
    "JacksonDatabind_45_/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java_63-64": {
      "loc": "63-64",
      "input": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property != null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format != null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }",
      "output": [
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregate",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateE",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\n",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\n"
      ],
      "function range": "49,5-81,5"
    },
    "JacksonDatabind_46_/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java_156-157": {
      "loc": "156-157",
      "input": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);",
      "output": [
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvalu",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.Hyr",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\n",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEval",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\n",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\n",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport"
      ],
      "function range": "150,5-158,5"
    },
    "JacksonDatabind_57_/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java_1441-1442": {
      "loc": "1441-1442",
      "input": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders != null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }",
      "output": [
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _findAndReadValues(src, offset, length, false);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected MappingIterator<JsonNode> _findAndReadValues(byte[] src, int offset, int length,\n            boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        JsonParser jp = _createParser(src, offset, length, needsCopy);\n        return _findAndReadValues(jp);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, false);\n        }\n        return _findAndReadValues(jp, false);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _detectBindAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _findAndReadValues(src, offset, length, false);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected MappingIterator<JsonNode> _findAndReadValues(byte[] src, int offset, int length,\n            boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        JsonParser jp = _createParser(src, offset, length, needsCopy);\n        return _findAndReadValues(jp);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, false);\n        }\n        return _findAndReadValues(jp, false);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _detectBindAndReadValues(JsonParser jp,\n            boolean needsCopy)\n        throws IOException, Json",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _findAndReadValues(src, offset, length, false);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected MappingIterator<JsonNode> _findAndReadValues(byte[] src, int offset, int length,\n            boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        JsonParser jp = _createParser(src, offset, length, needsCopy);\n        return _findAndReadValues(jp);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, false);\n        }\n        return _findAndReadValues(jp, false);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _detectBindAndReadValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _findAndReadValues(src, offset, length, false);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected MappingIterator<JsonNode> _findAndReadValues(byte[] src, int offset, int length,\n            boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        JsonParser jp = _createParser(src, offset, length, needsCopy);\n        return _findAndReadValues(jp);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, false);\n        }\n        return _findAndReadValues(jp, false);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        if",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _findAndReadValues(src, offset, length, false);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected MappingIterator<JsonNode> _findAndReadValues(byte[] src, int offset, int length,\n            boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        JsonParser jp = _createParser(src, offset, length, needsCopy);\n        return _findAndReadValues(jp);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, false);\n        }\n        return _findAndReadValues(jp, false);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n    \n    protected MappingIterator<JsonNode> _detectBindAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcess",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _findAndReadValues(src, offset, length, false);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected MappingIterator<JsonNode> _findAndReadValues(byte[] src, int offset, int length,\n            boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        JsonParser jp = _createParser(src, offset, length, needsCopy);\n        return _findAndReadValues(jp);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, false);\n        }\n        return _findAndReadValues(jp, false);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(byte[] src, int offset, int length,\n            boolean needsCopy)\n        throws IOException,",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _findAndReadValues(src, offset, length, false);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected MappingIterator<JsonNode> _findAndReadValues(byte[] src, int offset, int length,\n            boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        JsonParser jp = _createParser(src, offset, length, needsCopy);\n        return _findAndReadValues(jp);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, false);\n        }\n        return _findAndReadValues(jp, false);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected MappingIterator<JsonNode> _detectBindAndReadValues(JsonParser jp, boolean needsCopy)",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _findAndReadValues(src, offset, length, false);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected MappingIterator<JsonNode> _findAndReadValues(byte[] src, int offset, int length,\n            boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        JsonParser jp = _createParser(src, offset, length, needsCopy);\n        return _findAndReadValues(jp);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, false);\n        }\n        return _findAndReadValues(jp, false);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected MappingIterator<JsonNode> _detectBindAndReadValues(JsonParser jp, boolean needsCopy)\n",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _findAndReadValues(src, offset, length, false);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected MappingIterator<JsonNode> _findAndReadValues(byte[] src, int offset, int length,\n            boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        JsonParser jp = _createParser(src, offset, length, needsCopy);\n        return _findAndReadValues(jp);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, false);\n        }\n        return _findAndReadValues(jp, false);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        return",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _findAndReadValues(src, offset, length, false);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected MappingIterator<JsonNode> _findAndReadValues(byte[] src, int offset, int length,\n            boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        JsonParser jp = _createParser(src, offset, length, needsCopy);\n        return _findAndReadValues(jp);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, false);\n        }\n        return _findAndReadValues(jp, false);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _findAndReadValues(JsonParser jp, boolean needsCopy)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders!= null) {\n            return _detectBindAndReadValues(jp, needsCopy);\n        }\n        return _findAndReadValues(jp, needsCopy);\n    }\n\n    protected MappingIterator<JsonNode> _detectBindAndReadValues(JsonParser jp,\n            boolean needsCopy) throws IOException, JsonProcessingException"
      ],
      "function range": "1435,5-1443,5"
    },
    "JacksonDatabind_70_/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java_440-441": {
      "loc": "440-441",
      "input": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {",
      "output": [
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (prop.equals(propToRm)) {\n                found = true;\n            } else {\n                props.add(prop);\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (prop.equals(propToRm)) {\n                found = true;\n            } else {\n                props.add(prop);\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (prop.equals",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (prop.equals(propToRm)) {\n                found = true;\n            } else {\n                props.add(prop);\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (prop.equals(propToRm)) {\n                found = true;\n            } else {\n                props.add(prop);\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n        }\n",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (prop.equals(propToRm)) {\n                found = true;\n            } else {\n                props.add(prop);\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (prop.equals(propToRm)) {\n                found = true;\n            } else {\n                props.add(prop);\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (prop.equals(propToRm)) {\n                found = true;\n            } else {\n                props.add(prop);\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        for (int j = 0",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (prop.equals(propToRm)) {\n                found = true;\n            } else {\n                props.add(prop);\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop!= null) {\n            props.add(prop);\n        }\n    }",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (prop.equals(propToRm)) {\n                found = true;\n            } else {\n                props.add(prop);\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            _hashArea[i] = null;\n            ",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (prop.equals(propToRm)) {\n                found = true;\n            } else {\n                props.add(prop);\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            _hashArea[i] = null;\n        ",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (prop.equals(propToRm)) {\n                found = true;\n            } else {\n                props.add(prop);\n            }\n        } else {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = (SettableBeanProperty) props.get(i);\n        if (prop.equals(propToRm)) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        props.add(prop"
      ],
      "function range": "426,5-453,5"
    },
    "JacksonDatabind_71_/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java_75-76": {
      "loc": "75-76",
      "input": "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;",
      "output": [
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == String.class) {\n        kind = STRING;\n    } else if (raw == Boolean.class) {\n        kind = BOOLEAN;\n    } else if (raw == Character.class) {\n        kind = CHARACTER;\n    } else if (raw == Byte.class) {\n        kind = BYTE;\n    } else if (raw == Short.class) {\n        kind = SHORT;\n    } else if (raw == Integer.class) {\n        kind = INTEGER;\n    } else if (raw == Long.class) {\n        kind = LONG;\n    } else if (raw == Float.class) {\n        kind = FLOAT;\n    } else if (raw == Double.class) {\n        kind = DOUBLE;\n    } else if (raw == BigInteger.class) {\n        kind = BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = BIG_DECIMAL;\n    } else if (raw == Date.class) {\n        kind = DATE;\n    } else if (raw == Calendar.class) {\n        kind = CALENDAR;\n    } else if (raw == UUID.class) {\n        kind = UUID;\n    } else if (raw == InetAddress.class) {\n        kind = INET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = INET4_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = INET6_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = INET_SOCKET_ADDRESS;\n    } else if (raw == URI.class) {\n        kind = URI;\n    } else if (raw == URL.class) {\n        kind = URL;\n    } else if (raw == Locale.class) {\n        kind = LOCALE;\n    } else if (raw == Class.class) {\n        kind = CLASS;\n    } else",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == String.class) {\n        kind = STRING;\n    } else if (raw == Boolean.class) {\n        kind = BOOLEAN;\n    } else if (raw == Character.class) {\n        kind = CHARACTER;\n    } else if (raw == Byte.class) {\n        kind = BYTE;\n    } else if (raw == Short.class) {\n        kind = SHORT;\n    } else if (raw == Integer.class) {\n        kind = INTEGER;\n    } else if (raw == Long.class) {\n        kind = LONG;\n    } else if (raw == Float.class) {\n        kind = FLOAT;\n    } else if (raw == Double.class) {\n        kind = DOUBLE;\n    } else if (raw == BigInteger.class) {\n        kind = BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = BIG_DECIMAL;\n    } else if (raw == Date.class) {\n        kind = DATE;\n    } else if (raw == Calendar.class) {\n        kind = CALENDAR;\n    } else if (raw == UUID.class) {\n        kind = UUID;\n    } else if (raw == InetAddress.class) {\n        kind = INET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = INET4_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = INET6_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = INET_SOCKET_ADDRESS;\n    } else if (raw == URI.class) {\n        kind = URI;\n    } else if (raw == URL.class) {\n        kind = URL;\n    } else if (raw == File.class) {\n        kind = FILE;\n    } else if (raw == FileInputStream.class) {\n        kind = FILE_INPUT_ST",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == String.class) {\n        kind = STRING;\n    } else if (raw == Boolean.class) {\n        kind = BOOLEAN;\n    } else if (raw == Character.class) {\n        kind = CHARACTER;\n    } else if (raw == Byte.class) {\n        kind = BYTE;\n    } else if (raw == Short.class) {\n        kind = SHORT;\n    } else if (raw == Integer.class) {\n        kind = INTEGER;\n    } else if (raw == Long.class) {\n        kind = LONG;\n    } else if (raw == Float.class) {\n        kind = FLOAT;\n    } else if (raw == Double.class) {\n        kind = DOUBLE;\n    } else if (raw == BigInteger.class) {\n        kind = BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = BIG_DECIMAL;\n    } else if (raw == Date.class) {\n        kind = DATE;\n    } else if (raw == Calendar.class) {\n        kind = CALENDAR;\n    } else if (raw == UUID.class) {\n        kind = UUID;\n    } else if (raw == InetAddress.class) {\n        kind = INET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = INET4_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = INET6_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = INET_SOCKET_ADDRESS;\n    } else if (raw == URI.class) {\n        kind = URI;\n    } else if (raw == URL.class) {\n        kind = URL;\n    } else if (raw == File.class) {\n        kind = FILE;\n    } else if (raw == Class.class) {\n        kind = CLASS;\n    } else if (",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == String.class) {\n        kind = STRING;\n    } else if (raw == Boolean.class) {\n        kind = BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = BYTE;\n    } else if (raw == Character.class) {\n        kind = CHARACTER;\n    } else if (raw == Short.class) {\n        kind = SHORT;\n    } else if (raw == Integer.class) {\n        kind = INTEGER;\n    } else if (raw == Long.class) {\n        kind = LONG;\n    } else if (raw == Float.class) {\n        kind = FLOAT;\n    } else if (raw == Double.class) {\n        kind = DOUBLE;\n    } else if (raw == BigInteger.class) {\n        kind = BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = BIG_DECIMAL;\n    } else if (raw == Date.class) {\n        kind = DATE;\n    } else if (raw == Calendar.class) {\n        kind = CALENDAR;\n    } else if (raw == UUID.class) {\n        kind = UUID;\n    } else if (raw == InetAddress.class) {\n        kind = INET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = INET4_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = INET6_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = INET_SOCKET_ADDRESS;\n    } else if (raw == URI.class) {\n        kind = URI;\n    } else if (raw == URL.class) {\n        kind = URL;\n    } else if (raw == File.class) {\n        kind = FILE;\n    } else if (raw == FileInputStream.class) {\n        kind = FILE_INPUT_ST",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == String.class) {\n        kind = STRING;\n    } else if (raw == Boolean.class) {\n        kind = BOOLEAN;\n    } else if (raw == Character.class) {\n        kind = CHARACTER;\n    } else if (raw == Byte.class) {\n        kind = BYTE;\n    } else if (raw == Short.class) {\n        kind = SHORT;\n    } else if (raw == Integer.class) {\n        kind = INTEGER;\n    } else if (raw == Long.class) {\n        kind = LONG;\n    } else if (raw == Float.class) {\n        kind = FLOAT;\n    } else if (raw == Double.class) {\n        kind = DOUBLE;\n    } else if (raw == BigInteger.class) {\n        kind = BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = BIG_DECIMAL;\n    } else if (raw == Date.class) {\n        kind = DATE;\n    } else if (raw == Calendar.class) {\n        kind = CALENDAR;\n    } else if (raw == UUID.class) {\n        kind = UUID;\n    } else if (raw == InetAddress.class) {\n        kind = INET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = INET4_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = INET6_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = INET_SOCKET_ADDRESS;\n    } else if (raw == URI.class) {\n        kind = URI;\n    } else if (raw == URL.class) {\n        kind = URL;\n    } else if (raw == File.class) {\n        kind = FILE;\n    } else if (raw == Path.class) {\n        kind = PATH;\n    } else if (",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == String.class) {\n        kind = STRING;\n    } else if (raw == Boolean.class) {\n        kind = BOOLEAN;\n    } else if (raw == Character.class) {\n        kind = CHARACTER;\n    } else if (raw == Byte.class) {\n        kind = BYTE;\n    } else if (raw == Short.class) {\n        kind = SHORT;\n    } else if (raw == Integer.class) {\n        kind = INTEGER;\n    } else if (raw == Long.class) {\n        kind = LONG;\n    } else if (raw == Float.class) {\n        kind = FLOAT;\n    } else if (raw == Double.class) {\n        kind = DOUBLE;\n    } else if (raw == BigInteger.class) {\n        kind = BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = BIG_DECIMAL;\n    } else if (raw == Date.class) {\n        kind = DATE;\n    } else if (raw == Calendar.class) {\n        kind = CALENDAR;\n    } else if (raw == UUID.class) {\n        kind = UUID;\n    } else if (raw == InetAddress.class) {\n        kind = INET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = INET4_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = INET6_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = INET_SOCKET_ADDRESS;\n    } else if (raw == URI.class) {\n        kind = URI;\n    } else if (raw == URL.class) {\n        kind = URL;\n    } else if (raw == Pattern.class) {\n        kind = PATTERN;\n    } else if (raw == File.class) {\n        kind = FILE;\n    } else if",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == String.class) {\n        kind = STRING;\n    } else if (raw == Boolean.class) {\n        kind = BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = BYTE;\n    } else if (raw == Character.class) {\n        kind = CHARACTER;\n    } else if (raw == Short.class) {\n        kind = SHORT;\n    } else if (raw == Integer.class) {\n        kind = INTEGER;\n    } else if (raw == Long.class) {\n        kind = LONG;\n    } else if (raw == Float.class) {\n        kind = FLOAT;\n    } else if (raw == Double.class) {\n        kind = DOUBLE;\n    } else if (raw == BigInteger.class) {\n        kind = BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = BIG_DECIMAL;\n    } else if (raw == Date.class) {\n        kind = DATE;\n    } else if (raw == Calendar.class) {\n        kind = CALENDAR;\n    } else if (raw == UUID.class) {\n        kind = UUID;\n    } else if (raw == InetAddress.class) {\n        kind = INET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = INET4_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = INET6_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = INET_SOCKET_ADDRESS;\n    } else if (raw == URI.class) {\n        kind = URI;\n    } else if (raw == URL.class) {\n        kind = URL;\n    } else if (raw == File.class) {\n        kind = FILE;\n    } else if (raw == Class.class) {\n        kind = CLASS;\n    } else if (",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == String.class) {\n        kind = STRING;\n    } else if (raw == Boolean.class) {\n        kind = BOOLEAN;\n    } else if (raw == Character.class) {\n        kind = CHARACTER;\n    } else if (raw == Byte.class) {\n        kind = BYTE;\n    } else if (raw == Short.class) {\n        kind = SHORT;\n    } else if (raw == Integer.class) {\n        kind = INTEGER;\n    } else if (raw == Long.class) {\n        kind = LONG;\n    } else if (raw == Float.class) {\n        kind = FLOAT;\n    } else if (raw == Double.class) {\n        kind = DOUBLE;\n    } else if (raw == BigInteger.class) {\n        kind = BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = BIG_DECIMAL;\n    } else if (raw == Date.class) {\n        kind = DATE;\n    } else if (raw == Calendar.class) {\n        kind = CALENDAR;\n    } else if (raw == UUID.class) {\n        kind = UUID;\n    } else if (raw == InetAddress.class) {\n        kind = INET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = INET4_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = INET6_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = INET_SOCKET_ADDRESS;\n    } else if (raw == URI.class) {\n        kind = URI;\n    } else if (raw == URL.class) {\n        kind = URL;\n    } else if (raw == Locale.class) {\n        kind = LOCALE;\n    } else if (raw == Currency.class) {\n        kind = CURRENCY;\n    ",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == String.class) {\n        kind = STRING;\n    } else if (raw == Boolean.class) {\n        kind = BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = BYTE;\n    } else if (raw == Character.class) {\n        kind = CHARACTER;\n    } else if (raw == Short.class) {\n        kind = SHORT;\n    } else if (raw == Integer.class) {\n        kind = INTEGER;\n    } else if (raw == Long.class) {\n        kind = LONG;\n    } else if (raw == Float.class) {\n        kind = FLOAT;\n    } else if (raw == Double.class) {\n        kind = DOUBLE;\n    } else if (raw == BigInteger.class) {\n        kind = BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = BIG_DECIMAL;\n    } else if (raw == Date.class) {\n        kind = DATE;\n    } else if (raw == Calendar.class) {\n        kind = CALENDAR;\n    } else if (raw == UUID.class) {\n        kind = UUID;\n    } else if (raw == InetAddress.class) {\n        kind = INET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = INET4_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = INET6_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = INET_SOCKET_ADDRESS;\n    } else if (raw == URI.class) {\n        kind = URI;\n    } else if (raw == URL.class) {\n        kind = URL;\n    } else if (raw == Pattern.class) {\n        kind = PATTERN;\n    } else if (raw == File.class) {\n        kind = FILE;\n    } else if",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == String.class) {\n        kind = STRING;\n    } else if (raw == Boolean.class) {\n        kind = BOOLEAN;\n    } else if (raw == Character.class) {\n        kind = CHARACTER;\n    } else if (raw == Byte.class) {\n        kind = BYTE;\n    } else if (raw == Short.class) {\n        kind = SHORT;\n    } else if (raw == Integer.class) {\n        kind = INTEGER;\n    } else if (raw == Long.class) {\n        kind = LONG;\n    } else if (raw == Float.class) {\n        kind = FLOAT;\n    } else if (raw == Double.class) {\n        kind = DOUBLE;\n    } else if (raw == BigInteger.class) {\n        kind = BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = BIG_DECIMAL;\n    } else if (raw == Date.class) {\n        kind = DATE;\n    } else if (raw == Calendar.class) {\n        kind = CALENDAR;\n    } else if (raw == UUID.class) {\n        kind = UUID;\n    } else if (raw == InetAddress.class) {\n        kind = INET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = INET4_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = INET6_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = INET_SOCKET_ADDRESS;\n    } else if (raw == URI.class) {\n        kind = URI;\n    } else if (raw == URL.class) {\n        kind = URL;\n    } else if (raw == Pattern.class) {\n        kind = PATTERN;\n    } else if (raw == Locale.class) {\n        kind = LOCALE;\n    }"
      ],
      "function range": "70,5-116,5"
    },
    "JacksonDatabind_76_/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java_583-604": {
      "loc": "583-604",
      "input": "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {",
      "output": [
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            Object value = creatorProp.deserialize(p, ctxt);\n            buffer.assignParameter(creatorProp.getCreatorIndex(), value);\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    tokens.writeEndObject();\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OB",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            Object value = creatorProp.deserialize(p, ctxt);\n            buffer.assignParameter(creatorProp.getCreatorIndex(), value);\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    tokens.writeEndObject();\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                \"expected END_ARRAY after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_AR",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            Object value = creatorProp.deserialize(p, ctxt);\n            buffer.assignParameter(creatorProp.getCreatorIndex(), value);\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    tokens.writeEndObject();\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                \"expected END_ARRAY after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after END_ARRAY\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            Object value = creatorProp.deserialize(p, ctxt);\n            buffer.assignParameter(creatorProp.getCreatorIndex(), value);\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    tokens.writeEndObject();\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= null) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            Object value = creatorProp.deserialize(p, ctxt);\n            buffer.assignParameter(creatorProp.getCreatorIndex(), value);\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    tokens.writeEndObject();\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                \"expected END_ARRAY after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after END_ARRAY\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_DOCUMENT) {\n        throw ctxt.wrongTokenException(p, JsonToken.",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            Object value = creatorProp.deserialize(p, ctxt);\n            buffer.assignParameter(creatorProp.getCreatorIndex(), value);\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    tokens.writeEndObject();\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= null) {\n        throw ctxt.mappingException(\"Unexpected token \"+t);\n    }\n    return buffer.complete();",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            Object value = creatorProp.deserialize(p, ctxt);\n            buffer.assignParameter(creatorProp.getCreatorIndex(), value);\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    tokens.writeEndObject();\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= null) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n                \"expected no",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            Object value = creatorProp.deserialize(p, ctxt);\n            buffer.assignParameter(creatorProp.getCreatorIndex(), value);\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    tokens.writeEndObject();\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                \"expected END_ARRAY after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OB",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            Object value = creatorProp.deserialize(p, ctxt);\n            buffer.assignParameter(creatorProp.getCreatorIndex(), value);\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    tokens.writeEndObject();\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                \"expected END_ARRAY after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after END_ARRAY\");\n    }\n    t = p.nextToken();\n    if (t!= null) {\n        throw ctxt.mappingException(\"Unexpected token \"+t);\n    }\n    return buffer.",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n            Object value = creatorProp.deserialize(p, ctxt);\n            buffer.assignParameter(creatorProp.getCreatorIndex(), value);\n        } else {\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n    }\n    tokens.writeEndObject();\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                \"expected END_ARRAY after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_OBJECT) {\n        throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, \n                \"expected END_OBJECT after property values\");\n    }\n    t = p.nextToken();\n    if (t!= JsonToken.END_ARRAY) {\n        throw ctxt.mappingException(\"Unexpected token \"+t);\n    }"
      ],
      "function range": "565,5-637,5"
    },
    "JacksonDatabind_82_/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java_495-496": {
      "loc": "495-496",
      "input": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n            ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n            .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);",
      "output": [
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getKnownPropertyNames();\n        } else {\n            ignored = null;\n        }\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            ignored.add(prop.getName());\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getKnownPropertyNames();\n        } else {\n            ignored = null;\n        }\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            ignored.add(prop.getName());\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getKnownPropertyNames();\n        } else {\n            ignored = null;\n        }\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            ignored.add(prop.getName());\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getKnownPropertyNames();\n        } else {\n            ignored = null;\n        }\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            ignored.add(prop.getName());\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getKnownPropertyNames();\n        } else {\n            ignored = null;\n        }\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            ignored.add(prop.getName());\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getKnownPropertyNames();\n        } else {\n            ignored = null;\n        }\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            ignored.add(prop.getName());\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getKnownPropertyNames();\n        } else {\n            ignored = null;\n        }\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            ignored.add(prop.getName());\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getKnownPropertyNames();\n        } else {\n            ignored = null;\n        }\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            ignored.add(prop.getName());\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getKnownPropertyNames();\n        } else {\n            ignored = null;\n        }\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            ignored.add(prop.getName());\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        if (ignoreAny) {\n            ignored = ignorals.getKnownPropertyNames();\n        } else {\n            ignored = null;\n        }\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            ignored.add(prop.getName());\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the"
      ],
      "function range": "472,5-615,5"
    },
    "JacksonDatabind_93_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java_83-85": {
      "loc": "83-85",
      "input": "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }",
      "output": [
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {\n            break main_check;\n",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(Deserial",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {\n            break main_check;\n        }\n        ",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if (",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n            break main_check;\n        }\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL"
      ],
      "function range": "67,5-99,5"
    },
    "JacksonDatabind_96_/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java_735-736": {
      "loc": "735-736",
      "input": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1 != candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName != null) || (injectId != null);\n    if (!useProps && (paramDef != null)) {",
      "output": [
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    // [databind#################################################################################################################################################################################################################",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = (paramDef.getName()!= null);\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n\n    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = (paramDef",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = (paramDef.getName()!= null);\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n\n    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps) {\n        useProps = (paramDef!= null);\n    }",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = (paramDef.getName()!= null);\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n\n    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (useProps && (paramDef!= null)) {\n        useProps = (paramDef",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = (paramDef.getName()!= null);\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n\n    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = (paramDef.getName()!= null);\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n\n    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps) {\n        if (paramDef!= null) {\n            useProps",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = (paramDef.getName()!= null);\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n\n    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        if (paramDef.getName",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = (paramDef.getName()!= null);\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n\n    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps) {\n        useProps = (paramDef!= null) && (param",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = (paramDef.getName()!= null);\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n\n    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null) && (paramDef.getName()!= null",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = (paramDef.getName()!= null);\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n\n    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        useProps = ((paramDef"
      ],
      "function range": "701,5-752,5"
    },
    "JacksonDatabind_97_/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java_114-115": {
      "loc": "114-115",
      "input": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {",
      "output": [
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer) throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer, JsonToken t)\n    throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer, t);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer) throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer, JsonToken t)\n    throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer, t);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic final JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer) throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer, JsonToken t)\n    throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer, t);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic boolean equals(Object o)\n{\n    if (o == this) return true;\n    if (o == null) return",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer) throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer, JsonToken t)\n    throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer, t);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer) throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer, JsonToken t)\n    throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer, t);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer) throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer, JsonToken t)\n    throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer, t);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  ",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer) throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer, JsonToken t)\n    throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer, t);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  ",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer) throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer, JsonToken t)\n    throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer, t);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic boolean equals(Object o)\n{\n    if (this == o) return true;\n    if (o == null || get",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer) throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer, JsonToken t)\n    throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer, t);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic boolean equals(Object o) {\n    if (o == this) return true;\n    if (o == null) return false",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer) throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer, JsonToken t)\n    throws IOException\n{\n    if (_value == null) {\n        typeSer.writeTypePrefixForNull(gen);\n        gen.writeNull();\n        typeSer.writeTypeSuffixForNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serializeWithType(gen, ctxt, typeSer, t);\n    } else {\n        typeSer.writeTypePrefixForNonNull(gen, _value.getClass());\n        _value.serialize(gen, ctxt);\n        typeSer.writeTypeSuffixForNonNull(gen);\n    }\n}\n\n@Override\npublic String toString()\n{\n    return _value == null? \"null\" : _value.toString();\n}\n}"
      ],
      "function range": "104,5-116,5"
    },
    "JacksonDatabind_98_/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java_298-299": {
      "loc": "298-299",
      "input": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {",
      "output": [
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                values[typeProp.getCreatorIndex()] = values[prop.getCreatorIndex()];\n            }\n        }\n    }\n    return creator.create(values);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId)\n        throws IOException\n    {\n        if (typeId ==",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                values[typeProp.getCreatorIndex()] = values[prop.getCreatorIndex()];\n            }\n        }\n    }\n    return creator.create(values);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId) throws IOException\n    {\n        if (typeId == null) {",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                values[typeProp.getCreatorIndex()] = values[prop.getCreatorIndex()];\n            }\n        }\n    }\n    return creator.create(values);\n}\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId)\n        throws IOException\n    {\n        if (typeId",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                values[typeProp.getCreatorIndex()] = values[prop.getCreatorIndex()];\n            }\n        }\n    }\n    return creator.create(values);\n}\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    protected Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId)\n        throws IOException\n    {\n        if (typeId",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                values[typeProp.getCreatorIndex()] = values[prop.getCreatorIndex()];\n            }\n        }\n    }\n    return creator.create(values);\n}\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId) throws IOException\n    {\n        if (typeId == null)",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, _typeIds[typeProp.getCreatorIndex()]);\n            }\n        }\n    }\n    return creator.create(_beanType, values);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId)\n        throws IOException\n    {\n        if",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, _typeIds[typeProp.getCreatorIndex()]);\n            }\n        }\n    }\n    return creator.create(_beanType, values);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId)\n        throws IOException\n    {\n        //",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, _typeIds[typeProp.getCreatorIndex()]);\n            }\n        }\n    }\n    return creator.create(_beanType, values);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId)\n        throws IOException\n    {\n        final",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, _typeIds[typeProp.getCreatorIndex()]);\n            }\n        }\n    }\n    return creator.create(_beanType, values);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId)\n        throws IOException\n    {\n        J",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, _typeIds[typeProp.getCreatorIndex()]);\n            }\n        }\n    }\n    return creator.create(_beanType, values);\n}\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId)\n        throws IOException\n    {\n        Object"
      ],
      "function range": "255,5-311,5"
    },
    "JacksonDatabind_102_/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java_67-70": {
      "loc": "67-70",
      "input": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{",
      "output": [
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    JsonSerializer<?> ser = super.createContextual(serializers, property);\n    if (ser!= null) {\n        return ser;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, null);\n    if (format == null) {\n        return null;\n    }\n    JsonFormat.Shape shape = format.getShape();\n    if (shape == JsonFormat.Shape.OBJECT) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ANY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.BOOLEAN) {\n        return BooleanSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.BYTE) {\n        return ByteSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.CHARACTER) {\n        return CharacterSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.DATE) {\n        return DateSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.DOUBLE) {\n        return DoubleSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.FLOAT) {\n        return FloatSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.INTEGER) {\n        return IntegerSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.LONG) {\n        return LongSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.NUMBER) {\n        return NumberSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.SHORT) {\n        return ShortSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.STRING) {\n        return StringSerializer.instance;\n    }\n",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    JsonSerializer<?> ser = super.createContextual(serializers, property);\n    if (ser!= null) {\n        return ser;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, null);\n    if (format == null) {\n        return null;\n    }\n    JsonFormat.Shape shape = format.getShape();\n    if (shape == JsonFormat.Shape.OBJECT) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ANY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.BOOLEAN) {\n        return BooleanSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.BYTE) {\n        return ByteSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.CHAR) {\n        return CharacterSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.DATE) {\n        return DateSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.DOUBLE) {\n        return DoubleSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.FLOAT) {\n        return FloatSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.INT) {\n        return IntegerSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.LONG) {\n        return LongSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.NUMBER) {\n        return NumberSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.SHORT) {\n        return ShortSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.STRING) {\n        return StringSerializer.instance;\n    }\n    if (shape",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    JsonSerializer<?> ser = super.createContextual(serializers, property);\n    if (ser!= null) {\n        return ser;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, null);\n    if (format == null) {\n        return null;\n    }\n    JsonFormat.Shape shape = format.getShape();\n    if (shape == JsonFormat.Shape.OBJECT) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ANY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.BOOLEAN) {\n        return BooleanSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.BYTE) {\n        return ByteSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.CHAR) {\n        return CharacterSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.DATE) {\n        return DateSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.DOUBLE) {\n        return DoubleSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.FLOAT) {\n        return FloatSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.INT) {\n        return IntegerSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.LONG) {\n        return LongSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.NUMBER) {\n        return NumberSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.SHORT) {\n        return ShortSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.STRING) {\n        return StringSerializer.instance;\n    }\n    return null;",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    JsonSerializer<?> ser = super.createContextual(serializers, property);\n    if (ser!= null) {\n        return ser;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, null);\n    if (format == null) {\n        return null;\n    }\n    JsonFormat.Shape shape = format.getShape();\n    if (shape == JsonFormat.Shape.OBJECT) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ANY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.BOOLEAN) {\n        return BooleanSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.BYTE) {\n        return ByteSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.CHARACTER) {\n        return CharacterSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.DOUBLE) {\n        return DoubleSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.FLOAT) {\n        return FloatSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.INTEGER) {\n        return IntegerSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.LONG) {\n        return LongSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.NUMBER) {\n        return NumberSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.SHORT) {\n        return ShortSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.STRING) {\n        return StringSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.UNKNOWN) {\n        return null;\n    }\n    throw new Illegal",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    JsonSerializer<?> ser = super.createContextual(serializers, property);\n    if (ser!= null) {\n        return ser;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, null);\n    if (format == null) {\n        return null;\n    }\n    JsonFormat.Shape shape = format.getShape();\n    if (shape == JsonFormat.Shape.OBJECT) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ANY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.BOOLEAN) {\n        return BooleanSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.BYTE) {\n        return ByteSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.CHARACTER) {\n        return CharacterSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.DOUBLE) {\n        return DoubleSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.FLOAT) {\n        return FloatSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.INTEGER) {\n        return IntegerSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.LONG) {\n        return LongSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.NUMBER) {\n        return NumberSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.SHORT) {\n        return ShortSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.STRING) {\n        return StringSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.LOCAL_DATE) {\n        return LocalDateSerializer.instance;",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    JsonSerializer<?> ser = super.createContextual(serializers, property);\n    if (ser!= null) {\n        return ser;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, null);\n    if (format == null) {\n        return null;\n    }\n    JsonFormat.Shape shape = format.getShape();\n    if (shape == JsonFormat.Shape.OBJECT) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ANY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.BOOLEAN) {\n        return BooleanSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.BYTE) {\n        return ByteSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.CHAR) {\n        return CharacterSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.DOUBLE) {\n        return DoubleSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.FLOAT) {\n        return FloatSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.INT) {\n        return IntegerSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.LONG) {\n        return LongSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.NUMBER) {\n        return NumberSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.SHORT) {\n        return ShortSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.STRING) {\n        return StringSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.OBJECT) {\n        return ObjectSerializer.instance;\n    }\n    if (shape",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    JsonSerializer<?> ser = super.createContextual(serializers, property);\n    if (ser!= null) {\n        return ser;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, null);\n    if (format == null) {\n        return null;\n    }\n    JsonFormat.Shape shape = format.getShape();\n    if (shape == JsonFormat.Shape.OBJECT) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ANY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.BOOLEAN) {\n        return BooleanSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.BYTE) {\n        return ByteSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.CHARACTER) {\n        return CharacterSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.DOUBLE) {\n        return DoubleSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.FLOAT) {\n        return FloatSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.INT) {\n        return IntegerSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.LONG) {\n        return LongSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.NUMBER) {\n        return NumberSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.SHORT) {\n        return ShortSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.STRING) {\n        return StringSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.UNKNOWN) {\n        return null;\n    }\n    throw new IllegalStateException",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    JsonSerializer<?> ser = super.createContextual(serializers, property);\n    if (ser!= null) {\n        return ser;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, null);\n    if (format == null) {\n        return null;\n    }\n    JsonFormat.Shape shape = format.getShape();\n    if (shape == JsonFormat.Shape.OBJECT) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ANY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.BOOLEAN) {\n        return BooleanSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.BYTE) {\n        return ByteSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.CHAR) {\n        return CharacterSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.DATE) {\n        return DateSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.DOUBLE) {\n        return DoubleSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.FLOAT) {\n        return FloatSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.INT) {\n        return IntegerSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.LONG) {\n        return LongSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.NUMBER) {\n        return NumberSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.SHORT) {\n        return ShortSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.STRING) {\n        return StringSerializer.instance;\n    }\n    throw new Illegal",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    JsonSerializer<?> ser = super.createContextual(serializers, property);\n    if (ser!= null) {\n        return ser;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, null);\n    if (format == null) {\n        return null;\n    }\n    JsonFormat.Shape shape = format.getShape();\n    if (shape == JsonFormat.Shape.OBJECT) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ANY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.BOOLEAN) {\n        return BooleanSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.BYTE) {\n        return ByteSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.CHARACTER) {\n        return CharacterSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.DATE) {\n        return DateSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.DOUBLE) {\n        return DoubleSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.FLOAT) {\n        return FloatSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.INTEGER) {\n        return IntegerSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.LONG) {\n        return LongSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.NUMBER) {\n        return NumberSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.SHORT) {\n        return ShortSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.STRING) {\n        return StringSerializer.instance;\n    }\n\n",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    JsonSerializer<?> ser = super.createContextual(serializers, property);\n    if (ser!= null) {\n        return ser;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, null);\n    if (format == null) {\n        return null;\n    }\n    JsonFormat.Shape shape = format.getShape();\n    if (shape == JsonFormat.Shape.OBJECT) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.ANY) {\n        return null;\n    }\n    if (shape == JsonFormat.Shape.BOOLEAN) {\n        return BooleanSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.BYTE) {\n        return ByteSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.CHAR) {\n        return CharacterSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.DOUBLE) {\n        return DoubleSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.FLOAT) {\n        return FloatSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.INT) {\n        return IntegerSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.LONG) {\n        return LongSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.NUMBER) {\n        return NumberSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.SHORT) {\n        return ShortSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.STRING) {\n        return StringSerializer.instance;\n    }\n    if (shape == JsonFormat.Shape.UNKNOWN) {\n        return null;\n    }\n    throw new IllegalStateException(\"Un"
      ],
      "function range": "61,5-136,5"
    },
    "JacksonDatabind_107_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java_165-166": {
      "loc": "165-166",
      "input": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { ",
      "output": [
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        JsonDeserializer<?> deser = _findDeserializer(ctxt, property.getType());\n        if (deser!= null) {\n            return deser;\n        }\n        // [databind############################################################################################################################################################################",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, JavaType type)\n        throws IOException\n    {\n        return _findDeserializer(ctxt, type.getRawClass());\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, Class<?> cls)\n        throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(cls);\n        if (deser == null) {\n            deser = ctxt.findContextualValueDeserializer(cls, this);\n            if (deser!= null) {\n                _deserializers.put(cls, deser);\n            }\n        }",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, JavaType type)\n        throws IOException\n    {\n        return _findDeserializer(ctxt, type.getRawClass());\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, Class<?> cls)\n        throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(cls);\n        if (deser == null) {\n            deser = ctxt.findContextualValueDeserializer(cls, this);\n            _deserializers.put(cls, deser);\n        }\n        return deser;\n    }\n}\n",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, JavaType type)\n        throws IOException\n    {\n        return _findDeserializer(ctxt, type.getRawClass());\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, Class<?> cls)\n        throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(cls);\n        if (deser == null) {\n            deser = ctxt.findContextualValueDeserializer(cls, _property);\n            _deserializers.put(cls, deser);\n        }\n        return deser;\n    }\n}\n",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, JavaType type)\n        throws IOException\n    {\n        return _findDeserializer(ctxt, type.getRawClass());\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, Class<?> cls)\n        throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(cls);\n        if (deser == null) {\n            deser = ctxt.findContextualValueDeserializer(cls, this);\n            _deserializers.put(cls, deser);\n        }\n        return deser;\n    }\n\n    /*\n",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, JavaType type)\n        throws IOException\n    {\n        return _findDeserializer(ctxt, type.getRawClass());\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, Class<?> cls)\n        throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(cls);\n        if (deser == null) {\n            deser = ctxt.findContextualValueDeserializer(cls, _property);\n            _deserializers.put(cls, deser);\n        }\n        return deser;\n    }\n\n    /*",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, JavaType type)\n        throws IOException\n    {\n        return _findDeserializer(ctxt, type.getRawClass());\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, Class<?> cls)\n        throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(cls);\n        if (deser == null) {\n            deser = ctxt.findContextualValueDeserializer(cls, this);\n            _deserializers.put(cls, deser);\n        }\n        return deser;\n    }\n    \n    ",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, JavaType type)\n        throws IOException\n    {\n        return _findDeserializer(ctxt, type.getRawClass());\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, Class<?> cls)\n        throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(cls);\n        if (deser == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = ctxt.findContextualValueDeserializer(cls, this);\n            }\n            ",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, JavaType type)\n        throws IOException\n    {\n        return _findDeserializer(ctxt, type.getRawClass());\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, Class<?> cls)\n        throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(cls);\n        if (deser == null) {\n            deser = ctxt.findContextualValueDeserializer(cls, _property);\n            _deserializers.put(cls, deser);\n        }\n        return deser;\n    }\n    \n",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n        throws IOException\n    {\n        return null;\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, JavaType type)\n        throws IOException\n    {\n        return _findDeserializer(ctxt, type.getRawClass());\n    }\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, Class<?> cls)\n        throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(cls);\n        if (deser == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = ctxt.findContextualValueDeserializer(cls, _property);\n            }\n"
      ],
      "function range": "146,5-199,5"
    },
    "JacksonXml_5_/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java_59-60": {
      "loc": "59-60",
      "input": "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);",
      "output": [
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class LocalSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class MaxAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    ",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregateFunctionDynamicDesc",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\n/**",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAggregateDescriptor extends AbstractAggregateFunctionDynamic"
      ],
      "function range": "55,5-60,5"
    },
    "Jsoup_1_/src/main/java/org/jsoup/nodes/Document.java_125-127": {
      "loc": "125-127",
      "input": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);",
      "output": [
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        element.appendChild(node);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\n",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        element.appendChild(node);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEval",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        element.appendChild(node);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        element.appendChild(node);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        element.appendChild(node);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateE",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        element.appendChild(node);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        element.appendChild(node);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluator;\nimport",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        element.appendChild(node);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScal",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        element.appendChild(node);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\n",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        element.appendChild(node);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks."
      ],
      "function range": "113,5-128,5"
    },
    "Jsoup_15_/src/main/java/org/jsoup/parser/TreeBuilderState.java_283-284": {
      "loc": "283-284",
      "input": "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }",
      "output": [
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                tb.transition(InBody);\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                tb.reconstructFormattingElements();\n                tb.transition(InCaption);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                tb.transition(InBody);\n            } else if (name.equals(\"frameset\"))",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                tb.transition(InBody);\n                return tb.process(startTag);\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                return tb.process(startTag);\n            } else if (name.equals(\"body\")) {\n                if (tb.framesetOk()) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                tb.transition(InBody);\n                return tb.process(startTag);\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                return tb.process(startTag);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                tb.transition(InBody);\n                tb.framesetOk(false);\n                return tb",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                tb.transition(InBody);\n                return tb.process(startTag);\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                return tb.process(startTag);\n            } else if (name.equals(\"body\")) {\n                if (!tb.framesetOk()) {\n                    tb.error(this);\n                    return false;\n                }\n                tb.transition",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                tb.transition(InBody);\n                return tb.process(startTag);\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                return tb.process(startTag);\n            } else if (name.equals(\"body\")) {\n                tb.framesetOk(false);\n                return tb.process(startTag);\n            } else if (name.equals(\"frameset\"))",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                tb.transition(InBody);\n                return tb.process(startTag);\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                return tb.process(startTag);\n            } else if (name.equals(\"body\")) {\n                tb.framesetOk(false);\n                return tb.process(startTag);\n            } else if (name.equals(\"head\")) {",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                tb.transition(InBody);\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                tb.reconstructFormattingElements();\n                tb.transition(InCaption);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                tb.transition(InBody);\n            } else if (name.equals(\"br\")) {",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                tb.transition(InBody);\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                tb.insert(startTag);\n                tb.transition(InHead);\n            } else if (name.equals(\"body\")) {\n                if (!tb.inScope(\"body\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                tb.transition(InBody);\n                return tb.process(startTag);\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                tb.reconstructFormattingElements();\n                return tb.process(startTag);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                tb.transition(InBody);\n                tb",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                tb.transition(InBody);\n                return tb.process(startTag);\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n                return tb.process(startTag);\n            } else if (name.equals(\"body\")) {\n                if (!tb.framesetOk()) {\n                    tb.error(this);\n                    return false;\n                } else if (tb.get"
      ],
      "function range": "246,9-761,9"
    },
    "Jsoup_24_/src/main/java/org/jsoup/parser/TokeniserState.java_558-559": {
      "loc": "558-559",
      "input": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);",
      "output": [
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matchesNumber()) {\n        String name = r.consumeNumberSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matches('<')) {\n        t.advanceTransition(HTML40Transition);\n    }\n    else {\n        t.error(this);\n        t.advanceTransition(BogusCommentTransition);\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matchesNumber()) {\n        String name = r.consumeNumberSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matches('<')) {\n        t.advanceTransition(HTML40Transition);\n    }\n    else {\n        t.error(this);\n        t.advanceTransition(BogusCommentTransition);\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algeb",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matchesNumber()) {\n        String name = r.consumeNumberSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matches('<')) {\n        t.advanceTransition(HTML40Transition);\n    }\n    else {\n        t.error(this);\n        t.advanceTransition(BogusCommentTransition);\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyr",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matchesNumber()) {\n        String name = r.consumeNumberSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matches('<')) {\n        t.advanceTransition(HTML40Transition);\n    }\n    else {\n        t.error(this);\n        t.advanceTransition(BogusCommentTransition);\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matchesNumber()) {\n        String name = r.consumeNumberSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matches('<')) {\n        t.advanceTransition(HTML40Transition);\n    }\n    else {\n        t.error(this);\n        t.advanceTransition(BogusCommentTransition);\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamic",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matchesNumber()) {\n        String name = r.consumeNumberSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matches('<')) {\n        t.advanceTransition(HTML40Transition);\n    }\n    else {\n        t.error(this);\n        t.advanceTransition(BogusCommentTransition);\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.AsterixBuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matchesNumber()) {\n        String name = r.consumeNumberSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matches('<')) {\n        t.advanceTransition(HTML40Transition);\n    }\n    else {\n        t.error(this);\n        t.advanceTransition(BogusCommentTransition);\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.asterix.runtime.evalu",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matchesNumber()) {\n        String name = r.consumeNumberSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matches('<')) {\n        t.advanceTransition(HTML40Transition);\n    }\n    else {\n        t.error(this);\n        t.advanceTransition(BogusCommentTransition);\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matchesNumber()) {\n        String name = r.consumeNumberSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matches('<')) {\n        t.advanceTransition(HTML40Transition);\n    }\n    else {\n        t.error(this);\n        t.advanceTransition(BogusCommentTransition);\n    }\n}\n\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matchesNumber()) {\n        String name = r.consumeNumberSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    }\n    else if (r.matches('<')) {\n        t.advanceTransition(HTML40Transition);\n    }\n    else {\n        t.error(this);\n        t.advanceTransition(BogusCommentTransition);\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.AsterixBuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScal"
      ],
      "function range": "553,9-586,9"
    },
    "Jsoup_34_/src/main/java/org/jsoup/parser/CharacterReader.java_91-92": {
      "loc": "91-92",
      "input": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;",
      "output": [
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; j < seq.length(); j++) {\n            if (input[i]!= seq.charAt(j))\n                while(++i < last && input[i]!= seq.charAt(j));\n            else\n                i++;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; j < seq.length(); j++) {\n            if (input[i]!= seq.charAt(j))\n                while(++i < last && input[i]!= seq.charAt(j));\n            else\n                i++;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.Function",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; j < seq.length(); j++) {\n            if (input[i]!= seq.charAt(j))\n                while(++i < last && input[i]!= seq.charAt(j));\n            else\n                i++;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.serializable.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractSerializableAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.fun",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; j < seq.length(); j++) {\n            if (input[i]!= seq.charAt(j))\n                while(++i < last && input[i]!= seq.charAt(j));\n            else\n                i++;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; j < seq.length(); j++) {\n            if (input[i]!= seq.charAt(j))\n                while(++i < last && input[i]!= seq.charAt(j));\n            else\n                i++;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; j < seq.length(); j++) {\n            if (input[i]!= seq.charAt(j))\n                while(++i < last && input[i]!= seq.charAt(j));\n            else\n                i++;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.serializable.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractSerializableAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.Al",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; j < seq.length(); j++) {\n            if (input[i]!= seq.charAt(j))\n                while(++i < last && input[i]!= seq.charAt(j));\n            else\n                i++;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; j < seq.length(); j++) {\n            if (input[i]!= seq.charAt(j))\n                while(++i < last && input[i]!= seq.charAt(j));\n            else\n                i++;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.serializable.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractSerializableAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; j < seq.length(); j++) {\n            if (input[i]!= seq.charAt(j))\n                while(++i < last && input[i]!= seq.charAt(j));\n            else\n                i++;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        for (int j = 1; j < seq.length(); j++) {\n            if (input[i]!= seq.charAt(j))\n                while(++i < last && input[i]!= seq.charAt(j));\n            else\n                i++;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.h"
      ],
      "function range": "82,5-98,5"
    },
    "Jsoup_37_/src/main/java/org/jsoup/nodes/Element.java_1101-1102": {
      "loc": "1101-1102",
      "input": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);",
      "output": [
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.h",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.common.annotations.MissingNullInOutFunction;\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.al",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEval",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n    return accum.toString();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.asterix.runtime.evaluators"
      ],
      "function range": "1098,5-1102,5"
    },
    "Jsoup_40_/src/main/java/org/jsoup/nodes/DocumentType.java_22-23": {
      "loc": "22-23",
      "input": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);",
      "output": [
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n\n    DocumentType that = (DocumentType) o;\n\n    if (name!= null?!name.equals(that.name) : that.name!= null) return false;\n    if (publicId!= null?!publicId.equals(that.publicId) : that.publicId!= null) return false;\n    if (systemId!= null?!systemId.equals(that.systemId) : that.systemId!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (name!= null? name.hashCode() : 0);\n    result = 31 * result + (publicId!= null? publicId.hashCode() : 0);\n    result = 31 * result + (systemId!= null? systemId.hashCode() : 0);\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    return \"DocumentType{\" +\n        \"name='\" + name + '\\'' +\n        \", publicId='\" + publicId + '\\'' +\n        \", systemId='\" + systemId",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n\n    DocumentType that = (DocumentType) o;\n\n    if (name!= null?!name.equals(that.name) : that.name!= null) return false;\n    if (publicId!= null?!publicId.equals(that.publicId) : that.publicId!= null) return false;\n    if (systemId!= null?!systemId.equals(that.systemId) : that.systemId!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (name!= null? name.hashCode() : 0);\n    result = 31 * result + (publicId!= null? publicId.hashCode() : 0);\n    result = 31 * result + (systemId!= null? systemId.hashCode() : 0);\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    return \"DocumentType{\" +\n            \"name='\" + name + '\\'' +\n            \", publicId='\" + publicId + '\\'' +\n            \", systemId='\" + systemId",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n\n    DocumentType that = (DocumentType) o;\n\n    if (name!= null?!name.equals(that.name) : that.name!= null) return false;\n    if (publicId!= null?!publicId.equals(that.publicId) : that.publicId!= null) return false;\n    if (systemId!= null?!systemId.equals(that.systemId) : that.systemId!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (name!= null? name.hashCode() : 0);\n    result = 31 * result + (publicId!= null? publicId.hashCode() : 0);\n    result = 31 * result + (systemId!= null? systemId.hashCode() : 0);\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    return \"DocumentType{\" +\n      \"name='\" + name + '\\'' +\n      \", publicId='\" + publicId + '\\'' +\n      \", systemId='\" + systemId",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n\n    DocumentType that = (DocumentType) o;\n\n    if (name!= null?!name.equals(that.name) : that.name!= null) return false;\n    if (publicId!= null?!publicId.equals(that.publicId) : that.publicId!= null) return false;\n    if (systemId!= null?!systemId.equals(that.systemId) : that.systemId!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + (name!= null? name.hashCode() : 0);\n    result = 31 * result + (publicId!= null? publicId.hashCode() : 0);\n    result = 31 * result + (systemId!= null? systemId.hashCode() : 0);\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    return \"DocumentType{\" +\n           \"name='\" + name + '\\'' +\n           \", publicId='\" + publicId + '\\'' +\n           \", systemId='\" + systemId",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    DocumentType that = (DocumentType) o;\n\n    if (name!= null?!name.equals(that.name) : that.name!= null) return false;\n    if (publicId!= null?!publicId.equals(that.publicId) : that.publicId!= null) return false;\n    if (systemId!= null?!systemId.equals(that.systemId) : that.systemId!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = name!= null? name.hashCode() : 0;\n    result = 31 * result + (publicId!= null? publicId.hashCode() : 0);\n    result = 31 * result + (systemId!= null? systemId.hashCode() : 0);\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    return \"DocumentType{\" +\n        \"name='\" + name + '\\'' +\n        \", publicId='\" + publicId + '\\'' +\n        \", systemId='\" + systemId + '\\'' +\n        '}';\n  }\n}\n<|java|>/*\n * Licensed to the",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    DocumentType that = (DocumentType) o;\n\n    if (name!= null?!name.equals(that.name) : that.name!= null) return false;\n    if (publicId!= null?!publicId.equals(that.publicId) : that.publicId!= null) return false;\n    if (systemId!= null?!systemId.equals(that.systemId) : that.systemId!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = name!= null? name.hashCode() : 0;\n    result = 31 * result + (publicId!= null? publicId.hashCode() : 0);\n    result = 31 * result + (systemId!= null? systemId.hashCode() : 0);\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    return \"DocumentType{\" +\n        \"name='\" + name + '\\'' +\n        \", publicId='\" + publicId + '\\'' +\n        \", systemId='\" + systemId + '\\'' +\n        '}';\n  }\n}\n<|java|>/*\n * Copyright (c",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    DocumentType that = (DocumentType) o;\n\n    if (name!= null?!name.equals(that.name) : that.name!= null) return false;\n    if (publicId!= null?!publicId.equals(that.publicId) : that.publicId!= null) return false;\n    if (systemId!= null?!systemId.equals(that.systemId) : that.systemId!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = name!= null? name.hashCode() : 0;\n    result = 31 * result + (publicId!= null? publicId.hashCode() : 0);\n    result = 31 * result + (systemId!= null? systemId.hashCode() : 0);\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    return \"DocumentType{\" +\n            \"name='\" + name + '\\'' +\n            \", publicId='\" + publicId + '\\'' +\n            \", systemId='\" + systemId + '\\'' +\n            '}';\n  }\n}\n<|java|>/*\n * Licensed to the",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    DocumentType that = (DocumentType) o;\n\n    if (name!= null?!name.equals(that.name) : that.name!= null) return false;\n    if (publicId!= null?!publicId.equals(that.publicId) : that.publicId!= null) return false;\n    if (systemId!= null?!systemId.equals(that.systemId) : that.systemId!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = name!= null? name.hashCode() : 0;\n    result = 31 * result + (publicId!= null? publicId.hashCode() : 0);\n    result = 31 * result + (systemId!= null? systemId.hashCode() : 0);\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    return \"DocumentType{\" +\n      \"name='\" + name + '\\'' +\n      \", publicId='\" + publicId + '\\'' +\n      \", systemId='\" + systemId + '\\'' +\n      '}';\n  }\n}\n<|java|>/*\n * Licensed to the",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    DocumentType that = (DocumentType) o;\n\n    if (name!= null?!name.equals(that.name) : that.name!= null) return false;\n    if (publicId!= null?!publicId.equals(that.publicId) : that.publicId!= null) return false;\n    if (systemId!= null?!systemId.equals(that.systemId) : that.systemId!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = name!= null? name.hashCode() : 0;\n    result = 31 * result + (publicId!= null? publicId.hashCode() : 0);\n    result = 31 * result + (systemId!= null? systemId.hashCode() : 0);\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    return \"DocumentType{\" +\n            \"name='\" + name + '\\'' +\n            \", publicId='\" + publicId + '\\'' +\n            \", systemId='\" + systemId + '\\'' +\n            '}';\n  }\n}\n<|java|>/*\n * Copyright (c",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    DocumentType that = (DocumentType) o;\n\n    if (name!= null?!name.equals(that.name) : that.name!= null) return false;\n    if (publicId!= null?!publicId.equals(that.publicId) : that.publicId!= null) return false;\n    if (systemId!= null?!systemId.equals(that.systemId) : that.systemId!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = name!= null? name.hashCode() : 0;\n    result = 31 * result + (publicId!= null? publicId.hashCode() : 0);\n    result = 31 * result + (systemId!= null? systemId.hashCode() : 0);\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    return \"DocumentType{\" +\n        \"name='\" + name + '\\'' +\n        \", publicId='\" + publicId + '\\'' +\n        \", systemId='\" + systemId + '\\'' +\n        '}';\n  }\n}\n<|java|>/*\n * Copyright (C"
      ],
      "function range": "19,5-26,5"
    },
    "Jsoup_41_/src/main/java/org/jsoup/nodes/Element.java_1175-1176": {
      "loc": "1175-1176",
      "input": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;",
      "output": [
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + name.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test the ftps component over SSL (implicit) with client authentication\n */\npublic class FileToFtpsImplicitSSLWithClientAuthTest extends FtpsServerImplicitSSLWithClientAuthTestSupport {\n\n    protected String getFtpUrl() {\n        return \"ftps://admin@localhost:\" + getPort() + \"/tmp2/camel?password=admin&consumer.initialDelay=2000&disableSecureDataChannelDefaults=true\"\n               + \"&securityProtocol=SSLv3&isImplicit=true&ftpClient.keyStore",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + name.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to test noop option.\n */\npublic class FromFtpNoopTest extends FtpServerTestSupport {\n\n    protected String getFtpUrl() {\n        return \"ftp",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + name.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to test noop option.\n */\npublic class FromFtpNoopTest extends FtpServerTestSupport {\n\n    private String getFtpUrl() {\n        return \"ftp",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + name.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to test noop option.\n */\npublic class FromFtpNoopTest extends F",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + name.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to test noop option.\n */\npublic class FromFtpNoopTest extends Ftp",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + name.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test the ftps component over SSL (implicit) with client authentication\n */\npublic class FileToFtpsImplicitSSLWithClientAuthTest extends FtpsServerImplicitSSLWithClientAuthTestSupport {\n\n    protected String getFtpUrl() {\n        return \"ftps://admin@localhost:\" + getPort() + \"/tmp2/camel?password=admin&consumer.initialDelay=2000&disableSecureDataChannelDefaults=true\"\n               + \"&securityProtocol=SSLv2&isImplicit=true&ftpClient.keyStore",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + name.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\n/**\n * Unit test to test noop option.\n */\npublic class FromFtpNoopTest extends",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + name.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.apache.camel.converter.IOConverter;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class FtpProducer",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + name.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.apache.camel.converter.IOConverter;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + name.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.file.GenericFile;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class FtpProducerFileEx"
      ],
      "function range": "1167,5-1176,5"
    },
    "Jsoup_43_/src/main/java/org/jsoup/nodes/Element.java_574-575": {
      "loc": "574-575",
      "input": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);",
      "output": [
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEval",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateE",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTask",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScal",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalar",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyE",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScal",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context"
      ],
      "function range": "568,5-578,5"
    },
    "Jsoup_45_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_394-395": {
      "loc": "394-395",
      "input": "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; ",
      "output": [
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break; \n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break; \n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break; \n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break; \n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break; \n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break; \n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break; \n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break; \n        } else if (last) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        }",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break; \n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break; \n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break; \n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break; \n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break; \n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break; \n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break; \n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break; \n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name) || \"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break; \n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break; \n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break; \n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break; \n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break; \n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break; \n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break; \n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break; \n        } else if (\"html\".equals(name)) {\n            transition(Html",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name) || \"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break; \n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break; \n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break; \n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break; \n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break; \n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break; \n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break; \n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break; \n        } else if (last) {\n            transition(HtmlTreeBuilderState.In",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name) || \"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (last) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        }\n",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break; \n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break; \n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break; \n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break; \n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break; \n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break; \n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break; \n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break; \n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.AfterFrameset);\n            ",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (last) {",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name) || \"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (last) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        }\n    ",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (\"body\".equ",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if (\"td\".equals(name) || \"th\".equals(name) || \"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (last) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        }\n        "
      ],
      "function range": "382,5-429,5"
    },
    "Jsoup_46_/src/main/java/org/jsoup/nodes/Entities.java_118-119": {
      "loc": "118-119",
      "input": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else",
      "output": [
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&##########################################################################################################################",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(' ');\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    accum.append(\"&quot;\");\n                    break;\n                case '\\'':\n                    accum.append(\"&######################################",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else {\n                        accum.append(\"&#########################################################################################################################",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(String.format(\"&######################################################################################################################",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\" \");\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    accum.append(\"&quot;\");\n                    break;\n                case '\\'':\n                    accum.append(\"&######################################",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(' ');\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    accum.append(\"&quot;\");\n                    break;\n                default:\n                    if (map.containsKey(c))\n                        accum.append(map.get(c));\n                    else\n                        accum.append(c);\n                    break;\n            }\n        } else {",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(' ');\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    accum.append(\"&quot;\");\n                    break;\n                default:\n                    if (map.containsKey(c)) {\n                        accum.append(map.get(c));\n                    } else {\n                        accum.append(c);\n                    }\n                    break;\n            ",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(' ');\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    accum.append(\"&quot;\");\n                    break;\n                case '\\'':\n                    accum.append(\"&apos;\");\n                    break;\n                default:\n                    if (map.containsKey(c))\n                        accum.append(map.get(c));\n",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(' ');\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    accum.append(\"&quot;\");\n                    break;\n                default:\n                    if (map.containsKey(c))\n                        accum.append(map.get(c));\n                    else\n                        accum.append(c);\n                    break;\n            }\n        } else if",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(' ');\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    accum.append(\"&quot;\");\n                    break;\n                case '\\'':\n                    accum.append(\"&apos;\");\n                    break;\n                default:\n                    accum.append(c);\n                    break;\n            }\n        } else if (coreCharset"
      ],
      "function range": "79,5-154,5"
    },
    "Jsoup_47_/src/main/java/org/jsoup/nodes/Entities.java_122-123": {
      "loc": "122-123",
      "input": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':",
      "output": [
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    accum.append(\"&quot;\");\n                    break;\n                case '\\'':\n                    accum.append(\"&##################################",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    accum.append(\"&quot;\");\n                    break;\n                case '\\'':\n                    accum.append(\"&apos;\");\n                    break;\n                default:\n                    accum.append(c);\n                    break;\n            }\n        } else {\n",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    accum.append(\"&quot;\");\n                    break;\n                default:\n                    if (map.containsKey(c))\n                        accum.append(map.get(c));\n                    else\n                        accum.append(c);\n                    break;\n            }\n",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    accum.append(\"&quot;\");\n                    break;\n                default:\n                    if (map.containsKey(c))\n                        accum.append(map.get(c));\n                    else\n                        accum.append(c);\n            }\n        } else {",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    accum.append(\"&quot;\");\n                    break;\n                default:\n                    if (map.containsKey(c)) {\n                        accum.append(map.get(c));\n                    } else {\n                        accum.append(c);\n                    }\n                    ",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    accum.append(\"&quot;\");\n                    break;\n                case '\\'':\n                    accum.append(\"&apos;\");\n                    break;\n                default:\n                    accum.append(c);\n                    break;\n            }\n        } else if (",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case 0xD:\n                    accum.append(\"&#############################################################################",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(\"&########################################################################",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    accum.append(\"&quot;\");\n                    break;\n                case '\\'':\n                    accum.append(\"&apos;\");\n                    break;\n                default:\n                    if (map.containsKey(c))\n                        accum.append(map.get",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    accum.append(\"&quot;\");\n                    break;\n                default:\n                    accum.append(c);\n                    break;\n            }\n        } else {\n            accum.appendCodePoint(codePoint);\n        }\n    }\n    if (inAttribute"
      ],
      "function range": "79,5-155,5"
    },
    "Jsoup_51_/src/main/java/org/jsoup/parser/CharacterReader.java_300-301": {
      "loc": "300-301",
      "input": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];",
      "output": [
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= 'a' && c <= 'z')\n        return true;\n    if (c >= 'A' && c <= 'Z')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= '0' && c <= '9')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesSpace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c =='')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesNewline() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\n')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesCarriageReturn() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\r')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesFormFeed() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\f')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesHorizontalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\t')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesVerticalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\v')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesBackslash() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= 'a' && c <= 'z')\n        return true;\n    if (c >= 'A' && c <= 'Z')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= '0' && c <= '9')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesSpace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c =='')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesNewline() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\n')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesCarriageReturn() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\r')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesFormFeed() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\f')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesHorizontalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\t')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesLineFeed() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\n')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesVerticalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c ==",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= 'a' && c <= 'z')\n        return true;\n    if (c >= 'A' && c <= 'Z')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= '0' && c <= '9')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesSpace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c =='')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesNewline() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\n')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesCarriageReturn() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\r')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesFormFeed() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\f')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesHorizontalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\t')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesVerticalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\v')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesLineFeed() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c ==",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= 'a' && c <= 'z')\n        return true;\n    if (c >= 'A' && c <= 'Z')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= '0' && c <= '9')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesSpace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c =='')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesNewline() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\n')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesCarriageReturn() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\r')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesFormFeed() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\f')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesVerticalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\v')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesHorizontalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\t')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesBackslash() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= 'a' && c <= 'z')\n        return true;\n    if (c >= 'A' && c <= 'Z')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= '0' && c <= '9')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesSpace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c =='')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesNewline() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\n')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesCarriageReturn() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\r')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesFormFeed() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\f')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesHorizontalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\t')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesVerticalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\t')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesBackslash() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= 'a' && c <= 'z')\n        return true;\n    if (c >= 'A' && c <= 'Z')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= '0' && c <= '9')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesSpace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c =='')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesNewline() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\n')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesCarriageReturn() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\r')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesFormFeed() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\f')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesHorizontalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\t')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesVerticalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\v')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesBackspace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c ==",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= 'a' && c <= 'z')\n        return true;\n    if (c >= 'A' && c <= 'Z')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= '0' && c <= '9')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesSpace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c =='')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesNewline() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\n')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesCarriageReturn() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\r')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesFormFeed() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\f')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesHorizontalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\t')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesVerticalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\v')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesCaret() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c ==",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= 'a' && c <= 'z')\n        return true;\n    if (c >= 'A' && c <= 'Z')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= '0' && c <= '9')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesSpace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c =='')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesNewline() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\n')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesCarriageReturn() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\r')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesFormFeed() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\f')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesHorizontalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\t')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesVerticalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\v')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesNull() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= 'a' && c <= 'z')\n        return true;\n    if (c >= 'A' && c <= 'Z')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= '0' && c <= '9')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesSpace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c =='')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesNewline() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\n')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesCarriageReturn() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\r')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesFormFeed() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\f')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesHorizontalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\t')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesVerticalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\v')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesBackslash() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    switch (c",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= 'a' && c <= 'z')\n        return true;\n    if (c >= 'A' && c <= 'Z')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c >= '0' && c <= '9')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesSpace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c =='')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesNewline() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\n')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesCarriageReturn() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\r')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesFormFeed() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\f')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesHorizontalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\t')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesVerticalTab() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if (c == '\\v')\n        return true;\n    return false;\n}\n\nbool StringMatcher::matchesBackslash() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    if ((c"
      ],
      "function range": "296,5-301,5"
    },
    "Jsoup_57_/src/main/java/org/jsoup/nodes/Attributes.java_125-126": {
      "loc": "125-126",
      "input": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))",
      "output": [
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluator",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvalu",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\n",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEval",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key)) {\n            it.remove();\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarE"
      ],
      "function range": "118,5-127,5"
    },
    "Jsoup_61_/src/main/java/org/jsoup/nodes/Element.java_1092-1093": {
      "loc": "1092-1093",
      "input": "public boolean hasClass(String className) {",
      "output": [
        "public boolean hasClass(String className) {\n        return classes.containsKey(className);\n    }\n\n    @Override\n    public boolean hasMethod(String methodName) {\n        return methods.containsKey(methodName);\n    }\n\n    @Override\n    public boolean hasField(String fieldName) {\n        return fields.containsKey(fieldName);\n    }\n\n    @Override\n    public Class<?> getClass(String className) {\n        return classes.get(className);\n    }\n\n    @Override\n    public Method getMethod(String methodName) {\n        return methods.get(methodName);\n    }\n\n    @Override\n    public Field getField(String fieldName) {\n        return fields.get(fieldName);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport",
        "public boolean hasClass(String className) {\n        return classes.containsKey(className);\n    }\n\n    @Override\n    public boolean hasMethod(String methodName) {\n        return methods.containsKey(methodName);\n    }\n\n    @Override\n    public boolean hasField(String fieldName) {\n        return fields.containsKey(fieldName);\n    }\n\n    @Override\n    public Class<?> getClass(String className) {\n        return classes.get(className);\n    }\n\n    @Override\n    public Method getMethod(String methodName) {\n        return methods.get(methodName);\n    }\n\n    @Override\n    public Field getField(String fieldName) {\n        return fields.get(fieldName);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;",
        "public boolean hasClass(String className) {\n        return classes.containsKey(className);\n    }\n\n    @Override\n    public boolean hasMethod(String methodName) {\n        return methods.containsKey(methodName);\n    }\n\n    @Override\n    public boolean hasField(String fieldName) {\n        return fields.containsKey(fieldName);\n    }\n\n    @Override\n    public Class<?> getClass(String className) {\n        return classes.get(className);\n    }\n\n    @Override\n    public Method getMethod(String methodName) {\n        return methods.get(methodName);\n    }\n\n    @Override\n    public Field getField(String fieldName) {\n        return fields.get(fieldName);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregate",
        "public boolean hasClass(String className) {\n        return classes.containsKey(className);\n    }\n\n    @Override\n    public boolean hasMethod(String methodName) {\n        return methods.containsKey(methodName);\n    }\n\n    @Override\n    public boolean hasField(String fieldName) {\n        return fields.containsKey(fieldName);\n    }\n\n    @Override\n    public Class<?> getClass(String className) {\n        return classes.get(className);\n    }\n\n    @Override\n    public Method getMethod(String methodName) {\n        return methods.get(methodName);\n    }\n\n    @Override\n    public Field getField(String fieldName) {\n        return fields.get(fieldName);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org",
        "public boolean hasClass(String className) {\n        return classes.containsKey(className);\n    }\n\n    @Override\n    public boolean hasMethod(String methodName) {\n        return methods.containsKey(methodName);\n    }\n\n    @Override\n    public boolean hasField(String fieldName) {\n        return fields.containsKey(fieldName);\n    }\n\n    @Override\n    public Class<?> getClass(String className) {\n        return classes.get(className);\n    }\n\n    @Override\n    public Method getMethod(String methodName) {\n        return methods.get(methodName);\n    }\n\n    @Override\n    public Field getField(String fieldName) {\n        return fields.get(fieldName);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.",
        "public boolean hasClass(String className) {\n        return classes.containsKey(className);\n    }\n\n    @Override\n    public boolean hasMethod(String methodName) {\n        return methods.containsKey(methodName);\n    }\n\n    @Override\n    public boolean hasField(String fieldName) {\n        return fields.containsKey(fieldName);\n    }\n\n    @Override\n    public Class<?> getClass(String className) {\n        return classes.get(className);\n    }\n\n    @Override\n    public Method getMethod(String methodName) {\n        return methods.get(methodName);\n    }\n\n    @Override\n    public Field getField(String fieldName) {\n        return fields.get(fieldName);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\n",
        "public boolean hasClass(String className) {\n        return classes.containsKey(className);\n    }\n\n    @Override\n    public boolean hasMethod(String methodName) {\n        return methods.containsKey(methodName);\n    }\n\n    @Override\n    public boolean hasField(String fieldName) {\n        return fields.containsKey(fieldName);\n    }\n\n    @Override\n    public Class<?> getClass(String className) {\n        return classes.get(className);\n    }\n\n    @Override\n    public Method getMethod(String methodName) {\n        return methods.get(methodName);\n    }\n\n    @Override\n    public Field getField(String fieldName) {\n        return fields.get(fieldName);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.",
        "public boolean hasClass(String className) {\n        return classes.containsKey(className);\n    }\n\n    @Override\n    public boolean hasMethod(String methodName) {\n        return methods.containsKey(methodName);\n    }\n\n    @Override\n    public boolean hasField(String fieldName) {\n        return fields.containsKey(fieldName);\n    }\n\n    @Override\n    public Class<?> getClass(String className) {\n        return classes.get(className);\n    }\n\n    @Override\n    public Method getMethod(String methodName) {\n        return methods.get(methodName);\n    }\n\n    @Override\n    public Field getField(String fieldName) {\n        return fields.get(fieldName);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.asterix.runtime",
        "public boolean hasClass(String className) {\n        return classes.containsKey(className);\n    }\n\n    @Override\n    public boolean hasMethod(String methodName) {\n        return methods.containsKey(methodName);\n    }\n\n    @Override\n    public boolean hasField(String fieldName) {\n        return fields.containsKey(fieldName);\n    }\n\n    @Override\n    public Class<?> getClass(String className) {\n        return classes.get(className);\n    }\n\n    @Override\n    public Method getMethod(String methodName) {\n        return methods.get(methodName);\n    }\n\n    @Override\n    public Field getField(String fieldName) {\n        return fields.get(fieldName);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IS",
        "public boolean hasClass(String className) {\n        return classes.containsKey(className);\n    }\n\n    @Override\n    public boolean hasMethod(String methodName) {\n        return methods.containsKey(methodName);\n    }\n\n    @Override\n    public boolean hasField(String fieldName) {\n        return fields.containsKey(fieldName);\n    }\n\n    @Override\n    public Class<?> getClass(String className) {\n        return classes.get(className);\n    }\n\n    @Override\n    public Method getMethod(String methodName) {\n        return methods.get(methodName);\n    }\n\n    @Override\n    public Field getField(String fieldName) {\n        return fields.get(fieldName);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.Abstract"
      ],
      "function range": "1091,5-1132,5"
    },
    "Jsoup_68_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_468-472": {
      "loc": "468-472",
      "input": "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {",
      "output": [
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int i = 0; i < targetNames.length; i++) {\n            for (int j = 0; j < baseTypes.length; j++) {\n                if (targetNames[i].equals(baseTypes[j])) {\n                    return true;\n                }\n            }\n            for (int j = 0; j < extraTypes.length; j++) {\n                if (targetNames[i].equals(extraTypes[j])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n\n/**\n * Compute IF(expr1, expr2, expr3) for 3 input column expressions.\n * The first is always a boolean (LongColumnVector).\n * The second",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int i = 0; i < targetNames.length; i++) {\n            for (int j = 0; j < baseTypes.length; j++) {\n                if (targetNames[i].equals(baseTypes[j])) {\n                    return true;\n                }\n            }\n            for (int j = 0; j < extraTypes.length; j++) {\n                if (targetNames[i].equals(extraTypes[j])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheAtomicityMode;\nimport org.apache.ignite.cache.CacheMode;\nimport org.apache.ignite.configuration.CacheConfiguration;\nimport org.apache.ignite.configuration.IgniteConfiguration;\nimport org.apache.ignite.configuration.NearCacheConfiguration;\nimport org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;\nimport org.apache.ignite.spi.discovery.tcp.ip",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n    for (int i = 0; i < targetNames.length; i++) {\n      for (int j = 0; j < baseTypes.length; j++) {\n        if (targetNames[i].equals(baseTypes[j])) {\n          return true;\n        }\n      }\n      for (int j = 0; j < extraTypes.length; j++) {\n        if (targetNames[i].equals(extraTypes[j])) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n\n/**\n * Compute IF(expr1, expr2, expr3) for 3 input column expressions.\n * The first is always a boolean (LongColumnVector).\n * The second",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int i = 0; i < targetNames.length; i++) {\n            for (int j = 0; j < baseTypes.length; j++) {\n                if (targetNames[i].equals(baseTypes[j])) {\n                    return true;\n                }\n            }\n            for (int j = 0; j < extraTypes.length; j++) {\n                if (targetNames[i].equals(extraTypes[j])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int i = 0; i < targetNames.length; i++) {\n            for (int j = 0; j < baseTypes.length; j++) {\n                if (targetNames[i].equals(baseTypes[j])) {\n                    return true;\n                }\n            }\n            for (int j = 0; j < extraTypes.length; j++) {\n                if (targetNames[i].equals(extraTypes[j])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\n\n/**\n * This is a superclass",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int i = 0; i < targetNames.length; i++) {\n            for (int j = 0; j < baseTypes.length; j++) {\n                if (targetNames[i].equals(baseTypes[j])) {\n                    return true;\n                }\n            }\n            for (int j = 0; j < extraTypes.length; j++) {\n                if (targetNames[i].equals(extraTypes[j])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\n\n/**\n * Compute IF(expr1, expr2, expr3) for 3",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int i = 0; i < targetNames.length; i++) {\n            for (int j = 0; j < baseTypes.length; j++) {\n                if (targetNames[i].equals(baseTypes[j])) {\n                    return true;\n                }\n            }\n            for (int j = 0; j < extraTypes.length; j++) {\n                if (targetNames[i].equals(extraTypes[j])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\n\n/**\n * Compute IF(expr",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int i = 0; i < targetNames.length; i++) {\n            for (int j = 0; j < baseTypes.length; j++) {\n                if (targetNames[i].equals(baseTypes[j])) {\n                    return true;\n                }\n            }\n            for (int j = 0; j < extraTypes.length; j++) {\n                if (targetNames[i].equals(extraTypes[j])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.serde2.io.H",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int i = 0; i < targetNames.length; i++) {\n            for (int j = 0; j < baseTypes.length; j++) {\n                if (targetNames[i].equals(baseTypes[j])) {\n                    return true;\n                }\n            }\n            for (int j = 0; j < extraTypes.length; j++) {\n                if (targetNames[i].equals(extraTypes[j])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\n\n/**\n * This class is used to",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        for (int i = 0; i < targetNames.length; i++) {\n            for (int j = 0; j < baseTypes.length; j++) {\n                if (targetNames[i].equals(baseTypes[j])) {\n                    return true;\n                }\n            }\n            for (int j = 0; j < extraTypes.length; j++) {\n                if (targetNames[i].equals(extraTypes[j])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\n\n/**\n * This operation is handled as"
      ],
      "function range": "466,5-486,5"
    },
    "Jsoup_75_/src/main/java/org/jsoup/nodes/Attributes.java_319-321": {
      "loc": "319-321",
      "input": "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);",
      "output": [
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append('=').append('\"').append(val).append('\"');\n        }\n        accum.append('\\n');\n    }\n    accum.append('\\n');\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.alge",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append('=').append('\"').append(val).append('\"');\n        }\n        accum.append('\\n');\n    }\n    accum.append('\\n');\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append('=').append('\"').append(val).append('\"');\n        }\n        accum.append('\\n');\n    }\n    accum.append('\\n');\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algeb",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append('=').append('\"').append(val).append('\"');\n        }\n        accum.append('\\n');\n    }\n    accum.append('\\n');\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append('=').append('\"').append(val).append('\"');\n        }\n        accum.append('\\n');\n    }\n    accum.append('\\n');\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append('=').append('\"').append(val).append('\"');\n        }\n        accum.append('\\n');\n    }\n    accum.append('\\n');\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.al",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append('=').append('\"').append(val).append('\"');\n        }\n        accum.append('\\n');\n    }\n    accum.append('\\n');\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.alge",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append('=').append('\"').append(val).append('\"');\n        }\n        accum.append('\\n');\n    }\n    accum.append('\\n');\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IS",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append('=').append('\"').append(val).append('\"');\n        }\n        accum.append('\\n');\n    }\n    accum.append('\\n');\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IE",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (val!= null) {\n            accum.append('=').append('\"').append(val).append('\"');\n        }\n        accum.append('\\n');\n    }\n    accum.append('\\n');\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.AsterixBuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\n\npublic class Numeric"
      ],
      "function range": "310,5-326,5"
    },
    "Jsoup_77_/src/main/java/org/jsoup/parser/XmlTreeBuilder.java_117-118": {
      "loc": "117-118",
      "input": "private void popStackToClose(Token.EndTag endTag) {",
      "output": [
        "private void popStackToClose(Token.EndTag endTag) {\n        while (!stack.isEmpty() && stack.peek().equals(endTag)) {\n            stack.pop();\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;",
        "private void popStackToClose(Token.EndTag endTag) {\n        while (!stack.isEmpty() &&!stack.peek().equals(endTag)) {\n            stack.pop();\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException",
        "private void popStackToClose(Token.EndTag endTag) {\n        while (!stack.isEmpty() && stack.peek().equals(endTag)) {\n            stack.pop();\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarE",
        "private void popStackToClose(Token.EndTag endTag) {\n        while (!stack.isEmpty() &&!stack.peek().equals(endTag)) {\n            stack.pop();\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalar",
        "private void popStackToClose(Token.EndTag endTag) {\n        while (!stack.isEmpty() && stack.peek().equals(endTag)) {\n            stack.pop();\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.",
        "private void popStackToClose(Token.EndTag endTag) {\n        while (!stack.isEmpty() && stack.peek().equals(endTag)) {\n            stack.pop();\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class",
        "private void popStackToClose(Token.EndTag endTag) {\n        while (!stack.isEmpty() &&!stack.peek().equals(endTag)) {\n            stack.pop();\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic",
        "private void popStackToClose(Token.EndTag endTag) {\n        while (!stack.isEmpty() && stack.peek().equals(endTag)) {\n            stack.pop();\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\n",
        "private void popStackToClose(Token.EndTag endTag) {\n        while (!stack.isEmpty() && stack.peek().equals(endTag)) {\n            stack.pop();\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\n/**\n",
        "private void popStackToClose(Token.EndTag endTag) {\n        while (!stack.isEmpty() && stack.peek().equals(endTag)) {\n            stack.pop();\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org."
      ],
      "function range": "116,5-136,5"
    },
    "Jsoup_86_/src/main/java/org/jsoup/nodes/Comment.java_78-79": {
      "loc": "78-79",
      "input": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;",
      "output": [
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node n : doc.childNodes()) {\n      if (n instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) n;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregate",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregate",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node n : doc.childNodes()) {\n      if (n instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) n;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node n : doc.childNodes()) {\n      if (n instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) n;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateE",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateE",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node n : doc.childNodes()) {\n      if (n instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) n;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IS",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IS",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node n : doc.childNodes()) {\n      if (n instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) n;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyAggregate",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyAggregate"
      ],
      "function range": "74,5-84,5"
    },
    "Jsoup_88_/src/main/java/org/jsoup/nodes/Attribute.java_80-81": {
      "loc": "80-81",
      "input": "public String getValue() {",
      "output": [
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets the value of the href property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getHref() {\n        return href;\n    }\n\n    /**\n     * Sets the value of the href property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setHref(String value) {\n        this.href = value;\n    }\n\n    /**\n     * Gets a map that contains attributes that aren't bound to any typed property on this class.\n     * \n     * <p>\n     * the map is keyed by the name of the attribute and \n     * the value is the string value of the attribute.\n     * \n     * the map returned by this method is live, and you can add new attribute\n     * by updating the map directly. Because of this design, there's no setter.\n     * \n     * \n     * @return\n     *     always non-null\n     */\n    public Map<QName, String> getOtherAttributes() {\n        return otherAttributes;\n    }\n\n}\n<|java|>",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets the value of the href property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getHref() {\n        return href;\n    }\n\n    /**\n     * Sets the value of the href property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setHref(String value) {\n        this.href = value;\n    }\n\n    /**\n     * Gets the value of the role property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getRole() {\n        return role;\n    }\n\n    /**\n     * Sets the value of the role property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setRole(String value) {\n        this.role = value;\n    }\n\n    /**\n     * Gets the value of the title property.\n     * \n     * @return\n     *     possible object is",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets the value of the href property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getHref() {\n        return href;\n    }\n\n    /**\n     * Sets the value of the href property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setHref(String value) {\n        this.href = value;\n    }\n\n    /**\n     * Gets the value of the role property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getRole() {\n        return role;\n    }\n\n    /**\n     * Sets the value of the role property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setRole(String value) {\n        this.role = value;\n    }\n\n    /**\n     * Gets the value of the arcrole property.\n     * \n     * @return\n     *     possible object",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets a map that contains attributes that aren't bound to any typed property on this class.\n     * \n     * <p>\n     * the map is keyed by the name of the attribute and \n     * the value is the string value of the attribute.\n     * \n     * the map returned by this method is live, and you can add new attribute\n     * by updating the map directly. Because of this design, there's no setter.\n     * \n     * \n     * @return\n     *     always non-null\n     */\n    public Map<QName, String> getOtherAttributes() {\n        return otherAttributes;\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets the value of the href property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getHref() {\n        return href;\n    }\n\n    /**\n     * Sets the value of the href property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setHref(String value) {\n        this.href = value;\n    }\n\n    /**\n     * Gets a map that contains attributes that aren't bound to any typed property on this class.\n     * \n     * <p>\n     * the map is keyed by the name of the attribute and \n     * the value is the string value of the attribute.\n     * \n     * the map returned by this method is live, and you can add new attribute\n     * by updating the map directly. Because of this design, there's no setter.\n     * \n     * \n     * @return\n     *     always non-null\n     */\n    public Map<QName, String> getOtherAttributes() {\n        return otherAttributes;\n    }\n\n    /**\n     * Generates a String",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets a map that contains attributes that aren't bound to any typed property on this class.\n     * \n     * <p>\n     * the map is keyed by the name of the attribute and \n     * the value is the string value of the attribute.\n     * \n     * the map returned by this method is live, and you can add new attribute\n     * by updating the map directly. Because of this design, there's no setter.\n     * \n     * \n     * @return\n     *     always non-null\n     */\n    public Map<QName, String> getOtherAttributes() {\n        return otherAttributes;\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets a map that contains attributes that aren't bound to any typed property on this class.\n     * \n     * <p>\n     * the map is keyed by the name of the attribute and \n     * the value is the string value of the attribute.\n     * \n     * the map returned by this method is live, and you can add new attribute\n     * by updating the map directly. Because of this design, there's no setter.\n     * \n     * \n     * @return\n     *     always non-null\n     */\n    public Map<QName, String> getOtherAttributes() {\n        return otherAttributes;\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets the value of the href property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getHref() {\n        return href;\n    }\n\n    /**\n     * Sets the value of the href property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setHref(String value) {\n        this.href = value;\n    }\n\n    /**\n     * Gets the value of the role property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getRole() {\n        return role;\n    }\n\n    /**\n     * Sets the value of the role property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setRole(String value) {\n        this.role = value;\n    }\n\n    /**\n     * Gets a map that contains attributes that aren't bound to any typed property on this class.\n     * \n     *",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets the value of the href property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getHref() {\n        return href;\n    }\n\n    /**\n     * Sets the value of the href property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setHref(String value) {\n        this.href = value;\n    }\n\n    /**\n     * Gets a map that contains attributes that aren't bound to any typed property on this class.\n     * \n     * <p>\n     * the map is keyed by the name of the attribute and \n     * the value is the string value of the attribute.\n     * \n     * the map returned by this method is live, and you can add new attribute\n     * by updating the map directly. Because of this design, there's no setter.\n     * \n     * \n     * @return\n     *     always non-null\n     */\n    public Map getOtherAttributes() {\n        return otherAttributes;\n    }\n\n}\n<|java|>/*\n * Licensed to the",
        "public String getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the value property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the id property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getId() {\n        return id;\n    }\n\n    /**\n     * Sets the value of the id property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setId(String value) {\n        this.id = value;\n    }\n\n    /**\n     * Gets the value of the href property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getHref() {\n        return href;\n    }\n\n    /**\n     * Sets the value of the href property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setHref(String value) {\n        this.href = value;\n    }\n\n    /**\n     * Gets a map that contains attributes that aren't bound to any typed property on this class.\n     * \n     * <p>\n     * the map is keyed by the name of the attribute and \n     * the value is the string value of the attribute.\n     * \n     * the map returned by this method is live, and you can add new attribute\n     * by updating the map directly. Because of this design, there's no setter.\n     * \n     * \n     * @return\n     *     always non-null\n     */\n    public Map getOtherAttributes() {\n        return otherAttributes;\n    }\n\n}\n<|java|>/*\n * Copyright (c"
      ],
      "function range": "79,5-81,5"
    },
    "JxPath_5_/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java_665-668": {
      "loc": "665-668",
      "input": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0 ? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0 ? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1 != null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {",
      "output": [
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return -1;\n    }\n    if (depth2 == 1) {\n        return 1;\n    }\n    return 0;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return -1;\n    }\n    if (depth2 == 1) {\n        return 1;\n    }\n    return 0;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return -1;\n    }\n    if (depth2 == 1) {\n        return 1;\n    }\n    return 0;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.configuration.CacheConfiguration;\nimport org.apache.ignite.configuration.IgniteConfiguration;\nimport org.apache.",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return -1;\n    }\n    if (depth2 == 1) {\n        return 1;\n    }\n    return 0;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return -1;\n    }\n    if (depth2 == 1) {\n        return 1;\n    }\n    return 0;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Exchange;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return -1;\n    }\n    if (depth2 == 1) {\n        return 1;\n    }\n    return 0;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheAtomicityMode;\nimport org.apache.ignite.cache.CacheMode;\nimport org.apache.",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return -1;\n    }\n    if (depth2 == 1) {\n        return 1;\n    }\n    return 0;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.condition.EnabledIf;",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return -1;\n    }\n    if (depth2 == 1) {\n        return 1;\n    }\n    return 0;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return -1;\n    }\n    if (depth2 == 1) {\n        return 1;\n    }\n    return 0;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.j",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return -1;\n    }\n    if (depth2 == 1) {\n        return 1;\n    }\n    return 0;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.junit.jupiter.api.Test;\n\nimport static org"
      ],
      "function range": "642,5-675,5"
    },
    "JxPath_10_/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java_42-43": {
      "loc": "42-43",
      "input": "public final Object computeValue(EvalContext context) {",
      "output": [
        "public final Object computeValue(EvalContext context) {\n        return compute(context);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n",
        "public final Object computeValue(EvalContext context) {\n        return compute(context);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final",
        "public final Object computeValue(EvalContext context) {\n        return compute(context);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class LocalSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long",
        "public final Object computeValue(EvalContext context) {\n        return compute(context);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class MaxAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long serial",
        "public final Object computeValue(EvalContext context) {\n        return compute(context);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static",
        "public final Object computeValue(EvalContext context) {\n        return compute(context);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final",
        "public final Object computeValue(EvalContext context) {\n        return compute(context);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static",
        "public final Object computeValue(EvalContext context) {\n        return compute(context);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class Global",
        "public final Object computeValue(EvalContext context) {\n        return compute(context);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class Local",
        "public final Object computeValue(EvalContext context) {\n        return compute(context);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor"
      ],
      "function range": "41,5-44,5"
    },
    "JxPath_12_/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java_108-109": {
      "loc": "108-109",
      "input": "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);",
      "output": [
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (nodeNS.equals(namespaceURI)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        short nodeType = node.getNodeType();\n        if (nodeTypeTest.getNodeType() == nodeType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof CommentTest) {\n        if (node.getNodeType()!= Node.COMMENT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof TextTest) {\n        if (node.getNodeType()!= Node.TEXT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType()!= Node.PROCESSING_INSTRUCTION_NODE) {\n            return false;\n        }\n        ProcessingInstructionTest piTest = (ProcessingInstructionTest",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (nodeNS.equals(namespaceURI)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        short nodeType = node.getNodeType();\n        if (nodeTypeTest.getNodeType() == nodeType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof CommentTest) {\n        if (node.getNodeType()!= Node.COMMENT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof TextTest) {\n        if (node.getNodeType()!= Node.TEXT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType()!= Node.PROCESSING_INSTRUCTION_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof Doc",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (nodeNS.equals(namespaceURI)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        short nodeType = node.getNodeType();\n        if (nodeTypeTest.getNodeType() == nodeType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof TextNodeTest) {\n        if (node.getNodeType()!= Node.TEXT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof CommentNodeTest) {\n        if (node.getNodeType()!= Node.COMMENT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof ProcessingInstructionNodeTest) {\n        if (node.getNodeType()!= Node.PROCESSING_INSTRUCTION_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (nodeNS.equals(namespaceURI)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        short nodeType = node.getNodeType();\n        if (nodeTypeTest.getNodeType() == nodeType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof TextNodeTest) {\n        if (node.getNodeType()!= Node.TEXT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof CommentTest) {\n        if (node.getNodeType()!= Node.COMMENT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType()!= Node.PROCESSING_INSTRUCTION_NODE) {\n            return false;\n        }\n        ProcessingInstructionTest piTest = (ProcessingInstruction",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (nodeNS.equals(namespaceURI)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        short nodeType = node.getNodeType();\n        if (nodeTypeTest.getNodeType() == nodeType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof CommentTest) {\n        if (node.getNodeType()!= Node.COMMENT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof TextTest) {\n        if (node.getNodeType()!= Node.TEXT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType()!= Node.PROCESSING_INSTRUCTION_NODE) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\n",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (nodeNS.equals(namespaceURI)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        short nodeType = node.getNodeType();\n        if (nodeTypeTest.getNodeType() == nodeType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof TextNodeTest) {\n        if (node.getNodeType()!= Node.TEXT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof CommentTest) {\n        if (node.getNodeType()!= Node.COMMENT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType()!= Node.PROCESSING_INSTRUCTION_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (nodeNS.equals(namespaceURI)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        short nodeType = node.getNodeType();\n        if (nodeTypeTest.getNodeType() == nodeType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof CommentTest) {\n        if (node.getNodeType()!= Node.COMMENT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof TextTest) {\n        if (node.getNodeType()!= Node.TEXT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType()!= Node.PROCESSING_INSTRUCTION_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof Sche",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (nodeNS.equals(namespaceURI)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        short nodeType = node.getNodeType();\n        if (nodeTypeTest.getNodeType() == nodeType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof CommentTest) {\n        if (node.getNodeType()!= Node.COMMENT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof TextTest) {\n        if (node.getNodeType()!= Node.TEXT_NODE\n            && node.getNodeType()!= Node.CDATA_SECTION_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType()!= Node.PROCESSING_INSTRUCTION_NODE) {\n            return false",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (nodeNS.equals(namespaceURI)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        short nodeType = node.getNodeType();\n        if (nodeTypeTest.getNodeType() == nodeType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof CommentTest) {\n        if (node.getNodeType()!= Node.COMMENT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof TextTest) {\n        if (node.getNodeType()!= Node.TEXT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType()!= Node.PROCESSING_INSTRUCTION_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof Node",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            if (nodeNS.equals(namespaceURI)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        short nodeType = node.getNodeType();\n        if (nodeTypeTest.getNodeType() == nodeType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof CommentTest) {\n        if (node.getNodeType()!= Node.COMMENT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof TextTest) {\n        if (node.getNodeType()!= Node.TEXT_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType()!= Node.PROCESSING_INSTRUCTION_NODE) {\n            return false;\n        }\n        return true;\n    }\n    if (test instanceof Document"
      ],
      "function range": "87,5-136,5"
    },
    "JxPath_21_/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java_152-153": {
      "loc": "152-153",
      "input": "public int getLength() {",
      "output": [
        "public int getLength() {\n        return length;\n    }\n\n    public void setLength(int length) {\n        this.length = length;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\n",
        "public int getLength() {\n        return length;\n    }\n\n    public void setLength(int length) {\n        this.length = length;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAgg",
        "public int getLength() {\n        return length;\n    }\n\n    public void setLength(int length) {\n        this.length = length;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport",
        "public int getLength() {\n        return length;\n    }\n\n    public void setLength(int length) {\n        this.length = length;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregate",
        "public int getLength() {\r\n\t\treturn length;\r\n\t}\r\n\r\n\tpublic void setLength(int length) {\r\n\t\tthis.length = length;\r\n\t}\r\n\r\n\tpublic String getName() {\r\n\t\treturn name;\r\n\t}\r\n\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\tpublic String getType() {\r\n\t\treturn type;\r\n\t}\r\n\r\n\tpublic void setType(String type) {\r\n\t\tthis.type = type;\r\n\t}\r\n\r\n\tpublic String getValue() {\r\n\t\treturn value;\r\n\t}\r\n\r\n\tpublic void setValue(String value) {\r\n\t\tthis.value = value;\r\n\t}\r\n\r\n}\r\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* $Id$ */\n\npackage org.apache.fop.render.rtf.rtflib.rtfdoc;\n\n/*\n * This file is part of the RTF library of the FOP project, which was originally\n * created by Bertrand Delacretaz <bdelacretaz@codeconsult.ch> and by other\n * contributors to the jfor project (www.jfor.org), who agreed to donate jfor to\n * the FOP project.\n */\n\nimport java.io.IOException;\nimport",
        "public int getLength() {\n        return length;\n    }\n\n    public void setLength(int length) {\n        this.length = length;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;",
        "public int getLength() {\r\n\t\treturn length;\r\n\t}\r\n\r\n\tpublic void setLength(int length) {\r\n\t\tthis.length = length;\r\n\t}\r\n\r\n\tpublic String getName() {\r\n\t\treturn name;\r\n\t}\r\n\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\tpublic String getType() {\r\n\t\treturn type;\r\n\t}\r\n\r\n\tpublic void setType(String type) {\r\n\t\tthis.type = type;\r\n\t}\r\n\r\n\tpublic String getValue() {\r\n\t\treturn value;\r\n\t}\r\n\r\n\tpublic void setValue(String value) {\r\n\t\tthis.value = value;\r\n\t}\r\n\r\n}\r\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* $Id$ */\n\npackage org.apache.fop.render.rtf.rtflib.rtfdoc;\n\n/*\n * This file is part of the RTF library of the FOP project, which was originally\n * created by Bertrand Delacretaz <bdelacretaz@codeconsult.ch> and by other\n * contributors to the jfor project (www.jfor.org), who agreed to donate jfor to\n * the FOP project.\n */\n\nimport java.io.IOException;\n\n",
        "public int getLength() {\n        return length;\n    }\n\n    public void setLength(int length) {\n        this.length = length;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org",
        "public int getLength() {\n        return length;\n    }\n\n    public void setLength(int length) {\n        this.length = length;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.al",
        "public int getLength() {\r\n\t\treturn length;\r\n\t}\r\n\r\n\tpublic void setLength(int length) {\r\n\t\tthis.length = length;\r\n\t}\r\n\r\n\tpublic String getName() {\r\n\t\treturn name;\r\n\t}\r\n\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\tpublic String getType() {\r\n\t\treturn type;\r\n\t}\r\n\r\n\tpublic void setType(String type) {\r\n\t\tthis.type = type;\r\n\t}\r\n\r\n\tpublic String getValue() {\r\n\t\treturn value;\r\n\t}\r\n\r\n\tpublic void setValue(String value) {\r\n\t\tthis.value = value;\r\n\t}\r\n\r\n}\r\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n"
      ],
      "function range": "151,5-153,5"
    },
    "Lang_6_/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java_95-96": {
      "loc": "95-96",
      "input": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {",
      "output": [
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.AT",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.AsterixBuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.AsterixBuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.h",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.functions.",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.pointables."
      ],
      "function range": "75,5-98,5"
    },
    "Lang_16_/src/main/java/org/apache/commons/lang3/math/NumberUtils.java_458-459": {
      "loc": "458-459",
      "input": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }",
      "output": [
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"-\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\"--\")) {\n        str = str.substring(0, str.length() - 2);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.startsWith(\".\")) {\n        str = str.substring(1);\n    }\n    if (str.startsWith(\"0x\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0b\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\"L\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"l\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"f\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"F\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"d\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"D\")) {\n        str = str.substring(0,",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"-\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\"--\")) {\n        str = str.substring(0, str.length() - 2);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.startsWith(\".\")) {\n        str = str.substring(1);\n    }\n    if (str.startsWith(\"0x\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0b\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\"L\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"l\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"f\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"d\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"F\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"D\")) {\n        str = str.substring(0,",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"-\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\"--\")) {\n        str = str.substring(0, str.length() - 2);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.startsWith(\".\")) {\n        str = str.substring(1);\n    }\n    if (str.startsWith(\"0x\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0b\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0o\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0b\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0x\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0o\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0b\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0x\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0o\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0b\")) {\n        str = str",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"-\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\"--\")) {\n        str = str.substring(0, str.length() - 2);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\",\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\" \")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\":\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\";\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\",\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\" \")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\":\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"-\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\"--\")) {\n        str = str.substring(0, str.length() - 2);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.startsWith(\".\")) {\n        str = str.substring(1);\n    }\n    if (str.startsWith(\"0x\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0b\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0o\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0b\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0x\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0o\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0b\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0x\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0b\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0o\")) {\n        str = str",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"-\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\"--\")) {\n        str = str.substring(0, str.length() - 2);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.startsWith(\".\")) {\n        str = str.substring(1);\n    }\n    if (str.startsWith(\"0x\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0b\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\"L\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"l\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"f\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"d\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"e\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"E\")) {\n        str = str.substring(0,",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"-\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\"--\")) {\n        str = str.substring(0, str.length() - 2);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\",\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\" \")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\":\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\";\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\",\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\" \")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"-\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\"--\")) {\n        str = str.substring(0, str.length() - 2);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.startsWith(\".\")) {\n        str = str.substring(1);\n    }\n    if (str.startsWith(\"0x\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0b\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0o\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0b\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0x\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0o\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0b\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0x\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0b\")) {\n        str = str.substring(2);\n    }\n    if (str.startsWith(\"0x\")) {\n        str = str",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"-\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\"--\")) {\n        str = str.substring(0, str.length() - 2);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\",\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\" \")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\":\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\";\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"\\\"\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"(\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\")\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"!\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"-\")) {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\"--\")) {\n        str = str.substring(0, str.length() - 2);\n    }\n    if (str.endsWith(\"-\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\",\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\" \")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\".\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\":\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\";\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"\\\"\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\"(\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\")\")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    if (str.endsWith(\" \")) {\n        str = str.substring(0, str.length() - 1);\n    }\n"
      ],
      "function range": "444,5-594,5"
    },
    "Lang_21_/src/main/java/org/apache/commons/lang3/time/DateUtils.java_265-266": {
      "loc": "265-266",
      "input": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&",
      "output": [
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_YEAR) == cal2.get(Calendar.DAY_OF_WEEK_IN_YEAR) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET) &&\n            cal1.get",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_YEAR) == cal2.get(Calendar.DAY_OF_WEEK_IN_YEAR) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET) &&\n            cal1.get(Calendar.DST_OFFSET) == cal2.get(Calendar.DST_OFFSET) &&\n            cal1.get",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_YEAR) == cal2.get(Calendar.DAY_OF_WEEK_IN_YEAR) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET) &&\n            cal1.get(Calendar.DST_OFFSET) == cal2.get(Calendar.DST_OFFSET));\n  }\n}\n",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_YEAR) == cal2.get(Calendar.DAY_OF_WEEK_IN_YEAR) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET) &&\n            cal1.get(Calendar.DST_OFFSET) == cal2.get(Calendar.DST_OFFSET));\n  }\n\n  public static",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_YEAR) == cal2.get(Calendar.DAY_OF_WEEK_IN_YEAR) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET) &&\n            cal1.get(Calendar.DST_OFFSET) == cal2.get(Calendar.DST_OFFSET));\n  }\n\n  /**\n",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_YEAR) == cal2.get(Calendar.DAY_OF_WEEK_IN_YEAR) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET) &&\n            cal1.get(Calendar.DST_OFFSET) == cal2.get(Calendar.DST_OFFSET) &&\n            cal1.get",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_YEAR) == cal2.get(Calendar.DAY_OF_WEEK_IN_YEAR) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET));\n  }\n}\n",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_YEAR) == cal2.get(Calendar.DAY_OF_WEEK_IN_YEAR) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET) &&\n            cal1.get(Calendar.DST_OFFSET) == cal2.get(Calendar.DST_OFFSET));\n  }\n}\n",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_YEAR) == cal2.get(Calendar.DAY_OF_WEEK_IN_YEAR) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET));\n  }\n\n  public static",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_YEAR) == cal2.get(Calendar.DAY_OF_WEEK_IN_YEAR) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET) &&\n            cal1.get(Calendar.DST_OFFSET) == cal2.get(Calendar.DST_OFFSET));\n  }\n\n  public static"
      ],
      "function range": "258,5-270,5"
    },
    "Lang_26_/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java_820-821": {
      "loc": "820-821",
      "input": "public String format(Date date) {",
      "output": [
        "public String format(Date date) {\n        return dateFormat.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\n",
        "public String format(Date date) {\n        return dateFormat.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long",
        "public String format(Date date) {\n        return dateFormat.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class MaxAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long serialVersion",
        "public String format(Date date) {\n        return dateFormat.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class LocalSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long serial",
        "public String format(Date date) {\n        return dateFormat.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final",
        "public String format(Date date) {\n        return dateFormat.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long",
        "public String format(Date date) {\n        return dateFormat.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final",
        "public String format(Date date) {\n        return dateFormat.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport",
        "public String format(Date date) {\n        return dateFormat.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {",
        "public String format(Date date) {\n        return dateFormat.format(date);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalS"
      ],
      "function range": "819,5-823,5"
    },
    "Lang_33_/src/main/java/org/apache/commons/lang3/ClassUtils.java_910-911": {
      "loc": "910-911",
      "input": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {",
      "output": [
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i] == null? null : array[i].getClass();\n    }\n    return classes;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i] == null? null : array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvalu",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i] == null? null : array[i].getClass();\n    }\n    return classes;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i] == null? null : array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i] == null? null : array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i] == null? null : array[i].getClass();\n    }\n    return classes;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i] == null? null : array[i].getClass();\n    }\n    return classes;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEval",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i] == null? null : array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarE",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i] == null? null : array[i].getClass();\n    }\n    return classes;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyAggregateFunction;\nimport",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i] == null? null : array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyAggregateFunction;\n"
      ],
      "function range": "902,5-913,5"
    },
    "Lang_39_/src/java/org/apache/commons/lang3/StringUtils.java_3676-3677": {
      "loc": "3676-3677",
      "input": "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {",
      "output": [
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (searchList[i] == null || searchList[i].length() == 0) {\n            continue;\n        }\n        if (noMoreMatchesForReplIndex[i]) {\n            continue;\n        }",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (!noMoreMatchesForReplIndex[i] && searchList[i].length() > 0) {\n            increase = searchList[i].length();\n        }\n    }\n    increase *= repeat;",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (noMoreMatchesForReplIndex[i]) {\n            continue;\n        }\n        increase = searchList[i].length() - replacementList[i].length();\n        if (increase < 0) {",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (searchList[i] == null || searchList[i].length() == 0 || \n            noMoreMatchesForReplIndex[i]) \n        {\n            continue;\n        }\n        if (replaceIndex",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0) \n        {\n            continue;\n        }\n        if (search",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            increase",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0) \n        {\n            continue;\n        }\n        if (replace",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0) \n        {\n            continue;\n        }\n        if (start"
      ],
      "function range": "3605,5-3731,5"
    },
    "Lang_40_/src/java/org/apache/commons/lang/StringUtils.java_1048-1049": {
      "loc": "1048-1049",
      "input": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }",
      "output": [
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    int len = searchStr.length();\n    int max = str.length() - len;\n    for (int i = 0; i <= max; i++) {\n        if (str.regionMatches(true, i, searchStr, 0, len)) {\n            return true;\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.h",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    int len = searchStr.length();\n    int max = str.length() - len;\n    for (int i = 0; i <= max; i++) {\n        if (str.regionMatches(true, i, searchStr, 0, len)) {\n            return true;\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    int len = searchStr.length();\n    int max = str.length() - len;\n    for (int i = 0; i <= max; i++) {\n        if (str.regionMatches(true, i, searchStr, 0, len)) {\n            return true;\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    int len = searchStr.length();\n    int max = str.length() - len;\n    for (int i = 0; i <= max; i++) {\n        if (str.regionMatches(true, i, searchStr, 0, len)) {\n            return true;\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    int len = searchStr.length();\n    int max = str.length() - len;\n    for (int i = 0; i <= max; i++) {\n        if (str.regionMatches(true, i, searchStr, 0, len)) {\n            return true;\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\n",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    int len = searchStr.length();\n    int max = str.length() - len;\n    for (int i = 0; i <= max; i++) {\n        if (str.regionMatches(true, i, searchStr, 0, len)) {\n            return true;\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyr",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    int len = searchStr.length();\n    int max = str.length() - len;\n    for (int i = 0; i <= max; i++) {\n        if (str.regionMatches(true, i, searchStr, 0, len)) {\n            return true;\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    int len = searchStr.length();\n    int max = str.length() - len;\n    for (int i = 0; i <= max; i++) {\n        if (str.regionMatches(true, i, searchStr, 0, len)) {\n            return true;\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.h",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    int len = searchStr.length();\n    int max = str.length() - len;\n    for (int i = 0; i <= max; i++) {\n        if (str.regionMatches(true, i, searchStr, 0, len)) {\n            return true;\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluator;\nimport org.apache.hyr",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    int len = searchStr.length();\n    int max = str.length() - len;\n    for (int i = 0; i <= max; i++) {\n        if (str.regionMatches(true, i, searchStr, 0, len)) {\n            return true;\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime"
      ],
      "function range": "1044,5-1049,5"
    },
    "Lang_43_/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java_422-423": {
      "loc": "422-423",
      "input": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {",
      "output": [
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        appendTo.append(QUOTE);\n        start++;\n    }\n    for (int i = start; i < c.length; i++) {\n        switch (c[i]) {\n        case QUOTE:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            } else {\n                escapingOn = true;\n            }\n            break;\n        default:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            }\n            appendTo.append(c[i]);\n            break;\n        }\n    }\n    if (escapingOn) {\n        appendTo.append(QUOTE);\n    }\n    pos.setIndex(start);\n    return appendTo;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        appendTo.append(QUOTE);\n        start++;\n    }\n    for (int i = start; i < c.length; i++) {\n        switch (c[i]) {\n        case QUOTE:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            } else {\n                escapingOn = true;\n            }\n            break;\n        default:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            }\n            appendTo.append(c[i]);\n            break;\n        }\n    }\n    if (escapingOn) {\n        appendTo.append(QUOTE);\n    }\n    pos.setIndex(start);\n    return appendTo;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.dataflow.data",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        appendTo.append(QUOTE);\n        start++;\n    }\n    for (int i = start; i < c.length; i++) {\n        switch (c[i]) {\n        case QUOTE:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            } else {\n                escapingOn = true;\n            }\n            break;\n        default:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            }\n            appendTo.append(c[i]);\n            break;\n        }\n    }\n    if (escapingOn) {\n        appendTo.append(QUOTE);\n    }\n    pos.setIndex(start);\n    return appendTo;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.common.annotations.MissingNullInOutFunction;\nimport org.apache.asterix.om.fun",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        appendTo.append(QUOTE);\n        start++;\n    }\n    for (int i = start; i < c.length; i++) {\n        switch (c[i]) {\n        case QUOTE:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            } else {\n                escapingOn = true;\n            }\n            break;\n        default:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            }\n            appendTo.append(c[i]);\n            break;\n        }\n    }\n    if (escapingOn) {\n        appendTo.append(QUOTE);\n    }\n    pos.setIndex(start);\n    return appendTo;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.h",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        appendTo.append(QUOTE);\n        start++;\n    }\n    for (int i = start; i < c.length; i++) {\n        switch (c[i]) {\n        case QUOTE:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            } else {\n                escapingOn = true;\n            }\n            break;\n        default:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            }\n            appendTo.append(c[i]);\n            break;\n        }\n    }\n    if (escapingOn) {\n        appendTo.append(QUOTE);\n    }\n    pos.setIndex(start);\n    return appendTo;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.formats.n",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        appendTo.append(QUOTE);\n        start++;\n    }\n    for (int i = start; i < c.length; i++) {\n        switch (c[i]) {\n        case QUOTE:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            } else {\n                escapingOn = true;\n            }\n            break;\n        default:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            }\n            appendTo.append(c[i]);\n            break;\n        }\n    }\n    if (escapingOn) {\n        appendTo.append(QUOTE);\n    }\n    pos.setIndex(start);\n    return appendTo;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.common.annotations",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        appendTo.append(QUOTE);\n        start++;\n    }\n    for (int i = start; i < c.length; i++) {\n        switch (c[i]) {\n        case QUOTE:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            } else {\n                escapingOn = true;\n            }\n            break;\n        default:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            }\n            appendTo.append(c[i]);\n            break;\n        }\n    }\n    if (escapingOn) {\n        appendTo.append(QUOTE);\n    }\n    pos.setIndex(start);\n    return appendTo;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.om.functions",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        appendTo.append(QUOTE);\n        start++;\n    }\n    for (int i = start; i < c.length; i++) {\n        switch (c[i]) {\n        case QUOTE:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            } else {\n                escapingOn = true;\n            }\n            break;\n        default:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            }\n            appendTo.append(c[i]);\n            break;\n        }\n    }\n    if (escapingOn) {\n        appendTo.append(QUOTE);\n    }\n    pos.setIndex(start);\n    return appendTo;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheAtom",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        appendTo.append(QUOTE);\n        start++;\n    }\n    for (int i = start; i < c.length; i++) {\n        switch (c[i]) {\n        case QUOTE:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            } else {\n                escapingOn = true;\n            }\n            break;\n        default:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            }\n            appendTo.append(c[i]);\n            break;\n        }\n    }\n    if (escapingOn) {\n        appendTo.append(QUOTE);\n    }\n    pos.setIndex(start);\n    return appendTo;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheMode;",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        appendTo.append(QUOTE);\n        start++;\n    }\n    for (int i = start; i < c.length; i++) {\n        switch (c[i]) {\n        case QUOTE:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            } else {\n                escapingOn = true;\n            }\n            break;\n        default:\n            if (escapingOn) {\n                appendTo.append(QUOTE);\n                escapingOn = false;\n            }\n            appendTo.append(c[i]);\n            break;\n        }\n    }\n    if (escapingOn) {\n        appendTo.append(QUOTE);\n    }\n    pos.setIndex(start);\n    return appendTo;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions.records;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.form"
      ],
      "function range": "417,5-444,5"
    },
    "Lang_51_/src/java/org/apache/commons/lang/BooleanUtils.java_682-683": {
      "loc": "682-683",
      "input": "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) == 's' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) == 's');\n            }",
      "output": [
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n            break;\n        }\n        case 4: {\n            char ch = str.charAt(0);\n            if (ch == 't') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                    (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n            }\n            if (ch == 'T') {\n                return \n                    (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                    (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                    (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n            }\n            break;\n        }\n",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n            break;\n        }\n        case 4: {\n            char ch = str.charAt(0);\n            if (ch == 't' || ch == 'T') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                    (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n            }\n            if (ch == 'T') {\n                return \n                    (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                    (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                    (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n            }\n            ",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n            break;\n        }\n        case 5: {\n            char ch = str.charAt(0);\n            if (ch == 't') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                    (str.charAt(3) == 'e' || str.charAt(3) == 'E') &&\n                    (str.charAt(4) =='s' || str.charAt(4) == 'S');\n            }\n            if (ch == 'T') {\n                return \n                    (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                    (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                    (str.charAt(3)",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n            return false;\n        }\n        case 4: {\n            char ch = str.charAt(0);\n            if (ch == 't') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                    (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n            }\n            if (ch == 'T') {\n                return \n                    (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                    (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                    (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n            }\n            return false;\n        ",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n            break;\n        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            if (ch0 == 't' || ch0 == 'T') {\n                if (ch1 == 'r' || ch1 == 'R') {\n                    if (ch2 == 'u' || ch2 == 'U') {\n                        if (ch3 == 'e' || ch3 == 'E') {\n                            return true;\n                        }\n                    }\n                }\n            }\n            if (ch0 == 'f' || ch0 == 'F') {\n                if (ch1 == 'a' || ch1 == 'A') {\n                    if (ch2 == 'l' || ch2 == 'L') {\n                        if (ch3 =='s' || ch3 == 'S') {\n",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n            break;\n        }\n        case 4: {\n            char ch = str.charAt(0);\n            if (ch == 't' || ch == 'T') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                    (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n            }\n            if (ch == 'T' || ch == 't') {\n                return \n                    (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                    (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                    (str.charAt(3) == 'E' || str.charAt(3) == 'e",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n            return false;\n        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            if (ch0 == 't' || ch0 == 'T') {\n                if (ch1 == 'r' || ch1 == 'R') {\n                    if (ch2 == 'u' || ch2 == 'U') {\n                        if (ch3 == 'e' || ch3 == 'E') {\n                            return true;\n                        }\n                    }\n                }\n            }\n            if (ch0 == 'f' || ch0 == 'F') {\n                if (ch1 == 'a' || ch1 == 'A') {\n                    if (ch2 == 'l' || ch2 == 'L') {\n                        if (ch3 =='s' || ch3 == 'S') {",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n            return false;\n        }\n        case 4: {\n            char ch = str.charAt(0);\n            if (ch == 't') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                    (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n            }\n            if (ch == 'T') {\n                return \n                    (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                    (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                    (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n            }\n            if (ch == '",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n            break;\n        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            if (ch0 == 't' || ch0 == 'T') {\n                return \n                    (ch1 == 'r' || ch1 == 'R') &&\n                    (ch2 == 'u' || ch2 == 'U') &&\n                    (ch3 == 'e' || ch3 == 'E');\n            }\n            if (ch0 == 'T') {\n                return \n                    (ch1 == 'R' || ch1 == 'r') &&\n                    (ch2 == 'U' || ch2 == 'u') &&\n                    (ch3 == 'E' || ch3 == 'e');\n            }\n            break;\n        }\n        case 5: {\n            char ch0 =",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n            break;\n        }\n        case 4: {\n            char ch = str.charAt(0);\n            if (ch == 't') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                    (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n            }\n            if (ch == 'T') {\n                return \n                    (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                    (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                    (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n            }\n            if (ch == 'f"
      ],
      "function range": "649,5-700,5"
    },
    "Lang_57_/src/java/org/apache/commons/lang/LocaleUtils.java_223-224": {
      "loc": "223-224",
      "input": "public static boolean isAvailableLocale(Locale locale) {",
      "output": [
        "public static boolean isAvailableLocale(Locale locale) {\n        return availableLocales.contains(locale);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.",
        "public static boolean isAvailableLocale(Locale locale) {\n        return availableLocales.contains(locale);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregateFunctionDynamicDescript",
        "public static boolean isAvailableLocale(Locale locale) {\n        return availableLocales.contains(locale);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class LocalSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor",
        "public static boolean isAvailableLocale(Locale locale) {\n        return availableLocales.contains(locale);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class MaxAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {",
        "public static boolean isAvailableLocale(Locale locale) {\n        return availableLocales.contains(locale);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksData",
        "public static boolean isAvailableLocale(Locale locale) {\n        return availableLocales.contains(locale);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAggregateDescriptor extends AbstractAggregateFunctionDynamicDesc",
        "public static boolean isAvailableLocale(Locale locale) {\n        return availableLocales.contains(locale);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescript",
        "public static boolean isAvailableLocale(Locale locale) {\n        return availableLocales.contains(locale);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDesc",
        "public static boolean isAvailableLocale(Locale locale) {\n        return availableLocales.contains(locale);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends Abstract",
        "public static boolean isAvailableLocale(Locale locale) {\n        return availableLocales.contains(locale);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAggregateDescriptor extends"
      ],
      "function range": "222,5-224,5"
    },
    "Lang_58_/src/java/org/apache/commons/lang/math/NumberUtils.java_454-456": {
      "loc": "454-456",
      "input": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null",
      "output": [
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && allZeros",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && mant.length",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    &&!allZ",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && str.length",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && numbers.length",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && Integer.parse",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && isDouble(",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && numbers.index",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && str.ends"
      ],
      "function range": "397,5-545,5"
    },
    "Lang_59_/src/java/org/apache/commons/lang/text/StrBuilder.java_884-885": {
      "loc": "884-885",
      "input": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {",
      "output": [
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }\n\n  /**\n   * Appends a string.\n   *\n   * @param str the string to append\n   * @return this\n   */\n  public StrBuilder append(String str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends a string buffer.\n   *\n   * @param str the string buffer to append\n   * @return this\n   */\n  public StrBuilder append(StringBuffer str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends an object.\n   *\n   * @param obj the object to append\n   * @return this\n   */\n  public StrBuilder append(Object obj) {\n    if (obj == null) {\n      appendNull();\n      return this;\n    }\n    return append(obj.",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }\n\n  /**\n   * Appends a string.\n   *\n   * @param str the string to append\n   * @return this\n   */\n  public StrBuilder append(String str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends a string buffer.\n   *\n   * @param str the string buffer to append\n   * @return this\n   */\n  public StrBuilder append(StringBuffer str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends a string builder.\n   *\n   * @param str the string builder to append\n   * @return this\n   */\n  public StrBuilder append(StringBuilder str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen =",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }\n\n  /**\n   * Appends a string.\n   *\n   * @param str the string to append\n   * @return this\n   */\n  public StrBuilder append(String str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends a string buffer.\n   *\n   * @param str the string buffer to append\n   * @return this\n   */\n  public StrBuilder append(StringBuffer str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends an object.\n   *\n   * @param obj the object to append\n   * @return this\n   */\n  public StrBuilder append(Object obj) {\n    if (obj == null) {\n      return append(getNullText());\n    }\n    return append(obj.to",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }\n\n  /**\n   * Appends a string.\n   *\n   * @param str the string to append\n   * @return this\n   */\n  public StrBuilder append(String str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends a string.\n   *\n   * @param str the string to append\n   * @return this\n   */\n  public StrBuilder append(StringBuffer str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends a string.\n   *\n   * @param str the string to append\n   * @return this\n   */\n  public StrBuilder append(StringBuilder str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }\n\n  /**\n   * Appends a string.\n   *\n   * @param str the string to append\n   * @return this\n   */\n  public StrBuilder append(String str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends a string buffer.\n   *\n   * @param str the string buffer to append\n   * @return this\n   */\n  public StrBuilder append(StringBuffer str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends an object.\n   *\n   * @param obj the object to append\n   * @return this\n   */\n  public StrBuilder append(Object obj) {\n    if (obj == null) {\n      obj = getNullText();\n    }\n    return append(obj.toString",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }\n\n  /**\n   * Appends a string.\n   *\n   * @param str the string to append\n   * @return this\n   */\n  public StrBuilder append(String str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends a string.\n   *\n   * @param str the string to append\n   * @return this\n   */\n  public StrBuilder append(StringBuffer str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends a string.\n   *\n   * @param str the string to append\n   * @return this\n   */\n  public StrBuilder append(StrBuilder str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.size();",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }\n\n  /**\n   * Appends a string.\n   *\n   * @param str the string to append\n   * @return this\n   */\n  public StrBuilder append(String str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends a string buffer.\n   *\n   * @param str the string buffer to append\n   * @return this\n   */\n  public StrBuilder append(StringBuffer str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends an array of characters.\n   *\n   * @param chr the characters to append\n   * @return this\n   */\n  public StrBuilder append(char[] chr) {\n    if (chr == null) {\n      chr = getNullText().toCharArray();\n",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }\n\n  /**\n   * Appends a string.\n   *\n   * @param str the string to append\n   * @return this\n   */\n  public StrBuilder append(String str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends a string buffer.\n   *\n   * @param str the string buffer to append\n   * @return this\n   */\n  public StrBuilder append(StringBuffer str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends an object.\n   *\n   * @param obj the object to append\n   * @return this\n   */\n  public StrBuilder append(Object obj) {\n    if (obj == null) {\n      obj = getNullText();\n    }\n    ensureCapacity(size +",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }\n\n  /**\n   * Appends a string.\n   *\n   * @param str the string to append\n   * @return this\n   */\n  public StrBuilder append(String str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends a string buffer.\n   *\n   * @param str the string buffer to append\n   * @return this\n   */\n  public StrBuilder append(StringBuffer str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends an object.\n   *\n   * @param obj the object to append\n   * @return this\n   */\n  public StrBuilder append(Object obj) {\n    if (obj == null) {\n      appendNullText();\n    } else {\n      appendNotNullText(obj.",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }\n\n  /**\n   * Appends a string.\n   *\n   * @param str the string to append\n   * @return this\n   */\n  public StrBuilder append(String str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends a string buffer.\n   *\n   * @param str the string buffer to append\n   * @return this\n   */\n  public StrBuilder append(StringBuffer str) {\n    if (str == null) {\n      str = getNullText();\n    }\n    int strLen = str.length();\n    ensureCapacity(size + strLen);\n    str.getChars(0, strLen, buffer, size);\n    size += strLen;\n    return this;\n  }\n\n  /**\n   * Appends an object.\n   *\n   * @param obj the object to append\n   * @return this\n   */\n  public StrBuilder append(Object obj) {\n    if (obj == null) {\n      obj = getNullText();\n    }\n    if (obj instanceof CharSequ"
      ],
      "function range": "878,5-895,5"
    },
    "Lang_61_/src/java/org/apache/commons/lang/text/StrBuilder.java_1776-1777": {
      "loc": "1776-1777",
      "input": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0 ? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;",
      "output": [
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\n/**\n * Returns the index within this buffer of the first occurrence of the\n * specified character, starting the search at the specified\n * <code>beginIndex</code> and finishing at <code>endIndex</code>.\n * If no such character occurs in this buffer within the specified bounds,\n * <code>-1</code> is returned.\n * <p>\n * There is no restriction on the value of <code>beginIndex</code> and\n * <code>endIndex</code>. If <code>beginIndex</code> is negative,\n * it has the same effect as if it were zero. If <code>endIndex</code> is\n * greater than <code>length()</code>, it has the same effect as if it were\n * <code>length()</code>. If the <code>beginIndex</code> is greater than\n * the <code>endIndex</code>, <code>-1</code> is returned.\n *\n * @param   str     the char to search for.\n * @param   beginIndex the index to start the search from.\n * @param   endIndex the index to finish the search at.\n * @return  the index of the first occurrence of the character in the buffer\n",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\n/**\n * Returns the index within this buffer of the first occurrence of the\n * specified character, starting the search at the specified\n * <code>beginIndex</code> and finishing at <code>endIndex</code>.\n * If no such character occurs in this buffer within the specified bounds,\n * <code>-1</code> is returned.\n * <p>\n * There is no restriction on the value of <code>beginIndex</code> and\n * <code>endIndex</code>. If <code>beginIndex</code> is negative,\n * it has the same effect as if it were zero. If <code>endIndex</code> is\n * greater than <code>length()</code>, it has the same effect as if it were\n * <code>length()</code>. If the <code>beginIndex</code> is greater than\n * the <code>endIndex</code>, <code>-1</code> is returned.\n *\n * @param   str     the string to search for.\n * @param   beginIndex the index to start the search from.\n * @param   endIndex the index to finish the search at.\n * @return  the index of the first occurrence of the character in the buffer\n",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\n/**\n * Returns the index within this buffer of the first occurrence of the\n * specified character, starting the search at the specified\n * <code>beginIndex</code> and finishing at <code>endIndex</code>.\n * If no such character occurs in this buffer within the specified bounds,\n * <code>-1</code> is returned.\n * <p>\n * There is no restriction on the value of <code>beginIndex</code> and\n * <code>endIndex</code>. If <code>beginIndex</code> is negative,\n * it has the same effect as if it were zero. If <code>endIndex</code> is\n * greater than <code>length()</code>, it has the same effect as if it were\n * <code>length()</code>. If the <code>beginIndex</code> is greater than\n * the <code>endIndex</code>, <code>-1</code> is returned.\n *\n * @param ch  the character to search for.\n * @param beginIndex  the index to start the search from.\n * @param endIndex  the index to finish the search at.\n * @return the index of the first occurrence of the character in the buffer\n *  ",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\n/**\n * Returns the index within this buffer of the first occurrence of the\n * specified character, starting the search at the specified\n * <code>beginIndex</code> and finishing at <code>endIndex</code>.\n * If no such character occurs in this buffer within the specified bounds,\n * <code>-1</code> is returned.\n * <p>\n * There is no restriction on the value of <code>beginIndex</code> and\n * <code>endIndex</code>. If <code>beginIndex</code> is negative,\n * it has the same effect as if it were zero. If <code>endIndex</code> is\n * greater than <code>length()</code>, it has the same effect as if it were\n * <code>length()</code>. If the <code>beginIndex</code> is greater than\n * the <code>endIndex</code>, <code>-1</code> is returned.\n *\n * @param   ch          the char to search for.\n * @param   beginIndex  the index to start the search from.\n * @param   endIndex  the index to finish the search at.\n * @return  the index of the first occurrence of the character in the",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\n/**\n * Returns the index within this buffer of the first occurrence of the\n * specified character, starting the search at the specified\n * <code>beginIndex</code> and finishing at <code>endIndex</code>.\n * If no such character occurs in this buffer within the specified bounds,\n * <code>-1</code> is returned.\n * <p>\n * There is no restriction on the value of <code>beginIndex</code> and\n * <code>endIndex</code>. If <code>beginIndex</code> is negative,\n * it has the same effect as if it were zero. If <code>endIndex</code> is\n * greater than <code>length()</code>, it has the same effect as if it were\n * <code>length()</code>. If the <code>beginIndex</code> is greater than\n * the <code>endIndex</code>, <code>-1</code> is returned.\n *\n * @param ch\n *            the character to search for.\n * @param beginIndex\n *            the index to start the search from.\n * @param endIndex\n *            the index to finish the search at.\n * @return the index of the first occurrence of the character",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\n/**\n * Returns the index within this buffer of the first occurrence of the\n * specified character, starting the search at the specified\n * <code>beginIndex</code> and finishing at <code>endIndex</code>.\n * If no such character occurs in this buffer within the specified bounds,\n * <code>-1</code> is returned.\n * <p>\n * There is no restriction on the value of <code>beginIndex</code> and\n * <code>endIndex</code>. If <code>beginIndex</code> is negative,\n * it has the same effect as if it were zero. If <code>endIndex</code> is\n * greater than <code>length()</code>, it has the same effect as if it were\n * <code>length()</code>. If the <code>beginIndex</code> is greater than\n * the <code>endIndex</code>, <code>-1</code> is returned.\n *\n * @param   str     the char to search for.\n * @param   beginIndex   the index to start the search from.\n * @param   endIndex   the index to finish the search at.\n * @return  the index of the first occurrence of the character in the",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\n/**\n * Returns the index within this buffer of the first occurrence of the\n * specified character, starting the search at the specified\n * <code>beginIndex</code> and finishing at <code>endIndex</code>.\n * If no such character occurs in this buffer within the specified bounds,\n * <code>-1</code> is returned.\n * <p>\n * There is no restriction on the value of <code>beginIndex</code> and\n * <code>endIndex</code>. If <code>beginIndex</code> is negative,\n * it has the same effect as if it were zero. If <code>endIndex</code> is\n * greater than <code>length()</code>, it has the same effect as if it were\n * <code>length()</code>. If the <code>beginIndex</code> is greater than\n * the <code>endIndex</code>, <code>-1</code> is returned.\n *\n * @param   ch          the character to search for.\n * @param   beginIndex  the index to start the search from.\n * @param   endIndex  the index to finish the search at.\n * @return  the index of the first occurrence of the character in the",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\n/**\n * Returns the index within this buffer of the first occurrence of the\n * specified character, starting the search at the specified\n * <code>beginIndex</code> and finishing at <code>endIndex</code>.\n * If no such character occurs in this buffer within the specified bounds,\n * <code>-1</code> is returned.\n * <p>\n * There is no restriction on the value of <code>beginIndex</code> and\n * <code>endIndex</code>. If <code>beginIndex</code> is negative,\n * it has the same effect as if it were zero. If <code>endIndex</code> is\n * greater than <code>length()</code>, it has the same effect as if it were\n * <code>length()</code>. If the <code>beginIndex</code> is greater than\n * the <code>endIndex</code>, <code>-1</code> is returned.\n *\n * @param   str     the string to find.\n * @param   beginIndex the index to start the search from.\n * @param   endIndex   the index to finish the search at.\n * @return  the index of the first occurrence of the character in the buffer\n",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\n/**\n * Returns the index within this buffer of the first occurrence of the\n * specified character, starting the search at the specified\n * <code>beginIndex</code> and finishing at <code>endIndex</code>.\n * If no such character occurs in this buffer within the specified bounds,\n * <code>-1</code> is returned.\n * <p>\n * There is no restriction on the value of <code>beginIndex</code> and\n * <code>endIndex</code>. If <code>beginIndex</code> is negative,\n * it has the same effect as if it were zero. If <code>endIndex</code> is\n * greater than <code>length()</code>, it has the same effect as if it were\n * <code>length()</code>. If the <code>beginIndex</code> is greater than\n * the <code>endIndex</code>, <code>-1</code> is returned.\n *\n * @param   str         the string to search for.\n * @param   beginIndex the index to start the search from.\n * @param   endIndex   the index to finish the search at.\n * @return  the index of the first occurrence of the character in the buffer",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\n/**\n * Returns the index within this buffer of the first occurrence of the\n * specified character, starting the search at the specified\n * <code>beginIndex</code> and finishing at <code>endIndex</code>.\n * If no such character occurs in this buffer within the specified bounds,\n * <code>-1</code> is returned.\n * <p>\n * There is no restriction on the value of <code>beginIndex</code> and\n * <code>endIndex</code>. If <code>beginIndex</code> is negative,\n * it has the same effect as if it were zero. If <code>endIndex</code> is\n * greater than <code>length()</code>, it has the same effect as if it were\n * <code>length()</code>. If the <code>beginIndex</code> is greater than\n * the <code>endIndex</code>, <code>-1</code> is returned.\n *\n * @param   str     the string to search for.\n * @param   beginIndex the index to start the search from.\n * @param   endIndex the index to finish the search at.\n * @return  the index of the first occurrence of the character in the\n *"
      ],
      "function range": "1760,5-1787,5"
    },
    "Math_2_/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java_268-269": {
      "loc": "268-269",
      "input": "public double getNumericalMean() {",
      "output": [
        "public double getNumericalMean() {\n\t\treturn this.numericalMean;\n\t}\n\n\t@Override\n\tpublic double getNumericalVariance() {\n\t\treturn this.numericalVariance;\n\t}\n\n\t@Override\n\tpublic double getNumericalStandardDeviation() {\n\t\treturn this.numericalStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getGeometricMean() {\n\t\treturn this.geometricMean;\n\t}\n\n\t@Override\n\tpublic double getGeometricVariance() {\n\t\treturn this.geometricVariance;\n\t}\n\n\t@Override\n\tpublic double getGeometricStandardDeviation() {\n\t\treturn this.geometricStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getArithmeticMean() {\n\t\treturn this.arithmeticMean;\n\t}\n\n\t@Override\n\tpublic double getArithmeticVariance() {\n\t\treturn this.arithmeticVariance;\n\t}\n\n\t@Override\n\tpublic double getArithmeticStandardDeviation() {\n\t\treturn this.arithmeticStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getSum() {\n\t\treturn this.sum;\n\t}\n\n\t@Override\n\tpublic double getMinimum() {\n\t\treturn this.minimum;\n\t}\n\n\t@Override\n\tpublic double getMaximum() {\n\t\treturn this.maximum;\n\t}\n\n\t@Override\n\tpublic double getRange() {\n\t\treturn this.range;\n\t}\n\n\t@Override\n\tpublic double getSumOfSquares() {\n\t\treturn this.sumOfSquares;\n\t}\n\n\t@Override\n\tpublic double getSumOfLogs() {\n\t\treturn this.sumOfLogs;\n\t}\n\n\t@Override\n\tpublic double getSumOfInverses() {\n\t\treturn this.sumOfInverses;\n\t}\n\n\t@Override\n\tpublic double getProduct() {\n\t\treturn this.product;\n\t}\n\n\t@Override\n\tpublic double getQuotient() {\n\t\treturn this.quotient;\n\t}\n\n\t@Override\n\tpublic double getRootMeanSquare() {\n\t\treturn this.rootMeanSquare;\n\t}\n\n\t@Override",
        "public double getNumericalMean() {\n\t\treturn this.numericalMean;\n\t}\n\n\t@Override\n\tpublic double getNumericalVariance() {\n\t\treturn this.numericalVariance;\n\t}\n\n\t@Override\n\tpublic double getNumericalStandardDeviation() {\n\t\treturn this.numericalStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getGeometricMean() {\n\t\treturn this.geometricMean;\n\t}\n\n\t@Override\n\tpublic double getGeometricVariance() {\n\t\treturn this.geometricVariance;\n\t}\n\n\t@Override\n\tpublic double getGeometricStandardDeviation() {\n\t\treturn this.geometricStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getArithmeticMean() {\n\t\treturn this.arithmeticMean;\n\t}\n\n\t@Override\n\tpublic double getArithmeticVariance() {\n\t\treturn this.arithmeticVariance;\n\t}\n\n\t@Override\n\tpublic double getArithmeticStandardDeviation() {\n\t\treturn this.arithmeticStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getSum() {\n\t\treturn this.sum;\n\t}\n\n\t@Override\n\tpublic double getMinimum() {\n\t\treturn this.minimum;\n\t}\n\n\t@Override\n\tpublic double getMaximum() {\n\t\treturn this.maximum;\n\t}\n\n\t@Override\n\tpublic double getRange() {\n\t\treturn this.maximum - this.minimum;\n\t}\n\n\t@Override\n\tpublic double getSumOfSquares() {\n\t\treturn this.sumOfSquares;\n\t}\n\n\t@Override\n\tpublic double getSumOfLogs() {\n\t\treturn this.sumOfLogs;\n\t}\n\n\t@Override\n\tpublic double getSumOfInverses() {\n\t\treturn this.sumOfInverses;\n\t}\n\n\t@Override\n\tpublic double getProduct() {\n\t\treturn this.product;\n\t}\n\n\t@Override\n\tpublic double getQuotient() {\n\t\treturn this.quotient;\n\t}\n\n\t@Override\n\tpublic double getRootMeanSquare() {\n\t\treturn this.rootMeanSquare;\n\t}",
        "public double getNumericalMean() {\n\t\treturn this.numericalMean;\n\t}\n\n\t@Override\n\tpublic double getNumericalVariance() {\n\t\treturn this.numericalVariance;\n\t}\n\n\t@Override\n\tpublic double getNumericalStandardDeviation() {\n\t\treturn this.numericalStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getGeometricMean() {\n\t\treturn this.geometricMean;\n\t}\n\n\t@Override\n\tpublic double getGeometricVariance() {\n\t\treturn this.geometricVariance;\n\t}\n\n\t@Override\n\tpublic double getGeometricStandardDeviation() {\n\t\treturn this.geometricStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getArithmeticMean() {\n\t\treturn this.arithmeticMean;\n\t}\n\n\t@Override\n\tpublic double getArithmeticVariance() {\n\t\treturn this.arithmeticVariance;\n\t}\n\n\t@Override\n\tpublic double getArithmeticStandardDeviation() {\n\t\treturn this.arithmeticStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getSum() {\n\t\treturn this.sum;\n\t}\n\n\t@Override\n\tpublic double getMinimum() {\n\t\treturn this.minimum;\n\t}\n\n\t@Override\n\tpublic double getMaximum() {\n\t\treturn this.maximum;\n\t}\n\n\t@Override\n\tpublic double getMedian() {\n\t\treturn this.median;\n\t}\n\n\t@Override\n\tpublic double getSumOfSquares() {\n\t\treturn this.sumOfSquares;\n\t}\n\n\t@Override\n\tpublic double getSumOfLogs() {\n\t\treturn this.sumOfLogs;\n\t}\n\n\t@Override\n\tpublic double getSumOfInverses() {\n\t\treturn this.sumOfInverses;\n\t}\n\n\t@Override\n\tpublic double getProduct() {\n\t\treturn this.product;\n\t}\n\n\t@Override\n\tpublic double getQuotient() {\n\t\treturn this.quotient;\n\t}\n\n\t@Override\n\tpublic double getRootMeanSquare() {\n\t\treturn this.rootMeanSquare;\n\t}\n\n\t",
        "public double getNumericalMean() {\n\t\treturn this.numericalMean;\n\t}\n\n\t@Override\n\tpublic double getNumericalVariance() {\n\t\treturn this.numericalVariance;\n\t}\n\n\t@Override\n\tpublic double getNumericalStandardDeviation() {\n\t\treturn this.numericalStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getGeometricMean() {\n\t\treturn this.geometricMean;\n\t}\n\n\t@Override\n\tpublic double getGeometricVariance() {\n\t\treturn this.geometricVariance;\n\t}\n\n\t@Override\n\tpublic double getGeometricStandardDeviation() {\n\t\treturn this.geometricStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getArithmeticMean() {\n\t\treturn this.arithmeticMean;\n\t}\n\n\t@Override\n\tpublic double getArithmeticVariance() {\n\t\treturn this.arithmeticVariance;\n\t}\n\n\t@Override\n\tpublic double getArithmeticStandardDeviation() {\n\t\treturn this.arithmeticStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getSum() {\n\t\treturn this.sum;\n\t}\n\n\t@Override\n\tpublic double getMinimum() {\n\t\treturn this.minimum;\n\t}\n\n\t@Override\n\tpublic double getMaximum() {\n\t\treturn this.maximum;\n\t}\n\n\t@Override\n\tpublic double getRange() {\n\t\treturn this.range;\n\t}\n\n\t@Override\n\tpublic double getSumOfSquares() {\n\t\treturn this.sumOfSquares;\n\t}\n\n\t@Override\n\tpublic double getSumOfLogs() {\n\t\treturn this.sumOfLogs;\n\t}\n\n\t@Override\n\tpublic double getProduct() {\n\t\treturn this.product;\n\t}\n\n\t@Override\n\tpublic double getQuotient() {\n\t\treturn this.quotient;\n\t}\n\n\t@Override\n\tpublic double getRootMeanSquare() {\n\t\treturn this.rootMeanSquare;\n\t}\n\n\t@Override\n\tpublic double getSumLogs() {\n\t\treturn this.sumLogs;\n\t}\n\n\t@Override\n\tpublic double",
        "public double getNumericalMean() {\n\t\treturn this.numericalMean;\n\t}\n\n\t@Override\n\tpublic double getNumericalVariance() {\n\t\treturn this.numericalVariance;\n\t}\n\n\t@Override\n\tpublic double getNumericalStandardDeviation() {\n\t\treturn this.numericalStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getGeometricMean() {\n\t\treturn this.geometricMean;\n\t}\n\n\t@Override\n\tpublic double getGeometricVariance() {\n\t\treturn this.geometricVariance;\n\t}\n\n\t@Override\n\tpublic double getGeometricStandardDeviation() {\n\t\treturn this.geometricStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getArithmeticMean() {\n\t\treturn this.arithmeticMean;\n\t}\n\n\t@Override\n\tpublic double getArithmeticVariance() {\n\t\treturn this.arithmeticVariance;\n\t}\n\n\t@Override\n\tpublic double getArithmeticStandardDeviation() {\n\t\treturn this.arithmeticStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getSum() {\n\t\treturn this.sum;\n\t}\n\n\t@Override\n\tpublic double getMinimum() {\n\t\treturn this.minimum;\n\t}\n\n\t@Override\n\tpublic double getMaximum() {\n\t\treturn this.maximum;\n\t}\n\n\t@Override\n\tpublic double getSumOfSquares() {\n\t\treturn this.sumOfSquares;\n\t}\n\n\t@Override\n\tpublic double getSumOfLogs() {\n\t\treturn this.sumOfLogs;\n\t}\n\n\t@Override\n\tpublic double getSumOfInverses() {\n\t\treturn this.sumOfInverses;\n\t}\n\n\t@Override\n\tpublic double getProduct() {\n\t\treturn this.product;\n\t}\n\n\t@Override\n\tpublic double getQuotient() {\n\t\treturn this.quotient;\n\t}\n\n\t@Override\n\tpublic double getRootMeanSquare() {\n\t\treturn this.rootMeanSquare;\n\t}\n\n\t@Override\n\tpublic double getStandardError() {\n\t\treturn this.standardError;\n\t}\n\n\t",
        "public double getNumericalMean() {\n\t\treturn this.numericalMean;\n\t}\n\n\t@Override\n\tpublic double getNumericalVariance() {\n\t\treturn this.numericalVariance;\n\t}\n\n\t@Override\n\tpublic double getNumericalStandardDeviation() {\n\t\treturn this.numericalStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getGeometricMean() {\n\t\treturn this.geometricMean;\n\t}\n\n\t@Override\n\tpublic double getGeometricVariance() {\n\t\treturn this.geometricVariance;\n\t}\n\n\t@Override\n\tpublic double getGeometricStandardDeviation() {\n\t\treturn this.geometricStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getArithmeticMean() {\n\t\treturn this.arithmeticMean;\n\t}\n\n\t@Override\n\tpublic double getArithmeticVariance() {\n\t\treturn this.arithmeticVariance;\n\t}\n\n\t@Override\n\tpublic double getArithmeticStandardDeviation() {\n\t\treturn this.arithmeticStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getSum() {\n\t\treturn this.sum;\n\t}\n\n\t@Override\n\tpublic double getMinimum() {\n\t\treturn this.minimum;\n\t}\n\n\t@Override\n\tpublic double getMaximum() {\n\t\treturn this.maximum;\n\t}\n\n\t@Override\n\tpublic double getSumOfSquares() {\n\t\treturn this.sumOfSquares;\n\t}\n\n\t@Override\n\tpublic double getSumOfLogs() {\n\t\treturn this.sumOfLogs;\n\t}\n\n\t@Override\n\tpublic double getSumOfInverses() {\n\t\treturn this.sumOfInverses;\n\t}\n\n\t@Override\n\tpublic double getProduct() {\n\t\treturn this.product;\n\t}\n\n\t@Override\n\tpublic double getQuotient() {\n\t\treturn this.quotient;\n\t}\n\n\t@Override\n\tpublic double getRootMeanSquare() {\n\t\treturn this.rootMeanSquare;\n\t}\n\n\t@Override\n\tpublic double getStandardDeviation() {\n\t\treturn this.standardDeviation;\n\t}",
        "public double getNumericalMean() {\n\t\treturn this.numericalMean;\n\t}\n\n\t@Override\n\tpublic double getNumericalVariance() {\n\t\treturn this.numericalVariance;\n\t}\n\n\t@Override\n\tpublic double getNumericalStandardDeviation() {\n\t\treturn this.numericalStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getGeometricMean() {\n\t\treturn this.geometricMean;\n\t}\n\n\t@Override\n\tpublic double getGeometricVariance() {\n\t\treturn this.geometricVariance;\n\t}\n\n\t@Override\n\tpublic double getGeometricStandardDeviation() {\n\t\treturn this.geometricStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getArithmeticMean() {\n\t\treturn this.arithmeticMean;\n\t}\n\n\t@Override\n\tpublic double getArithmeticVariance() {\n\t\treturn this.arithmeticVariance;\n\t}\n\n\t@Override\n\tpublic double getArithmeticStandardDeviation() {\n\t\treturn this.arithmeticStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getSum() {\n\t\treturn this.sum;\n\t}\n\n\t@Override\n\tpublic double getMinimum() {\n\t\treturn this.minimum;\n\t}\n\n\t@Override\n\tpublic double getMaximum() {\n\t\treturn this.maximum;\n\t}\n\n\t@Override\n\tpublic double getSumOfSquares() {\n\t\treturn this.sumOfSquares;\n\t}\n\n\t@Override\n\tpublic double getSumOfLogs() {\n\t\treturn this.sumOfLogs;\n\t}\n\n\t@Override\n\tpublic double getSumOfInverses() {\n\t\treturn this.sumOfInverses;\n\t}\n\n\t@Override\n\tpublic double getProduct() {\n\t\treturn this.product;\n\t}\n\n\t@Override\n\tpublic double getQuotient() {\n\t\treturn this.quotient;\n\t}\n\n\t@Override\n\tpublic double getRootMeanSquare() {\n\t\treturn this.rootMeanSquare;\n\t}\n\n\t@Override\n\tpublic double getSumLogs() {\n\t\treturn this.sumLogs;\n\t}",
        "public double getNumericalMean() {\n\t\treturn this.numericalMean;\n\t}\n\n\t@Override\n\tpublic double getNumericalVariance() {\n\t\treturn this.numericalVariance;\n\t}\n\n\t@Override\n\tpublic double getNumericalStandardDeviation() {\n\t\treturn this.numericalStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getGeometricMean() {\n\t\treturn this.geometricMean;\n\t}\n\n\t@Override\n\tpublic double getGeometricVariance() {\n\t\treturn this.geometricVariance;\n\t}\n\n\t@Override\n\tpublic double getGeometricStandardDeviation() {\n\t\treturn this.geometricStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getArithmeticMean() {\n\t\treturn this.arithmeticMean;\n\t}\n\n\t@Override\n\tpublic double getArithmeticVariance() {\n\t\treturn this.arithmeticVariance;\n\t}\n\n\t@Override\n\tpublic double getArithmeticStandardDeviation() {\n\t\treturn this.arithmeticStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getSum() {\n\t\treturn this.sum;\n\t}\n\n\t@Override\n\tpublic double getMinimum() {\n\t\treturn this.minimum;\n\t}\n\n\t@Override\n\tpublic double getMaximum() {\n\t\treturn this.maximum;\n\t}\n\n\t@Override\n\tpublic double getSumOfSquares() {\n\t\treturn this.sumOfSquares;\n\t}\n\n\t@Override\n\tpublic double getSumOfLogs() {\n\t\treturn this.sumOfLogs;\n\t}\n\n\t@Override\n\tpublic double getSumOfInverses() {\n\t\treturn this.sumOfInverses;\n\t}\n\n\t@Override\n\tpublic double getProduct() {\n\t\treturn this.product;\n\t}\n\n\t@Override\n\tpublic double getQuotient() {\n\t\treturn this.quotient;\n\t}\n\n\t@Override\n\tpublic double getRootMeanSquared() {\n\t\treturn this.rootMeanSquared;\n\t}\n\n\t@Override\n\tpublic double getRootVariance() {\n\t\treturn this.rootVariance;\n",
        "public double getNumericalMean() {\n\t\treturn this.numericalMean;\n\t}\n\n\t@Override\n\tpublic double getNumericalVariance() {\n\t\treturn this.numericalVariance;\n\t}\n\n\t@Override\n\tpublic double getNumericalStandardDeviation() {\n\t\treturn this.numericalStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getGeometricMean() {\n\t\treturn this.geometricMean;\n\t}\n\n\t@Override\n\tpublic double getGeometricVariance() {\n\t\treturn this.geometricVariance;\n\t}\n\n\t@Override\n\tpublic double getGeometricStandardDeviation() {\n\t\treturn this.geometricStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getArithmeticMean() {\n\t\treturn this.arithmeticMean;\n\t}\n\n\t@Override\n\tpublic double getArithmeticVariance() {\n\t\treturn this.arithmeticVariance;\n\t}\n\n\t@Override\n\tpublic double getArithmeticStandardDeviation() {\n\t\treturn this.arithmeticStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getSum() {\n\t\treturn this.sum;\n\t}\n\n\t@Override\n\tpublic double getMinimum() {\n\t\treturn this.minimum;\n\t}\n\n\t@Override\n\tpublic double getMaximum() {\n\t\treturn this.maximum;\n\t}\n\n\t@Override\n\tpublic double getSumOfSquares() {\n\t\treturn this.sumOfSquares;\n\t}\n\n\t@Override\n\tpublic double getSumOfLogs() {\n\t\treturn this.sumOfLogs;\n\t}\n\n\t@Override\n\tpublic double getSumOfInverses() {\n\t\treturn this.sumOfInverses;\n\t}\n\n\t@Override\n\tpublic double getProduct() {\n\t\treturn this.product;\n\t}\n\n\t@Override\n\tpublic double getQuotient() {\n\t\treturn this.quotient;\n\t}\n\n\t@Override\n\tpublic double getRootSumOfSquares() {\n\t\treturn this.rootSumOfSquares;\n\t}\n\n\t@Override\n\tpublic double getRootSumOfLogs() {\n\t\treturn this.rootSumOf",
        "public double getNumericalMean() {\n\t\treturn this.numericalMean;\n\t}\n\n\t@Override\n\tpublic double getNumericalVariance() {\n\t\treturn this.numericalVariance;\n\t}\n\n\t@Override\n\tpublic double getNumericalStandardDeviation() {\n\t\treturn this.numericalStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getGeometricMean() {\n\t\treturn this.geometricMean;\n\t}\n\n\t@Override\n\tpublic double getGeometricVariance() {\n\t\treturn this.geometricVariance;\n\t}\n\n\t@Override\n\tpublic double getGeometricStandardDeviation() {\n\t\treturn this.geometricStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getArithmeticMean() {\n\t\treturn this.arithmeticMean;\n\t}\n\n\t@Override\n\tpublic double getArithmeticVariance() {\n\t\treturn this.arithmeticVariance;\n\t}\n\n\t@Override\n\tpublic double getArithmeticStandardDeviation() {\n\t\treturn this.arithmeticStandardDeviation;\n\t}\n\n\t@Override\n\tpublic double getSum() {\n\t\treturn this.sum;\n\t}\n\n\t@Override\n\tpublic double getMinimum() {\n\t\treturn this.minimum;\n\t}\n\n\t@Override\n\tpublic double getMaximum() {\n\t\treturn this.maximum;\n\t}\n\n\t@Override\n\tpublic double getRange() {\n\t\treturn this.range;\n\t}\n\n\t@Override\n\tpublic double getSumOfSquares() {\n\t\treturn this.sumOfSquares;\n\t}\n\n\t@Override\n\tpublic double getProduct() {\n\t\treturn this.product;\n\t}\n\n\t@Override\n\tpublic double getQuotient() {\n\t\treturn this.quotient;\n\t}\n\n\t@Override\n\tpublic double getRootMeanSquare() {\n\t\treturn this.rootMeanSquare;\n\t}\n\n\t@Override\n\tpublic double getStandardDeviation() {\n\t\treturn this.standardDeviation;\n\t}\n\n\t@Override\n\tpublic double getVariance() {\n\t\treturn this.variance;\n\t}\n\n\t@Override\n\tpublic double getPopulationVariance"
      ],
      "function range": "267,5-269,5"
    },
    "Math_5_/src/main/java/org/apache/commons/math3/complex/Complex.java_305-306": {
      "loc": "305-306",
      "input": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {",
      "output": [
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n}\n\npublic Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n}\n\npublic Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real - imaginary * z.imaginary,\n                       real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real + imaginary * z.imaginary,\n                       -real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex negate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(-real, -imaginary);\n}\n\npublic Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex absolute() {\n    if (isNaN) {\n        return Na",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n}\n\npublic Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n}\n\npublic Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real - imaginary * z.imaginary,\n                       real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real + imaginary * z.imaginary,\n                       -real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex negate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(-real, -imaginary);\n}\n\npublic Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(double r, double i) {\n    if (isNaN",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n}\n\npublic Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n}\n\npublic Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real - imaginary * z.imaginary,\n                       real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real + imaginary * z.imaginary,\n                       -real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex negate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(-real, -imaginary);\n}\n\npublic Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(double z) {\n    if (isNaN) {\n",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n}\n\npublic Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n}\n\npublic Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real - imaginary * z.imaginary,\n            real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real + imaginary * z.imaginary,\n            -real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex negate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(-real, -imaginary);\n}\n\npublic Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex absolute() {\n    if (isNaN) {\n        return Na",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n}\n\npublic Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n}\n\npublic Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real - imaginary * z.imaginary,\n            real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real + imaginary * z.imaginary,\n            -real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex negate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(-real, -imaginary);\n}\n\npublic Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(double z) {\n    if (isNaN) {\n",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n}\n\npublic Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n}\n\npublic Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real - imaginary * z.imaginary,\n            real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real + imaginary * z.imaginary,\n            -real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex negate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(-real, -imaginary);\n}\n\npublic Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(double r, double i) {\n    if (isNaN",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n}\n\npublic Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n}\n\npublic Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real - imaginary * z.imaginary,\n                       real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real + imaginary * z.imaginary,\n                       -real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex negate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(-real, -imaginary);\n}\n\npublic Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex pow(Complex z) {\n    if (isNaN || z",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n}\n\npublic Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n}\n\npublic Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real - imaginary * z.imaginary,\n                       real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real + imaginary * z.imaginary,\n                       -real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex negate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(-real, -imaginary);\n}\n\npublic Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic String toString() {\n    if (isNaN) {\n        return",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n}\n\npublic Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n}\n\npublic Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real - imaginary * z.imaginary,\n                       real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real + imaginary * z.imaginary,\n                       -real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex negate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(-real, -imaginary);\n}\n\npublic Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(double r, double i) {\n    return new Complex(r",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real + z.real, imaginary + z.imaginary);\n}\n\npublic Complex subtract(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real - z.real, imaginary - z.imaginary);\n}\n\npublic Complex multiply(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real - imaginary * z.imaginary,\n                       real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex divide(Complex z) {\n    if (isNaN || z.isNaN) {\n        return NaN;\n    }\n    return new Complex(real * z.real + imaginary * z.imaginary,\n                       -real * z.imaginary + imaginary * z.real);\n}\n\npublic Complex negate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(-real, -imaginary);\n}\n\npublic Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return new Complex(real, -imaginary);\n}\n\npublic Complex add(double x) {\n    if (isNaN) {\n"
      ],
      "function range": "299,5-321,5"
    },
    "Math_9_/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java_87-88": {
      "loc": "87-88",
      "input": "public Line revert() {",
      "output": [
        "public Line revert() {\n        return this;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long serialVersionUID = 1L;\n",
        "public Line revert() {\n        return this;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class LocalSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long serialVersionUID = 1L;\n    ",
        "public Line revert() {\n        return this;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class MaxAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long serialVersionUID = 1L;\n    public",
        "public Line revert() {\n        return this;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long serialVersionUID = 1L;",
        "public Line revert() {\n        return this;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlSumAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {\n\n    private static final long serialVersionUID = 1L;\n",
        "public Line revert() {\n        return this;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class MaxAggregateDescriptor",
        "public Line revert() {\n        return this;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class LocalSumAggregateDescript",
        "public Line revert() {\n        return this;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDesc",
        "public Line revert() {\n        return this;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAggregate",
        "public Line revert() {\n        return this;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class LocalSqlStddev"
      ],
      "function range": "86,5-89,5"
    },
    "Math_11_/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java_183-184": {
      "loc": "183-184",
      "input": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length != dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }",
      "output": [
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return density(vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y) throws OutOfRangeException {\n    return density(x, y, 0d, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z)\n    throws OutOfRangeException {\n    return density(x, y, z, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w) throws OutOfRangeException {\n    return density(x, y, z, w, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u) throws OutOfRangeException {\n    return density(x, y, z, w, u, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u, final double v)\n    throws OutOfRangeException {\n\n    if (x < minX || x > maxX) {\n      throw new OutOfRangeException(x, minX, maxX);\n    }\n    if (y < minY || y > maxY) {\n      throw new OutOfRangeException(y, minY, maxY);\n    }\n    if (z < minZ || z > maxZ) {\n      throw new OutOfRangeException(z, minZ, maxZ",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return density(vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y) throws OutOfRangeException {\n    return density(x, y, 0d, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z)\n    throws OutOfRangeException {\n    return density(x, y, z, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w) throws OutOfRangeException {\n    return density(x, y, z, w, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u) throws OutOfRangeException {\n    return density(x, y, z, w, u, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u, final double v)\n    throws OutOfRangeException {\n\n    if (x < minx || x > maxx) {\n      throw new OutOfRangeException(x, minx, maxx);\n    }\n    if (y < miny || y > maxy) {\n      throw new OutOfRangeException(y, miny, maxy);\n    }\n    if (z < minz || z > maxz) {\n      throw new OutOfRangeException(z, minz, maxz",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return density(vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y) throws OutOfRangeException {\n    return density(x, y, 0d, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z)\n    throws OutOfRangeException {\n    return density(x, y, z, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w) throws OutOfRangeException {\n    return density(x, y, z, w, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u) throws OutOfRangeException {\n    return density(x, y, z, w, u, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u, final double v)\n    throws OutOfRangeException {\n\n    if (x < minX || x > maxX) {\n        throw new OutOfRangeException(x, minX, maxX);\n    }\n    if (y < minY || y > maxY) {\n        throw new OutOfRangeException(y, minY, maxY);\n    }\n    if (z < minZ || z > maxZ) {\n        throw new OutOfRangeException(z, minZ, maxZ",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return density(vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y) throws OutOfRangeException {\n    return density(x, y, 0d, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z)\n    throws OutOfRangeException {\n    return density(x, y, z, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w) throws OutOfRangeException {\n    return density(x, y, z, w, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u) throws OutOfRangeException {\n    return density(x, y, z, w, u, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u, final double v)\n    throws OutOfRangeException {\n\n    if (w < 0d || w > 1d) {\n      throw new OutOfRangeException(w, 0d, 1d);\n    }\n    if (u < 0d || u > 1d) {\n      throw new OutOfRangeException(u, 0d, 1d);\n    }\n    if (v < 0d || v > 1d) {\n      throw new OutOfRangeException(v, 0d, 1d",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return density(vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y) throws OutOfRangeException {\n    return density(x, y, 0d, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z)\n    throws OutOfRangeException {\n    return density(x, y, z, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n      final double w) throws OutOfRangeException {\n    return density(x, y, z, w, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n      final double w, final double u) throws OutOfRangeException {\n    return density(x, y, z, w, u, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n      final double w, final double u, final double v) throws OutOfRangeException {\n\n    if (w < 0d || w > 1d) {\n      throw new OutOfRangeException(w, 0d, 1d);\n    }\n    if (u < 0d || u > 1d) {\n      throw new OutOfRangeException(u, 0d, 1d);\n    }\n    if (v < 0d || v > 1d) {\n      throw new OutOfRangeException(v, 0d, 1d);\n    ",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return density(vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y) throws OutOfRangeException {\n    return density(x, y, 0d, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z)\n    throws OutOfRangeException {\n    return density(x, y, z, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w) throws OutOfRangeException {\n    return density(x, y, z, w, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u) throws OutOfRangeException {\n    return density(x, y, z, w, u, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u, final double v)\n    throws OutOfRangeException {\n\n    if (w < 0d || w > 1d) {\n        throw new OutOfRangeException(w, 0d, 1d);\n    }\n    if (u < 0d || u > 1d) {\n        throw new OutOfRangeException(u, 0d, 1d);\n    }\n    if (v < 0d || v > 1d) {\n        throw new OutOfRangeException(v, 0d, 1d",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return density(vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y) throws OutOfRangeException {\n    return density(x, y, 0d, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z)\n    throws OutOfRangeException {\n    return density(x, y, z, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n      final double w) throws OutOfRangeException {\n    return density(x, y, z, w, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n      final double w, final double u) throws OutOfRangeException {\n    return density(x, y, z, w, u, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n      final double w, final double u, final double v) throws OutOfRangeException {\n\n    if (w < 0d || w > 1d) {\n        throw new OutOfRangeException(w, 0d, 1d);\n    }\n    if (u < 0d || u > 1d) {\n        throw new OutOfRangeException(u, 0d, 1d);\n    }\n    if (v < 0d || v > 1d) {\n        throw new OutOfRangeException(v, 0d, 1d);\n    ",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return density(vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y) throws OutOfRangeException {\n    return density(x, y, 0d, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z)\n    throws OutOfRangeException {\n    return density(x, y, z, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w) throws OutOfRangeException {\n    return density(x, y, z, w, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u) throws OutOfRangeException {\n    return density(x, y, z, w, u, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u, final double v)\n    throws OutOfRangeException {\n\n    if (Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z) || Double.isNaN(w) ||\n        Double.isNaN(u) || Double.isNaN(v)) {\n      return Double.NaN;\n    }\n\n    if (x < minx || x > maxx) {\n      throw new OutOfRangeException(x, minx, max",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return density(vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y) throws OutOfRangeException {\n    return density(x, y, 0d, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z)\n    throws OutOfRangeException {\n    return density(x, y, z, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w) throws OutOfRangeException {\n    return density(x, y, z, w, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u) throws OutOfRangeException {\n    return density(x, y, z, w, u, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u, final double v)\n    throws OutOfRangeException {\n\n    if (Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z) || Double.isNaN(w) ||\n        Double.isNaN(u) || Double.isNaN(v)) {\n      return Double.NaN;\n    }\n\n    final int xi = (int) x;\n    final int yi = (int) y;\n    final int zi",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return density(vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y) throws OutOfRangeException {\n    return density(x, y, 0d, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z)\n    throws OutOfRangeException {\n    return density(x, y, z, 0d, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w) throws OutOfRangeException {\n    return density(x, y, z, w, 0d, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u) throws OutOfRangeException {\n    return density(x, y, z, w, u, 0d);\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public double density(final double x, final double y, final double z,\n                        final double w, final double u, final double v)\n    throws OutOfRangeException {\n\n    if (Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z) || Double.isNaN(w) ||\n        Double.isNaN(u) || Double.isNaN(v)) {\n      return Double.NaN;\n    }\n\n    final double x0 = FastMath.min(FastMath.min(x, y), z);\n    final double x1 ="
      ],
      "function range": "177,5-186,5"
    },
    "Math_20_/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java_921-922": {
      "loc": "921-922",
      "input": "public double[] repairAndDecode(final double[] x) {",
      "output": [
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repair(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repair(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repair(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repair(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repair(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalar",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repair(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repair(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repair(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repair(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache",
        "public double[] repairAndDecode(final double[] x) {\n        final double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = repair(x[i]);\n        }\n        return y;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class N"
      ],
      "function range": "920,9-923,9"
    },
    "Math_27_/src/main/java/org/apache/commons/math3/fraction/Fraction.java_597-598": {
      "loc": "597-598",
      "input": "public double percentageValue() {",
      "output": [
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    /**\n     * Sets the value of the percentageValue property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setPercentageValue(Double value) {\n        this.percentageValue = value;\n    }\n\n\n    /**\n     * <p>Java class for anonymous complex type.\n     * \n     * <p>The following schema fragment specifies the expected content contained within this class.\n     * \n     * <pre>\n     * &lt;complexType>\n     *   &lt;simpleContent>\n     *     &lt;extension base=\"&lt;http://www.w3.org/2001/XMLSchema>double\">\n     *       &lt;attribute name=\"unitOfMeasure\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\n     *     &lt;/extension>\n     *   &lt;/simpleContent>\n     * &lt;/complexType>\n     * </pre>\n     * \n     * \n     */\n    @XmlAccessorType(XmlAccessType.FIELD)\n    @XmlType(name = \"\", propOrder = {\n        \"value\"\n    })\n    public static class Value {\n\n        @XmlValue\n        protected double value;\n        @XmlAttribute(name = \"unitOfMeasure\", required = true)\n        protected String unitOfMeasure;\n\n        /**\n         * Gets the value of the value property.\n         * \n         */\n        public double getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the value of the value property.\n         * \n         */\n        public void setValue(double value) {\n            this.value = value;\n        }\n\n        /**\n         * Gets the value of the unitOfMeasure property.\n         * \n         * @return\n         *     possible object is\n         *     {@link String }\n         *     \n         */\n        public String getUnitOfMeasure() {\n            return unitOfMeasure;\n        }",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    /**\n     * Sets the value of the percentageValue property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setPercentageValue(Double value) {\n        this.percentageValue = value;\n    }\n\n\n    /**\n     * <p>Java class for anonymous complex type.\n     * \n     * <p>The following schema fragment specifies the expected content contained within this class.\n     * \n     * <pre>\n     * &lt;complexType>\n     *   &lt;simpleContent>\n     *     &lt;extension base=\"&lt;http://www.w3.org/2001/XMLSchema>double\">\n     *       &lt;attribute name=\"unitOfMeasure\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\n     *     &lt;/extension>\n     *   &lt;/simpleContent>\n     * &lt;/complexType>\n     * </pre>\n     * \n     * \n     */\n    @XmlAccessorType(XmlAccessType.FIELD)\n    @XmlType(name = \"\", propOrder = {\n        \"value\"\n    })\n    public static class PercentageValue {\n\n        @XmlValue\n        protected double value;\n        @XmlAttribute(name = \"unitOfMeasure\", required = true)\n        protected String unitOfMeasure;\n\n        /**\n         * Gets the value of the value property.\n         * \n         */\n        public double getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the value of the value property.\n         * \n         */\n        public void setValue(double value) {\n            this.value = value;\n        }\n\n        /**\n         * Gets the value of the unitOfMeasure property.\n         * \n         * @return\n         *     possible object is\n         *     {@link String }\n         *     \n         */\n        public String getUnitOfMeasure() {\n            return unitOfMeasure;\n        ",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    /**\n     * Sets the value of the percentageValue property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setPercentageValue(Double value) {\n        this.percentageValue = value;\n    }\n\n\n    /**\n     * <p>Java class for anonymous complex type.\n     * \n     * <p>The following schema fragment specifies the expected content contained within this class.\n     * \n     * <pre>\n     * &lt;complexType>\n     *   &lt;simpleContent>\n     *     &lt;extension base=\"&lt;http://www.w3.org/2001/XMLSchema>double\">\n     *       &lt;attribute name=\"unitOfMeasure\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\n     *     &lt;/extension>\n     *   &lt;/simpleContent>\n     * &lt;/complexType>\n     * </pre>\n     * \n     * \n     */\n    @XmlAccessorType(XmlAccessType.FIELD)\n    @XmlType(name = \"\", propOrder = {\n        \"value\"\n    })\n    public static class Amount {\n\n        @XmlValue\n        protected double value;\n        @XmlAttribute(name = \"unitOfMeasure\", required = true)\n        protected String unitOfMeasure;\n\n        /**\n         * Gets the value of the value property.\n         * \n         */\n        public double getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the value of the value property.\n         * \n         */\n        public void setValue(double value) {\n            this.value = value;\n        }\n\n        /**\n         * Gets the value of the unitOfMeasure property.\n         * \n         * @return\n         *     possible object is\n         *     {@link String }\n         *     \n         */\n        public String getUnitOfMeasure() {\n            return unitOfMeasure;\n        }",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    /**\n     * Sets the value of the percentageValue property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setPercentageValue(Double value) {\n        this.percentageValue = value;\n    }\n\n\n    /**\n     * <p>Java class for anonymous complex type.\n     * \n     * <p>The following schema fragment specifies the expected content contained within this class.\n     * \n     * <pre>\n     * &lt;complexType>\n     *   &lt;simpleContent>\n     *     &lt;extension base=\"&lt;http://www.w3.org/2001/XMLSchema>double\">\n     *       &lt;attribute name=\"unitOfMeasure\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\n     *     &lt;/extension>\n     *   &lt;/simpleContent>\n     * &lt;/complexType>\n     * </pre>\n     * \n     * \n     */\n    @XmlAccessorType(XmlAccessType.FIELD)\n    @XmlType(name = \"\", propOrder = {\n        \"value\"\n    })\n    public static class QuantityValue {\n\n        @XmlValue\n        protected double value;\n        @XmlAttribute(name = \"unitOfMeasure\", required = true)\n        protected String unitOfMeasure;\n\n        /**\n         * Gets the value of the value property.\n         * \n         */\n        public double getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the value of the value property.\n         * \n         */\n        public void setValue(double value) {\n            this.value = value;\n        }\n\n        /**\n         * Gets the value of the unitOfMeasure property.\n         * \n         * @return\n         *     possible object is\n         *     {@link String }\n         *     \n         */\n        public String getUnitOfMeasure() {\n            return unitOfMeasure;\n        ",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    /**\n     * Sets the value of the percentageValue property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setPercentageValue(Double value) {\n        this.percentageValue = value;\n    }\n\n\n    /**\n     * <p>Java class for anonymous complex type.\n     * \n     * <p>The following schema fragment specifies the expected content contained within this class.\n     * \n     * <pre>\n     * &lt;complexType>\n     *   &lt;simpleContent>\n     *     &lt;extension base=\"&lt;http://www.w3.org/2001/XMLSchema>double\">\n     *       &lt;attribute name=\"unitOfMeasure\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\n     *     &lt;/extension>\n     *   &lt;/simpleContent>\n     * &lt;/complexType>\n     * </pre>\n     * \n     * \n     */\n    @XmlAccessorType(XmlAccessType.FIELD)\n    @XmlType(name = \"\", propOrder = {\n        \"value\"\n    })\n    public static class Percentage {\n\n        @XmlValue\n        protected double value;\n        @XmlAttribute(name = \"unitOfMeasure\", required = true)\n        protected String unitOfMeasure;\n\n        /**\n         * Gets the value of the value property.\n         * \n         */\n        public double getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the value of the value property.\n         * \n         */\n        public void setValue(double value) {\n            this.value = value;\n        }\n\n        /**\n         * Gets the value of the unitOfMeasure property.\n         * \n         * @return\n         *     possible object is\n         *     {@link String }\n         *     \n         */\n        public String getUnitOfMeasure() {\n            return unitOfMeasure;\n        }",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    /**\n     * Sets the value of the percentageValue property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setPercentageValue(Double value) {\n        this.percentageValue = value;\n    }\n\n\n    /**\n     * <p>Java class for anonymous complex type.\n     * \n     * <p>The following schema fragment specifies the expected content contained within this class.\n     * \n     * <pre>\n     * &lt;complexType>\n     *   &lt;simpleContent>\n     *     &lt;extension base=\"&lt;http://www.w3.org/2001/XMLSchema>double\">\n     *       &lt;attribute name=\"unitOfMeasure\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\n     *     &lt;/extension>\n     *   &lt;/simpleContent>\n     * &lt;/complexType>\n     * </pre>\n     * \n     * \n     */\n    @XmlAccessorType(XmlAccessType.FIELD)\n    @XmlType(name = \"\", propOrder = {\n        \"value\"\n    })\n    public static class Value {\n\n        @XmlValue\n        protected double value;\n        @XmlAttribute(required = true)\n        protected String unitOfMeasure;\n\n        /**\n         * Gets the value of the value property.\n         * \n         */\n        public double getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the value of the value property.\n         * \n         */\n        public void setValue(double value) {\n            this.value = value;\n        }\n\n        /**\n         * Gets the value of the unitOfMeasure property.\n         * \n         * @return\n         *     possible object is\n         *     {@link String }\n         *     \n         */\n        public String getUnitOfMeasure() {\n            return unitOfMeasure;\n        }\n\n        /**\n         * Sets",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    /**\n     * Sets the value of the percentageValue property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setPercentageValue(Double value) {\n        this.percentageValue = value;\n    }\n\n\n    /**\n     * <p>Java class for anonymous complex type.\n     * \n     * <p>The following schema fragment specifies the expected content contained within this class.\n     * \n     * <pre>\n     * &lt;complexType>\n     *   &lt;simpleContent>\n     *     &lt;extension base=\"&lt;http://www.w3.org/2001/XMLSchema>double\">\n     *       &lt;attribute name=\"unitOfMeasure\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\n     *     &lt;/extension>\n     *   &lt;/simpleContent>\n     * &lt;/complexType>\n     * </pre>\n     * \n     * \n     */\n    @XmlAccessorType(XmlAccessType.FIELD)\n    @XmlType(name = \"\", propOrder = {\n        \"value\"\n    })\n    public static class Quantity {\n\n        @XmlValue\n        protected double value;\n        @XmlAttribute(name = \"unitOfMeasure\", required = true)\n        protected String unitOfMeasure;\n\n        /**\n         * Gets the value of the value property.\n         * \n         */\n        public double getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the value of the value property.\n         * \n         */\n        public void setValue(double value) {\n            this.value = value;\n        }\n\n        /**\n         * Gets the value of the unitOfMeasure property.\n         * \n         * @return\n         *     possible object is\n         *     {@link String }\n         *     \n         */\n        public String getUnitOfMeasure() {\n            return unitOfMeasure;\n        }",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    /**\n     * Sets the value of the percentageValue property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setPercentageValue(Double value) {\n        this.percentageValue = value;\n    }\n\n\n    /**\n     * <p>Java class for anonymous complex type.\n     * \n     * <p>The following schema fragment specifies the expected content contained within this class.\n     * \n     * <pre>\n     * &lt;complexType>\n     *   &lt;simpleContent>\n     *     &lt;extension base=\"&lt;http://www.w3.org/2001/XMLSchema>double\">\n     *       &lt;attribute name=\"unitOfMeasure\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\n     *     &lt;/extension>\n     *   &lt;/simpleContent>\n     * &lt;/complexType>\n     * </pre>\n     * \n     * \n     */\n    @XmlAccessorType(XmlAccessType.FIELD)\n    @XmlType(name = \"\", propOrder = {\n        \"value\"\n    })\n    public static class AmountValue {\n\n        @XmlValue\n        protected double value;\n        @XmlAttribute(name = \"unitOfMeasure\", required = true)\n        protected String unitOfMeasure;\n\n        /**\n         * Gets the value of the value property.\n         * \n         */\n        public double getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the value of the value property.\n         * \n         */\n        public void setValue(double value) {\n            this.value = value;\n        }\n\n        /**\n         * Gets the value of the unitOfMeasure property.\n         * \n         * @return\n         *     possible object is\n         *     {@link String }\n         *     \n         */\n        public String getUnitOfMeasure() {\n            return unitOfMeasure;\n        ",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    /**\n     * Sets the value of the percentageValue property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setPercentageValue(Double value) {\n        this.percentageValue = value;\n    }\n\n\n    /**\n     * <p>Java class for anonymous complex type.\n     * \n     * <p>The following schema fragment specifies the expected content contained within this class.\n     * \n     * <pre>\n     * &lt;complexType>\n     *   &lt;simpleContent>\n     *     &lt;extension base=\"&lt;http://www.w3.org/2001/XMLSchema>double\">\n     *       &lt;attribute name=\"unitOfMeasure\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\n     *     &lt;/extension>\n     *   &lt;/simpleContent>\n     * &lt;/complexType>\n     * </pre>\n     * \n     * \n     */\n    @XmlAccessorType(XmlAccessType.FIELD)\n    @XmlType(name = \"\", propOrder = {\n        \"value\"\n    })\n    public static class DoubleValue {\n\n        @XmlValue\n        protected double value;\n        @XmlAttribute(name = \"unitOfMeasure\", required = true)\n        protected String unitOfMeasure;\n\n        /**\n         * Gets the value of the value property.\n         * \n         */\n        public double getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the value of the value property.\n         * \n         */\n        public void setValue(double value) {\n            this.value = value;\n        }\n\n        /**\n         * Gets the value of the unitOfMeasure property.\n         * \n         * @return\n         *     possible object is\n         *     {@link String }\n         *     \n         */\n        public String getUnitOfMeasure() {\n            return unitOfMeasure;\n        ",
        "public double percentageValue() {\n        return percentageValue;\n    }\n\n    /**\n     * Sets the value of the percentageValue property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Double }\n     *     \n     */\n    public void setPercentageValue(Double value) {\n        this.percentageValue = value;\n    }\n\n\n    /**\n     * <p>Java class for anonymous complex type.\n     * \n     * <p>The following schema fragment specifies the expected content contained within this class.\n     * \n     * <pre>\n     * &lt;complexType>\n     *   &lt;simpleContent>\n     *     &lt;extension base=\"&lt;http://www.w3.org/2001/XMLSchema>double\">\n     *       &lt;attribute name=\"unitOfMeasure\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\n     *     &lt;/extension>\n     *   &lt;/simpleContent>\n     * &lt;/complexType>\n     * </pre>\n     * \n     * \n     */\n    @XmlAccessorType(XmlAccessType.FIELD)\n    @XmlType(name = \"\", propOrder = {\n        \"value\"\n    })\n    public static class Unit {\n\n        @XmlValue\n        protected double value;\n        @XmlAttribute(name = \"unitOfMeasure\", required = true)\n        protected String unitOfMeasure;\n\n        /**\n         * Gets the value of the value property.\n         * \n         */\n        public double getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the value of the value property.\n         * \n         */\n        public void setValue(double value) {\n            this.value = value;\n        }\n\n        /**\n         * Gets the value of the unitOfMeasure property.\n         * \n         * @return\n         *     possible object is\n         *     {@link String }\n         *     \n         */\n        public String getUnitOfMeasure() {\n            return unitOfMeasure;\n        }"
      ],
      "function range": "596,5-598,5"
    },
    "Math_30_/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java_173-174": {
      "loc": "173-174",
      "input": "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {",
      "output": [
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        return 1.0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The lower bound of the support is always 0 no matter the mean parameter.\n     *\n     * @return lower bound of the support (always 0)\n     */\n    public double getSupportLowerBound() {\n        return 0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The upper bound of the support is always positive infinity\n     * no matter the mean parameter.\n     *\n     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n     */\n    public double getSupportUpperBound() {\n        return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportLowerBoundInclusive() {\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportUpperBoundInclusive() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The support of this distribution is connected.\n     *\n     * @return {@code true}\n     */\n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        return 1.0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The lower bound of the support is always 0 no matter the mean parameter.\n     *\n     * @return lower bound of the support (always 0)\n     */\n    public double getSupportLowerBound() {\n        return 0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The upper bound of the support is always positive infinity\n     * no matter the mean parameter.\n     *\n     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n     */\n    public double getSupportUpperBound() {\n        return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportLowerBoundInclusive() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportUpperBoundInclusive() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The support of this distribution is connected.\n     *\n     * @return {@code true}\n     */\n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        return 1.0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The lower bound of the support is always 0 no matter the mean parameter.\n     *\n     * @return lower bound of the support (always 0)\n     */\n    public double getSupportLowerBound() {\n        return 0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The upper bound of the support is always positive infinity\n     * no matter the mean parameter.\n     *\n     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n     */\n    public double getSupportUpperBound() {\n        return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportLowerBoundInclusive() {\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportUpperBoundInclusive() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The support of this distribution is connected.\n     *\n     * @return {@code true}\n     */\n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\"",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        return 1.0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The lower bound of the support is always 0 no matter the mean parameter.\n     *\n     * @return lower bound of the support (always 0)\n     */\n    public double getSupportLowerBound() {\n        return 0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The upper bound of the support is always positive infinity\n     * no matter the mean parameter.\n     *\n     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n     */\n    public double getSupportUpperBound() {\n        return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportLowerBoundInclusive() {\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportUpperBoundInclusive() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The support of this distribution is connected.\n     *\n     * @return {@code true}\n     */\n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        return 1.0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The lower bound of the support is always 0 no matter the mean parameter.\n     *\n     * @return lower bound of the support (always 0)\n     */\n    public double getSupportLowerBound() {\n        return 0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The upper bound of the support is always positive infinity\n     * no matter the mean parameter.\n     *\n     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n     */\n    public double getSupportUpperBound() {\n        return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportLowerBoundInclusive() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportUpperBoundInclusive() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The support of this distribution is connected.\n     *\n     * @return {@code true}\n     */\n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        return 1.0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The lower bound of the support is always 0 no matter the mean parameter.\n     *\n     * @return lower bound of the support (always 0)\n     */\n    public double getSupportLowerBound() {\n        return 0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The upper bound of the support is always positive infinity\n     * no matter the mean parameter.\n     *\n     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n     */\n    public double getSupportUpperBound() {\n        return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportLowerBoundInclusive() {\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportUpperBoundInclusive() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The support of this distribution is connected.\n     *\n     * @return {@code true}\n     */\n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        return 1.0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The lower bound of the support is always 0 no matter the mean parameter.\n     *\n     * @return lower bound of the support (always 0)\n     */\n    public double getSupportLowerBound() {\n        return 0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The upper bound of the support is always positive infinity\n     * no matter the mean parameter.\n     *\n     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n     */\n    public double getSupportUpperBound() {\n        return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportLowerBoundInclusive() {\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportUpperBoundInclusive() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The support of this distribution is connected.\n     *\n     * @return {@code true}\n     */\n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        return 1.0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The lower bound of the support is always 0 no matter the mean parameter.\n     *\n     * @return lower bound of the support (always 0)\n     */\n    public double getSupportLowerBound() {\n        return 0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The upper bound of the support is always positive infinity\n     * no matter the mean parameter.\n     *\n     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n     */\n    public double getSupportUpperBound() {\n        return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportLowerBoundInclusive() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportUpperBoundInclusive() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The support of this distribution is connected.\n     *\n     * @return {@code true}\n     */\n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        return 1.0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The lower bound of the support is always 0 no matter the mean parameter.\n     *\n     * @return lower bound of the support (always 0)\n     */\n    public double getSupportLowerBound() {\n        return 0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The upper bound of the support is always positive infinity\n     * no matter the mean parameter.\n     *\n     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n     */\n    public double getSupportUpperBound() {\n        return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportLowerBoundInclusive() {\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportUpperBoundInclusive() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The support of this distribution is connected.\n     *\n     * @return {@code true}\n     */\n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BAS",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n        return 1.0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The lower bound of the support is always 0 no matter the mean parameter.\n     *\n     * @return lower bound of the support (always 0)\n     */\n    public double getSupportLowerBound() {\n        return 0;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The upper bound of the support is always positive infinity\n     * no matter the mean parameter.\n     *\n     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n     */\n    public double getSupportUpperBound() {\n        return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportLowerBoundInclusive() {\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isSupportUpperBoundInclusive() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The support of this distribution is connected.\n     *\n     * @return {@code true}\n     */\n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS"
      ],
      "function range": "168,5-184,5"
    },
    "Math_32_/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java_136-137": {
      "loc": "136-137",
      "input": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);",
      "output": [
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree!= null) {\n            computeGeometricalProperties(tree);\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                final Vector2D vertex = v[i][j];\n                vertex.setCoordinates(vertex.getX(), vertex.getY());\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree!= null) {\n            computeGeometricalProperties(tree);\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                final Vector2D vertex = v[i][j];\n                vertex.setCoordinates(vertex.getX(), vertex.getY());\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree!= null) {\n            computeGeometricalProperties(tree);\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                final Vector2D vertex = v[i][j];\n                vertex.setCoordinates(vertex.getX(), vertex.getY());\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\n",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree!= null) {\n            computeGeometricalProperties(tree);\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                final Vector2D vertex = v[i][j];\n                vertex.setCoordinates(vertex.getX(), vertex.getY());\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregate",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree!= null) {\n            computeGeometricalProperties(tree);\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                final Vector2D vertex = v[i][j];\n                vertex.setCoordinates(vertex.getX(), vertex.getY());\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree!= null) {\n            computeGeometricalProperties(tree);\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                final Vector2D vertex = v[i][j];\n                vertex.setCoordinates(vertex.getX(), vertex.getY());\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree!= null) {\n            computeGeometricalProperties(tree);\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                final Vector2D vertex = v[i][j];\n                vertex.setCoordinates(vertex.getX(), vertex.getY());\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\n",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree!= null) {\n            computeGeometricalProperties(tree);\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                final Vector2D vertex = v[i][j];\n                vertex.setCoordinates(vertex.getX(), vertex.getY());\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree!= null) {\n            computeGeometricalProperties(tree);\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                final Vector2D vertex = v[i][j];\n                vertex.setCoordinates(vertex.getX(), vertex.getY());\n            }\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree!= null) {\n            computeGeometricalProperties(tree);\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                final Vector2D vertex = v[i][j];\n                vertex.setCoordinates(vertex.getX(), vertex.getY());\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.al"
      ],
      "function range": "129,5-181,5"
    },
    "Math_33_/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java_338-339": {
      "loc": "338-339",
      "input": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);",
      "output": [
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (FastMath.abs(entry) > 1.0e-12) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        int index = columnsToDrop.get(i);\n        setColumnObjectiveValue(index, 0.0);\n        for (int j = index - 1; j >= 0; j--) {\n            double value = tableau.getEntry(0, j);\n            tableau.setEntry(0, j, tableau.getEntry(0, j + 1));\n            tableau.setEntry(1, j, tableau.getEntry(1, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(1, index);\n                tableau.setEntry(1, index, Double.NaN);\n            }\n            tableau.setEntry(2, j, tableau.getEntry(2, j + 1));\n            tableau.setEntry(3, j, tableau.getEntry(3, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(3, index);\n                tableau.setEntry(3, index, Double.NaN);\n            }\n            tableau.setEntry(4, j, tableau.getEntry(4, j + 1));\n            tableau.setEntry(5, j, tableau.getEntry(5, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(5, index);\n                tableau.setEntry(5, index, Double.NaN);\n            }\n            tableau.setEntry(6, j",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (FastMath.abs(entry) > 1.0e-12) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        int index = columnsToDrop.get(i);\n        setColumnObjectiveValue(index, 0.0);\n        for (int j = index - 1; j >= 0; j--) {\n            double value = tableau.getEntry(0, j);\n            tableau.setEntry(0, j, tableau.getEntry(0, j + 1));\n            tableau.setEntry(1, j, tableau.getEntry(1, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(1, index);\n                tableau.setEntry(1, index, Double.NaN);\n            }\n            tableau.setEntry(2, j, tableau.getEntry(2, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(2, index);\n                tableau.setEntry(2, index, Double.NaN);\n            }\n            tableau.setEntry(3, j, tableau.getEntry(3, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(3, index);\n                tableau.setEntry(3, index, Double.NaN);\n            }\n            tableau.setEntry(4, j, tableau.getEntry(4, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(4, index);\n                tableau.setEntry(4,",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (FastMath.abs(entry) > 1.0e-12) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        int index = columnsToDrop.get(i);\n        setColumnObjectiveValue(index, 0.0);\n        for (int j = index - 1; j >= 0; j--) {\n            double value = tableau.getEntry(0, j);\n            tableau.setEntry(0, j, tableau.getEntry(0, j + 1));\n            tableau.setEntry(1, j, tableau.getEntry(1, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(1, index);\n                tableau.setEntry(1, index, Double.NaN);\n            }\n            tableau.setEntry(2, j, tableau.getEntry(2, j + 1));\n            tableau.setEntry(3, j, tableau.getEntry(3, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(2, index);\n                tableau.setEntry(2, index, Double.NaN);\n            }\n            tableau.setEntry(4, j, tableau.getEntry(4, j + 1));\n            tableau.setEntry(5, j, tableau.getEntry(5, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(4, index);\n                tableau.setEntry(4, index, Double.NaN);\n            }\n            tableau.setEntry(6, j",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (FastMath.abs(entry) > 1.0e-12) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        int index = columnsToDrop.get(i);\n        setColumnObjectiveValue(index, 0.0);\n        for (int j = index - 1; j >= 0; j--) {\n            double value = tableau.getEntry(0, j);\n            tableau.setEntry(0, j, tableau.getEntry(0, j + 1));\n            tableau.setEntry(1, j, tableau.getEntry(1, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(1, index);\n                tableau.setEntry(1, index, Double.NaN);\n            }\n            tableau.setEntry(2, j, tableau.getEntry(2, j + 1));\n            tableau.setEntry(3, j, tableau.getEntry(3, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(3, index);\n                tableau.setEntry(3, index, Double.NaN);\n            }\n            tableau.setEntry(4, j, tableau.getEntry(4, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(4, index);\n                tableau.setEntry(4, index, Double.NaN);\n            }\n            tableau.setEntry(5, j, tableau.getEntry(5, j + 1));\n            if (j == index - 1) {",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (FastMath.abs(entry) > 1.0e-12) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        int index = columnsToDrop.get(i);\n        setColumnObjectiveValue(index, 0.0);\n        for (int j = index - 1; j >= 0; j--) {\n            double value = tableau.getEntry(0, j);\n            tableau.setEntry(0, j, tableau.getEntry(0, j + 1));\n            tableau.setEntry(1, j, tableau.getEntry(1, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(1, index);\n                tableau.setEntry(1, index, Double.NaN);\n            }\n            tableau.setEntry(2, j, tableau.getEntry(2, j + 1));\n            tableau.setEntry(3, j, tableau.getEntry(3, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(2, index);\n                tableau.setEntry(2, index, Double.NaN);\n            }\n            tableau.setEntry(4, j, tableau.getEntry(4, j + 1));\n            tableau.setEntry(5, j, tableau.getEntry(5, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(3, index);\n                tableau.setEntry(3, index, Double.NaN);\n            }\n            tableau.setEntry(6, j",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (FastMath.abs(entry) > 1.0e-12) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        int index = columnsToDrop.get(i);\n        setColumnObjectiveValue(index, 0.0);\n        for (int j = index - 1; j >= 0; j--) {\n            double value = tableau.getEntry(0, j);\n            tableau.setEntry(0, j, tableau.getEntry(0, j + 1));\n            tableau.setEntry(1, j, tableau.getEntry(1, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(1, index);\n                tableau.setEntry(1, index, Double.NaN);\n            }\n            tableau.setEntry(2, j, tableau.getEntry(2, j + 1));\n            tableau.setEntry(3, j, tableau.getEntry(3, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(2, index);\n                tableau.setEntry(2, index, Double.NaN);\n            }\n            tableau.setEntry(4, j, tableau.getEntry(4, j + 1));\n            tableau.setEntry(5, j, tableau.getEntry(5, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(4, index);\n                tableau.setEntry(4, index, Double.NaN);\n            }\n            if (value == 0.0) {",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (FastMath.abs(entry) > 1.0e-12) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        int index = columnsToDrop.get(i);\n        setColumnObjectiveValue(index, 0.0);\n        for (int j = index - 1; j >= 0; j--) {\n            double value = tableau.getEntry(0, j);\n            tableau.setEntry(0, j, tableau.getEntry(0, j + 1));\n            tableau.setEntry(1, j, tableau.getEntry(1, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(1, index);\n                tableau.setEntry(1, index, Double.NaN);\n            }\n            tableau.setEntry(2, j, tableau.getEntry(2, j + 1));\n            tableau.setEntry(3, j, tableau.getEntry(3, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(3, index);\n                tableau.setEntry(3, index, Double.NaN);\n            }\n            tableau.setEntry(4, j, tableau.getEntry(4, j + 1));\n            tableau.setEntry(5, j, tableau.getEntry(5, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(5, index);\n                tableau.setEntry(5, index, Double.NaN);\n            }\n            if (value == 0.0) {",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (FastMath.abs(entry) > 1.0e-12) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        int index = columnsToDrop.get(i);\n        setColumnObjectiveValue(index, 0.0);\n        for (int j = index - 1; j >= 0; j--) {\n            double value = tableau.getEntry(0, j);\n            tableau.setEntry(0, j, tableau.getEntry(0, j + 1));\n            tableau.setEntry(1, j, tableau.getEntry(1, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(1, index);\n                tableau.setEntry(1, index, Double.NaN);\n            }\n            tableau.setEntry(2, j, tableau.getEntry(2, j + 1));\n            tableau.setEntry(3, j, tableau.getEntry(3, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(3, index);\n                tableau.setEntry(3, index, Double.NaN);\n            }\n            tableau.setEntry(4, j, tableau.getEntry(4, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(4, index);\n                tableau.setEntry(4, index, Double.NaN);\n            }\n            tableau.setEntry(5, j, tableau.getEntry(5, j + 1));\n            tableau.setEntry(6, j",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (FastMath.abs(entry) > 1.0e-12) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        int index = columnsToDrop.get(i);\n        setColumnObjectiveValue(index, 0.0);\n        for (int j = index - 1; j >= 0; j--) {\n            double value = tableau.getEntry(0, j);\n            tableau.setEntry(0, j, tableau.getEntry(0, j + 1));\n            tableau.setEntry(1, j, tableau.getEntry(1, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(1, index);\n                tableau.setEntry(1, index, Double.NaN);\n            }\n            tableau.setEntry(2, j, tableau.getEntry(2, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(2, index);\n                tableau.setEntry(2, index, Double.NaN);\n            }\n            tableau.setEntry(3, j, tableau.getEntry(3, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(3, index);\n                tableau.setEntry(3, index, Double.NaN);\n            }\n            tableau.setEntry(0, j + 1, tableau.getEntry(0, j));\n            tableau.setEntry(1, j + 1, tableau.getEntry(1, j));\n            tableau.setEntry(2, j",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (FastMath.abs(entry) > 1.0e-12) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n        int index = columnsToDrop.get(i);\n        setColumnObjectiveValue(index, 0.0);\n        for (int j = index - 1; j >= 0; j--) {\n            double value = tableau.getEntry(0, j);\n            tableau.setEntry(0, j, tableau.getEntry(0, j + 1));\n            tableau.setEntry(1, j, tableau.getEntry(1, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(1, index);\n                tableau.setEntry(1, index, Double.NaN);\n            }\n            tableau.setEntry(2, j, tableau.getEntry(2, j + 1));\n            tableau.setEntry(3, j, tableau.getEntry(3, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(3, index);\n                tableau.setEntry(3, index, Double.NaN);\n            }\n            tableau.setEntry(4, j, tableau.getEntry(4, j + 1));\n            tableau.setEntry(5, j, tableau.getEntry(5, j + 1));\n            if (j == index - 1) {\n                value = tableau.getEntry(5, index);\n                tableau.setEntry(5, index, Double.NaN);\n            }\n            if (j == index - 2) {"
      ],
      "function range": "327,5-367,5"
    },
    "Math_34_/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java_209-210": {
      "loc": "209-210",
      "input": "public Iterator<Chromosome> iterator() {",
      "output": [
        "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.",
        "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache",
        "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.alge",
        "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.",
        "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyr",
        "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.al",
        "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport",
        "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.ICopyEvaluator;\nimport org.apache.hyracks.al",
        "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.",
        "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base."
      ],
      "function range": "208,5-210,5"
    },
    "Math_41_/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java_520-521": {
      "loc": "520-521",
      "input": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;",
      "output": [
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (sumWts * accum2)) / (sumWts * (sumWts - 1.0));\n        }\n    }\n    return var;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights) {\n    return evaluate(values, weights, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values) {\n    return evaluate(values, null, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double mean) {\n    return evaluate(values, weights, mean, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double mean, final int begin, final int length) {\n    return evaluate(values, weights, mean, begin, length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = Math.sqrt(accum / sumWts - (accum2 / sumWts) * (accum2 / sumWts));\n        }\n    }\n    return var;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights) {\n    return evaluate(values, weights, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values) {\n    return evaluate(values, null, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double mean) {\n    return evaluate(values, weights, mean, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double mean, final int begin, final int length) {\n    return evaluate(values, weights, mean, begin, length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (sumWts * accum2) / length) / (sumWts * (sumWts - 1.0));\n        }\n    }\n    return var;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights) {\n    return evaluate(values, weights, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values) {\n    return evaluate(values, null, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double mean) {\n    return evaluate(values, weights, mean, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double mean, final int begin, final int length) {\n    return evaluate(values, weights, mean, begin, length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (sumWts * accum2)) / (sumWts * (sumWts - 1.0));\n        }\n    }\n    return var;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights) {\n    return evaluate(values, weights, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values) {\n    return evaluate(values, null, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final int begin, final int length, final double[] values,\n                         final double[] weights) {\n    return evaluate(values, weights, 0, begin, length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final int begin, final int length, final double[] values) {\n    return evaluate(values, null, 0, begin, length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[]",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (sumWts * accum2)) / (sumWts * (sumWts - 1.0));\n        }\n    }\n    return var;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights) {\n    return evaluate(values, weights, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values) {\n    return evaluate(values, null, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double mean) {\n    return evaluate(values, weights, mean, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final int begin, final int length) {\n    return evaluate(values, weights, 0, begin, length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (sumWts * accum2)) / (sumWts * (sumWts - 1.0));\n        }\n    }\n    return var;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights) {\n    return evaluate(values, weights, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values) {\n    return evaluate(values, null, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double mean) {\n    return evaluate(values, weights, mean, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double mean, final double dev) {\n    return evaluate(values, weights, mean, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  ",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (sumWts * accum2)) / (sumWts * (sumWts - 1.0));\n        }\n    }\n    return var;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights) {\n    return evaluate(values, weights, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values) {\n    return evaluate(values, null, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final int begin, final int length, final double[] values,\n                         final double[] weights) {\n    return evaluate(values, weights, 0, begin, length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final int begin, final int length, final double[] values) {\n    return evaluate(values, null, 0, begin, length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final int begin",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = Math.sqrt(accum / sumWts - (accum2 / sumWts) * (accum2 / sumWts));\n        }\n    }\n    return var;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights) {\n    return evaluate(values, weights, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values) {\n    return evaluate(values, null, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double mean) {\n    return evaluate(values, weights, mean, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final double mean, final int begin) {\n    return evaluate(values, weights, mean, begin, values.length - begin);\n  }\n\n  /**\n   * {@inheritDoc}\n   */",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (sumWts * accum2)) / (sumWts * (sumWts - 1.0));\n        }\n    }\n    return var;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights) {\n    return evaluate(values, weights, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values) {\n    return evaluate(values, null, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final int begin, final int length) {\n    return evaluate(values, null, 0, begin, length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights,\n                         final int begin, final int length) {\n    return evaluate(values, weights, 0, begin, length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[]",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (sumWts * accum2)) / (sumWts * (sumWts - 1.0));\n        }\n    }\n    return var;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights) {\n    return evaluate(values, weights, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values) {\n    return evaluate(values, null, 0, values.length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final int begin, final int length) {\n    return evaluate(values, null, 0, begin, length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {\n    return evaluate(values, weights, 0, begin, length);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public double evaluate(final double[] values,"
      ],
      "function range": "501,5-532,5"
    },
    "Math_48_/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java_189-190": {
      "loc": "189-190",
      "input": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:",
      "output": [
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= (f1 + fx) / f1;\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= f1 / (f1 + fx);\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= f1 / (f1 + fx);\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= (f1 + fx) / f1;\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      ",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= f1 / (f1 + fx);\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= (f1 + fx) / f1;\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     ",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= f1 / (f1 + fx);\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= (f1 + fx) / f1;\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    ",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= (f1 + fx) / f1;\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyInterval(x0, x1);\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= (f1 + fx) / f1;\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyInterval(x0, x1);\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License"
      ],
      "function range": "129,5-251,5"
    },
    "Math_50_/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java_187-191": {
      "loc": "187-191",
      "input": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:",
      "output": [
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= (f1 + fx) / f1;\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= f1 / (f1 + fx);\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= f1 / (f1 + fx);\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= (f1 + fx) / f1;\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      ",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= f1 / (f1 + fx);\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= (f1 + fx) / f1;\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     ",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= f1 / (f1 + fx);\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= (f1 + fx) / f1;\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    ",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= (f1 + fx) / f1;\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyInterval(x0, x1);\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                f0 *= (f1 + fx) / f1;\n                break;\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyInterval(x0, x1);\n        verifyBracketing(x0, x1);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License"
      ],
      "function range": "128,5-253,5"
    },
    "Math_53_/src/main/java/org/apache/commons/math/complex/Complex.java_153-154": {
      "loc": "153-154",
      "input": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);",
      "output": [
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() + rhs.getReal(), getImaginary() + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() - rhs.getReal(), getImaginary() - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() - getImaginary() * rhs.getImaginary(),\n                       getReal() * rhs.getImaginary() + getImaginary() * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() + getImaginary() * rhs.getImaginary(),\n                       getImaginary() * rhs.getReal() - getReal() * rhs.getImaginary());\n  }\n\n  @Override\n  public Complex negate() {\n    return new Complex(-getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex reciprocal() {\n    return new Complex(1.0 / getReal(), -1.0 / getImaginary());\n  }\n\n  @Override\n  public Complex conjugate() {\n    return new Complex(getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex abs() {\n    return new Complex(Math.abs(getReal()), Math.abs(getImaginary()));\n  }\n\n  @Override\n  public Complex sqrt() {\n    return new Complex(Math.sqrt(getReal()), Math.sqrt(getImaginary()));\n  }\n\n  @Override\n  ",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() + rhs.getReal(), getImaginary() + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() - rhs.getReal(), getImaginary() - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() - getImaginary() * rhs.getImaginary(),\n                       getReal() * rhs.getImaginary() + getImaginary() * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() + getImaginary() * rhs.getImaginary(),\n                       getImaginary() * rhs.getReal() - getReal() * rhs.getImaginary());\n  }\n\n  @Override\n  public Complex negate() {\n    return new Complex(-getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex reciprocal() {\n    return new Complex(1.0 / getReal(), -1.0 / getImaginary());\n  }\n\n  @Override\n  public Complex conjugate() {\n    return new Complex(getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex absoluteValue() {\n    return new Complex(Math.abs(getReal()), Math.abs(getImaginary()));\n  }\n\n  @Override\n  public Complex square() {\n    return new Complex(getReal() * getReal(), getImaginary() * getImaginary());\n  }\n\n  @Override\n  public Complex",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() + rhs.getReal(), getImaginary() + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() - rhs.getReal(), getImaginary() - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() - getImaginary() * rhs.getImaginary(),\n                       getReal() * rhs.getImaginary() + getImaginary() * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() + getImaginary() * rhs.getImaginary(),\n                       getImaginary() * rhs.getReal() - getReal() * rhs.getImaginary());\n  }\n\n  @Override\n  public Complex negate() {\n    return new Complex(-getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex reciprocal() {\n    return new Complex(1.0 / getReal(), -1.0 / getImaginary());\n  }\n\n  @Override\n  public Complex conjugate() {\n    return new Complex(getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex absoluteValue() {\n    return new Complex(Math.sqrt(getReal() * getReal() + getImaginary() * getImaginary()),\n                       Math.sqrt(getImaginary() * getImaginary() + getReal() * getReal()));\n  }\n\n  @Override\n  public Complex sqrt() {",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() + rhs.getReal(), getImaginary() + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() - rhs.getReal(), getImaginary() - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() - getImaginary() * rhs.getImaginary(),\n                       getReal() * rhs.getImaginary() + getImaginary() * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() + getImaginary() * rhs.getImaginary(),\n                       getImaginary() * rhs.getReal() - getReal() * rhs.getImaginary());\n  }\n\n  @Override\n  public Complex negate() {\n    return new Complex(-getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex reciprocal() {\n    return new Complex(1.0 / getReal(), -1.0 / getImaginary());\n  }\n\n  @Override\n  public Complex conjugate() {\n    return new Complex(getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex abs() {\n    return new Complex(Math.abs(getReal()), Math.abs(getImaginary()));\n  }\n\n  @Override\n  public Complex sqrt() {\n    return new Complex(Math.sqrt(getReal() * getReal() + getImaginary() * getImaginary()),\n                       Math.",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() + rhs.getReal(), getImaginary() + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() - rhs.getReal(), getImaginary() - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() - getImaginary() * rhs.getImaginary(),\n                       getReal() * rhs.getImaginary() + getImaginary() * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() + getImaginary() * rhs.getImaginary(),\n                       getImaginary() * rhs.getReal() - getReal() * rhs.getImaginary());\n  }\n\n  @Override\n  public Complex negate() {\n    return new Complex(-getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex reciprocal() {\n    return new Complex(1.0 / getReal(), -1.0 / getImaginary());\n  }\n\n  @Override\n  public Complex sqrt() {\n    return new Complex(Math.sqrt(getReal() * getReal() + getImaginary() * getImaginary()),\n                       Math.sqrt(getImaginary() * getImaginary() + getReal() * getReal()));\n  }\n\n  @Override\n  public Complex conjugate() {\n    return new Complex(getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex abs() {\n",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() + rhs.getReal(), getImaginary() + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() - rhs.getReal(), getImaginary() - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() - getImaginary() * rhs.getImaginary(),\n                       getReal() * rhs.getImaginary() + getImaginary() * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() + getImaginary() * rhs.getImaginary(),\n                       getImaginary() * rhs.getReal() - getReal() * rhs.getImaginary());\n  }\n\n  @Override\n  public Complex negate() {\n    return new Complex(-getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex reciprocal() {\n    return new Complex(1.0 / getReal(), -1.0 / getImaginary());\n  }\n\n  @Override\n  public Complex conjugate() {\n    return new Complex(getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex absoluteValue() {\n    return new Complex(Math.sqrt(getReal() * getReal() + getImaginary() * getImaginary()),\n                       Math.sqrt(getImaginary() * getImaginary() + getReal() * getReal()));\n  }\n\n  @Override\n  public Complex square() {\n",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() + rhs.getReal(), getImaginary() + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() - rhs.getReal(), getImaginary() - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() - getImaginary() * rhs.getImaginary(),\n                       getReal() * rhs.getImaginary() + getImaginary() * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() + getImaginary() * rhs.getImaginary(),\n                       getImaginary() * rhs.getReal() - getReal() * rhs.getImaginary());\n  }\n\n  @Override\n  public Complex negate() {\n    return new Complex(-getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex reciprocal() {\n    return new Complex(1.0 / getReal(), -1.0 / getImaginary());\n  }\n\n  @Override\n  public Complex conjugate() {\n    return new Complex(getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex absoluteValue() {\n    return new Complex(Math.sqrt(getReal() * getReal() + getImaginary() * getImaginary()),\n                       Math.sqrt(getImaginary() * getImaginary() + getReal() * getReal()));\n  }\n\n  @Override\n  public double getReal() {",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() + rhs.getReal(), getImaginary() + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() - rhs.getReal(), getImaginary() - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() - getImaginary() * rhs.getImaginary(),\n                       getReal() * rhs.getImaginary() + getImaginary() * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() + getImaginary() * rhs.getImaginary(),\n                       getImaginary() * rhs.getReal() - getReal() * rhs.getImaginary());\n  }\n\n  @Override\n  public Complex negate() {\n    return new Complex(-getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex reciprocal() {\n    return new Complex(1.0 / getReal(), -1.0 / getImaginary());\n  }\n\n  @Override\n  public Complex sqrt() {\n    return new Complex(Math.sqrt(getReal() * getReal() + getImaginary() * getImaginary()),\n                       Math.sqrt(getImaginary() * getImaginary() + getReal() * getReal()));\n  }\n\n  @Override\n  public Complex pow(Complex exponent)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(exponent);\n    return new Complex(get",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() + rhs.getReal(), getImaginary() + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() - rhs.getReal(), getImaginary() - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() - getImaginary() * rhs.getImaginary(),\n                       getReal() * rhs.getImaginary() + getImaginary() * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() + getImaginary() * rhs.getImaginary(),\n                       getImaginary() * rhs.getReal() - getReal() * rhs.getImaginary());\n  }\n\n  @Override\n  public Complex negate() {\n    return new Complex(-getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex reciprocal() {\n    return new Complex(1.0 / getReal(), -1.0 / getImaginary());\n  }\n\n  @Override\n  public Complex conjugate() {\n    return new Complex(getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex absoluteValue() {\n    return new Complex(Math.abs(getReal()), Math.abs(getImaginary()));\n  }\n\n  @Override\n  public Complex sqrt() {\n    return new Complex(Math.sqrt(getReal() * getReal() + getImaginary() * getImaginary()),\n                       Math",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() + rhs.getReal(), getImaginary() + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() - rhs.getReal(), getImaginary() - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() - getImaginary() * rhs.getImaginary(),\n                       getReal() * rhs.getImaginary() + getImaginary() * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return new Complex(getReal() * rhs.getReal() + getImaginary() * rhs.getImaginary(),\n                       getImaginary() * rhs.getReal() - getReal() * rhs.getImaginary());\n  }\n\n  @Override\n  public Complex negate() {\n    return new Complex(-getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex reciprocal() {\n    return new Complex(1.0 / getReal(), -1.0 / getImaginary());\n  }\n\n  @Override\n  public Complex conjugate() {\n    return new Complex(getReal(), -getImaginary());\n  }\n\n  @Override\n  public Complex absoluteValue() {\n    return new Complex(Math.abs(getReal()), Math.abs(getImaginary()));\n  }\n\n  @Override\n  public Complex square() {\n    return new Complex(getReal() * getReal(), getImaginary() * getImaginary());\n  }\n\n  @Override\n  public boolean"
      ],
      "function range": "150,5-155,5"
    },
    "Math_56_/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java_237-244": {
      "loc": "237-244",
      "input": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }",
      "output": [
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.al",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.alge",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.aster",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    return indices;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.h"
      ],
      "function range": "216,5-246,5"
    },
    "Math_57_/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java_175-176": {
      "loc": "175-176",
      "input": "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {",
      "output": [
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      final double[] dx = new double[pointSet.size()];\n      for (int i = 0; i < pointSet.size(); i++) {\n        dx[i] = random.nextDouble() - 0.5;\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        for (int j = i + 1; j < pointSet.size(); j++) {\n          dx2[i] += dx[i] * dx[j];\n          dx2[j] += dx[j] * dx[i];\n        }\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        if (dx2[i] > dx2[resultSet.size()]) {\n          resultSet.add(new Cluster<T>(pointSet.get(i)));\n          dx2[i] = Double.POSITIVE_INFINITY;\n        }\n      }\n    }\n    return resultSet;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      final double[] dx = new double[pointSet.size()];\n      for (int i = 0; i < pointSet.size(); i++) {\n        dx[i] = random.nextDouble() - 0.5;\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        for (int j = i + 1; j < pointSet.size(); j++) {\n          dx2[i] += dx[i] * dx[j];\n          dx2[j] += dx[j] * dx[i];\n        }\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        if (dx2[i] > dx2[resultSet.size()]) {\n          resultSet.add(new Cluster<T>(pointSet.get(i)));\n          dx2[i] = Double.POSITIVE_INFINITY;\n        }\n      }\n    }\n    return resultSet;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      final double[] dx = new double[pointSet.size()];\n      for (int i = 0; i < pointSet.size(); i++) {\n        dx[i] = random.nextDouble() - 0.5;\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        for (int j = i + 1; j < pointSet.size(); j++) {\n          dx2[i] += dx[i] * dx[j];\n          dx2[j] += dx[j] * dx[i];\n        }\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        if (dx2[i] > dx2[resultSet.size()]) {\n          resultSet.add(new Cluster<T>(pointSet.get(i)));\n          dx2[i] = Double.POSITIVE_INFINITY;\n        }\n      }\n    }\n    return resultSet;\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      final double[] dx = new double[pointSet.size()];\n      for (int i = 0; i < pointSet.size(); i++) {\n        dx[i] = random.nextDouble() - 0.5;\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        for (int j = i + 1; j < pointSet.size(); j++) {\n          dx2[i] += dx[i] * dx[j];\n          dx2[j] += dx[j] * dx[i];\n        }\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        if (dx2[i] > dx2[resultSet.size()]) {\n          resultSet.add(new Cluster<T>(pointSet.get(i)));\n          dx2[i] = Double.POSITIVE_INFINITY;\n        }\n      }\n    }\n    return resultSet;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      final double[] dx = new double[pointSet.size()];\n      for (int i = 0; i < pointSet.size(); i++) {\n        dx[i] = random.nextDouble() - 0.5;\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        for (int j = i + 1; j < pointSet.size(); j++) {\n          dx2[i] += dx[i] * dx[j];\n          dx2[j] += dx[j] * dx[i];\n        }\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        if (dx2[i] > dx2[resultSet.size()]) {\n          final T point = pointSet.get(i);\n          resultSet.add(new Cluster<T>(point));\n          dx2[i] = Double.POSITIVE_INFINITY;\n        }\n      }\n    }\n    return resultSet;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      final double[] dx = new double[pointSet.size()];\n      for (int i = 0; i < pointSet.size(); i++) {\n        dx[i] = random.nextDouble() - 0.5;\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        for (int j = i + 1; j < pointSet.size(); j++) {\n          dx2[i] += dx[i] * dx[j];\n          dx2[j] += dx[j] * dx[i];\n        }\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        if (dx2[i] > dx2[resultSet.size()]) {\n          resultSet.add(new Cluster<T>(pointSet.get(i)));\n          dx2[i] = Double.POSITIVE_INFINITY;\n        }\n      }\n    }\n    return resultSet;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      final double[] dx = new double[pointSet.size()];\n      for (int i = 0; i < pointSet.size(); i++) {\n        dx[i] = random.nextDouble() - 0.5;\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        for (int j = i + 1; j < pointSet.size(); j++) {\n          dx2[i] += dx[i] * dx[j];\n          dx2[j] += dx[j] * dx[i];\n        }\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        if (dx2[i] > dx2[resultSet.size()]) {\n          resultSet.add(new Cluster<T>(pointSet.get(i)));\n          dx2[i] = Double.POSITIVE_INFINITY;\n        }\n      }\n    }\n    return resultSet;\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      final double[] dx = new double[pointSet.size()];\n      for (int i = 0; i < pointSet.size(); i++) {\n        dx[i] = random.nextDouble() - 0.5;\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        for (int j = i + 1; j < pointSet.size(); j++) {\n          dx2[i] += dx[i] * dx[j];\n          dx2[j] += dx[j] * dx[i];\n        }\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        if (dx2[i] > dx2[resultSet.size()]) {\n          final T point = pointSet.get(i);\n          resultSet.add(new Cluster<T>(point));\n          dx2[i] = Double.POSITIVE_INFINITY;\n        }\n      }\n    }\n    return resultSet;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      final double[] dx = new double[pointSet.size()];\n      for (int i = 0; i < pointSet.size(); i++) {\n        dx[i] = random.nextDouble() - 0.5;\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        for (int j = i + 1; j < pointSet.size(); j++) {\n          dx2[i] += dx[i] * dx[j];\n          dx2[j] += dx[j] * dx[i];\n        }\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        if (dx2[i] > dx2[resultSet.size()]) {\n          final T point = pointSet.get(i);\n          resultSet.add(new Cluster<T>(point));\n          dx2[i] = Double.POSITIVE_INFINITY;\n        }\n      }\n    }\n    return resultSet;\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n      final double[] dx = new double[pointSet.size()];\n      for (int i = 0; i < pointSet.size(); i++) {\n        dx[i] = random.nextDouble() - 0.5;\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        for (int j = i + 1; j < pointSet.size(); j++) {\n          dx2[i] += dx[i] * dx[j];\n          dx2[j] += dx[j] * dx[i];\n        }\n      }\n      for (int i = 0; i < pointSet.size(); i++) {\n        if (dx2[i] > dx2[resultSet.size()]) {\n          final T point = pointSet.get(i);\n          resultSet.add(new Cluster<T>(point));\n          dx2[i] = Double.POSITIVE_INFINITY;\n        }\n      }\n    }\n    return resultSet;\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-"
      ],
      "function range": "161,5-198,5"
    },
    "Math_58_/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java_121-122": {
      "loc": "121-122",
      "input": "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();",
      "output": [
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n    final LeastSquaresProblem problem = new LeastSquaresBuilder()\n       .maxEvaluations(getMaxEvaluations())\n       .maxIterations(getMaxIterations())\n       .start(guess)\n       .model(this)\n       .build();\n    return optimizer.optimize(problem).getPoint();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.alge",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n    final LeastSquaresProblem problem = new LeastSquaresBuilder()\n       .maxEvaluations(getMaxEvaluations())\n       .maxIterations(getMaxIterations())\n       .start(guess)\n       .model(this)\n       .build();\n    return optimizer.optimize(problem).getPoint();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n    final LeastSquaresProblem problem = new LeastSquaresBuilder()\n       .maxEvaluations(getMaxEvaluations())\n       .maxIterations(getMaxIterations())\n       .start(guess)\n       .model(this)\n       .build();\n    return optimizer.optimize(problem).getPoint();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algeb",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n    final LeastSquaresProblem problem = new LeastSquaresBuilder()\n       .maxEvaluations(getMaxEvaluations())\n       .maxIterations(getMaxIterations())\n       .start(guess)\n       .model(this)\n       .build();\n    return optimizer.optimize(problem).getPoint();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n    final LeastSquaresProblem problem = new LeastSquaresBuilder()\n       .maxEvaluations(getMaxEvaluations())\n       .maxIterations(getMaxIterations())\n       .start(guess)\n       .model(this)\n       .build();\n    return optimizer.optimize(problem).getPoint();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n    final LeastSquaresProblem problem = new LeastSquaresBuilder()\n       .maxEvaluations(getMaxEvaluations())\n       .maxIterations(getMaxIterations())\n       .start(guess)\n       .model(this)\n       .build();\n    return optimizer.optimize(problem).getPoint();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.al",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n    final LeastSquaresProblem problem = new LeastSquaresBuilder()\n       .maxEvaluations(getMaxEvaluations())\n       .maxIterations(getMaxIterations())\n       .start(guess)\n       .model(this)\n       .build();\n    return optimizer.optimize(problem).getPoint();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.alge",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n    final LeastSquaresProblem problem = new LeastSquaresBuilder()\n       .maxEvaluations(getMaxEvaluations())\n       .maxIterations(getMaxIterations())\n       .start(guess)\n       .model(this)\n       .build();\n    return optimizer.optimize(problem).getPoint();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IS",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n    final LeastSquaresProblem problem = new LeastSquaresBuilder()\n       .maxEvaluations(getMaxEvaluations())\n       .maxIterations(getMaxIterations())\n       .start(guess)\n       .model(this)\n       .build();\n    return optimizer.optimize(problem).getPoint();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.al",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n    final LeastSquaresProblem problem = new LeastSquaresBuilder()\n       .maxEvaluations(getMaxEvaluations())\n       .maxIterations(getMaxIterations())\n       .start(guess)\n       .model(this)\n       .build();\n    return optimizer.optimize(problem).getPoint();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IE"
      ],
      "function range": "119,5-122,5"
    },
    "Math_59_/src/main/java/org/apache/commons/math/util/FastMath.java_3482-3483": {
      "loc": "3482-3483",
      "input": "public static float max(final float a, final float b) {",
      "output": [
        "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }\n\n    public static float min(final float a, final float b) {\n        return Math.min(a, b);\n    }\n\n    public static int max(final int a, final int b) {\n        return Math.max(a, b);\n    }\n\n    public static int min(final int a, final int b) {\n        return Math.min(a, b);\n    }\n\n    public static long max(final long a, final long b) {\n        return Math.max(a, b);\n    }\n\n    public static long min(final long a, final long b) {\n        return Math.min(a, b);\n    }\n\n    public static short max(final short a, final short b) {\n        return Math.max(a, b);\n    }\n\n    public static short min(final short a, final short b) {\n        return Math.min(a, b);\n    }\n\n    public static byte max(final byte a, final byte b) {\n        return Math.max(a, b);\n    }\n\n    public static byte min(final byte a, final byte b) {\n        return Math.min(a, b);\n    }\n\n    public static char max(final char a, final char b) {\n        return Math.max(a, b);\n    }\n\n    public static char min(final char a, final char b) {\n        return Math.min(a, b);\n    }\n\n    public static double max(final double a, final double b) {\n        return Math.max(a, b);\n    }\n\n    public static double min(final double a, final double b) {\n        return Math.min(a, b);\n    }\n\n    public static float abs(final float a) {\n        return Math.abs(a);\n    }\n\n    public static int abs(final int a) {\n        return Math.abs(a);\n    }\n\n    public static long abs(final long a) {\n        return Math.abs(a);\n    }\n\n    public static short abs(final short a) {\n        return Math.abs(a);\n",
        "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }\n\n    public static float min(final float a, final float b) {\n        return Math.min(a, b);\n    }\n\n    public static int max(final int a, final int b) {\n        return Math.max(a, b);\n    }\n\n    public static int min(final int a, final int b) {\n        return Math.min(a, b);\n    }\n\n    public static long max(final long a, final long b) {\n        return Math.max(a, b);\n    }\n\n    public static long min(final long a, final long b) {\n        return Math.min(a, b);\n    }\n\n    public static double max(final double a, final double b) {\n        return Math.max(a, b);\n    }\n\n    public static double min(final double a, final double b) {\n        return Math.min(a, b);\n    }\n\n    public static BigDecimal max(final BigDecimal a, final BigDecimal b) {\n        return Math.max(a, b);\n    }\n\n    public static BigDecimal min(final BigDecimal a, final BigDecimal b) {\n        return Math.min(a, b);\n    }\n\n    public static BigInteger max(final BigInteger a, final BigInteger b) {\n        return Math.max(a, b);\n    }\n\n    public static BigInteger min(final BigInteger a, final BigInteger b) {\n        return Math.min(a, b);\n    }\n\n    public static BigInteger max(final BigInteger a, final BigInteger b, final MathContext context) {\n        return Math.max(a, b, context);\n    }\n\n    public static BigInteger min(final BigInteger a, final BigInteger b, final MathContext context) {\n        return Math.min(a, b, context);\n    }\n\n    public static BigDecimal max(final BigDecimal a, final BigDecimal b, final MathContext context) {\n        return Math.max(a, b, context);\n    }\n\n    public static BigDecimal min(final BigDecimal",
        "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }\n\n    public static float min(final float a, final float b) {\n        return Math.min(a, b);\n    }\n\n    public static int max(final int a, final int b) {\n        return Math.max(a, b);\n    }\n\n    public static int min(final int a, final int b) {\n        return Math.min(a, b);\n    }\n\n    public static long max(final long a, final long b) {\n        return Math.max(a, b);\n    }\n\n    public static long min(final long a, final long b) {\n        return Math.min(a, b);\n    }\n\n    public static short max(final short a, final short b) {\n        return Math.max(a, b);\n    }\n\n    public static short min(final short a, final short b) {\n        return Math.min(a, b);\n    }\n\n    public static byte max(final byte a, final byte b) {\n        return Math.max(a, b);\n    }\n\n    public static byte min(final byte a, final byte b) {\n        return Math.min(a, b);\n    }\n\n    public static char max(final char a, final char b) {\n        return Math.max(a, b);\n    }\n\n    public static char min(final char a, final char b) {\n        return Math.min(a, b);\n    }\n\n    public static double max(final double a, final double b) {\n        return Math.max(a, b);\n    }\n\n    public static double min(final double a, final double b) {\n        return Math.min(a, b);\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return Math.max(a, b, c);\n    }\n\n    public static float min(final float a, final float b, final float c) {\n        return Math.min(a, b, c);\n    }\n\n    public static int max(final int a, final int b, final int c) {\n        ",
        "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }\n\n    public static float min(final float a, final float b) {\n        return Math.min(a, b);\n    }\n\n    public static int max(final int a, final int b) {\n        return Math.max(a, b);\n    }\n\n    public static int min(final int a, final int b) {\n        return Math.min(a, b);\n    }\n\n    public static long max(final long a, final long b) {\n        return Math.max(a, b);\n    }\n\n    public static long min(final long a, final long b) {\n        return Math.min(a, b);\n    }\n\n    public static short max(final short a, final short b) {\n        return Math.max(a, b);\n    }\n\n    public static short min(final short a, final short b) {\n        return Math.min(a, b);\n    }\n\n    public static byte max(final byte a, final byte b) {\n        return Math.max(a, b);\n    }\n\n    public static byte min(final byte a, final byte b) {\n        return Math.min(a, b);\n    }\n\n    public static char max(final char a, final char b) {\n        return Math.max(a, b);\n    }\n\n    public static char min(final char a, final char b) {\n        return Math.min(a, b);\n    }\n\n    public static double max(final double a, final double b) {\n        return Math.max(a, b);\n    }\n\n    public static double min(final double a, final double b) {\n        return Math.min(a, b);\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return Math.max(a, Math.max(b, c));\n    }\n\n    public static float min(final float a, final float b, final float c) {\n        return Math.min(a, Math.min(b, c));\n    }\n\n    public static int max(final int a, final int b",
        "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }\n\n    public static float min(final float a, final float b) {\n        return Math.min(a, b);\n    }\n\n    public static int max(final int a, final int b) {\n        return Math.max(a, b);\n    }\n\n    public static int min(final int a, final int b) {\n        return Math.min(a, b);\n    }\n\n    public static long max(final long a, final long b) {\n        return Math.max(a, b);\n    }\n\n    public static long min(final long a, final long b) {\n        return Math.min(a, b);\n    }\n\n    public static double max(final double a, final double b) {\n        return Math.max(a, b);\n    }\n\n    public static double min(final double a, final double b) {\n        return Math.min(a, b);\n    }\n\n    public static BigDecimal max(final BigDecimal a, final BigDecimal b) {\n        return Math.max(a, b);\n    }\n\n    public static BigDecimal min(final BigDecimal a, final BigDecimal b) {\n        return Math.min(a, b);\n    }\n\n    public static BigInteger max(final BigInteger a, final BigInteger b) {\n        return Math.max(a, b);\n    }\n\n    public static BigInteger min(final BigInteger a, final BigInteger b) {\n        return Math.min(a, b);\n    }\n\n    public static BigInteger max(final BigInteger a, final BigInteger b, final MathContext mathContext) {\n        return Math.max(a, b, mathContext);\n    }\n\n    public static BigInteger min(final BigInteger a, final BigInteger b, final MathContext mathContext) {\n        return Math.min(a, b, mathContext);\n    }\n\n    public static BigDecimal max(final BigDecimal a, final BigDecimal b, final MathContext mathContext) {\n        return Math.max(a, b, mathContext);\n    }\n\n    public static BigDecimal",
        "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }\n\n    public static float min(final float a, final float b) {\n        return Math.min(a, b);\n    }\n\n    public static int max(final int a, final int b) {\n        return Math.max(a, b);\n    }\n\n    public static int min(final int a, final int b) {\n        return Math.min(a, b);\n    }\n\n    public static long max(final long a, final long b) {\n        return Math.max(a, b);\n    }\n\n    public static long min(final long a, final long b) {\n        return Math.min(a, b);\n    }\n\n    public static short max(final short a, final short b) {\n        return Math.max(a, b);\n    }\n\n    public static short min(final short a, final short b) {\n        return Math.min(a, b);\n    }\n\n    public static byte max(final byte a, final byte b) {\n        return Math.max(a, b);\n    }\n\n    public static byte min(final byte a, final byte b) {\n        return Math.min(a, b);\n    }\n\n    public static char max(final char a, final char b) {\n        return Math.max(a, b);\n    }\n\n    public static char min(final char a, final char b) {\n        return Math.min(a, b);\n    }\n\n    public static double max(final double a, final double b) {\n        return Math.max(a, b);\n    }\n\n    public static double min(final double a, final double b) {\n        return Math.min(a, b);\n    }\n\n    public static float abs(final float a) {\n        return Math.abs(a);\n    }\n\n    public static int abs(final int a) {\n        return Math.abs(a);\n    }\n\n    public static long abs(final long a) {\n        return Math.abs(a);\n    }\n\n    public static double abs(final double a) {\n        return Math.abs(a);\n",
        "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }\n\n    public static float min(final float a, final float b) {\n        return Math.min(a, b);\n    }\n\n    public static int max(final int a, final int b) {\n        return Math.max(a, b);\n    }\n\n    public static int min(final int a, final int b) {\n        return Math.min(a, b);\n    }\n\n    public static long max(final long a, final long b) {\n        return Math.max(a, b);\n    }\n\n    public static long min(final long a, final long b) {\n        return Math.min(a, b);\n    }\n\n    public static short max(final short a, final short b) {\n        return Math.max(a, b);\n    }\n\n    public static short min(final short a, final short b) {\n        return Math.min(a, b);\n    }\n\n    public static byte max(final byte a, final byte b) {\n        return Math.max(a, b);\n    }\n\n    public static byte min(final byte a, final byte b) {\n        return Math.min(a, b);\n    }\n\n    public static double max(final double a, final double b) {\n        return Math.max(a, b);\n    }\n\n    public static double min(final double a, final double b) {\n        return Math.min(a, b);\n    }\n\n    public static float abs(final float a) {\n        return Math.abs(a);\n    }\n\n    public static int abs(final int a) {\n        return Math.abs(a);\n    }\n\n    public static long abs(final long a) {\n        return Math.abs(a);\n    }\n\n    public static short abs(final short a) {\n        return Math.abs(a);\n    }\n\n    public static byte abs(final byte a) {\n        return Math.abs(a);\n    }\n\n    public static double abs(final double a) {\n        return Math.abs(a);\n    }\n}\n<|java|>/*",
        "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }\n\n    public static float min(final float a, final float b) {\n        return Math.min(a, b);\n    }\n\n    public static int max(final int a, final int b) {\n        return Math.max(a, b);\n    }\n\n    public static int min(final int a, final int b) {\n        return Math.min(a, b);\n    }\n\n    public static long max(final long a, final long b) {\n        return Math.max(a, b);\n    }\n\n    public static long min(final long a, final long b) {\n        return Math.min(a, b);\n    }\n\n    public static short max(final short a, final short b) {\n        return Math.max(a, b);\n    }\n\n    public static short min(final short a, final short b) {\n        return Math.min(a, b);\n    }\n\n    public static byte max(final byte a, final byte b) {\n        return Math.max(a, b);\n    }\n\n    public static byte min(final byte a, final byte b) {\n        return Math.min(a, b);\n    }\n\n    public static double max(final double a, final double b) {\n        return Math.max(a, b);\n    }\n\n    public static double min(final double a, final double b) {\n        return Math.min(a, b);\n    }\n\n    public static float abs(final float a) {\n        return Math.abs(a);\n    }\n\n    public static int abs(final int a) {\n        return Math.abs(a);\n    }\n\n    public static long abs(final long a) {\n        return Math.abs(a);\n    }\n\n    public static short abs(final short a) {\n        return Math.abs(a);\n    }\n\n    public static byte abs(final byte a) {\n        return Math.abs(a);\n    }\n\n    public static double abs(final double a) {\n        return Math.abs(a);\n    }\n}\n<|java|>package",
        "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }\n\n    public static float min(final float a, final float b) {\n        return Math.min(a, b);\n    }\n\n    public static int max(final int a, final int b) {\n        return Math.max(a, b);\n    }\n\n    public static int min(final int a, final int b) {\n        return Math.min(a, b);\n    }\n\n    public static long max(final long a, final long b) {\n        return Math.max(a, b);\n    }\n\n    public static long min(final long a, final long b) {\n        return Math.min(a, b);\n    }\n\n    public static short max(final short a, final short b) {\n        return Math.max(a, b);\n    }\n\n    public static short min(final short a, final short b) {\n        return Math.min(a, b);\n    }\n\n    public static byte max(final byte a, final byte b) {\n        return Math.max(a, b);\n    }\n\n    public static byte min(final byte a, final byte b) {\n        return Math.min(a, b);\n    }\n\n    public static double max(final double a, final double b) {\n        return Math.max(a, b);\n    }\n\n    public static double min(final double a, final double b) {\n        return Math.min(a, b);\n    }\n\n    public static float abs(final float a) {\n        return Math.abs(a);\n    }\n\n    public static int abs(final int a) {\n        return Math.abs(a);\n    }\n\n    public static long abs(final long a) {\n        return Math.abs(a);\n    }\n\n    public static short abs(final short a) {\n        return Math.abs(a);\n    }\n\n    public static byte abs(final byte a) {\n        return Math.abs(a);\n    }\n\n    public static double abs(final double a) {\n        return Math.abs(a);\n    }\n\n    public static float sqrt(final float",
        "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }\n\n    public static float min(final float a, final float b) {\n        return Math.min(a, b);\n    }\n\n    public static int max(final int a, final int b) {\n        return Math.max(a, b);\n    }\n\n    public static int min(final int a, final int b) {\n        return Math.min(a, b);\n    }\n\n    public static long max(final long a, final long b) {\n        return Math.max(a, b);\n    }\n\n    public static long min(final long a, final long b) {\n        return Math.min(a, b);\n    }\n\n    public static short max(final short a, final short b) {\n        return Math.max(a, b);\n    }\n\n    public static short min(final short a, final short b) {\n        return Math.min(a, b);\n    }\n\n    public static byte max(final byte a, final byte b) {\n        return Math.max(a, b);\n    }\n\n    public static byte min(final byte a, final byte b) {\n        return Math.min(a, b);\n    }\n\n    public static double max(final double a, final double b) {\n        return Math.max(a, b);\n    }\n\n    public static double min(final double a, final double b) {\n        return Math.min(a, b);\n    }\n\n    public static float abs(final float a) {\n        return Math.abs(a);\n    }\n\n    public static int abs(final int a) {\n        return Math.abs(a);\n    }\n\n    public static long abs(final long a) {\n        return Math.abs(a);\n    }\n\n    public static short abs(final short a) {\n        return Math.abs(a);\n    }\n\n    public static byte abs(final byte a) {\n        return Math.abs(a);\n    }\n\n    public static double abs(final double a) {\n        return Math.abs(a);\n    }\n\n    public static int signum(final float"
      ],
      "function range": "3481,5-3483,5"
    },
    "Math_63_/src/main/java/org/apache/commons/math/util/MathUtils.java_417-418": {
      "loc": "417-418",
      "input": "public static boolean equals(double x, double y) {",
      "output": [
        "public static boolean equals(double x, double y) {\n        return x == y;\n    }\n\n    public static boolean notEquals(double x, double y) {\n        return x!= y;\n    }\n\n    public static boolean lessThan(double x, double y) {\n        return x < y;\n    }\n\n    public static boolean lessThanOrEquals(double x, double y) {\n        return x <= y;\n    }\n\n    public static boolean greaterThan(double x, double y) {\n        return x > y;\n    }\n\n    public static boolean greaterThanOrEquals(double x, double y) {\n        return x >= y;\n    }\n\n    public static double add(double x, double y) {\n        return x + y;\n    }\n\n    public static double subtract(double x, double y) {\n        return x - y;\n    }\n\n    public static double multiply(double x, double y) {\n        return x * y;\n    }\n\n    public static double divide(double x, double y) {\n        return x / y;\n    }\n\n    public static double mod(double x, double y) {\n        return x % y;\n    }\n\n    public static double and(double x, double y) {\n        return x & y;\n    }\n\n    public static double or(double x, double y) {\n        return x | y;\n    }\n\n    public static double xor(double x, double y) {\n        return x ^ y;\n    }\n\n    public static double leftShift(double x, int y) {\n        return x << y;\n    }\n\n    public static double rightShift(double x, int y) {\n        return x >> y;\n    }\n\n    public static double unsignedRightShift(double x, int y) {\n        return x >>> y;\n    }\n\n    public static boolean equalTo(double x, double y) {\n        return x == y;\n    }\n\n    public static boolean notEqualTo(double x, double y) {\n        return x!= y;\n    }\n\n    public static boolean lessThan(double x, double y) {\n        return x < y;\n    }\n\n    public static boolean lessTh",
        "public static boolean equals(double x, double y) {\n        return x == y;\n    }\n\n    public static boolean notEquals(double x, double y) {\n        return x!= y;\n    }\n\n    public static boolean lessThan(double x, double y) {\n        return x < y;\n    }\n\n    public static boolean lessThanOrEquals(double x, double y) {\n        return x <= y;\n    }\n\n    public static boolean greaterThan(double x, double y) {\n        return x > y;\n    }\n\n    public static boolean greaterThanOrEquals(double x, double y) {\n        return x >= y;\n    }\n\n    public static double add(double x, double y) {\n        return x + y;\n    }\n\n    public static double subtract(double x, double y) {\n        return x - y;\n    }\n\n    public static double multiply(double x, double y) {\n        return x * y;\n    }\n\n    public static double divide(double x, double y) {\n        return x / y;\n    }\n\n    public static double mod(double x, double y) {\n        return x % y;\n    }\n\n    public static double and(double x, double y) {\n        return x & y;\n    }\n\n    public static double or(double x, double y) {\n        return x | y;\n    }\n\n    public static double xor(double x, double y) {\n        return x ^ y;\n    }\n\n    public static double leftShift(double x, int y) {\n        return x << y;\n    }\n\n    public static double rightShift(double x, int y) {\n        return x >> y;\n    }\n\n    public static double unsignedRightShift(double x, int y) {\n        return x >>> y;\n    }\n\n    public static boolean equalTo(double x, double y) {\n        return x == y;\n    }\n\n    public static boolean notEqualTo(double x, double y) {\n        return x!= y;\n    }\n\n    public static boolean greaterThan(double x, double y) {\n        return x > y;\n    }\n\n    public static boolean greaterTh",
        "public static boolean equals(double x, double y) {\n        return x == y;\n    }\n\n    public static boolean notEquals(double x, double y) {\n        return x!= y;\n    }\n\n    public static boolean lessThan(double x, double y) {\n        return x < y;\n    }\n\n    public static boolean lessThanOrEquals(double x, double y) {\n        return x <= y;\n    }\n\n    public static boolean greaterThan(double x, double y) {\n        return x > y;\n    }\n\n    public static boolean greaterThanOrEquals(double x, double y) {\n        return x >= y;\n    }\n\n    public static double add(double x, double y) {\n        return x + y;\n    }\n\n    public static double subtract(double x, double y) {\n        return x - y;\n    }\n\n    public static double multiply(double x, double y) {\n        return x * y;\n    }\n\n    public static double divide(double x, double y) {\n        return x / y;\n    }\n\n    public static double mod(double x, double y) {\n        return x % y;\n    }\n\n    public static double and(double x, double y) {\n        return x & y;\n    }\n\n    public static double or(double x, double y) {\n        return x | y;\n    }\n\n    public static double xor(double x, double y) {\n        return x ^ y;\n    }\n\n    public static double leftShift(double x, double y) {\n        return x << y;\n    }\n\n    public static double rightShift(double x, double y) {\n        return x >> y;\n    }\n\n    public static double leftShiftUnsigned(double x, double y) {\n        return x >>> y;\n    }\n\n    public static double rightShiftUnsigned(double x, double y) {\n        return x >>> y;\n    }\n\n    public static boolean isNaN(double x) {\n        return Double.isNaN(x);\n    }\n\n    public static boolean isInfinite(double x) {\n        return Double.isInfinite(x);\n    }\n\n    public",
        "public static boolean equals(double x, double y) {\n        return x == y;\n    }\n\n    public static boolean notEquals(double x, double y) {\n        return x!= y;\n    }\n\n    public static boolean lessThan(double x, double y) {\n        return x < y;\n    }\n\n    public static boolean lessThanOrEquals(double x, double y) {\n        return x <= y;\n    }\n\n    public static boolean greaterThan(double x, double y) {\n        return x > y;\n    }\n\n    public static boolean greaterThanOrEquals(double x, double y) {\n        return x >= y;\n    }\n\n    public static double add(double x, double y) {\n        return x + y;\n    }\n\n    public static double subtract(double x, double y) {\n        return x - y;\n    }\n\n    public static double multiply(double x, double y) {\n        return x * y;\n    }\n\n    public static double divide(double x, double y) {\n        return x / y;\n    }\n\n    public static double mod(double x, double y) {\n        return x % y;\n    }\n\n    public static double and(double x, double y) {\n        return x & y;\n    }\n\n    public static double or(double x, double y) {\n        return x | y;\n    }\n\n    public static double xor(double x, double y) {\n        return x ^ y;\n    }\n\n    public static double leftShift(double x, int y) {\n        return x << y;\n    }\n\n    public static double rightShift(double x, int y) {\n        return x >> y;\n    }\n\n    public static double unsignedRightShift(double x, int y) {\n        return x >>> y;\n    }\n\n    public static double andAlso(double x, double y) {\n        return x & y;\n    }\n\n    public static double orElse(double x, double y) {\n        return x | y;\n    }\n\n    public static double xorAlso(double x, double y) {\n        return x ^ y;\n    }\n}\n<|java|>",
        "public static boolean equals(double x, double y) {\n        return x == y;\n    }\n\n    public static boolean notEquals(double x, double y) {\n        return x!= y;\n    }\n\n    public static boolean lessThan(double x, double y) {\n        return x < y;\n    }\n\n    public static boolean lessThanOrEquals(double x, double y) {\n        return x <= y;\n    }\n\n    public static boolean greaterThan(double x, double y) {\n        return x > y;\n    }\n\n    public static boolean greaterThanOrEquals(double x, double y) {\n        return x >= y;\n    }\n\n    public static double add(double x, double y) {\n        return x + y;\n    }\n\n    public static double subtract(double x, double y) {\n        return x - y;\n    }\n\n    public static double multiply(double x, double y) {\n        return x * y;\n    }\n\n    public static double divide(double x, double y) {\n        return x / y;\n    }\n\n    public static double mod(double x, double y) {\n        return x % y;\n    }\n\n    public static double and(double x, double y) {\n        return x & y;\n    }\n\n    public static double or(double x, double y) {\n        return x | y;\n    }\n\n    public static double xor(double x, double y) {\n        return x ^ y;\n    }\n\n    public static double leftShift(double x, double y) {\n        return x << y;\n    }\n\n    public static double rightShift(double x, double y) {\n        return x >> y;\n    }\n\n    public static double leftShiftUnsigned(double x, double y) {\n        return x >>> y;\n    }\n\n    public static double rightShiftUnsigned(double x, double y) {\n        return x >>> y;\n    }\n\n    public static boolean isNaN(double x) {\n        return Double.isNaN(x);\n    }\n\n    public static boolean isInfinite(double x) {\n        return Double.isInfinite(x);\n    }\n\n    //",
        "public static boolean equals(double x, double y) {\n        return x == y;\n    }\n\n    public static boolean notEquals(double x, double y) {\n        return x!= y;\n    }\n\n    public static boolean lessThan(double x, double y) {\n        return x < y;\n    }\n\n    public static boolean lessThanOrEquals(double x, double y) {\n        return x <= y;\n    }\n\n    public static boolean greaterThan(double x, double y) {\n        return x > y;\n    }\n\n    public static boolean greaterThanOrEquals(double x, double y) {\n        return x >= y;\n    }\n\n    public static double add(double x, double y) {\n        return x + y;\n    }\n\n    public static double subtract(double x, double y) {\n        return x - y;\n    }\n\n    public static double multiply(double x, double y) {\n        return x * y;\n    }\n\n    public static double divide(double x, double y) {\n        return x / y;\n    }\n\n    public static double mod(double x, double y) {\n        return x % y;\n    }\n\n    public static double and(double x, double y) {\n        return x & y;\n    }\n\n    public static double or(double x, double y) {\n        return x | y;\n    }\n\n    public static double xor(double x, double y) {\n        return x ^ y;\n    }\n\n    public static double leftShift(double x, int y) {\n        return x << y;\n    }\n\n    public static double rightShift(double x, int y) {\n        return x >> y;\n    }\n\n    public static double unsignedRightShift(double x, int y) {\n        return x >>> y;\n    }\n\n    public static double andAlso(double x, double y) {\n        return x & y;\n    }\n\n    public static double orElse(double x, double y) {\n        return x | y;\n    }\n\n    public static double xorElse(double x, double y) {\n        return x ^ y;\n    }\n}\n<|java|>",
        "public static boolean equals(double x, double y) {\n        return x == y;\n    }\n\n    public static boolean notEquals(double x, double y) {\n        return x!= y;\n    }\n\n    public static boolean lessThan(double x, double y) {\n        return x < y;\n    }\n\n    public static boolean lessThanOrEquals(double x, double y) {\n        return x <= y;\n    }\n\n    public static boolean greaterThan(double x, double y) {\n        return x > y;\n    }\n\n    public static boolean greaterThanOrEquals(double x, double y) {\n        return x >= y;\n    }\n\n    public static double add(double x, double y) {\n        return x + y;\n    }\n\n    public static double subtract(double x, double y) {\n        return x - y;\n    }\n\n    public static double multiply(double x, double y) {\n        return x * y;\n    }\n\n    public static double divide(double x, double y) {\n        return x / y;\n    }\n\n    public static double mod(double x, double y) {\n        return x % y;\n    }\n\n    public static double and(double x, double y) {\n        return x & y;\n    }\n\n    public static double or(double x, double y) {\n        return x | y;\n    }\n\n    public static double xor(double x, double y) {\n        return x ^ y;\n    }\n\n    public static double leftShift(double x, double y) {\n        return x << y;\n    }\n\n    public static double rightShift(double x, double y) {\n        return x >> y;\n    }\n\n    public static double leftShiftUnsigned(double x, double y) {\n        return x >>> y;\n    }\n\n    public static double rightShiftUnsigned(double x, double y) {\n        return x >>> y;\n    }\n\n    public static boolean isNaN(double x) {\n        return Double.isNaN(x);\n    }\n\n    public static boolean isInfinite(double x) {\n        return Double.isInfinite(x);\n    }\n}\n",
        "public static boolean equals(double x, double y) {\n        return x == y;\n    }\n\n    public static boolean notEquals(double x, double y) {\n        return x!= y;\n    }\n\n    public static boolean lessThan(double x, double y) {\n        return x < y;\n    }\n\n    public static boolean lessThanOrEquals(double x, double y) {\n        return x <= y;\n    }\n\n    public static boolean greaterThan(double x, double y) {\n        return x > y;\n    }\n\n    public static boolean greaterThanOrEquals(double x, double y) {\n        return x >= y;\n    }\n\n    public static double add(double x, double y) {\n        return x + y;\n    }\n\n    public static double subtract(double x, double y) {\n        return x - y;\n    }\n\n    public static double multiply(double x, double y) {\n        return x * y;\n    }\n\n    public static double divide(double x, double y) {\n        return x / y;\n    }\n\n    public static double mod(double x, double y) {\n        return x % y;\n    }\n\n    public static double and(double x, double y) {\n        return x & y;\n    }\n\n    public static double or(double x, double y) {\n        return x | y;\n    }\n\n    public static double xor(double x, double y) {\n        return x ^ y;\n    }\n\n    public static double leftShift(double x, int y) {\n        return x << y;\n    }\n\n    public static double rightShift(double x, int y) {\n        return x >> y;\n    }\n\n    public static double unsignedRightShift(double x, int y) {\n        return x >>> y;\n    }\n\n    public static double andAlso(double x, double y) {\n        return x & y;\n    }\n\n    public static double orElse(double x, double y) {\n        return x | y;\n    }\n\n    public static double xorAlso(double x, double y) {\n        return x ^ y;\n    }\n\n    public static double negate(double x",
        "public static boolean equals(double x, double y) {\n        return x == y;\n    }\n\n    public static boolean notEquals(double x, double y) {\n        return x!= y;\n    }\n\n    public static boolean lessThan(double x, double y) {\n        return x < y;\n    }\n\n    public static boolean lessThanOrEquals(double x, double y) {\n        return x <= y;\n    }\n\n    public static boolean greaterThan(double x, double y) {\n        return x > y;\n    }\n\n    public static boolean greaterThanOrEquals(double x, double y) {\n        return x >= y;\n    }\n\n    public static double add(double x, double y) {\n        return x + y;\n    }\n\n    public static double subtract(double x, double y) {\n        return x - y;\n    }\n\n    public static double multiply(double x, double y) {\n        return x * y;\n    }\n\n    public static double divide(double x, double y) {\n        return x / y;\n    }\n\n    public static double mod(double x, double y) {\n        return x % y;\n    }\n\n    public static double and(double x, double y) {\n        return x & y;\n    }\n\n    public static double or(double x, double y) {\n        return x | y;\n    }\n\n    public static double xor(double x, double y) {\n        return x ^ y;\n    }\n\n    public static double leftShift(double x, int y) {\n        return x << y;\n    }\n\n    public static double rightShift(double x, int y) {\n        return x >> y;\n    }\n\n    public static double unsignedRightShift(double x, int y) {\n        return x >>> y;\n    }\n\n    public static boolean equalTo(double x, double y) {\n        return x == y;\n    }\n\n    public static boolean notEqualTo(double x, double y) {\n        return x!= y;\n    }\n\n    public static boolean lessThan(double x, double y) {\n        return x < y;\n    }\n\n    public static boolean lessE",
        "public static boolean equals(double x, double y) {\n        return x == y;\n    }\n\n    public static boolean notEquals(double x, double y) {\n        return x!= y;\n    }\n\n    public static boolean lessThan(double x, double y) {\n        return x < y;\n    }\n\n    public static boolean lessThanOrEquals(double x, double y) {\n        return x <= y;\n    }\n\n    public static boolean greaterThan(double x, double y) {\n        return x > y;\n    }\n\n    public static boolean greaterThanOrEquals(double x, double y) {\n        return x >= y;\n    }\n\n    public static double add(double x, double y) {\n        return x + y;\n    }\n\n    public static double subtract(double x, double y) {\n        return x - y;\n    }\n\n    public static double multiply(double x, double y) {\n        return x * y;\n    }\n\n    public static double divide(double x, double y) {\n        return x / y;\n    }\n\n    public static double mod(double x, double y) {\n        return x % y;\n    }\n\n    public static double and(double x, double y) {\n        return x & y;\n    }\n\n    public static double or(double x, double y) {\n        return x | y;\n    }\n\n    public static double xor(double x, double y) {\n        return x ^ y;\n    }\n\n    public static double leftShift(double x, double y) {\n        return x << y;\n    }\n\n    public static double rightShift(double x, double y) {\n        return x >> y;\n    }\n\n    public static double leftShiftUnsigned(double x, double y) {\n        return x >>> y;\n    }\n\n    public static double rightShiftUnsigned(double x, double y) {\n        return x >>> y;\n    }\n\n    public static boolean isNaN(double x) {\n        return Double.isNaN(x);\n    }\n\n    public static boolean isInfinite(double x) {\n        return Double.isInfinite(x);\n    }\n\n    private"
      ],
      "function range": "416,5-418,5"
    },
    "Math_69_/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java_171-172": {
      "loc": "171-172",
      "input": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));",
      "output": [
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                double p = 2 * tDistribution.cumulativeProbability(t);\n                out[i][j] = p;\n                out[j][i] = p;\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                double p = 2 * tDistribution.cumulativeProbability(t);\n                out[i][j] = p;\n                out[j][i] = p;\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.fun",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                double p = 2 * tDistribution.cumulativeProbability(t);\n                out[i][j] = p;\n                out[j][i] = p;\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.agg",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                double p = 2 * tDistribution.cumulativeProbability(t);\n                out[i][j] = p;\n                out[j][i] = p;\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                double p = 2 * tDistribution.cumulativeProbability(t);\n                out[i][j] = p;\n                out[j][i] = p;\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.formats.nontagged.AqlSerializerDeserializerProvider;\nimport org.apache.aster",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                double p = 2 * tDistribution.cumulativeProbability(t);\n                out[i][j] = p;\n                out[j][i] = p;\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                double p = 2 * tDistribution.cumulativeProbability(t);\n                out[i][j] = p;\n                out[j][i] = p;\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                double p = 2 * tDistribution.cumulativeProbability(t);\n                out[i][j] = p;\n                out[j][i] = p;\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.formats.nontagged.SerializerDeserializerProvider;\nimport org.apache.asterix.",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                double p = 2 * tDistribution.cumulativeProbability(t);\n                out[i][j] = p;\n                out[j][i] = p;\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.dataflow.data.nontagged.serde.ADoubleSerializerDeserializer;\nimport org",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                double p = 2 * tDistribution.cumulativeProbability(t);\n                out[i][j] = p;\n                out[j][i] = p;\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.common.annotations.MissingNullInOutFunction;\nimport org.apache.asterix.om.fun"
      ],
      "function range": "160,5-176,5"
    },
    "Math_70_/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java_72-73": {
      "loc": "72-73",
      "input": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {",
      "output": [
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solver.solve(f, min, max, initial);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solver.solve(f, min, max, initial);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solver.solve(f, min, max, initial);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.H",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solver.solve(f, min, max, initial);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solver.solve(f, min, max, initial);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solver.solve(f, min, max, initial);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.data.std.api.IPointable;\n",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solver.solve(f, min, max, initial);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.H",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solver.solve(f, min, max, initial);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescript",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solver.solve(f, min, max, initial);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.api.exceptions",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solver.solve(f, min, max, initial);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class LocalSqlStddevAgg"
      ],
      "function range": "70,5-73,5"
    },
    "Math_73_/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java_136-137": {
      "loc": "136-137",
      "input": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }",
      "output": [
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.fl",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hado",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.h",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.beam."
      ],
      "function range": "98,5-140,5"
    },
    "Math_75_/src/main/java/org/apache/commons/math/stat/Frequency.java_303-304": {
      "loc": "303-304",
      "input": "@Deprecated\npublic double getPct(Object v) {",
      "output": [
        "@Deprecated\npublic double getPct(Object v) {\n        if (v instanceof Double) {\n            return ((Double) v).doubleValue();\n        } else if (v instanceof Integer) {\n            return ((Integer) v).doubleValue();\n        } else if (v instanceof Long) {\n            return ((Long) v).doubleValue();\n        } else if (v instanceof Float) {\n            return ((Float) v).doubleValue();\n        } else if (v instanceof Short) {\n            return ((Short) v).doubleValue();\n        } else if (v instanceof Byte) {\n            return ((Byte) v).doubleValue();\n        } else if (v instanceof BigDecimal) {\n            return ((BigDecimal) v).doubleValue();\n        } else if (v instanceof BigInteger) {\n            return ((BigInteger) v).doubleValue();\n        } else if (v instanceof Number) {\n            return ((Number) v).doubleValue();\n        } else if (v instanceof Boolean) {\n            return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n        } else if (v instanceof Character) {\n            return ((Character) v).charValue();\n        } else if (v instanceof String) {\n            return Double.parseDouble((String) v);\n        } else {\n            return 0.0;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and",
        "@Deprecated\npublic double getPct(Object v) {\n        if (v instanceof Double) {\n            return ((Double) v).doubleValue();\n        } else if (v instanceof Integer) {\n            return ((Integer) v).doubleValue();\n        } else if (v instanceof Long) {\n            return ((Long) v).doubleValue();\n        } else if (v instanceof Float) {\n            return ((Float) v).doubleValue();\n        } else if (v instanceof Short) {\n            return ((Short) v).doubleValue();\n        } else if (v instanceof Byte) {\n            return ((Byte) v).doubleValue();\n        } else if (v instanceof BigDecimal) {\n            return ((BigDecimal) v).doubleValue();\n        } else if (v instanceof BigInteger) {\n            return ((BigInteger) v).doubleValue();\n        } else if (v instanceof Number) {\n            return ((Number) v).doubleValue();\n        } else if (v instanceof Boolean) {\n            return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n        } else if (v instanceof Character) {\n            return ((Character) v).charValue();\n        } else if (v instanceof String) {\n            return Double.parseDouble((String) v);\n        } else {\n            return 0.0;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language",
        "@Deprecated\npublic double getPct(Object v) {\n        if (v instanceof Double) {\n            return ((Double) v).doubleValue();\n        } else if (v instanceof Integer) {\n            return ((Integer) v).doubleValue();\n        } else if (v instanceof Long) {\n            return ((Long) v).doubleValue();\n        } else if (v instanceof Float) {\n            return ((Float) v).doubleValue();\n        } else if (v instanceof Short) {\n            return ((Short) v).doubleValue();\n        } else if (v instanceof Byte) {\n            return ((Byte) v).doubleValue();\n        } else if (v instanceof BigDecimal) {\n            return ((BigDecimal) v).doubleValue();\n        } else if (v instanceof BigInteger) {\n            return ((BigInteger) v).doubleValue();\n        } else if (v instanceof Number) {\n            return ((Number) v).doubleValue();\n        } else if (v instanceof Boolean) {\n            return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n        } else if (v instanceof Character) {\n            return ((Character) v).charValue();\n        } else if (v instanceof String) {\n            return Double.parseDouble((String) v);\n        } else {\n            return 0.0;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and",
        "@Deprecated\npublic double getPct(Object v) {\n        if (v instanceof Double) {\n            return ((Double) v).doubleValue();\n        } else if (v instanceof Integer) {\n            return ((Integer) v).doubleValue();\n        } else if (v instanceof Long) {\n            return ((Long) v).doubleValue();\n        } else if (v instanceof Float) {\n            return ((Float) v).doubleValue();\n        } else if (v instanceof Short) {\n            return ((Short) v).doubleValue();\n        } else if (v instanceof Byte) {\n            return ((Byte) v).doubleValue();\n        } else if (v instanceof BigDecimal) {\n            return ((BigDecimal) v).doubleValue();\n        } else if (v instanceof BigInteger) {\n            return ((BigInteger) v).doubleValue();\n        } else if (v instanceof Number) {\n            return ((Number) v).doubleValue();\n        } else if (v instanceof Boolean) {\n            return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n        } else if (v instanceof Character) {\n            return ((Character) v).charValue();\n        } else if (v instanceof String) {\n            return Double.parseDouble((String) v);\n        } else {\n            return 0.0;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n",
        "@Deprecated\npublic double getPct(Object v) {\n        if (v instanceof Double) {\n            return ((Double) v).doubleValue();\n        } else if (v instanceof Integer) {\n            return ((Integer) v).doubleValue();\n        } else if (v instanceof Long) {\n            return ((Long) v).doubleValue();\n        } else if (v instanceof Float) {\n            return ((Float) v).doubleValue();\n        } else if (v instanceof Short) {\n            return ((Short) v).doubleValue();\n        } else if (v instanceof Byte) {\n            return ((Byte) v).doubleValue();\n        } else if (v instanceof BigDecimal) {\n            return ((BigDecimal) v).doubleValue();\n        } else if (v instanceof BigInteger) {\n            return ((BigInteger) v).doubleValue();\n        } else if (v instanceof Number) {\n            return ((Number) v).doubleValue();\n        } else if (v instanceof Boolean) {\n            return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n        } else if (v instanceof Character) {\n            return ((Character) v).charValue();\n        } else if (v instanceof String) {\n            return Double.parseDouble((String) v);\n        } else {\n            return 0.0;\n        }\n    }\n\n    @Deprecated\n    public double getPct(Object v, double defaultValue) {\n        if (v instanceof Double) {\n            return ((Double) v).doubleValue();\n        } else if (v instanceof Integer) {\n            return ((Integer) v).doubleValue();\n        } else if (v instanceof Long) {\n            return ((Long) v).doubleValue();\n        } else if (v instanceof Float) {\n            return ((Float) v).doubleValue();\n        } else if (v instanceof Short) {\n            return ((Short) v).doubleValue();\n        } else if (v instanceof Byte) {\n            return ((Byte) v).doubleValue();\n        } else if (v instanceof BigDecimal) {\n            return ((BigDecimal) v).doubleValue();\n        } else",
        "@Deprecated\npublic double getPct(Object v) {\n        if (v instanceof Double) {\n            return ((Double) v).doubleValue();\n        } else if (v instanceof Integer) {\n            return ((Integer) v).doubleValue();\n        } else if (v instanceof Long) {\n            return ((Long) v).doubleValue();\n        } else if (v instanceof Float) {\n            return ((Float) v).doubleValue();\n        } else if (v instanceof Short) {\n            return ((Short) v).doubleValue();\n        } else if (v instanceof Byte) {\n            return ((Byte) v).doubleValue();\n        } else if (v instanceof BigDecimal) {\n            return ((BigDecimal) v).doubleValue();\n        } else if (v instanceof BigInteger) {\n            return ((BigInteger) v).doubleValue();\n        } else if (v instanceof Number) {\n            return ((Number) v).doubleValue();\n        } else if (v instanceof Boolean) {\n            return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n        } else if (v instanceof Character) {\n            return ((Character) v).charValue();\n        } else if (v instanceof String) {\n            return Double.parseDouble((String) v);\n        } else {\n            return 0.0;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and",
        "@Deprecated\npublic double getPct(Object v) {\n        if (v instanceof Double) {\n            return ((Double) v).doubleValue();\n        } else if (v instanceof Integer) {\n            return ((Integer) v).doubleValue();\n        } else if (v instanceof Long) {\n            return ((Long) v).doubleValue();\n        } else if (v instanceof Float) {\n            return ((Float) v).doubleValue();\n        } else if (v instanceof Short) {\n            return ((Short) v).doubleValue();\n        } else if (v instanceof Byte) {\n            return ((Byte) v).doubleValue();\n        } else if (v instanceof BigDecimal) {\n            return ((BigDecimal) v).doubleValue();\n        } else if (v instanceof BigInteger) {\n            return ((BigInteger) v).doubleValue();\n        } else if (v instanceof Number) {\n            return ((Number) v).doubleValue();\n        } else if (v instanceof Boolean) {\n            return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n        } else if (v instanceof Character) {\n            return ((Character) v).charValue();\n        } else if (v instanceof String) {\n            return Double.parseDouble((String) v);\n        } else {\n            return Double.parseDouble(v.toString());\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for",
        "@Deprecated\npublic double getPct(Object v) {\n        if (v instanceof Double) {\n            return ((Double) v).doubleValue();\n        } else if (v instanceof Integer) {\n            return ((Integer) v).doubleValue();\n        } else if (v instanceof Long) {\n            return ((Long) v).doubleValue();\n        } else if (v instanceof Float) {\n            return ((Float) v).doubleValue();\n        } else if (v instanceof Short) {\n            return ((Short) v).doubleValue();\n        } else if (v instanceof Byte) {\n            return ((Byte) v).doubleValue();\n        } else if (v instanceof BigDecimal) {\n            return ((BigDecimal) v).doubleValue();\n        } else if (v instanceof BigInteger) {\n            return ((BigInteger) v).doubleValue();\n        } else if (v instanceof Number) {\n            return ((Number) v).doubleValue();\n        } else if (v instanceof Boolean) {\n            return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n        } else if (v instanceof Character) {\n            return ((Character) v).charValue();\n        } else if (v instanceof String) {\n            return Double.parseDouble((String) v);\n        } else {\n            return 0.0;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.",
        "@Deprecated\npublic double getPct(Object v) {\n        if (v instanceof Double) {\n            return ((Double) v).doubleValue();\n        } else if (v instanceof Integer) {\n            return ((Integer) v).doubleValue();\n        } else if (v instanceof Long) {\n            return ((Long) v).doubleValue();\n        } else if (v instanceof Float) {\n            return ((Float) v).doubleValue();\n        } else if (v instanceof Short) {\n            return ((Short) v).doubleValue();\n        } else if (v instanceof Byte) {\n            return ((Byte) v).doubleValue();\n        } else if (v instanceof BigDecimal) {\n            return ((BigDecimal) v).doubleValue();\n        } else if (v instanceof BigInteger) {\n            return ((BigInteger) v).doubleValue();\n        } else if (v instanceof Number) {\n            return ((Number) v).doubleValue();\n        } else if (v instanceof Boolean) {\n            return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n        } else if (v instanceof Character) {\n            return ((Character) v).charValue();\n        } else if (v instanceof String) {\n            return Double.parseDouble((String) v);\n        } else {\n            return Double.parseDouble(v.toString());\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See",
        "@Deprecated\npublic double getPct(Object v) {\n        if (v instanceof Double) {\n            return ((Double) v).doubleValue();\n        } else if (v instanceof Integer) {\n            return ((Integer) v).doubleValue();\n        } else if (v instanceof Long) {\n            return ((Long) v).doubleValue();\n        } else if (v instanceof Float) {\n            return ((Float) v).doubleValue();\n        } else if (v instanceof Short) {\n            return ((Short) v).doubleValue();\n        } else if (v instanceof Byte) {\n            return ((Byte) v).doubleValue();\n        } else if (v instanceof BigDecimal) {\n            return ((BigDecimal) v).doubleValue();\n        } else if (v instanceof BigInteger) {\n            return ((BigInteger) v).doubleValue();\n        } else if (v instanceof Number) {\n            return ((Number) v).doubleValue();\n        } else if (v instanceof Boolean) {\n            return ((Boolean) v).booleanValue()? 1.0 : 0.0;\n        } else if (v instanceof Character) {\n            return ((Character) v).charValue();\n        } else if (v instanceof String) {\n            return Double.parseDouble((String) v);\n        } else {\n            return 0.0;\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing"
      ],
      "function range": "301,5-304,5"
    },
    "Math_80_/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java_1135-1136": {
      "loc": "1135-1136",
      "input": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {",
      "output": [
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[pingPong] = work[4 * (n - 1) + pingPong];\n      work[pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[pingPong + 4] = work[4 * (n - 1) + pingPong + 4];\n      work[pingPong + 5] = work[4 * (n - 1) + pingPong + 5];\n      work[pingPong + 6] = work[4 * (n - 1) + pingPong + 6];\n      work[pingPong + 7] = work[4 * (n - 1) + pingPong + 7];\n      work[pingPong + 8] = work[4 * (n - 1) + pingPong + 8];\n      work[pingPong + 9] = work[4 * (n - 1) + pingPong + 9];\n      work[pingPong + 10] = work[4 * (n - 1) + pingPong + 10];\n      work[pingPong + 11] = work[4 * (n - 1) + pingPong + 11];\n      work[pingPong + 12] = work[4 * (n - 1) + pingPong + 12];\n      work[pingPong + 13] = work[4 * (n - 1) + pingPong + 13];\n      work[pingPong + 14] = work[4 * (n - 1) + pingPong + 14];\n      work[pingPong + 15] = work[4 * (n - 1) + pingPong + 15];\n      work[pingPong + 16] = work[4 * (n - 1) + pingPong + 16];\n      work[pingPong + 17] =",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[pingPong] = work[4 * (n - 1) + pingPong];\n      work[pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[pingPong + 4] = work[4 * (n - 1) + pingPong + 4];\n      work[pingPong + 5] = work[4 * (n - 1) + pingPong + 5];\n      work[pingPong + 6] = work[4 * (n - 1) + pingPong + 6];\n      work[pingPong + 7] = work[4 * (n - 1) + pingPong + 7];\n      work[pingPong + 8] = work[4 * (n - 1) + pingPong + 8];\n      work[4 * (n - 1) + pingPong] = work[pingPong];\n      work[4 * (n - 1) + pingPong + 1] = work[pingPong + 1];\n      work[4 * (n - 1) + pingPong + 2] = work[pingPong + 2];\n      work[4 * (n - 1) + pingPong + 3] = work[pingPong + 3];\n      work[4 * (n - 1) + pingPong + 4] = work[pingPong + 4];\n      work[4 * (n - 1) + pingPong + 5] = work[pingPong + 5];\n      work[4 * (n - 1) + pingPong + 6] = work[pingPong + 6];\n      work[4 * (n - 1) + pingPong + 7] = work[pingPong + 7];\n      work[4 * (n - 1) + pingPong",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[pingPong] = work[4 * (n - 1) + pingPong];\n      work[pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[pingPong + 4] = work[4 * (n - 1) + pingPong + 4];\n      work[pingPong + 5] = work[4 * (n - 1) + pingPong + 5];\n      work[pingPong + 6] = work[4 * (n - 1) + pingPong + 6];\n      work[pingPong + 7] = work[4 * (n - 1) + pingPong + 7];\n      work[pingPong + 8] = work[4 * (n - 1) + pingPong + 8];\n      work[pingPong + 9] = work[4 * (n - 1) + pingPong + 9];\n      work[4 * (n - 1) + pingPong] = work[pingPong];\n      work[4 * (n - 1) + pingPong + 1] = work[pingPong + 1];\n      work[4 * (n - 1) + pingPong + 2] = work[pingPong + 2];\n      work[4 * (n - 1) + pingPong + 3] = work[pingPong + 3];\n      work[4 * (n - 1) + pingPong + 4] = work[pingPong + 4];\n      work[4 * (n - 1) + pingPong + 5] = work[pingPong + 5];\n      work[4 * (n - 1) + pingPong + 6] = work[pingPong + 6];\n      work[4 * (n - 1) + pingPong",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[pingPong] = work[4 * (n - 1) + pingPong];\n      work[pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[pingPong + 4] = work[4 * (n - 1) + pingPong + 4];\n      work[pingPong + 5] = work[4 * (n - 1) + pingPong + 5];\n      work[pingPong + 6] = work[4 * (n - 1) + pingPong + 6];\n      work[pingPong + 7] = work[4 * (n - 1) + pingPong + 7];\n      work[pingPong + 8] = work[4 * (n - 1) + pingPong + 8];\n      work[pingPong + 9] = work[4 * (n - 1) + pingPong + 9];\n      work[pingPong + 10] = work[4 * (n - 1) + pingPong + 10];\n      work[pingPong + 11] = work[4 * (n - 1) + pingPong + 11];\n      work[pingPong + 12] = work[4 * (n - 1) + pingPong + 12];\n      work[pingPong + 13] = work[4 * (n - 1) + pingPong + 13];\n      work[pingPong + 14] = work[4 * (n - 1) + pingPong + 14];\n      work[pingPong + 15] = work[4 * (n - 1) + pingPong + 15];\n      work[pingPong + 16] = work[4 * (n - 1) + pingPong + 16];\n      return true;\n    }\n    return",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[pingPong] = work[4 * (n - 1) + pingPong];\n      work[pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[pingPong + 4] = work[4 * (n - 1) + pingPong + 4];\n      work[pingPong + 5] = work[4 * (n - 1) + pingPong + 5];\n      work[pingPong + 6] = work[4 * (n - 1) + pingPong + 6];\n      work[pingPong + 7] = work[4 * (n - 1) + pingPong + 7];\n      work[pingPong + 8] = work[4 * (n - 1) + pingPong + 8];\n      work[pingPong + 9] = work[4 * (n - 1) + pingPong + 9];\n      work[pingPong + 10] = work[4 * (n - 1) + pingPong + 10];\n      work[pingPong + 11] = work[4 * (n - 1) + pingPong + 11];\n      work[pingPong + 12] = work[4 * (n - 1) + pingPong + 12];\n      work[pingPong + 13] = work[4 * (n - 1) + pingPong + 13];\n      work[pingPong + 14] = work[4 * (n - 1) + pingPong + 14];\n      work[pingPong + 15] = work[4 * (n - 1) + pingPong + 15];\n      work[4 * (n - 1) + pingPong] = work[pingPong];\n      work[4 * (n - 1) + pingPong",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[pingPong] = work[4 * (n - 1) + pingPong];\n      work[pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[pingPong + 4] = work[4 * (n - 1) + pingPong + 4];\n      work[pingPong + 5] = work[4 * (n - 1) + pingPong + 5];\n      work[pingPong + 6] = work[4 * (n - 1) + pingPong + 6];\n      work[pingPong + 7] = work[4 * (n - 1) + pingPong + 7];\n      work[pingPong + 8] = work[4 * (n - 1) + pingPong + 8];\n      work[pingPong + 9] = work[4 * (n - 1) + pingPong + 9];\n      work[pingPong + 10] = work[4 * (n - 1) + pingPong + 10];\n      work[pingPong + 11] = work[4 * (n - 1) + pingPong + 11];\n      work[pingPong + 12] = work[4 * (n - 1) + pingPong + 12];\n      work[pingPong + 13] = work[4 * (n - 1) + pingPong + 13];\n      work[pingPong + 14] = work[4 * (n - 1) + pingPong + 14];\n      work[pingPong + 15] = work[4 * (n - 1) + pingPong + 15];\n      work[pingPong + 16] = work[4 * (n - 1) + pingPong + 16];\n      return true;\n    } else {\n",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[pingPong] = work[4 * (n - 1) + pingPong];\n      work[pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[pingPong + 4] = work[4 * (n - 1) + pingPong + 4];\n      work[pingPong + 5] = work[4 * (n - 1) + pingPong + 5];\n      work[pingPong + 6] = work[4 * (n - 1) + pingPong + 6];\n      work[pingPong + 7] = work[4 * (n - 1) + pingPong + 7];\n      work[pingPong + 8] = work[4 * (n - 1) + pingPong + 8];\n      work[pingPong + 9] = work[4 * (n - 1) + pingPong + 9];\n      work[pingPong + 10] = work[4 * (n - 1) + pingPong + 10];\n      work[pingPong + 11] = work[4 * (n - 1) + pingPong + 11];\n      work[pingPong + 12] = work[4 * (n - 1) + pingPong + 12];\n      work[pingPong + 13] = work[4 * (n - 1) + pingPong + 13];\n      work[pingPong + 14] = work[4 * (n - 1) + pingPong + 14];\n      work[pingPong + 15] = work[4 * (n - 1) + pingPong + 15];\n      work[pingPong + 16] = work[4 * (n - 1) + pingPong + 16];\n      work[4 * (n - 1)",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[pingPong] = work[4 * (n - 1) + pingPong];\n      work[pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[pingPong + 4] = work[4 * (n - 1) + pingPong + 4];\n      work[pingPong + 5] = work[4 * (n - 1) + pingPong + 5];\n      work[pingPong + 6] = work[4 * (n - 1) + pingPong + 6];\n      work[pingPong + 7] = work[4 * (n - 1) + pingPong + 7];\n      work[pingPong + 8] = work[4 * (n - 1) + pingPong + 8];\n      work[pingPong + 9] = work[4 * (n - 1) + pingPong + 9];\n      work[pingPong + 10] = work[4 * (n - 1) + pingPong + 10];\n      work[pingPong + 11] = work[4 * (n - 1) + pingPong + 11];\n      work[pingPong + 12] = work[4 * (n - 1) + pingPong + 12];\n      work[pingPong + 13] = work[4 * (n - 1) + pingPong + 13];\n      work[pingPong + 14] = work[4 * (n - 1) + pingPong + 14];\n      work[pingPong + 15] = work[4 * (n - 1) + pingPong + 15];\n      work[pingPong + 16] = work[4 * (n - 1) + pingPong + 16];\n    }\n    return work[pingPong",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[pingPong] = work[4 * (n - 1) + pingPong];\n      work[pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[pingPong + 4] = work[4 * (n - 1) + pingPong + 4];\n      work[pingPong + 5] = work[4 * (n - 1) + pingPong + 5];\n      work[pingPong + 6] = work[4 * (n - 1) + pingPong + 6];\n      work[pingPong + 7] = work[4 * (n - 1) + pingPong + 7];\n      work[pingPong + 8] = work[4 * (n - 1) + pingPong + 8];\n      work[pingPong + 9] = work[4 * (n - 1) + pingPong + 9];\n      work[pingPong + 10] = work[4 * (n - 1) + pingPong + 10];\n      work[pingPong + 11] = work[4 * (n - 1) + pingPong + 11];\n      work[pingPong + 12] = work[4 * (n - 1) + pingPong + 12];\n      work[pingPong + 13] = work[4 * (n - 1) + pingPong + 13];\n      work[pingPong + 14] = work[4 * (n - 1) + pingPong + 14];\n      work[pingPong + 15] = work[4 * (n - 1) + pingPong + 15];\n      work[pingPong + 16] = work[4 * (n - 1) + pingPong + 16];\n    }\n    return true;\n  }",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n      work[pingPong] = work[4 * (n - 1) + pingPong];\n      work[pingPong + 1] = work[4 * (n - 1) + pingPong + 1];\n      work[pingPong + 2] = work[4 * (n - 1) + pingPong + 2];\n      work[pingPong + 3] = work[4 * (n - 1) + pingPong + 3];\n      work[pingPong + 4] = work[4 * (n - 1) + pingPong + 4];\n      work[pingPong + 5] = work[4 * (n - 1) + pingPong + 5];\n      work[pingPong + 6] = work[4 * (n - 1) + pingPong + 6];\n      work[pingPong + 7] = work[4 * (n - 1) + pingPong + 7];\n      work[pingPong + 8] = work[4 * (n - 1) + pingPong + 8];\n      work[pingPong + 9] = work[4 * (n - 1) + pingPong + 9];\n      work[pingPong + 10] = work[4 * (n - 1) + pingPong + 10];\n      work[pingPong + 11] = work[4 * (n - 1) + pingPong + 11];\n      work[pingPong + 12] = work[4 * (n - 1) + pingPong + 12];\n      work[pingPong + 13] = work[4 * (n - 1) + pingPong + 13];\n      work[pingPong + 14] = work[4 * (n - 1) + pingPong + 14];\n      work[pingPong + 15] = work[4 * (n - 1) + pingPong + 15];\n      work[pingPong + 16] = work[4 * (n - 1) + pingPong + 16];\n      pingPong += 17;\n      return"
      ],
      "function range": "1132,5-1147,5"
    },
    "Math_82_/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java_82-83": {
      "loc": "82-83",
      "input": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);",
      "output": [
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        final double ratio = rhs / entry;\n        if (ratio < minRatio) {\n            minRatio = ratio;\n            minRatioPos = i;\n        }\n    }\n    return minRatioPos;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.al",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        final double ratio = rhs / entry;\n        if (ratio < minRatio) {\n            minRatio = ratio;\n            minRatioPos = i;\n        }\n    }\n    return minRatioPos;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        final double ratio = rhs / entry;\n        if (ratio < minRatio) {\n            minRatio = ratio;\n            minRatioPos = i;\n        }\n    }\n    return minRatioPos;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        final double ratio = rhs / entry;\n        if (ratio < minRatio) {\n            minRatio = ratio;\n            minRatioPos = i;\n        }\n    }\n    return minRatioPos;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyr",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        final double ratio = rhs / entry;\n        if (ratio < minRatio) {\n            minRatio = ratio;\n            minRatioPos = i;\n        }\n    }\n    return minRatioPos;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        final double ratio = rhs / entry;\n        if (ratio < minRatio) {\n            minRatio = ratio;\n            minRatioPos = i;\n        }\n    }\n    return minRatioPos;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.alge",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        final double ratio = rhs / entry;\n        if (ratio < minRatio) {\n            minRatio = ratio;\n            minRatioPos = i;\n        }\n    }\n    return minRatioPos;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        final double ratio = rhs / entry;\n        if (ratio < minRatio) {\n            minRatio = ratio;\n            minRatioPos = i;\n        }\n    }\n    return minRatioPos;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.al",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        final double ratio = rhs / entry;\n        if (ratio < minRatio) {\n            minRatio = ratio;\n            minRatioPos = i;\n        }\n    }\n    return minRatioPos;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        final double ratio = rhs / entry;\n        if (ratio < minRatio) {\n            minRatio = ratio;\n            minRatioPos = i;\n        }\n    }\n    return minRatioPos;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra"
      ],
      "function range": "76,5-91,5"
    },
    "Math_85_/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java_198-199": {
      "loc": "198-199",
      "input": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));",
      "output": [
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (a >= lowerBound && b <= upperBound) {\n        return new double[] {a, b};\n    } else if (numIterations >= maximumIterations) {\n        throw new ConvergenceException(\n            \"maximum number of iterations reached: {0}\", maximumIterations);\n    } else {\n        throw new ConvergenceException(\n            \"function {0} not bounded in interval [{1}, {2}] within {3} iterations\",\n            function, lowerBound, upperBound, maximumIterations);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (a >= lowerBound && b <= upperBound) {\n        return new double[] {a, b};\n    } else if (numIterations >= maximumIterations) {\n        throw new ConvergenceException(\n            \"maximum number of iterations reached: {0}\", maximumIterations);\n    } else {\n        throw new ConvergenceException(\n            \"function {0} not bounded in interval [{1}, {2}] within maximum {3} iterations\",\n            function, lowerBound, upperBound, maximumIterations);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (a >= lowerBound && b <= upperBound) {\n        return new double[] {a, b};\n    } else if (numIterations >= maximumIterations) {\n        throw new ConvergenceException(\n            \"maximum number of iterations reached: {0}\", maximumIterations);\n    } else {\n        throw new ConvergenceException(\n            \"function {0} not bounded in interval [{1}, {2}] within {3} iterations\",\n            function, lowerBound, upperBound, maximumIterations);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (a >= lowerBound && b <= upperBound) {\n        return new double[] {a, b};\n    } else if (numIterations >= maximumIterations) {\n        throw new ConvergenceException(\n            \"maximum number of iterations reached: {0}\", maximumIterations);\n    } else {\n        throw new ConvergenceException(\n            \"function {0} not bounded in interval [{1}, {2}] within maximum {3} iterations\",\n            function, lowerBound, upperBound, maximumIterations);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (a >= lowerBound && b <= upperBound) {\n        return new double[] {a, b};\n    } else if (numIterations >= maximumIterations) {\n        throw new ConvergenceException(\n            \"maximum number of iterations reached: {0}\", maximumIterations);\n    } else {\n        throw new ConvergenceException(\n            \"function {0} not bounded in interval [{1}, {2}] within {3} iterations\",\n            function, lowerBound, upperBound, maximumIterations);\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (a >= lowerBound && b <= upperBound) {\n        return new double[] {a, b};\n    } else if (numIterations >= maximumIterations) {\n        throw new ConvergenceException(\n            \"maximum number of iterations reached: {0}\", maximumIterations);\n    } else {\n        throw new ConvergenceException(\n            \"function {0} not bounded in interval [{1}, {2}] within maximum {3} iterations\",\n            function, lowerBound, upperBound, maximumIterations);\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (a >= lowerBound && b <= upperBound) {\n        return new double[] {a, b};\n    } else if (numIterations >= maximumIterations) {\n        throw new ConvergenceException(\n            \"maximum number of iterations reached: {0}\", maximumIterations);\n    } else {\n        throw new ConvergenceException(\n            \"function {0} not bounded in interval [{1}, {2}] within {3} iterations\",\n            function, lowerBound, upperBound, maximumIterations);\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (a >= lowerBound && b <= upperBound) {\n        return new double[] {a, b};\n    } else if (numIterations >= maximumIterations) {\n        throw new ConvergenceException(\n            \"maximum number of iterations reached: {0}\", maximumIterations);\n    } else {\n        throw new ConvergenceException(\n            \"function {0} not bounded in interval [{1}, {2}] within maximum {3} iterations\",\n            function, lowerBound, upperBound, maximumIterations);\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n *",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (a >= lowerBound && b <= upperBound) {\n        return new double[] {a, b};\n    } else if (numIterations >= maximumIterations) {\n        throw new ConvergenceException(\n            \"maximum number of iterations reached: {0}\", maximumIterations);\n    } else {\n        throw new ConvergenceException(\n            \"function {0} not bounded in interval [{1}, {2}] within {3} iterations\",\n            function, lowerBound, upperBound, maximumIterations);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (a >= lowerBound && b <= upperBound) {\n        return new double[] {a, b};\n    } else if (numIterations >= maximumIterations) {\n        throw new ConvergenceException(\n            \"maximum number of iterations reached: {0}\", maximumIterations);\n    } else {\n        throw new ConvergenceException(\n            \"function {0} not bounded in interval [{1}, {2}] within maximum {3} iterations\",\n            function, lowerBound, upperBound, maximumIterations);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership."
      ],
      "function range": "165,5-208,5"
    },
    "Math_91_/src/java/org/apache/commons/math/fraction/Fraction.java_259-261": {
      "loc": "259-261",
      "input": "public int compareTo(Fraction object) {",
      "output": [
        "public int compareTo(Fraction object) {\n        return getNumerator() - object.getNumerator();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass()!= obj.getClass()) {\n            return false;\n        }\n        Fraction other = (Fraction) obj;\n        if (numerator!= other.numerator) {\n            return false;\n        }\n        if (denominator!= other.denominator) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + denominator;\n        result = prime * result + numerator;\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Fraction [numerator=\" + numerator + \", denominator=\" + denominator + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix",
        "public int compareTo(Fraction object) {\n        return getNumerator() - object.getNumerator();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass()!= obj.getClass()) {\n            return false;\n        }\n        Fraction other = (Fraction) obj;\n        if (numerator!= other.numerator) {\n            return false;\n        }\n        if (denominator!= other.denominator) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + denominator;\n        result = prime * result + numerator;\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Fraction [numerator=\" + numerator + \", denominator=\" + denominator + \"]\";\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.",
        "public int compareTo(Fraction object) {\n        return getNumerator() - object.getNumerator();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass()!= obj.getClass()) {\n            return false;\n        }\n        Fraction other = (Fraction) obj;\n        if (numerator!= other.numerator) {\n            return false;\n        }\n        if (denominator!= other.denominator) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + denominator;\n        result = prime * result + numerator;\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Fraction [numerator=\" + numerator + \", denominator=\" + denominator + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.aster",
        "public int compareTo(Fraction object) {\n        return getNumerator() - object.getNumerator();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass()!= obj.getClass()) {\n            return false;\n        }\n        Fraction other = (Fraction) obj;\n        if (numerator!= other.numerator) {\n            return false;\n        }\n        if (denominator!= other.denominator) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + denominator;\n        result = prime * result + numerator;\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Fraction [numerator=\" + numerator + \", denominator=\" + denominator + \"]\";\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix",
        "public int compareTo(Fraction object) {\n        return getNumerator() - object.getNumerator();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass()!= obj.getClass()) {\n            return false;\n        }\n        Fraction other = (Fraction) obj;\n        if (numerator!= other.numerator) {\n            return false;\n        }\n        if (denominator!= other.denominator) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + denominator;\n        result = prime * result + numerator;\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Fraction [numerator=\" + numerator + \", denominator=\" + denominator + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.aster",
        "public int compareTo(Fraction object) {\n        return getNumerator() - object.getNumerator();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass()!= obj.getClass()) {\n            return false;\n        }\n        Fraction other = (Fraction) obj;\n        if (numerator!= other.numerator) {\n            return false;\n        }\n        if (denominator!= other.denominator) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + denominator;\n        result = prime * result + numerator;\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Fraction [numerator=\" + numerator + \", denominator=\" + denominator + \"]\";\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix",
        "public int compareTo(Fraction object) {\n        return getNumerator() - object.getNumerator();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass()!= obj.getClass()) {\n            return false;\n        }\n        Fraction other = (Fraction) obj;\n        if (numerator!= other.numerator) {\n            return false;\n        }\n        if (denominator!= other.denominator) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + denominator;\n        result = prime * result + numerator;\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Fraction [numerator=\" + numerator + \", denominator=\" + denominator + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n",
        "public int compareTo(Fraction object) {\n        return getNumerator() - object.getNumerator();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass()!= obj.getClass()) {\n            return false;\n        }\n        Fraction other = (Fraction) obj;\n        if (numerator!= other.numerator) {\n            return false;\n        }\n        if (denominator!= other.denominator) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + denominator;\n        result = prime * result + numerator;\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Fraction [numerator=\" + numerator + \", denominator=\" + denominator + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions.records;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.",
        "public int compareTo(Fraction object) {\n        return getNumerator() - object.getNumerator();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass()!= obj.getClass()) {\n            return false;\n        }\n        Fraction other = (Fraction) obj;\n        if (numerator!= other.numerator) {\n            return false;\n        }\n        if (denominator!= other.denominator) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + denominator;\n        result = prime * result + numerator;\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Fraction [numerator=\" + numerator + \", denominator=\" + denominator + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\n\nimport org.apache.asterix.formats.nontagged.",
        "public int compareTo(Fraction object) {\n        return getNumerator() - object.getNumerator();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass()!= obj.getClass()) {\n            return false;\n        }\n        Fraction other = (Fraction) obj;\n        if (numerator!= other.numerator) {\n            return false;\n        }\n        if (denominator!= other.denominator) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + denominator;\n        result = prime * result + numerator;\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Fraction [numerator=\" + numerator + \", denominator=\" + denominator + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions.records;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.util"
      ],
      "function range": "258,5-262,5"
    },
    "Math_94_/src/java/org/apache/commons/math/util/MathUtils.java_412-413": {
      "loc": "412-413",
      "input": "public static int gcd(int u, int v) {",
      "output": [
        "public static int gcd(int u, int v) {\n        while (v!= 0) {\n            int t = v;\n            v = u % v;\n            u = t;\n        }\n        return u;\n    }\n\n    public static int lcm(int u, int v) {\n        return u / gcd(u, v) * v;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        for (int i = 0; i < n; i++) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n            System.out.println(gcd(u, v));\n            System.out.println(lcm(u, v));\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.",
        "public static int gcd(int u, int v) {\n        while (v!= 0) {\n            int t = v;\n            v = u % v;\n            u = t;\n        }\n        return u;\n    }\n\n    public static int lcm(int u, int v) {\n        return u / gcd(u, v) * v;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        for (int i = 0; i < n; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(gcd(a, b));\n            System.out.println(lcm(a, b));\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.",
        "public static int gcd(int u, int v) {\n        while (v!= 0) {\n            int t = v;\n            v = u % v;\n            u = t;\n        }\n        return u;\n    }\n\n    public static int lcm(int u, int v) {\n        return u / gcd(u, v) * v;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        for (int i = 0; i < n; i++) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n            System.out.println(gcd(u, v));\n            System.out.println(lcm(u, v));\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyr",
        "public static int gcd(int u, int v) {\n        while (v!= 0) {\n            int t = v;\n            v = u % v;\n            u = t;\n        }\n        return u;\n    }\n\n    public static int lcm(int u, int v) {\n        return u / gcd(u, v) * v;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        for (int i = 0; i < n; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(gcd(a, b));\n            System.out.println(lcm(a, b));\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyr",
        "public static int gcd(int u, int v) {\n        while (v!= 0) {\n            int t = v;\n            v = u % v;\n            u = t;\n        }\n        return u;\n    }\n\n    public static int lcm(int u, int v) {\n        return u / gcd(u, v) * v;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        for (int i = 0; i < n; i++) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n            System.out.println(gcd(u, v));\n            System.out.println(lcm(u, v));\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org",
        "public static int gcd(int u, int v) {\n        while (v!= 0) {\n            int t = v;\n            v = u % v;\n            u = t;\n        }\n        return u;\n    }\n\n    public static int lcm(int u, int v) {\n        return u / gcd(u, v) * v;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        for (int i = 0; i < n; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(gcd(a, b));\n            System.out.println(lcm(a, b));\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org",
        "public static int gcd(int u, int v) {\n        while (v!= 0) {\n            int t = v;\n            v = u % v;\n            u = t;\n        }\n        return u;\n    }\n\n    public static int lcm(int u, int v) {\n        return u / gcd(u, v) * v;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        for (int i = 0; i < n; i++) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n            System.out.println(gcd(u, v));\n            System.out.println(lcm(u, v));\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.Abstract",
        "public static int gcd(int u, int v) {\n        while (v!= 0) {\n            int t = v;\n            v = u % v;\n            u = t;\n        }\n        return u;\n    }\n\n    public static int lcm(int u, int v) {\n        return u / gcd(u, v) * v;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        for (int i = 0; i < n; i++) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n            System.out.println(gcd(u, v));\n            System.out.println(lcm(u, v));\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.",
        "public static int gcd(int u, int v) {\n        while (v!= 0) {\n            int t = v;\n            v = u % v;\n            u = t;\n        }\n        return u;\n    }\n\n    public static int lcm(int u, int v) {\n        return u / gcd(u, v) * v;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        for (int i = 0; i < n; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(gcd(a, b));\n            System.out.println(lcm(a, b));\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.Abstract",
        "public static int gcd(int u, int v) {\n        while (v!= 0) {\n            int t = v;\n            v = u % v;\n            u = t;\n        }\n        return u;\n    }\n\n    public static int lcm(int u, int v) {\n        return u / gcd(u, v) * v;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        for (int i = 0; i < n; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            System.out.println(gcd(a, b));\n            System.out.println(lcm(a, b));\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org."
      ],
      "function range": "411,5-460,5"
    },
    "Math_96_/src/java/org/apache/commons/math/complex/Complex.java_258-259": {
      "loc": "258-259",
      "input": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {",
      "output": [
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.getReal() == rhs.getReal() && this.getImaginary() == rhs.getImaginary();\n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.getReal() == rhs.getReal() && this.getImaginary() == rhs.getImaginary();\n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algeb",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.getReal() == rhs.getReal() && this.getImaginary() == rhs.getImaginary();\n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyr",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.getReal() == rhs.getReal() && this.getImaginary() == rhs.getImaginary();\n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.getReal() == rhs.getReal() && this.getImaginary() == rhs.getImaginary();\n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.alge",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.getReal() == rhs.getReal() && this.getImaginary() == rhs.getImaginary();\n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.getReal() == rhs.getReal() && this.getImaginary() == rhs.getImaginary();\n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.getReal() == rhs.getReal() && this.getImaginary() == rhs.getImaginary();\n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.getReal() == rhs.getReal() && this.getImaginary() == rhs.getImaginary();\n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = this.getReal() == rhs.getReal() && this.getImaginary() == rhs.getImaginary();\n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions"
      ],
      "function range": "245,5-267,5"
    },
    "Math_101_/src/java/org/apache/commons/math/complex/ComplexFormat.java_377-378": {
      "loc": "377-378",
      "input": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;",
      "output": [
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setErrorIndex(startIndex);\n        pos.setIndex(endIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setErrorIndex(startIndex);\n        pos.setIndex(endIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setErrorIndex(startIndex);\n        pos.setIndex(endIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setErrorIndex(startIndex);\n        pos.setIndex(endIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setErrorIndex(startIndex);\n        pos.setIndex(endIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n"
      ],
      "function range": "320,5-389,5"
    },
    "Math_105_/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java_264-265": {
      "loc": "264-265",
      "input": "public double getSumSquaredErrors() {",
      "output": [
        "public double getSumSquaredErrors() {\r\n\t\treturn sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic void setSumSquaredErrors(double sumSquaredErrors) {\r\n\t\tthis.sumSquaredErrors = sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic double getMeanAbsoluteError() {\r\n\t\treturn meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setMeanAbsoluteError(double meanAbsoluteError) {\r\n\t\tthis.meanAbsoluteError = meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getMeanRelativeError() {\r\n\t\treturn meanRelativeError;\r\n\t}\r\n\r\n\tpublic void setMeanRelativeError(double meanRelativeError) {\r\n\t\tthis.meanRelativeError = meanRelativeError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredError() {\r\n\t\treturn rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredError(double rootMeanSquaredError) {\r\n\t\tthis.rootMeanSquaredError = rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredAbsoluteError() {\r\n\t\treturn rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredAbsoluteError(double rootMeanSquaredAbsoluteError) {\r\n\t\tthis.rootMeanSquaredAbsoluteError = rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredRelativeError() {\r\n\t\treturn rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredRelativeError(double rootMeanSquaredRelativeError) {\r\n\t\tthis.rootMeanSquaredRelativeError = rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic double getRootSumSquaredErrors() {\r\n\t\treturn rootSumSquaredErrors;\r\n\t}\r\n\r\n\tpublic void setRootSumSquaredErrors(double rootSumSquared",
        "public double getSumSquaredErrors() {\r\n\t\treturn sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic void setSumSquaredErrors(double sumSquaredErrors) {\r\n\t\tthis.sumSquaredErrors = sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic double getMeanAbsoluteError() {\r\n\t\treturn meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setMeanAbsoluteError(double meanAbsoluteError) {\r\n\t\tthis.meanAbsoluteError = meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getMeanRelativeError() {\r\n\t\treturn meanRelativeError;\r\n\t}\r\n\r\n\tpublic void setMeanRelativeError(double meanRelativeError) {\r\n\t\tthis.meanRelativeError = meanRelativeError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredError() {\r\n\t\treturn rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredError(double rootMeanSquaredError) {\r\n\t\tthis.rootMeanSquaredError = rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredAbsoluteError() {\r\n\t\treturn rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredAbsoluteError(\r\n\t\t\tdouble rootMeanSquaredAbsoluteError) {\r\n\t\tthis.rootMeanSquaredAbsoluteError = rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredRelativeError() {\r\n\t\treturn rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredRelativeError(\r\n\t\t\tdouble rootMeanSquaredRelativeError) {\r\n\t\tthis.rootMeanSquaredRelativeError = rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic double getRootSumSquaredErrors() {\r\n\t\treturn rootSumSquaredErrors;\r\n\t}\r\n\r\n\tpublic void setRootSumSquaredErrors",
        "public double getSumSquaredErrors() {\r\n\t\treturn sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic void setSumSquaredErrors(double sumSquaredErrors) {\r\n\t\tthis.sumSquaredErrors = sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic double getMeanAbsoluteError() {\r\n\t\treturn meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setMeanAbsoluteError(double meanAbsoluteError) {\r\n\t\tthis.meanAbsoluteError = meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getMeanRelativeError() {\r\n\t\treturn meanRelativeError;\r\n\t}\r\n\r\n\tpublic void setMeanRelativeError(double meanRelativeError) {\r\n\t\tthis.meanRelativeError = meanRelativeError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredError() {\r\n\t\treturn rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredError(double rootMeanSquaredError) {\r\n\t\tthis.rootMeanSquaredError = rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredAbsoluteError() {\r\n\t\treturn rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredAbsoluteError(double rootMeanSquaredAbsoluteError) {\r\n\t\tthis.rootMeanSquaredAbsoluteError = rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredRelativeError() {\r\n\t\treturn rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredRelativeError(double rootMeanSquaredRelativeError) {\r\n\t\tthis.rootMeanSquaredRelativeError = rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic double getRMS() {\r\n\t\treturn rms;\r\n\t}\r\n\r\n\tpublic void setRMS(double rms) {\r\n\t\tthis.rms = rms;\r",
        "public double getSumSquaredErrors() {\r\n\t\treturn sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic void setSumSquaredErrors(double sumSquaredErrors) {\r\n\t\tthis.sumSquaredErrors = sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic double getMeanAbsoluteError() {\r\n\t\treturn meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setMeanAbsoluteError(double meanAbsoluteError) {\r\n\t\tthis.meanAbsoluteError = meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getMeanRelativeError() {\r\n\t\treturn meanRelativeError;\r\n\t}\r\n\r\n\tpublic void setMeanRelativeError(double meanRelativeError) {\r\n\t\tthis.meanRelativeError = meanRelativeError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredError() {\r\n\t\treturn rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredError(double rootMeanSquaredError) {\r\n\t\tthis.rootMeanSquaredError = rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredAbsoluteError() {\r\n\t\treturn rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredAbsoluteError(\r\n\t\t\tdouble rootMeanSquaredAbsoluteError) {\r\n\t\tthis.rootMeanSquaredAbsoluteError = rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredRelativeError() {\r\n\t\treturn rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredRelativeError(\r\n\t\t\tdouble rootMeanSquaredRelativeError) {\r\n\t\tthis.rootMeanSquaredRelativeError = rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic double getRMS() {\r\n\t\treturn rms;\r\n\t}\r\n\r\n\tpublic void setRMS(double rms) {\r\n\t\tthis.r",
        "public double getSumSquaredErrors() {\r\n\t\treturn sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic void setSumSquaredErrors(double sumSquaredErrors) {\r\n\t\tthis.sumSquaredErrors = sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic double getMeanAbsoluteError() {\r\n\t\treturn meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setMeanAbsoluteError(double meanAbsoluteError) {\r\n\t\tthis.meanAbsoluteError = meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getMeanRelativeError() {\r\n\t\treturn meanRelativeError;\r\n\t}\r\n\r\n\tpublic void setMeanRelativeError(double meanRelativeError) {\r\n\t\tthis.meanRelativeError = meanRelativeError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredError() {\r\n\t\treturn rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredError(double rootMeanSquaredError) {\r\n\t\tthis.rootMeanSquaredError = rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredAbsoluteError() {\r\n\t\treturn rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredAbsoluteError(\r\n\t\t\tdouble rootMeanSquaredAbsoluteError) {\r\n\t\tthis.rootMeanSquaredAbsoluteError = rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredRelativeError() {\r\n\t\treturn rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredRelativeError(\r\n\t\t\tdouble rootMeanSquaredRelativeError) {\r\n\t\tthis.rootMeanSquaredRelativeError = rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic double getRootRelativeSquaredError() {\r\n\t\treturn rootRelativeSquaredError;\r\n\t}\r\n\r\n\tpublic void setRootRelativeSquaredError",
        "public double getSumSquaredErrors() {\r\n\t\treturn sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic void setSumSquaredErrors(double sumSquaredErrors) {\r\n\t\tthis.sumSquaredErrors = sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic double getMeanAbsoluteError() {\r\n\t\treturn meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setMeanAbsoluteError(double meanAbsoluteError) {\r\n\t\tthis.meanAbsoluteError = meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getMeanRelativeError() {\r\n\t\treturn meanRelativeError;\r\n\t}\r\n\r\n\tpublic void setMeanRelativeError(double meanRelativeError) {\r\n\t\tthis.meanRelativeError = meanRelativeError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredError() {\r\n\t\treturn rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredError(double rootMeanSquaredError) {\r\n\t\tthis.rootMeanSquaredError = rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredAbsoluteError() {\r\n\t\treturn rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredAbsoluteError(\r\n\t\t\tdouble rootMeanSquaredAbsoluteError) {\r\n\t\tthis.rootMeanSquaredAbsoluteError = rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredRelativeError() {\r\n\t\treturn rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredRelativeError(\r\n\t\t\tdouble rootMeanSquaredRelativeError) {\r\n\t\tthis.rootMeanSquaredRelativeError = rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic double getRMS() {\r\n\t\treturn rMS;\r\n\t}\r\n\r\n\tpublic void setRMS(double rMS) {\r\n\t\tthis.r",
        "public double getSumSquaredErrors() {\r\n\t\treturn sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic void setSumSquaredErrors(double sumSquaredErrors) {\r\n\t\tthis.sumSquaredErrors = sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic double getMeanAbsoluteError() {\r\n\t\treturn meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setMeanAbsoluteError(double meanAbsoluteError) {\r\n\t\tthis.meanAbsoluteError = meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getMeanRelativeError() {\r\n\t\treturn meanRelativeError;\r\n\t}\r\n\r\n\tpublic void setMeanRelativeError(double meanRelativeError) {\r\n\t\tthis.meanRelativeError = meanRelativeError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredError() {\r\n\t\treturn rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredError(double rootMeanSquaredError) {\r\n\t\tthis.rootMeanSquaredError = rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredAbsoluteError() {\r\n\t\treturn rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredAbsoluteError(\r\n\t\t\tdouble rootMeanSquaredAbsoluteError) {\r\n\t\tthis.rootMeanSquaredAbsoluteError = rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredRelativeError() {\r\n\t\treturn rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredRelativeError(\r\n\t\t\tdouble rootMeanSquaredRelativeError) {\r\n\t\tthis.rootMeanSquaredRelativeError = rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n}\r\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n *",
        "public double getSumSquaredErrors() {\r\n\t\treturn sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic void setSumSquaredErrors(double sumSquaredErrors) {\r\n\t\tthis.sumSquaredErrors = sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic double getMeanAbsoluteError() {\r\n\t\treturn meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setMeanAbsoluteError(double meanAbsoluteError) {\r\n\t\tthis.meanAbsoluteError = meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getMeanRelativeError() {\r\n\t\treturn meanRelativeError;\r\n\t}\r\n\r\n\tpublic void setMeanRelativeError(double meanRelativeError) {\r\n\t\tthis.meanRelativeError = meanRelativeError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredError() {\r\n\t\treturn rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredError(double rootMeanSquaredError) {\r\n\t\tthis.rootMeanSquaredError = rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredAbsoluteError() {\r\n\t\treturn rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredAbsoluteError(double rootMeanSquaredAbsoluteError) {\r\n\t\tthis.rootMeanSquaredAbsoluteError = rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredRelativeError() {\r\n\t\treturn rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredRelativeError(double rootMeanSquaredRelativeError) {\r\n\t\tthis.rootMeanSquaredRelativeError = rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic double getRMS() {\r\n\t\treturn rms;\r\n\t}\r\n\r\n\tpublic void setRMS(double rMS) {\r\n\t\tthis.rms = rMS;\r",
        "public double getSumSquaredErrors() {\r\n\t\treturn sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic void setSumSquaredErrors(double sumSquaredErrors) {\r\n\t\tthis.sumSquaredErrors = sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic double getMeanAbsoluteError() {\r\n\t\treturn meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setMeanAbsoluteError(double meanAbsoluteError) {\r\n\t\tthis.meanAbsoluteError = meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getMeanRelativeError() {\r\n\t\treturn meanRelativeError;\r\n\t}\r\n\r\n\tpublic void setMeanRelativeError(double meanRelativeError) {\r\n\t\tthis.meanRelativeError = meanRelativeError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredError() {\r\n\t\treturn rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredError(double rootMeanSquaredError) {\r\n\t\tthis.rootMeanSquaredError = rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredAbsoluteError() {\r\n\t\treturn rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredAbsoluteError(\r\n\t\t\tdouble rootMeanSquaredAbsoluteError) {\r\n\t\tthis.rootMeanSquaredAbsoluteError = rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredRelativeError() {\r\n\t\treturn rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredRelativeError(\r\n\t\t\tdouble rootMeanSquaredRelativeError) {\r\n\t\tthis.rootMeanSquaredRelativeError = rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n}\r\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with",
        "public double getSumSquaredErrors() {\r\n\t\treturn sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic void setSumSquaredErrors(double sumSquaredErrors) {\r\n\t\tthis.sumSquaredErrors = sumSquaredErrors;\r\n\t}\r\n\r\n\tpublic double getMeanAbsoluteError() {\r\n\t\treturn meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setMeanAbsoluteError(double meanAbsoluteError) {\r\n\t\tthis.meanAbsoluteError = meanAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getMeanRelativeError() {\r\n\t\treturn meanRelativeError;\r\n\t}\r\n\r\n\tpublic void setMeanRelativeError(double meanRelativeError) {\r\n\t\tthis.meanRelativeError = meanRelativeError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredError() {\r\n\t\treturn rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredError(double rootMeanSquaredError) {\r\n\t\tthis.rootMeanSquaredError = rootMeanSquaredError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredAbsoluteError() {\r\n\t\treturn rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredAbsoluteError(\r\n\t\t\tdouble rootMeanSquaredAbsoluteError) {\r\n\t\tthis.rootMeanSquaredAbsoluteError = rootMeanSquaredAbsoluteError;\r\n\t}\r\n\r\n\tpublic double getRootMeanSquaredRelativeError() {\r\n\t\treturn rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic void setRootMeanSquaredRelativeError(\r\n\t\t\tdouble rootMeanSquaredRelativeError) {\r\n\t\tthis.rootMeanSquaredRelativeError = rootMeanSquaredRelativeError;\r\n\t}\r\n\r\n\tpublic double getRMS() {\r\n\t\treturn rms;\r\n\t}\r\n\r\n\tpublic void setRMS(double rMS) {\r\n\t\tthis.r"
      ],
      "function range": "263,5-265,5"
    },
    "Mockito_1_/src/org/mockito/internal/invocation/InvocationMatcher.java_123-124": {
      "loc": "123-124",
      "input": "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;",
      "output": [
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        Object vararg = invocation.getRawArguments()[indexOfVararg];\n        if (vararg instanceof Object[]) {\n            Object[] varargArray = (Object[]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                captureArgument(invocation, varargArray[i], i);\n            }\n        } else if (vararg instanceof Object[][]) {\n            Object[][] varargArray = (Object[][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    captureArgument(invocation, varargArray[i][j], i, j);\n                }\n            }\n        } else if (vararg instanceof Object[][][]) {\n            Object[][][] varargArray = (Object[][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        captureArgument(invocation, varargArray[i][j][k], i, j, k);\n                    }\n                }\n            }\n        } else if (vararg instanceof Object[][][][]) {\n            Object[][][][] varargArray = (Object[][][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        for (int l = 0; l < varargArray[i][j][k].length; l++) {\n                            captureArgument(inv",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        Object vararg = invocation.getRawArguments()[indexOfVararg];\n        if (vararg instanceof Object[]) {\n            Object[] varargArray = (Object[]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                captureArgument(invocation, varargArray[i], i);\n            }\n        } else if (vararg instanceof Object[][]) {\n            Object[][] varargArray = (Object[][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    captureArgument(invocation, varargArray[i][j], i * varargArray[i].length + j);\n                }\n            }\n        } else if (vararg instanceof Object[][][]) {\n            Object[][][] varargArray = (Object[][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        captureArgument(invocation, varargArray[i][j][k], i * varargArray[i].length * varargArray[i][j].length + j * varargArray[i][j].length + k);\n                    }\n                }\n            }\n        } else if (vararg instanceof Object[][][][]) {\n            Object[][][][] varargArray = (Object[][][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        Object vararg = invocation.getRawArguments()[indexOfVararg];\n        if (vararg instanceof Object[]) {\n            Object[] varargArray = (Object[]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                captureArgument(invocation, varargArray[i], i);\n            }\n        } else if (vararg instanceof Object[][]) {\n            Object[][] varargArray = (Object[][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    captureArgument(invocation, varargArray[i][j], i, j);\n                }\n            }\n        } else if (vararg instanceof Object[][][]) {\n            Object[][][] varargArray = (Object[][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        captureArgument(invocation, varargArray[i][j][k], i, j, k);\n                    }\n                }\n            }\n        } else if (vararg instanceof Object[][][][]) {\n            Object[][][][] varargArray = (Object[][][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        captureArgument(invocation, varargArray[i][j][k], i, j, k);\n                    }\n                }\n            ",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        Object vararg = invocation.getRawArguments()[indexOfVararg];\n        if (vararg instanceof Object[]) {\n            Object[] varargArray = (Object[]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                captureArgument(invocation, varargArray[i], i);\n            }\n        } else if (vararg instanceof Object[][]) {\n            Object[][] varargArray = (Object[][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    captureArgument(invocation, varargArray[i][j], i, j);\n                }\n            }\n        } else if (vararg instanceof Object[][][]) {\n            Object[][][] varargArray = (Object[][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        captureArgument(invocation, varargArray[i][j][k], i, j, k);\n                    }\n                }\n            }\n        } else if (vararg instanceof Object[][][][]) {\n            Object[][][][] varargArray = (Object[][][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        for (int m = 0; m < varargArray[i][j][k].length; m++) {\n                            captureArgument(inv",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        Object vararg = invocation.getRawArguments()[indexOfVararg];\n        if (vararg instanceof Object[]) {\n            Object[] varargArray = (Object[]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                captureArgument(invocation, varargArray[i], i);\n            }\n        } else if (vararg instanceof Object[][]) {\n            Object[][] varargArray = (Object[][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    captureArgument(invocation, varargArray[i][j], i, j);\n                }\n            }\n        } else if (vararg instanceof Object[][][]) {\n            Object[][][] varargArray = (Object[][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        captureArgument(invocation, varargArray[i][j][k], i, j, k);\n                    }\n                }\n            }\n        } else if (vararg instanceof Object[][][][]) {\n            Object[][][][] varargArray = (Object[][][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        for (int l = 0; l < varargArray[i][j][k].length; l++) {\n                            captureArgument(\n",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        Object vararg = invocation.getRawArguments()[indexOfVararg];\n        if (vararg instanceof Object[]) {\n            Object[] varargArray = (Object[]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                captureArgument(invocation, varargArray[i], i);\n            }\n        } else if (vararg instanceof Object[][]) {\n            Object[][] varargArray = (Object[][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    captureArgument(invocation, varargArray[i][j], i, j);\n                }\n            }\n        } else if (vararg instanceof Object[][][]) {\n            Object[][][] varargArray = (Object[][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        captureArgument(invocation, varargArray[i][j][k], i, j, k);\n                    }\n                }\n            }\n        } else if (vararg instanceof Object[][][][]) {\n            Object[][][][] varargArray = (Object[][][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        for (int l = 0; l < varargArray[i][j][k].length;\n                             l++) {\n                            captureArgument",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        Object vararg = invocation.getRawArguments()[indexOfVararg];\n        if (vararg instanceof Object[]) {\n            Object[] varargArray = (Object[]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                captureArgument(invocation, varargArray[i], i);\n            }\n        } else if (vararg instanceof Object[][]) {\n            Object[][] varargArray = (Object[][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    captureArgument(invocation, varargArray[i][j], i, j);\n                }\n            }\n        } else if (vararg instanceof Object[][][]) {\n            Object[][][] varargArray = (Object[][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        captureArgument(invocation, varargArray[i][j][k], i, j, k);\n                    }\n                }\n            }\n        } else if (vararg instanceof Object[][][][]) {\n            Object[][][][] varargArray = (Object[][][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        captureArgument(invocation, varargArray[i][j][k][0], i, j, k);\n                    }\n                }",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        Object vararg = invocation.getRawArguments()[indexOfVararg];\n        if (vararg instanceof Object[]) {\n            Object[] varargArray = (Object[]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                captureArgument(invocation, varargArray[i], i);\n            }\n        } else if (vararg instanceof Object[][]) {\n            Object[][] varargArray = (Object[][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    captureArgument(invocation, varargArray[i][j], i, j);\n                }\n            }\n        } else if (vararg instanceof Object[][][]) {\n            Object[][][] varargArray = (Object[][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        captureArgument(invocation, varargArray[i][j][k], i, j, k);\n                    }\n                }\n            }\n        } else if (vararg instanceof Object[][][][]) {\n            Object[][][][] varargArray = (Object[][][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        captureArgument(invocation, varargArray[i][j][k][0], i, j, k, 0);\n                    }\n",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        Object vararg = invocation.getRawArguments()[indexOfVararg];\n        if (vararg instanceof Object[]) {\n            Object[] varargArray = (Object[]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                captureArgument(invocation, varargArray[i], i);\n            }\n        } else if (vararg instanceof Object[][]) {\n            Object[][] varargArray = (Object[][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    captureArgument(invocation, varargArray[i][j], i, j);\n                }\n            }\n        } else if (vararg instanceof Object[][][]) {\n            Object[][][] varargArray = (Object[][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        captureArgument(invocation, varargArray[i][j][k], i, j, k);\n                    }\n                }\n            }\n        } else if (vararg instanceof Object[][][][]) {\n            Object[][][][] varargArray = (Object[][][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        for (int l = 0; l < varargArray[i][j][k].length; l++) {\n                            if (varargArray[",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        Object vararg = invocation.getRawArguments()[indexOfVararg];\n        if (vararg instanceof Object[]) {\n            Object[] varargArray = (Object[]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                captureArgument(invocation, varargArray[i], i);\n            }\n        } else if (vararg instanceof Object[][]) {\n            Object[][] varargArray = (Object[][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    captureArgument(invocation, varargArray[i][j], i, j);\n                }\n            }\n        } else if (vararg instanceof Object[][][]) {\n            Object[][][] varargArray = (Object[][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        captureArgument(invocation, varargArray[i][j][k], i, j, k);\n                    }\n                }\n            }\n        } else if (vararg instanceof Object[][][][]) {\n            Object[][][][] varargArray = (Object[][][][]) vararg;\n            for (int i = 0; i < varargArray.length; i++) {\n                for (int j = 0; j < varargArray[i].length; j++) {\n                    for (int k = 0; k < varargArray[i][j].length; k++) {\n                        for (int l = 0; l < varargArray[i][j][k].length;\n                            l++) {\n                            captureArgument"
      ],
      "function range": "120,5-150,5"
    },
    "Mockito_5_/src/org/mockito/internal/verification/VerificationOverTimeImpl.java_91-92": {
      "loc": "91-92",
      "input": "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }",
      "output": [
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (AssertionError e) {\n            error = handleAssertionError(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n}\n\nprivate AssertionError handleVerifyException(MockitoAssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\nprivate AssertionError handleAssertionError(AssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache.",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (AssertionError e) {\n            error = handleAssertionError(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n}\n\nprivate AssertionError handleVerifyException(MockitoAssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    return error;\n}\n\nprivate AssertionError handleAssertionError(AssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    return error;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (AssertionError e) {\n            error = handleAssertionError(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n}\n\nprivate AssertionError handleVerifyException(MockitoAssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    return error;\n}\n\nprivate AssertionError handleAssertionError(AssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    return error;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\n",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (AssertionError e) {\n            error = handleAssertionError(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n}\n\nprivate AssertionError handleVerifyException(MockitoAssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\nprivate AssertionError handleAssertionError(AssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jackrabbit.oak.spi.security.",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (AssertionError e) {\n            error = handleAssertionError(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n}\n\nprivate AssertionError handleVerifyException(MockitoAssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\nprivate AssertionError handleAssertionError(AssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (AssertionError e) {\n            error = handleAssertionError(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n}\n\nprivate AssertionError handleVerifyException(MockitoAssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\nprivate AssertionError handleAssertionError(AssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\n",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (AssertionError e) {\n            error = handleAssertionError(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n}\n\nprivate AssertionError handleVerifyException(MockitoAssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\nprivate AssertionError handleAssertionError(AssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.query.",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (AssertionError e) {\n            error = handleAssertionError(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n}\n\nprivate AssertionError handleVerifyException(MockitoAssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\nprivate AssertionError handleAssertionError(AssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.platform.",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (AssertionError e) {\n            error = handleAssertionError(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n}\n\nprivate AssertionError handleVerifyException(MockitoAssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\nprivate AssertionError handleAssertionError(AssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jackrabbit.oak.security.authorization.",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        } catch (AssertionError e) {\n            error = handleAssertionError(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n}\n\nprivate AssertionError handleVerifyException(MockitoAssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\nprivate AssertionError handleAssertionError(AssertionError e) {\n    AssertionError error = new AssertionError(e.getMessage());\n    error.setStackTrace(e.getStackTrace());\n    error.initCause(e);\n    return error;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jackrabbit.oak.plugins.document.rd"
      ],
      "function range": "75,5-99,5"
    },
    "Mockito_7_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_379-380": {
      "loc": "379-380",
      "input": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }",
      "output": [
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn(((GenericArrayType) type).getGenericComponentType());\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn(((ParameterizedType) type).getActualTypeArguments());\n    } else if (type instanceof WildcardType) {\n      for (Type bound : ((WildcardType) type).getUpperBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n      for (Type bound : ((WildcardType) type).getLowerBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    } else if (type instanceof TypeVariable) {\n      for (Type bound : ((TypeVariable<?>) type).getBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescript",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn(((GenericArrayType) type).getGenericComponentType());\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn(((ParameterizedType) type).getActualTypeArguments());\n    } else if (type instanceof WildcardType) {\n      for (Type bound : ((WildcardType) type).getUpperBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n      for (Type bound : ((WildcardType) type).getLowerBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    } else if (type instanceof TypeVariable) {\n      for (Type bound : ((TypeVariable<?>) type).getBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDesc",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn(((GenericArrayType) type).getGenericComponentType());\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn(((ParameterizedType) type).getActualTypeArguments());\n    } else if (type instanceof WildcardType) {\n      for (Type bound : ((WildcardType) type).getUpperBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n      for (Type bound : ((WildcardType) type).getLowerBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    } else if (type instanceof TypeVariable) {\n      for (Type bound : ((TypeVariable<?>) type).getBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.dataflow.data.nontagged",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn(((GenericArrayType) type).getGenericComponentType());\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn(((ParameterizedType) type).getActualTypeArguments());\n    } else if (type instanceof WildcardType) {\n      for (Type bound : ((WildcardType) type).getUpperBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n      for (Type bound : ((WildcardType) type).getLowerBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    } else if (type instanceof TypeVariable) {\n      for (Type bound : ((TypeVariable<?>) type).getBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.h",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn(((GenericArrayType) type).getGenericComponentType());\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn(((ParameterizedType) type).getActualTypeArguments());\n    } else if (type instanceof WildcardType) {\n      for (Type bound : ((WildcardType) type).getUpperBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n      for (Type bound : ((WildcardType) type).getLowerBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    } else if (type instanceof TypeVariable) {\n      for (Type bound : ((TypeVariable<?>) type).getBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.common.annotations.MissingNullIn",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn(((GenericArrayType) type).getGenericComponentType());\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn(((ParameterizedType) type).getActualTypeArguments());\n    } else if (type instanceof WildcardType) {\n      for (Type bound : ((WildcardType) type).getUpperBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n      for (Type bound : ((WildcardType) type).getLowerBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    } else if (type instanceof TypeVariable) {\n      for (Type bound : ((TypeVariable<?>) type).getBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.formats.nontagged.A",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn(((GenericArrayType) type).getGenericComponentType());\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn(((ParameterizedType) type).getActualTypeArguments());\n    } else if (type instanceof WildcardType) {\n      for (Type bound : ((WildcardType) type).getUpperBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n      for (Type bound : ((WildcardType) type).getLowerBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    } else if (type instanceof TypeVariable) {\n      for (Type bound : ((TypeVariable<?>) type).getBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.om.functions.BuiltinFun",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn(((GenericArrayType) type).getGenericComponentType());\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn(((ParameterizedType) type).getActualTypeArguments());\n    } else if (type instanceof WildcardType) {\n      for (Type bound : ((WildcardType) type).getUpperBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n      for (Type bound : ((WildcardType) type).getLowerBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    } else if (type instanceof TypeVariable) {\n      for (Type bound : ((TypeVariable<?>) type).getBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.formats.nontagged.Serial",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn(((GenericArrayType) type).getGenericComponentType());\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn(((ParameterizedType) type).getActualTypeArguments());\n    } else if (type instanceof WildcardType) {\n      for (Type bound : ((WildcardType) type).getUpperBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n      for (Type bound : ((WildcardType) type).getLowerBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    } else if (type instanceof TypeVariable) {\n      for (Type bound : ((TypeVariable<?>) type).getBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheAtomicityMode;\n",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn(((GenericArrayType) type).getGenericComponentType());\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn(((ParameterizedType) type).getActualTypeArguments());\n    } else if (type instanceof WildcardType) {\n      for (Type bound : ((WildcardType) type).getUpperBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n      for (Type bound : ((WildcardType) type).getLowerBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    } else if (type instanceof TypeVariable) {\n      for (Type bound : ((TypeVariable<?>) type).getBounds()) {\n        registerTypeVariablesOn(bound);\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheMode;\nimport org."
      ],
      "function range": "375,9-380,9"
    },
    "Mockito_8_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_79-80": {
      "loc": "79-80",
      "input": "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));",
      "output": [
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else {\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else {\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.j",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else {\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.file.GenericFile;\nimport org.apache.",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else {\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache;\n\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.CacheAtomicityMode;\nimport org.apache.ignite.cache.CacheMode;\nimport org.apache.ignite.configuration.CacheConfiguration;\nimport org.apache.ignite.configuration.IgniteConfiguration;\nimport org.",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else {\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Exchange;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else {\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.file.GenericFileOperationFailedException;\nimport",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else {\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test the ftps component over SSL (implicit) with client authentication",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else {\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else {\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else {\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\n\nimport java.io.File;\n\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Producer;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.file.GenericFile;\nimport org.junit"
      ],
      "function range": "66,5-84,5"
    },
    "Mockito_22_/src/org/mockito/internal/matchers/Equality.java_13-14": {
      "loc": "13-14",
      "input": "public static boolean areEqual(Object o1, Object o2) {",
      "output": [
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            }\n            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            }\n            if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            }\n            if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            }\n            if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            }\n            if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            }\n            if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            }\n            if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            }\n            if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n        }\n        return false;\n    ",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n            }\n            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            }\n            if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            }\n            if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            }\n            if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            }\n            if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            }\n            if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            }\n            if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            }\n            if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n        }\n        return false;\n",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            } else if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            } else if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            } else if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            } else if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            } else if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            } else if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            } else if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            } else if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n        }\n        return false;\n    }\n}\n<|java",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            } else if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            } else if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            } else if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            } else if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            } else if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            } else if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            } else if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            } else if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            } else {\n                return o1.equals(o2);\n            }\n",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n            } else if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            } else if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            } else if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            } else if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            } else if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            } else if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            } else if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            } else if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n        }\n        return false;\n    }\n}\n<|",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n            } else if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            } else if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            } else if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            } else if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            } else if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            } else if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            } else if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            } else if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n        }\n        return false;\n    }\n\n    /**\n     *",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            } else if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            } else if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            } else if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            } else if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            } else if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            } else if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            } else if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            } else if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n        }\n        return false;\n    }\n\n}\n<|",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            } else if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            } else if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            } else if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            } else if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            } else if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            } else if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            } else if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            } else if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            } else if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            } else if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            } else if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            } else if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            } else if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            } else if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            } else if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            } else if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * \ufffd",
        "public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n            } else if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            } else if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            } else if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            } else if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            } else if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            } else if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            } else if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            } else if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n        }\n        return false;\n    }\n\n    public static boolean is"
      ],
      "function range": "12,5-20,5"
    },
    "Mockito_24_/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java_76-77": {
      "loc": "76-77",
      "input": "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {",
      "output": [
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", compareTo: \" + mock.compareTo(invocation.getArguments()[0]);\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", equals: \" + mock.equals(invocation.getArguments()[0]);\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            ",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isToStringMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.get",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    }\n    return null;\n  }",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else {\n        return null;\n",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isToStringMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else {\n        return invocation.call",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getM",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else {\n        Object mock = invocation",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else {\n        return invocation.get"
      ],
      "function range": "63,5-81,5"
    },
    "Mockito_27_/src/org/mockito/internal/util/MockUtil.java_64-66": {
      "loc": "64-66",
      "input": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);",
      "output": [
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.reset();\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> MockHandlerInterface<T> getMockHandler(T mock) {\n    return (MockHandlerInterface<T>) mockHandlers.get(mock);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> void putMockHandler(T mock, MockHandlerInterface<T> mockHandler) {\n    mockHandlers.put(mock, mockHandler);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.reset();\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> MockHandlerInterface<T> getMockHandler(T mock) {\n    return (MockHandlerInterface<T>) mockHandlers.get(mock);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> void putMockHandler(T mock, MockHandlerInterface<T> mockHandler) {\n    mockHandlers.put(mock, mockHandler);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.reset();\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> MockHandlerInterface<T> getMockHandler(T mock) {\n    return (MockHandlerInterface<T>) mockHandlers.get(mock);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> void putMockHandler(T mock, MockHandlerInterface<T> mockHandler) {\n    mockHandlers.put(mock, mockHandler);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvalu",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.reset();\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> MockHandlerInterface<T> getMockHandler(T mock) {\n    return (MockHandlerInterface<T>) mockHandlers.get(mock);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> void putMockHandler(T mock, MockHandlerInterface<T> mockHandler) {\n    mockHandlers.put(mock, mockHandler);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.reset();\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> MockHandlerInterface<T> getMockHandler(T mock) {\n    return (MockHandlerInterface<T>) mockHandlers.get(mock);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> void putMockHandler(T mock, MockHandlerInterface<T> mockHandler) {\n    mockHandlers.put(mock, mockHandler);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.reset();\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> MockHandlerInterface<T> getMockHandler(T mock) {\n    return (MockHandlerInterface<T>) mockHandlers.get(mock);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> void putMockHandler(T mock, MockHandlerInterface<T> mockHandler) {\n    mockHandlers.put(mock, mockHandler);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.reset();\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> MockHandlerInterface<T> getMockHandler(T mock) {\n    return (MockHandlerInterface<T>) mockHandlers.get(mock);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> void putMockHandler(T mock, MockHandlerInterface<T> mockHandler) {\n    mockHandlers.put(mock, mockHandler);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algeb",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.reset();\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> MockHandlerInterface<T> getMockHandler(T mock) {\n    return (MockHandlerInterface<T>) mockHandlers.get(mock);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> void putMockHandler(T mock, MockHandlerInterface<T> mockHandler) {\n    mockHandlers.put(mock, mockHandler);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarE",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.reset();\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> MockHandlerInterface<T> getMockHandler(T mock) {\n    return (MockHandlerInterface<T>) mockHandlers.get(mock);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> void putMockHandler(T mock, MockHandlerInterface<T> mockHandler) {\n    mockHandlers.put(mock, mockHandler);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.asterix.runtime.evalu",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler!= null) {\n      oldMockHandler.reset();\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> MockHandlerInterface<T> getMockHandler(T mock) {\n    return (MockHandlerInterface<T>) mockHandlers.get(mock);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private <T> void putMockHandler(T mock, MockHandlerInterface<T> mockHandler) {\n    mockHandlers.put(mock, mockHandler);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalar"
      ],
      "function range": "62,5-67,5"
    },
    "Mockito_28_/src/org/mockito/internal/configuration/DefaultInjectionEngine.java_93-94": {
      "loc": "93-94",
      "input": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {",
      "output": [
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      if(field.getType().isAssignableFrom(fieldInstance.getClass())) {\n        field.setAccessible(true);\n        try {\n          field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n        } catch (IllegalAccessException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      if(field.getType().isAssignableFrom(fieldInstance.getClass())) {\n        field.setAccessible(true);\n        try {\n          field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n        } catch (IllegalAccessException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\n",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      if(field.getType().isAssignableFrom(fieldInstance.getClass())) {\n        field.setAccessible(true);\n        try {\n          field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n        } catch (IllegalAccessException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      if(field.getType().isAssignableFrom(fieldInstance.getClass())) {\n        field.setAccessible(true);\n        try {\n          field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n        } catch (IllegalAccessException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;\nimport org.apache.h",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      if(field.getType().isAssignableFrom(fieldInstance.getClass())) {\n        field.setAccessible(true);\n        try {\n          field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n        } catch (IllegalAccessException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      if(field.getType().isAssignableFrom(fieldInstance.getClass())) {\n        field.setAccessible(true);\n        try {\n          field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n        } catch (IllegalAccessException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyr",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      if(field.getType().isAssignableFrom(fieldInstance.getClass())) {\n        field.setAccessible(true);\n        try {\n          field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n        } catch (IllegalAccessException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      if(field.getType().isAssignableFrom(fieldInstance.getClass())) {\n        field.setAccessible(true);\n        try {\n          field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n        } catch (IllegalAccessException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      if(field.getType().isAssignableFrom(fieldInstance.getClass())) {\n        field.setAccessible(true);\n        try {\n          field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n        } catch (IllegalAccessException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyr",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n      if(field.getType().isAssignableFrom(fieldInstance.getClass())) {\n        field.setAccessible(true);\n        try {\n          field.set(fieldInstance, mocks.remove(field.get(fieldInstance)));\n        } catch (IllegalAccessException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\n\npublic class Numeric"
      ],
      "function range": "91,5-95,5"
    },
    "Mockito_29_/src/org/mockito/internal/matchers/Same.java_29-30": {
      "loc": "29-30",
      "input": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);",
      "output": [
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass()!= obj.getClass()) {\n      return false;\n    }\n    if (!super.equals(obj)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass()!= obj.getClass()) {\n      return false;\n    }\n    if (!super.equals(obj)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.al",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass()!= obj.getClass()) {\n      return false;\n    }\n    if (!super.equals(obj)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algeb",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass()!= obj.getClass()) {\n      return false;\n    }\n    if (!super.equals(obj)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass()!= obj.getClass()) {\n      return false;\n    }\n    if (!super.equals(obj)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\n",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass()!= obj.getClass()) {\n      return false;\n    }\n    if (!super.equals(obj)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass()!= obj.getClass()) {\n      return false;\n    }\n    if (!super.equals(obj)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.al",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass()!= obj.getClass()) {\n      return false;\n    }\n    if (!super.equals(obj)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.ex",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass()!= obj.getClass()) {\n      return false;\n    }\n    if (!super.equals(obj)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.asterix.common.annotations.MissingNullInOutFunction;\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass()!= obj.getClass()) {\n      return false;\n    }\n    if (!super.equals(obj)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.evaluators.functions;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;\nimport org.apache.asterix.runtime.evaluators.common.G"
      ],
      "function range": "26,5-32,5"
    },
    "Mockito_34_/src/org/mockito/internal/invocation/InvocationMatcher.java_106-107": {
      "loc": "106-107",
      "input": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {",
      "output": [
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.serializable.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractSerializableAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAggregateEvaluatorFactory;\nimport org.apache.",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions.HyracksData",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.serializable.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractSerializableAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAggregateEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.serializable.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractSerializableAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAggregateEvaluatorFactory;\nimport org.apache",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends Abstract",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.serializable.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractSerializableAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAggregateEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\n\npublic class SerializableIntermediateSql",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      m.captureArgumentsFrom(i, k);\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.serializable.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractSerializableAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.ISerializedAggregateEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\n\npublic class SerializableLocalSqlSum"
      ],
      "function range": "103,5-111,5"
    },
    "Mockito_38_/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java_48-49": {
      "loc": "48-49",
      "input": "private boolean toStringEquals(Matcher m, Object arg) {",
      "output": [
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregateDescriptor extends AbstractAgg",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class LocalSumAggregateDescriptor extends AbstractAggregate",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class MaxAggregateDescriptor extends AbstractAggregateFunction",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.exceptions",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAggregateDescriptor extends Abstract",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlSumAggregateDescriptor extends AbstractAgg",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptor;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlSumAggregateDescriptor extends Abstract",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class SqlMinAggregate",
        "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.runtime.aggregates.std;\n\nimport org.apache.asterix.om.functions.BuiltinFunctions;\nimport org.apache.asterix.om.functions.IFunctionDescriptorFactory;\nimport org.apache.asterix.runtime.aggregates.base.AbstractAggregateFunctionDynamicDescriptor;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluator;\nimport org.apache.hyracks.algebricks.runtime.base.IAggregateEvaluatorFactory;\nimport org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;\nimport org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\n\npublic class GlobalSqlAvgAgg"
      ],
      "function range": "47,5-49,5"
    },
    "Time_4_/src/main/java/org/joda/time/Partial.java_464-465": {
      "loc": "464-465",
      "input": "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);",
      "output": [
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n        return this;\n    } else {\n        iTypes[index] = fieldType;\n        iValues[index] = value;\n        return this;\n    }\n  }\n\n  /**\n",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n    } else {\n        iTypes[index] = fieldType;\n        iValues[index] = value;\n    }\n    return this;\n  }\n\n  //-----------------------------------------------------------------------\n  /**\n",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n    } else {\n        iTypes[index] = fieldType;\n        iValues[index] = value;\n    }\n    return this;\n  }\n\n}\n<|java|",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n        return this;\n    } else {\n        iTypes[index] = fieldType;\n        iValues[index] = value;\n        return this;\n    }\n  }\n\n  //----------------------------------------------------------------",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n        return this;\n    } else {\n        iTypes[index] = fieldType;\n        iValues[index] = value;\n        return this;\n    }\n  }\n\n  public Partial",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n    } else {\n        iTypes[index] = fieldType;\n        iValues[index] = value;\n    }\n    return this;\n  }\n\n  //-----------------------------------------------------------------------\n  @Override",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n    } else {\n        iTypes[index] = fieldType;\n        iValues[index] = value;\n    }\n    return this;\n  }\n\n  /**\n   * Returns a copy",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n    } else {\n        iTypes[index] = fieldType;\n        iValues[index] = value;\n    }\n    return (Partial) this;\n}\n\n    /**\n     *",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n    } else {\n        iTypes[index] = fieldType;\n        iValues[index] = value;\n    }\n    return this;\n  }\n\n  /**\n   * Gets the field",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        iTypes = newTypes;\n        iValues = newValues;\n    } else {\n        iTypes[index] = fieldType;\n        iValues[index] = value;\n    }\n    return this;\n  }\n\n  /**\n   * Sets the field"
      ],
      "function range": "426,5-474,5"
    },
    "Time_15_/src/main/java/org/joda/time/field/FieldUtils.java_138-139": {
      "loc": "138-139",
      "input": "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:",
      "output": [
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n            return -val1;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 * 2;\n        case 3:\n            return val1 * 3;\n        case 4:\n            return val1 * 4;\n        case 5:\n            return val1 * 5;\n        case 6:\n            return val1 * 6;\n        case 7:\n            return val1 * 7;\n        case 8:\n            return val1 * 8;\n        case 9:\n            return val1 * 9;\n        case 10:\n            return val1 * 10;\n        case 11:\n            return val1 * 11;\n        case 12:\n            return val1 * 12;\n        case 13:\n            return val1 * 13;\n        case 14:\n            return val1 * 14;\n        case 15:\n            return val1 * 15;\n        case 16:\n            return val1 * 16;\n        case 17:\n            return val1 * 17;\n        case 18:\n            return val1 * 18;\n        case 19:\n            return val1 * 19;\n        case 20:\n            return val1 * 20;\n        case 21:\n            return val1 * 21;\n        case 22:\n            return val1 * 22;\n        case 23:\n            return val1 * 23;\n        case 24:\n            return val1 * 24;\n        case 25:\n            return val1 * 25;\n        case 26:\n            return val1 * 26;\n        case 27:\n            return val1 * 27;\n        case 28:\n            return val1 * 28;\n        case 29:\n            return val1 * 29;\n        case 30:\n            return val1 * 30;\n        case 31:\n            return val1 * 31;\n        case 32:\n            return val1 * 32;\n        case 33:\n            return val1 * 33;\n        case 34:\n            return val1 * 34;\n        case 35:\n            return val1 * 35;\n        case 36:\n            return val1 *",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n        case 0:\n            return val1;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        case 33:\n            return val1 << 32;\n        case 34:\n            return val1 << 33;\n        case 35:\n            return val1 << 34;\n        case 36:\n            return val1 << 35;\n        case 37",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 11:\n        case 12:\n        case 13:\n        case 14:\n        case 15:\n        case 16:\n        case 17:\n        case 18:\n        case 19:\n        case 20:\n        case 21:\n        case 22:\n        case 23:\n        case 24:\n        case 25:\n        case 26:\n        case 27:\n        case 28:\n        case 29:\n        case 30:\n        case 31:\n        case 32:\n        case 33:\n        case 34:\n        case 35:\n        case 36:\n        case 37:\n        case 38:\n        case 39:\n        case 40:\n        case 41:\n        case 42:\n        case 43:\n        case 44:\n        case 45:\n        case 46:\n        case 47:\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n        case 58:\n        case 59:\n        case 60:\n        case 61:\n        case 62:\n        case 63:\n        case 64:\n        case 65:\n        case 66:\n        case 67:\n        case 68:\n        case 69:\n        case 70:\n        case 71:\n        case 72:\n        case 73:\n        case 74:\n        case 75:\n        case 76:\n        case 77:\n        case 78:\n        case 79:\n        case 80:\n        case 81:\n        case 82:\n        case 83:\n        case 84:\n        case 85:\n        case 86:\n        case 87:\n        case 88:\n        case 89:\n        case 90:\n        case 91:\n        case 92:\n        case 93:\n        case 94:\n        case 95:\n",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n        case 0:\n            return val1;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 11;\n        case 12:\n            return val1 << 12;\n        case 13:\n            return val1 << 13;\n        case 14:\n            return val1 << 14;\n        case 15:\n            return val1 << 15;\n        case 16:\n            return val1 << 16;\n        case 17:\n            return val1 << 17;\n        case 18:\n            return val1 << 18;\n        case 19:\n            return val1 << 19;\n        case 20:\n            return val1 << 20;\n        case 21:\n            return val1 << 21;\n        case 22:\n            return val1 << 22;\n        case 23:\n            return val1 << 23;\n        case 24:\n            return val1 << 24;\n        case 25:\n            return val1 << 25;\n        case 26:\n            return val1 << 26;\n        case 27:\n            return val1 << 27;\n        case 28:\n            return val1 << 28;\n        case 29:\n            return val1 << 29;\n        case 30:\n            return val1 << 30;\n        case 31:\n            return val1 << 31;\n        case 32:\n            return val1 << 32;\n        case 33:\n            return val1 << 33;\n        case 34:\n            return val1 << 34;\n        case 35:\n            return val1 << 35;\n        case 36:\n            return val1 << 36;\n        case 37",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n        case 0:\n            return val1;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 4:\n            return val1 << 2;\n        case 8:\n            return val1 << 3;\n        case 16:\n            return val1 << 4;\n        case 32:\n            return val1 << 5;\n        case 64:\n            return val1 << 6;\n        case 128:\n            return val1 << 7;\n        case 256:\n            return val1 << 8;\n        case 512:\n            return val1 << 9;\n        case 1024:\n            return val1 << 10;\n        case 2048:\n            return val1 << 11;\n        case 4096:\n            return val1 << 12;\n        case 8192:\n            return val1 << 13;\n        case 16384:\n            return val1 << 14;\n        case 32768:\n            return val1 << 15;\n        case 65536:\n            return val1 << 16;\n        case 131072:\n            return val1 << 17;\n        case 262144:\n            return val1 << 18;\n        case 524288:\n            return val1 << 19;\n        case 1048576:\n            return val1 << 20;\n        case 2097152:\n            return val1 << 21;\n        case 4194304:\n            return val1 << 22;\n        case 8388608:\n            return val1 << 23;\n        case 16777216:\n            return val1 << 24;\n        case 33554432:\n            return val1 << 25;\n        case 67108864:\n            return val1 << 26;\n        case 134217728:\n            return val1 << 27;\n        case 268435456:\n            return val1 << 28;\n        case 536870912:\n            return val1 << 29;\n        case 1073741824:\n            return val1 << 30;\n        case 2147483648L:\n            return val1 << 31;\n        default:\n            throw new IllegalArgumentException(\"",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n        case 0:\n            return val1;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 4:\n            return val1 << 2;\n        case 8:\n            return val1 << 3;\n        case 16:\n            return val1 << 4;\n        case 32:\n            return val1 << 5;\n        case 64:\n            return val1 << 6;\n        case 128:\n            return val1 << 7;\n        case 256:\n            return val1 << 8;\n        case 512:\n            return val1 << 9;\n        case 1024:\n            return val1 << 10;\n        case 2048:\n            return val1 << 11;\n        case 4096:\n            return val1 << 12;\n        case 8192:\n            return val1 << 13;\n        case 16384:\n            return val1 << 14;\n        case 32768:\n            return val1 << 15;\n        case 65536:\n            return val1 << 16;\n        case 131072:\n            return val1 << 17;\n        case 262144:\n            return val1 << 18;\n        case 524288:\n            return val1 << 19;\n        case 1048576:\n            return val1 << 20;\n        case 2097152:\n            return val1 << 21;\n        case 4194304:\n            return val1 << 22;\n        case 8388608:\n            return val1 << 23;\n        case 16777216:\n            return val1 << 24;\n        case 33554432:\n            return val1 << 25;\n        case 67108864:\n            return val1 << 26;\n        case 134217728:\n            return val1 << 27;\n        case 268435456:\n            return val1 << 28;\n        case 536870912:\n            return val1 << 29;\n        case 1073741824:\n            return val1 << 30;\n        case 2147483648L:\n            return val1 << 31;\n        case 4294967296L:\n            return val",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n        case 0:\n            return val1;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 4:\n            return val1 << 2;\n        case 8:\n            return val1 << 3;\n        case 16:\n            return val1 << 4;\n        case 32:\n            return val1 << 5;\n        case 64:\n            return val1 << 6;\n        case 128:\n            return val1 << 7;\n        case 256:\n            return val1 << 8;\n        case 512:\n            return val1 << 9;\n        case 1024:\n            return val1 << 10;\n        case 2048:\n            return val1 << 11;\n        case 4096:\n            return val1 << 12;\n        case 8192:\n            return val1 << 13;\n        case 16384:\n            return val1 << 14;\n        case 32768:\n            return val1 << 15;\n        case 65536:\n            return val1 << 16;\n        case 131072:\n            return val1 << 17;\n        case 262144:\n            return val1 << 18;\n        case 524288:\n            return val1 << 19;\n        case 1048576:\n            return val1 << 20;\n        case 2097152:\n            return val1 << 21;\n        case 4194304:\n            return val1 << 22;\n        case 8388608:\n            return val1 << 23;\n        case 16777216:\n            return val1 << 24;\n        case 33554432:\n            return val1 << 25;\n        case 67108864:\n            return val1 << 26;\n        case 134217728:\n            return val1 << 27;\n        case 268435456:\n            return val1 << 28;\n        case 536870912:\n            return val1 << 29;\n        case 1073741824:\n            return val1 << 30;\n        case 2147483648UL:\n            return val1 << 31;\n        default:\n            throw new IllegalArgumentException(\"",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n        case 0:\n            return val1;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        case 33:\n            return val1 << 32;\n        case 34:\n            return val1 << 33;\n        case 35:\n            return val1 << 34;\n        case 36:\n            return val1 << 35;\n        default:",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n        case 0:\n            return val1;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 4:\n            return val1 << 2;\n        case 8:\n            return val1 << 3;\n        case 16:\n            return val1 << 4;\n        case 32:\n            return val1 << 5;\n        case 64:\n            return val1 << 6;\n        case 128:\n            return val1 << 7;\n        case 256:\n            return val1 << 8;\n        case 512:\n            return val1 << 9;\n        case 1024:\n            return val1 << 10;\n        case 2048:\n            return val1 << 11;\n        case 4096:\n            return val1 << 12;\n        case 8192:\n            return val1 << 13;\n        case 16384:\n            return val1 << 14;\n        case 32768:\n            return val1 << 15;\n        case 65536:\n            return val1 << 16;\n        case 131072:\n            return val1 << 17;\n        case 262144:\n            return val1 << 18;\n        case 524288:\n            return val1 << 19;\n        case 1048576:\n            return val1 << 20;\n        case 2097152:\n            return val1 << 21;\n        case 4194304:\n            return val1 << 22;\n        case 8388608:\n            return val1 << 23;\n        case 16777216:\n            return val1 << 24;\n        case 33554432:\n            return val1 << 25;\n        case 67108864:\n            return val1 << 26;\n        case 134217728:\n            return val1 << 27;\n        case 268435456:\n            return val1 << 28;\n        case 536870912:\n            return val1 << 29;\n        case 1073741824:\n            return val1 << 30;\n        case 2147483648UL:\n            return val1 << 31;\n        case 4294967296UL:\n            return val",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n        case 0:\n            return val1;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 4:\n            return val1 << 2;\n        case 8:\n            return val1 << 3;\n        case 16:\n            return val1 << 4;\n        case 32:\n            return val1 << 5;\n        case 64:\n            return val1 << 6;\n        case 128:\n            return val1 << 7;\n        case 256:\n            return val1 << 8;\n        case 512:\n            return val1 << 9;\n        case 1024:\n            return val1 << 10;\n        case 2048:\n            return val1 << 11;\n        case 4096:\n            return val1 << 12;\n        case 8192:\n            return val1 << 13;\n        case 16384:\n            return val1 << 14;\n        case 32768:\n            return val1 << 15;\n        case 65536:\n            return val1 << 16;\n        case 131072:\n            return val1 << 17;\n        case 262144:\n            return val1 << 18;\n        case 524288:\n            return val1 << 19;\n        case 1048576:\n            return val1 << 20;\n        case 2097152:\n            return val1 << 21;\n        case 4194304:\n            return val1 << 22;\n        case 8388608:\n            return val1 << 23;\n        case 16777216:\n            return val1 << 24;\n        case 33554432:\n            return val1 << 25;\n        case 67108864:\n            return val1 << 26;\n        case 134217728:\n            return val1 << 27;\n        case 268435456:\n            return val1 << 28;\n        case 536870912:\n            return val1 << 29;\n        case 1073741824:\n            return val1 << 30;\n        case 2147483648L:\n            return val1 << 31;\n        default:\n            throw new IllegalArgumentException("
      ],
      "function range": "135,5-149,5"
    },
    "Time_16_/src/main/java/org/joda/time/format/DateTimeFormatter.java_709-710": {
      "loc": "709-710",
      "input": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(",
      "output": [
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(text, position, chrono);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    int year = bucket.getYear();\n    int monthOfYear = bucket.getMonthOfYear();\n    int dayOfMonth = bucket.getDayOfMonth();\n    int hourOfDay = bucket.getHourOfDay();\n    int minuteOfHour = bucket.getMinuteOfHour();\n    int secondOfMinute = bucket.getSecondOfMinute();\n    int millisOfSecond = bucket.getMillisOfSecond();\n    if (newPos >= 0) {\n        instantLocal = chrono.year().set(instantLocal, year);\n        instantLocal = chrono.monthOfYear().set(instantLocal, monthOfYear);\n        instantLocal = chrono.dayOfMonth().set(instantLocal, dayOfMonth);\n        instantLocal = chrono.hourOfDay().set(instantLocal, hourOfDay);\n        instantLocal = chrono.minuteOfHour().set(instantLocal, minuteOfHour);\n        instantLocal = chrono.secondOfMinute().set(instantLocal, secondOfMinute);\n        instantLocal = chrono.millisOfSecond().set(instantLocal, millisOfSecond);\n        if (bucket.getTimeZone()!= null) {\n            instantLocal = bucket.getTimeZone().adjustInto(instantLocal);\n        }\n        instant.setMillis(instantLocal);\n    }\n    return newPos",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(text, position, chrono);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    int year = bucket.getYear();\n    int monthOfYear = bucket.getMonthOfYear();\n    int dayOfMonth = bucket.getDayOfMonth();\n    int hourOfDay = bucket.getHourOfDay();\n    int minuteOfHour = bucket.getMinuteOfHour();\n    int secondOfMinute = bucket.getSecondOfMinute();\n    int millisOfSecond = bucket.getMillisOfSecond();\n    if (newPos >= 0) {\n        instantLocal = chrono.year().set(instantLocal, year);\n        instantLocal = chrono.monthOfYear().set(instantLocal, monthOfYear);\n        instantLocal = chrono.dayOfMonth().set(instantLocal, dayOfMonth);\n        instantLocal = chrono.hourOfDay().set(instantLocal, hourOfDay);\n        instantLocal = chrono.minuteOfHour().set(instantLocal, minuteOfHour);\n        instantLocal = chrono.secondOfMinute().set(instantLocal, secondOfMinute);\n        instantLocal = chrono.millisOfSecond().set(instantLocal, millisOfSecond);\n        instantMillis = instantLocal - chrono.getZone().getOffset(instantMillis);\n        instant.setMillis(instantMillis);\n    }\n    return newPos;\n}\n\n\n}\n<|java|>",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(text, position, chrono);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    int year = bucket.getYear();\n    int monthOfYear = bucket.getMonthOfYear();\n    int dayOfMonth = bucket.getDayOfMonth();\n    int hourOfDay = bucket.getHourOfDay();\n    int minuteOfHour = bucket.getMinuteOfHour();\n    int secondOfMinute = bucket.getSecondOfMinute();\n    int millisOfSecond = bucket.getMillisOfSecond();\n    if (newPos >= 0) {\n        instantLocal = chrono.year().set(instantLocal, year);\n        instantLocal = chrono.monthOfYear().set(instantLocal, monthOfYear);\n        instantLocal = chrono.dayOfMonth().set(instantLocal, dayOfMonth);\n        instantLocal = chrono.hourOfDay().set(instantLocal, hourOfDay);\n        instantLocal = chrono.minuteOfHour().set(instantLocal, minuteOfHour);\n        instantLocal = chrono.secondOfMinute().set(instantLocal, secondOfMinute);\n        instantLocal = chrono.millisOfSecond().set(instantLocal, millisOfSecond);\n        instant.setMillis(instantLocal);\n    }\n    return newPos;\n}\n\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(text, position, chrono);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    int year = bucket.getYear();\n    int monthOfYear = bucket.getMonthOfYear();\n    int dayOfMonth = bucket.getDayOfMonth();\n    int hourOfDay = bucket.getHourOfDay();\n    int minuteOfHour = bucket.getMinuteOfHour();\n    int secondOfMinute = bucket.getSecondOfMinute();\n    int millisOfSecond = bucket.getMillisOfSecond();\n    if (newPos >= 0) {\n        instantLocal = chrono.year().set(instantLocal, year);\n        instantLocal = chrono.monthOfYear().set(instantLocal, monthOfYear);\n        instantLocal = chrono.dayOfMonth().set(instantLocal, dayOfMonth);\n        instantLocal = chrono.hourOfDay().set(instantLocal, hourOfDay);\n        instantLocal = chrono.minuteOfHour().set(instantLocal, minuteOfHour);\n        instantLocal = chrono.secondOfMinute().set(instantLocal, secondOfMinute);\n        instantLocal = chrono.millisOfSecond().set(instantLocal, millisOfSecond);\n        if (bucket.getTimeZone()!= null) {\n            instantLocal = bucket.getTimeZone().adjustInto(instantLocal);\n        }\n        instant.setMillis(instantLocal);\n        return newPos;\n    ",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(text, position, chrono);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    int year = bucket.getYear();\n    int monthOfYear = bucket.getMonthOfYear();\n    int dayOfMonth = bucket.getDayOfMonth();\n    int hourOfDay = bucket.getHourOfDay();\n    int minuteOfHour = bucket.getMinuteOfHour();\n    int secondOfMinute = bucket.getSecondOfMinute();\n    int millisOfSecond = bucket.getMillisOfSecond();\n    if (newPos >= 0) {\n        instantLocal = chrono.year().set(instantLocal, year);\n        instantLocal = chrono.monthOfYear().set(instantLocal, monthOfYear);\n        instantLocal = chrono.dayOfMonth().set(instantLocal, dayOfMonth);\n        instantLocal = chrono.hourOfDay().set(instantLocal, hourOfDay);\n        instantLocal = chrono.minuteOfHour().set(instantLocal, minuteOfHour);\n        instantLocal = chrono.secondOfMinute().set(instantLocal, secondOfMinute);\n        instantLocal = chrono.millisOfSecond().set(instantLocal, millisOfSecond);\n        instant.setMillis(instantLocal);\n    }\n    return newPos;\n}\n\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(text, position, chrono);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    int year = bucket.getYear();\n    int monthOfYear = bucket.getMonthOfYear();\n    int dayOfMonth = bucket.getDayOfMonth();\n    int hourOfDay = bucket.getHourOfDay();\n    int minuteOfHour = bucket.getMinuteOfHour();\n    int secondOfMinute = bucket.getSecondOfMinute();\n    int millisOfSecond = bucket.getMillisOfSecond();\n    if (newPos >= 0) {\n        instantLocal = chrono.year().set(instantLocal, year);\n        instantLocal = chrono.monthOfYear().set(instantLocal, monthOfYear);\n        instantLocal = chrono.dayOfMonth().set(instantLocal, dayOfMonth);\n        instantLocal = chrono.hourOfDay().set(instantLocal, hourOfDay);\n        instantLocal = chrono.minuteOfHour().set(instantLocal, minuteOfHour);\n        instantLocal = chrono.secondOfMinute().set(instantLocal, secondOfMinute);\n        instantLocal = chrono.millisOfSecond().set(instantLocal, millisOfSecond);\n        instantMillis = instantLocal - chrono.getZone().getOffset(instantMillis);\n        instant.setMillis(instantMillis);\n    }\n    return newPos;\n}\n\n}\n<|java|>",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(text, position, chrono);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    int year = bucket.getYear();\n    int monthOfYear = bucket.getMonthOfYear();\n    int dayOfMonth = bucket.getDayOfMonth();\n    int hourOfDay = bucket.getHourOfDay();\n    int minuteOfHour = bucket.getMinuteOfHour();\n    int secondOfMinute = bucket.getSecondOfMinute();\n    int millisOfSecond = bucket.getMillisOfSecond();\n    if (newPos >= 0) {\n        instantLocal = chrono.year().set(instantLocal, year);\n        instantLocal = chrono.monthOfYear().set(instantLocal, monthOfYear);\n        instantLocal = chrono.dayOfMonth().set(instantLocal, dayOfMonth);\n        instantLocal = chrono.hourOfDay().set(instantLocal, hourOfDay);\n        instantLocal = chrono.minuteOfHour().set(instantLocal, minuteOfHour);\n        instantLocal = chrono.secondOfMinute().set(instantLocal, secondOfMinute);\n        instantLocal = chrono.millisOfSecond().set(instantLocal, millisOfSecond);\n        instantMillis = instantLocal - chrono.getZone().getOffset(instantMillis);\n        instant.setMillis(instantMillis);\n        return newPos;\n    } else {\n        return newPos;\n    }\n",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(text, position, chrono);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    int year = bucket.getYear();\n    int monthOfYear = bucket.getMonthOfYear();\n    int dayOfMonth = bucket.getDayOfMonth();\n    int hourOfDay = bucket.getHourOfDay();\n    int minuteOfHour = bucket.getMinuteOfHour();\n    int secondOfMinute = bucket.getSecondOfMinute();\n    int millisOfSecond = bucket.getMillisOfSecond();\n    if (newPos >= 0) {\n        instantLocal = chrono.year().set(instantLocal, year);\n        instantLocal = chrono.monthOfYear().set(instantLocal, monthOfYear);\n        instantLocal = chrono.dayOfMonth().set(instantLocal, dayOfMonth);\n        instantLocal = chrono.hourOfDay().set(instantLocal, hourOfDay);\n        instantLocal = chrono.minuteOfHour().set(instantLocal, minuteOfHour);\n        instantLocal = chrono.secondOfMinute().set(instantLocal, secondOfMinute);\n        instantLocal = chrono.millisOfSecond().set(instantLocal, millisOfSecond);\n        instant.setMillis(instantLocal);\n        return newPos;\n    } else {\n        return newPos;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(text, position, chrono);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    int year = bucket.getYear();\n    int monthOfYear = bucket.getMonthOfYear();\n    int dayOfMonth = bucket.getDayOfMonth();\n    int hourOfDay = bucket.getHourOfDay();\n    int minuteOfHour = bucket.getMinuteOfHour();\n    int secondOfMinute = bucket.getSecondOfMinute();\n    int millisOfSecond = bucket.getMillisOfSecond();\n    if (newPos >= 0) {\n        instantLocal = chrono.year().set(instantLocal, year);\n        instantLocal = chrono.monthOfYear().set(instantLocal, monthOfYear);\n        instantLocal = chrono.dayOfMonth().set(instantLocal, dayOfMonth);\n        instantLocal = chrono.hourOfDay().set(instantLocal, hourOfDay);\n        instantLocal = chrono.minuteOfHour().set(instantLocal, minuteOfHour);\n        instantLocal = chrono.secondOfMinute().set(instantLocal, secondOfMinute);\n        instantLocal = chrono.millisOfSecond().set(instantLocal, millisOfSecond);\n        instantMillis = instantLocal - chrono.getZone().getOffset(instantMillis);\n        instant.setMillis(instantMillis);\n        return newPos;\n    } else {\n        return -1;\n    }\n",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(text, position, chrono);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    int year = bucket.getYear();\n    int monthOfYear = bucket.getMonthOfYear();\n    int dayOfMonth = bucket.getDayOfMonth();\n    int hourOfDay = bucket.getHourOfDay();\n    int minuteOfHour = bucket.getMinuteOfHour();\n    int secondOfMinute = bucket.getSecondOfMinute();\n    int millisOfSecond = bucket.getMillisOfSecond();\n    if (newPos >= 0) {\n        instantLocal = chrono.year().set(instantLocal, year);\n        instantLocal = chrono.monthOfYear().set(instantLocal, monthOfYear);\n        instantLocal = chrono.dayOfMonth().set(instantLocal, dayOfMonth);\n        instantLocal = chrono.hourOfDay().set(instantLocal, hourOfDay);\n        instantLocal = chrono.minuteOfHour().set(instantLocal, minuteOfHour);\n        instantLocal = chrono.secondOfMinute().set(instantLocal, secondOfMinute);\n        instantLocal = chrono.millisOfSecond().set(instantLocal, millisOfSecond);\n        if (bucket.getTimeZone()!= null) {\n            instantLocal = bucket.getTimeZone().adjustInto(instantLocal);\n        }\n        instant.setMillis(instantLocal);\n    } else {\n        inst"
      ],
      "function range": "697,5-724,5"
    },
    "Time_19_/src/main/java/org/joda/time/DateTimeZone.java_900-901": {
      "loc": "900-901",
      "input": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal != offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }",
      "output": [
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else if ((offsetAdjusted - offsetLocal) < 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetAdjusted;\n            }\n        } else {\n            return offsetAdjusted;\n        }\n    } else {\n        return offsetLocal;\n    }\n    return getOffset(instantLocal);\n}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else if ((offsetAdjusted - offsetLocal) < 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetAdjusted;\n            }\n        } else {\n            return offsetAdjusted;\n        }\n    } else {\n        return offsetLocal;\n    }\n    return getOffset(instantLocal);\n}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     * \n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else if ((offsetAdjusted - offsetLocal) < 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetAdjusted;\n            }\n        } else {\n            return offsetAdjusted;\n        }\n    } else {\n        return offsetLocal;\n    }\n    return getOffset(instantLocal);\n}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant millis from 1970-01-01T00:00:00Z\n     * @return millis from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant millis from 1970-01-01T00:00:00Z\n     * @return millis from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else if ((offsetAdjusted - offsetLocal) < 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetAdjusted;\n            }\n        } else {\n            return offsetAdjusted;\n        }\n    } else {\n        return offsetLocal;\n    }\n    return getOffset(instantLocal);\n}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant millis from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant millis from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    //",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else if ((offsetAdjusted - offsetLocal) < 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetAdjusted;\n            }\n        } else {\n            return offsetAdjusted;\n        }\n    } else {\n        return offsetLocal;\n    }\n    return getOffset(instantLocal);\n}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant millis from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant millis from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    /**",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else if ((offsetAdjusted - offsetLocal) < 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetAdjusted;\n            }\n        } else {\n            return offsetAdjusted;\n        }\n    } else {\n        return offsetLocal;\n    }\n    return getOffset(instantLocal);\n}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in,\n     * then no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else if ((offsetAdjusted - offsetLocal) < 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetAdjusted;\n            }\n        } else {\n            return offsetAdjusted;\n        }\n    } else {\n        return offsetLocal;\n    }\n    return getOffset(instantLocal);\n}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long prevTransition(long instant",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else if ((offsetAdjusted - offsetLocal) < 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetAdjusted;\n            }\n        } else {\n            return offsetAdjusted;\n        }\n    } else {\n        return offsetLocal;\n    }\n    return getOffset(instantLocal);\n}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant the instant to advance\n     * @return the instant at the change\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant the instant to retreat\n     * @return the instant at the change\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else if ((offsetAdjusted - offsetLocal) < 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetAdjusted;\n            }\n        } else {\n            return offsetAdjusted;\n        }\n    } else {\n        return offsetLocal;\n    }\n    return getOffset(instantLocal);\n}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     * \n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long prevTransition(long",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        } else if ((offsetAdjusted - offsetLocal) < 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetAdjusted;\n            }\n        } else {\n            return offsetAdjusted;\n        }\n    } else {\n        return offsetLocal;\n    }\n    return getOffset(instantLocal);\n}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if this time zone has no transitions.\n     *\n     * @return true if no transitions\n     */\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant the instant to advance\n     * @return the instant at the change\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant the instant to retreat\n     * @return the instant at the change\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     *\n     * @return the closest"
      ],
      "function range": "880,5-911,5"
    }
  }
}