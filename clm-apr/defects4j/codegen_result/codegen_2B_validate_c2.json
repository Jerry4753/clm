{
  "config": "CODEGEN_COMPLETE_CODEFORM_COMMENTFORM_NOCOMMENT",
  "data": {
    "Chart_14_source/org/jfree/chart/plot/CategoryPlot.java_2166-2167": {
      "loc": "2166-2167",
      "input": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n// buggy line:    boolean removed = markers.remove(marker);",
      "function range": "2155,5-2171,5",
      "output": [
        {
          "patch": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_40_src/com/google/javascript/jscomp/NameAnalyzer.java_635-636": {
      "loc": "635-636",
      "input": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns != null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns != null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null && ns.onlyAffectsClassDef) {\n// buggy line:      JsName name = getName(ns.name, false);",
      "function range": "595,5-642,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(nameNode.getString(), false);\n      if (name!= null) {\n        recordSet(name.name, nameNode);\n      }\n    }\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(nameNode.getString(), false);\n      if (name!= null) {\n        recordSet(name.name, nameNode);\n      }\n    }\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n      JsName name = getName(nameNode.getString(), false);\n      if (name!= null) {\n        recordSet(name.name, nameNode);\n      }\n    }\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_46_src/com/google/javascript/rhino/jstype/RecordType.java_142-145": {
      "loc": "142-145",
      "input": "@Override\npublic JSType getLeastSupertype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getLeastSupertype(that);\n// buggy line:  }",
      "function range": "140,3-155,3",
      "output": [
        {
          "patch": "@Override\npublic JSType getLeastSupertype(JSType that) {\n  if (!that.isRecordType()) {\n    return super.getLeastSupertype(that);\n  }\n  RecordType rt1 = (RecordType) this;\n  RecordType rt2 = (RecordType) that;\n  RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n  for (String pname : rt1.getOwnPropertyNames()) {\n    builder.addProperty(pname, rt1.getPropertyType(pname), null);\n  }\n  for (String pname : rt2.getOwnPropertyNames()) {\n    if (!rt1.hasProperty(pname)) {\n      builder.addProperty(pname, rt2.getPropertyType(pname), null);\n    }\n  }\n  return builder.build();\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic JSType getLeastSupertype(JSType that) {\n  if (!that.isRecordType()) {\n    return super.getLeastSupertype(that);\n  }\n  RecordType rt1 = (RecordType) this;\n  RecordType rt2 = (RecordType) that;\n  RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n  for (String pname : rt1.getOwnPropertyNames()) {\n    builder.addProperty(pname, rt1.getPropertyType(pname), null);\n  }\n  for (String pname : rt2.getOwnPropertyNames()) {\n    if (!rt1.getOwnPropertyNames().contains(pname)) {\n      builder.addProperty(pname, rt2.getPropertyType(pname), null);\n    }\n  }\n  return builder.build();\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic JSType getLeastSupertype(JSType that) {\n  if (!that.isRecordType()) {\n    return super.getLeastSupertype(that);\n  }\n  RecordType rt1 = (RecordType) this;\n  RecordType rt2 = (RecordType) that;\n  RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n  for (String pname : rt1.getOwnPropertyNames()) {\n    builder.addProperty(pname, rt1.getPropertyType(pname), null);\n  }\n  for (String pname : rt2.getOwnPropertyNames()) {\n    if (!rt1.hasProperty(pname)) {\n      builder.addProperty(pname, rt2.getPropertyType(pname), null);\n    }\n  }\n  return builder.build();\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic JSType getLeastSupertype(JSType that) {\n  if (!that.isRecordType()) {\n    return super.getLeastSupertype(that);\n  }\n  RecordType rt1 = (RecordType) this;\n  RecordType rt2 = (RecordType) that;\n  RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n  for (String pname : rt1.getOwnPropertyNames()) {\n    builder.addProperty(pname, rt1.getPropertyType(pname), null);\n  }\n  for (String pname : rt2.getOwnPropertyNames()) {\n    if (!rt1.getOwnPropertyNames().contains(pname)) {\n      builder.addProperty(pname, rt2.getPropertyType(pname), null);\n    }\n  }\n  return builder.build();\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic JSType getLeastSupertype(JSType that) {\n  if (!that.isRecordType()) {\n    return super.getLeastSupertype(that);\n  }\n  RecordType rt1 = (RecordType) this;\n  RecordType rt2 = (RecordType) that;\n  RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n  for (String pname : rt1.getOwnPropertyNames()) {\n    if (!rt2.hasProperty(pname)) {\n      builder.addProperty(pname, rt1.getPropertyType(pname), null);\n    }\n  }\n  for (String pname : rt2.getOwnPropertyNames()) {\n    if (!rt1.hasProperty(pname)) {\n      builder.addProperty(pname, rt2.getPropertyType(pname), null);\n    }\n  }\n  return builder.build();\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic JSType getLeastSupertype(JSType that) {\n  if (!that.isRecordType()) {\n    return super.getLeastSupertype(that);\n  }\n  RecordType rt1 = (RecordType) this;\n  RecordType rt2 = (RecordType) that;\n  RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n  for (String pname : rt1.getOwnPropertyNames()) {\n    if (!rt2.hasProperty(pname)) {\n      builder.addProperty(pname, rt1.getPropertyType(pname), null);\n    }\n  }\n  for (String pname : rt2.getOwnPropertyNames()) {\n    if (!rt1.hasProperty(pname)) {\n      builder.addProperty(pname, rt2.getPropertyType(pname), null);\n    }\n  }\n  return builder.build();\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic JSType getLeastSupertype(JSType that) {\n  if (!that.isRecordType()) {\n    return super.getLeastSupertype(that);\n  }\n  RecordType rt1 = (RecordType) this;\n  RecordType rt2 = (RecordType) that;\n  RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n  for (String pname : rt1.getOwnPropertyNames()) {\n    builder.addProperty(pname, rt1.getPropertyType(pname), null);\n  }\n  for (String pname : rt2.getOwnPropertyNames()) {\n    if (!rt1.hasProperty(pname)) {\n      builder.addProperty(pname, rt2.getPropertyType(pname), null);\n    }\n  }\n  return builder.build();\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic JSType getLeastSupertype(JSType that) {\n  if (!that.isRecordType()) {\n    return super.getLeastSupertype(that);\n  }\n  RecordType rt1 = (RecordType) this;\n  RecordType rt2 = (RecordType) that;\n  RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n  for (String pname : rt1.getOwnPropertyNames()) {\n    builder.addProperty(pname, rt1.getPropertyType(pname), null);\n  }\n  for (String pname : rt2.getOwnPropertyNames()) {\n    if (!rt1.hasProperty(pname)) {\n      builder.addProperty(pname, rt2.getPropertyType(pname), null);\n    }\n  }\n  return builder.build();\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic JSType getLeastSupertype(JSType that) {\n  if (!that.isRecordType()) {\n    return super.getLeastSupertype(that);\n  }\n  RecordType rt1 = (RecordType) this;\n  RecordType rt2 = (RecordType) that;\n  RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n  for (String pname : rt1.getOwnPropertyNames()) {\n    builder.addProperty(pname, rt1.getPropertyType(pname), null);\n  }\n  for (String pname : rt2.getOwnPropertyNames()) {\n    if (!rt1.hasProperty(pname)) {\n      builder.addProperty(pname, rt2.getPropertyType(pname), null);\n    }\n  }\n  return builder.build();\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic JSType getLeastSupertype(JSType that) {\n  if (!that.isRecordType()) {\n    return super.getLeastSupertype(that);\n  }\n  RecordType rt1 = (RecordType) this;\n  RecordType rt2 = (RecordType) that;\n  RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n  for (String pname : rt1.getOwnPropertyNames()) {\n    builder.addProperty(pname, rt1.getPropertyType(pname), null);\n  }\n  for (String pname : rt2.getOwnPropertyNames()) {\n    if (!rt1.getOwnPropertyNames().contains(pname)) {\n      builder.addProperty(pname, rt2.getPropertyType(pname), null);\n    }\n  }\n  return builder.build();\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_77_src/com/google/javascript/jscomp/CodeGenerator.java_967-967": {
      "loc": "967-967",
      "input": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n// buggy line:      case '\\r': sb.append(\"\\\\r\"); break;",
      "function range": "956,3-1025,3",
      "output": [
        {
          "patch": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null) {\n          CharBuffer cb = outputCharsetEncoder.encode(Character.toString(c));\n          if (cb.hasArray()) {\n            sb.append(new String(cb.array(), cb.arrayOffset(), cb.length()));\n          } else {\n            sb.append(\"\\\\u\");\n            sb.append(Hex.encodeHex(cb.array(), cb.arrayOffset(), cb.length()));\n          }\n        } else {\n          sb.append(c);\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null) {\n          CharBuffer cb = outputCharsetEncoder.encode(Character.toString(c));\n          if (cb.hasArray()) {\n            sb.append(new String(cb.array(), cb.arrayOffset(), cb.length()));\n          } else {\n            sb.append(\"\\\\u\");\n            sb.append(Hex.encodeHex(cb.array(), cb.arrayOffset(), cb.length()));\n          }\n        } else {\n          sb.append(c);\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null) {\n          CharBuffer cb = outputCharsetEncoder.encode(Character.toString(c));\n          if (cb.hasArray()) {\n            sb.append(new String(cb.array(), cb.arrayOffset(), cb.length()));\n          } else {\n            sb.append(\"\\\\u\");\n            sb.append(Hex.encodeHex(cb.array(), cb.arrayOffset(), cb.length()));\n          }\n        } else {\n          sb.append(c);\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null) {\n          CharBuffer cb = outputCharsetEncoder.encode(Character.toString(c));\n          if (cb.hasArray()) {\n            sb.append(new String(cb.array(), cb.arrayOffset(), cb.length()));\n          } else {\n            sb.append(\"\\\\u\");\n            sb.append(Hex.encodeHex(cb.array(), cb.arrayOffset(), cb.length()));\n          }\n        } else {\n          sb.append(c);\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null) {\n          CharBuffer cb = outputCharsetEncoder.encode(Character.toString(c));\n          if (cb.hasArray()) {\n            sb.append(new String(cb.array(), cb.arrayOffset(), cb.length()));\n          } else {\n            sb.append(\"\\\\u\");\n            sb.append(Hex.encodeHex(cb.array(), cb.arrayOffset(), cb.length()));\n          }\n        } else {\n          sb.append(c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null) {\n          CharBuffer cb = outputCharsetEncoder.encode(Character.toString(c));\n          if (cb.hasArray()) {\n            sb.append(new String(cb.array(), cb.arrayOffset(), cb.length()));\n          } else {\n            sb.append(\"\\\\u\");\n            sb.append(Hex.encodeHex(cb.array(), cb.arrayOffset(), cb.length()));\n          }\n        } else {\n          sb.append(c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null) {\n          CharBuffer cb = outputCharsetEncoder.encode(Character.toString(c));\n          if (cb.hasArray()) {\n            sb.append(new String(cb.array(), cb.arrayOffset(), cb.length()));\n          } else {\n            sb.append(\"\\\\u\");\n            sb.append(Hex.encodeHex(cb.array(), cb.arrayOffset(), cb.length()));\n          }\n        } else {\n          sb.append(c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null) {\n          CharBuffer cb = outputCharsetEncoder.encode(Character.toString(c));\n          if (cb.hasArray()) {\n            sb.append(new String(cb.array(), cb.arrayOffset(), cb.length()));\n          } else {\n            sb.append(\"\\\\u\");\n            sb.append(Hex.encodeHex(cb.array(), cb.arrayOffset(), cb.length()));\n          }\n        } else {\n          sb.append(c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null) {\n          CharBuffer cb = outputCharsetEncoder.encode(Character.toString(c));\n          if (cb.hasArray()) {\n            sb.append(new String(cb.array(), cb.arrayOffset(), cb.length()));\n          } else {\n            sb.append(\"\\\\u\");\n            sb.append(Hex.encodeHex(cb.array(), cb.arrayOffset(), cb.length()));\n          }\n        } else {\n          sb.append(c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null) {\n          CharBuffer cb = outputCharsetEncoder.encode(Character.toString(c));\n          if (cb.hasArray()) {\n            sb.append(new String(cb.array(), cb.arrayOffset(), cb.length()));\n          } else {\n            sb.append(\"\\\\u\");\n            sb.append(Hex.encodeHex(cb.array(), cb.arrayOffset(), cb.length()));\n          }\n        } else {\n          sb.append(c);\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_119_src/com/google/javascript/jscomp/GlobalNamespace.java_366-366": {
      "loc": "366-366",
      "input": "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent != null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n// buggy line:          case Token.INC:",
      "function range": "306,5-430,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_10_src/main/java/org/apache/commons/lang3/time/FastDateParser.java_307-314": {
      "loc": "307-314",
      "input": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }",
      "function range": "303,5-343,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_38_src/java/org/apache/commons/lang3/time/FastDateFormat.java_872-872": {
      "loc": "872-872",
      "input": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n// buggy line:        calendar = (Calendar) calendar.clone();",
      "function range": "870,5-876,5",
      "output": [
        {
          "patch": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return super.format(calendar, buf);\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_65_src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java_258-259": {
      "loc": "258-259",
      "input": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n// buggy line:        chiSquare += residual * residual / residualsWeights[i];",
      "function range": "254,5-261,5",
      "output": [
        {
          "patch": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Math_79_src/main/java/org/apache/commons/math/util/MathUtils.java_1624-1625": {
      "loc": "1624-1625",
      "input": "public static double distance(int[] p1, int[] p2) {\n// buggy line:  int sum = 0;",
      "function range": "1623,5-1630,5",
      "output": [
        {
          "patch": "public static double distance(int[] p1, int[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += Math.pow(p1[i] - p2[i], 2);\n        }\n        return Math.sqrt(sum);\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static double distance(int[] p1, int[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += Math.pow(p1[i] - p2[i], 2);\n        }\n        return Math.sqrt(sum);\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static double distance(int[] p1, int[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += Math.pow(p1[i] - p2[i], 2);\n        }\n        return Math.sqrt(sum);\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static double distance(int[] p1, int[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += Math.pow(p1[i] - p2[i], 2);\n        }\n        return Math.sqrt(sum);\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static double distance(int[] p1, int[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += Math.pow(p1[i] - p2[i], 2);\n        }\n        return Math.sqrt(sum);\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "public static double distance(int[] p1, int[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += Math.pow(p1[i] - p2[i], 2);\n        }\n        return Math.sqrt(sum);\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "public static double distance(int[] p1, int[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += Math.pow(p1[i] - p2[i], 2);\n        }\n        return Math.sqrt(sum);\n    }",
          "correctness": "plausible"
        }
      ]
    },
    "Math_98_src/java/org/apache/commons/math/linear/BigMatrixImpl.java_991-992": {
      "loc": "991-992",
      "input": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length != this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];",
      "function range": "985,5-1000,5",
      "output": [
        {
          "patch": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        out[row] = sum;\n    }\n    return out;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        out[row] = sum;\n    }\n    return out;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        out[row] = sum;\n    }\n    return out;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        out[row] = sum;\n    }\n    return out;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        out[row] = sum;\n    }\n    return out;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        out[row] = sum;\n    }\n    return out;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        out[row] = sum;\n    }\n    return out;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        out[row] = sum;\n    }\n    return out;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        out[row] = sum;\n    }\n    return out;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = BigDecimal.ZERO;\n        for (int col = 0; col < nCols; col++) {\n            sum = sum.add(this.getEntry(row, col).multiply(v[col]));\n        }\n        out[row] = sum;\n    }\n    return out;\n  }",
          "correctness": "wrong"
        }
      ]
    },
    "Chart_1_/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java_1797-1798": {
      "loc": "1797-1798",
      "input": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n// buggy line:    if (dataset != null) {",
      "function range": "1790,5-1822,5",
      "output": [
        {
          "patch": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset!= null) {\n        int seriesCount = dataset.getRowCount();\n        int categoryCount = dataset.getColumnCount();\n        for (int series = 0; series < seriesCount; series++) {\n            for (int category = 0; category < categoryCount; category++) {\n                Paint paint = lookupSeriesPaint(series);\n                Stroke stroke = lookupSeriesStroke(series);\n                LegendItem item = new LegendItem(\n                    dataset.getRowKey(series).toString(),\n                    dataset.getColumnKey(category).toString(),\n                    null,\n                    null,\n                    paint,\n                    stroke\n                );\n                item.setDataset(dataset);\n                item.setSeriesKey(dataset.getRowKey(series));\n                item.setSeriesIndex(series);\n                item.setDataset(dataset);\n                item.setSeriesIndex(series);\n                item.setSeriesKey(dataset.getRowKey(series));\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset!= null) {\n        int seriesCount = dataset.getRowCount();\n        int categoryCount = dataset.getColumnCount();\n        for (int series = 0; series < seriesCount; series++) {\n            for (int category = 0; category < categoryCount; category++) {\n                Paint paint = lookupSeriesPaint(series);\n                Stroke stroke = lookupSeriesStroke(series);\n                LegendItem item = new LegendItem(\n                    dataset.getRowKey(series).toString(),\n                    dataset.getColumnKey(category).toString(),\n                    null,\n                    null,\n                    paint,\n                    stroke\n                );\n                item.setDataset(dataset);\n                item.setSeriesKey(dataset.getRowKey(series));\n                item.setSeriesIndex(series);\n                item.setDataset(dataset);\n                item.setSeriesIndex(series);\n                item.setSeriesKey(dataset.getRowKey(series));\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset!= null) {\n        int seriesCount = dataset.getRowCount();\n        int categoryCount = dataset.getColumnCount();\n        for (int series = 0; series < seriesCount; series++) {\n            for (int category = 0; category < categoryCount; category++) {\n                Paint paint = lookupSeriesPaint(series);\n                Stroke stroke = lookupSeriesStroke(series);\n                LegendItem item = new LegendItem(\n                    dataset.getRowKey(series).toString(),\n                    dataset.getColumnKey(category).toString(),\n                    null,\n                    null,\n                    paint,\n                    stroke\n                );\n                item.setDataset(dataset);\n                item.setSeriesKey(dataset.getRowKey(series));\n                item.setSeriesIndex(series);\n                item.setDataset(dataset);\n                item.setSeriesIndex(series);\n                item.setSeriesKey(dataset.getRowKey(series));\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset!= null) {\n        int seriesCount = dataset.getRowCount();\n        int categoryCount = dataset.getColumnCount();\n        for (int series = 0; series < seriesCount; series++) {\n            for (int category = 0; category < categoryCount; category++) {\n                Paint paint = lookupSeriesPaint(series);\n                Stroke stroke = lookupSeriesStroke(series);\n                LegendItem item = new LegendItem(\n                    dataset.getRowKey(series).toString(),\n                    dataset.getColumnKey(category).toString(),\n                    null,\n                    null,\n                    paint,\n                    stroke\n                );\n                item.setDataset(dataset);\n                item.setSeriesKey(dataset.getRowKey(series));\n                item.setSeriesIndex(series);\n                item.setDataset(dataset);\n                item.setSeriesIndex(series);\n                item.setSeriesKey(dataset.getRowKey(series));\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset!= null) {\n        int seriesCount = dataset.getRowCount();\n        int categoryCount = dataset.getColumnCount();\n        for (int series = 0; series < seriesCount; series++) {\n            for (int category = 0; category < categoryCount; category++) {\n                Paint paint = lookupSeriesPaint(series);\n                Stroke stroke = lookupSeriesStroke(series);\n                LegendItem item = new LegendItem(\n                    dataset.getRowKey(series).toString(),\n                    dataset.getColumnKey(category).toString(),\n                    null,\n                    null,\n                    paint,\n                    stroke\n                );\n                item.setDataset(dataset);\n                item.setSeriesKey(dataset.getRowKey(series));\n                item.setSeriesIndex(series);\n                item.setDataset(dataset);\n                item.setSeriesIndex(series);\n                item.setSeriesKey(dataset.getRowKey(series));\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset!= null) {\n        int seriesCount = dataset.getRowCount();\n        int categoryCount = dataset.getColumnCount();\n        for (int series = 0; series < seriesCount; series++) {\n            for (int category = 0; category < categoryCount; category++) {\n                Paint paint = lookupSeriesPaint(series);\n                Stroke stroke = lookupSeriesStroke(series);\n                LegendItem item = new LegendItem(\n                    dataset.getRowKey(series).toString(),\n                    dataset.getColumnKey(category).toString(),\n                    null,\n                    null,\n                    paint,\n                    stroke\n                );\n                item.setDataset(dataset);\n                item.setSeriesKey(dataset.getRowKey(series));\n                item.setSeriesIndex(series);\n                item.setDataset(dataset);\n                item.setSeriesIndex(series);\n                item.setSeriesKey(dataset.getRowKey(series));\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset!= null) {\n        int seriesCount = dataset.getRowCount();\n        int categoryCount = dataset.getColumnCount();\n        for (int series = 0; series < seriesCount; series++) {\n            for (int category = 0; category < categoryCount; category++) {\n                Paint paint = lookupSeriesPaint(series);\n                Stroke stroke = lookupSeriesStroke(series);\n                LegendItem item = new LegendItem(\n                    dataset.getRowKey(series).toString(),\n                    dataset.getColumnKey(category).toString(),\n                    null,\n                    null,\n                    paint,\n                    stroke\n                );\n                item.setDataset(dataset);\n                item.setSeriesKey(dataset.getRowKey(series));\n                item.setSeriesIndex(series);\n                item.setDataset(dataset);\n                item.setSeriesIndex(series);\n                item.setSeriesKey(dataset.getRowKey(series));\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset!= null) {\n        int seriesCount = dataset.getRowCount();\n        int categoryCount = dataset.getColumnCount();\n        for (int series = 0; series < seriesCount; series++) {\n            for (int category = 0; category < categoryCount; category++) {\n                Paint paint = lookupSeriesPaint(series);\n                Stroke stroke = lookupSeriesStroke(series);\n                LegendItem item = new LegendItem(\n                    dataset.getRowKey(series).toString(),\n                    dataset.getColumnKey(category).toString(),\n                    null,\n                    null,\n                    paint,\n                    stroke\n                );\n                item.setDataset(dataset);\n                item.setSeriesKey(dataset.getRowKey(series));\n                item.setSeriesIndex(series);\n                item.setDataset(dataset);\n                item.setSeriesIndex(series);\n                item.setSeriesKey(dataset.getRowKey(series));\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset!= null) {\n        int seriesCount = dataset.getRowCount();\n        int categoryCount = dataset.getColumnCount();\n        for (int series = 0; series < seriesCount; series++) {\n            for (int category = 0; category < categoryCount; category++) {\n                Paint paint = lookupSeriesPaint(series);\n                Stroke stroke = lookupSeriesStroke(series);\n                LegendItem item = new LegendItem(\n                    dataset.getRowKey(series).toString(),\n                    dataset.getColumnKey(category).toString(),\n                    null,\n                    null,\n                    paint,\n                    stroke\n                );\n                item.setDataset(dataset);\n                item.setSeriesKey(dataset.getRowKey(series));\n                item.setSeriesIndex(series);\n                item.setDataset(dataset);\n                item.setSeriesKey(dataset.getColumnKey(category));\n                item.setSeriesIndex(series);\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset!= null) {\n        int seriesCount = dataset.getRowCount();\n        int categoryCount = dataset.getColumnCount();\n        for (int series = 0; series < seriesCount; series++) {\n            for (int category = 0; category < categoryCount; category++) {\n                Paint paint = lookupSeriesPaint(series);\n                Stroke stroke = lookupSeriesStroke(series);\n                LegendItem item = new LegendItem(\n                    dataset.getRowKey(series).toString(),\n                    dataset.getColumnKey(category).toString(),\n                    null,\n                    null,\n                    paint,\n                    stroke\n                );\n                item.setDataset(dataset);\n                item.setSeriesKey(dataset.getRowKey(series));\n                item.setSeriesIndex(series);\n                item.setDataset(dataset);\n                item.setSeriesIndex(series);\n                item.setSeriesKey(dataset.getRowKey(series));\n                result.add(item);\n            }\n        }\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_3_/source/org/jfree/data/time/TimeSeries.java_1057-1058": {
      "loc": "1057-1058",
      "input": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n// buggy line:    copy.data = new java.util.ArrayList();",
      "function range": "1048,5-1072,5",
      "output": [
        {
          "patch": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new ArrayList<>(end - start);\n    for (int i = start; i < end; i++) {\n        copy.data.add(i, data.get(i));\n    }\n    return copy;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new ArrayList<>(end - start);\n    for (int i = start; i < end; i++) {\n        copy.data.add(i, this.data.get(i));\n    }\n    return copy;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new ArrayList<>(end - start);\n    for (int i = start; i < end; i++) {\n        copy.data.add(i, data.get(i));\n    }\n    return copy;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new ArrayList<>(end - start);\n    for (int i = start; i < end; i++) {\n        copy.data.add(i, this.data.get(i));\n    }\n    return copy;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new ArrayList<>(end - start);\n    for (int i = start; i < end; i++) {\n        copy.data.add(i, data.get(i));\n    }\n    return copy;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new ArrayList<>(end - start);\n    for (int i = start; i < end; i++) {\n        copy.data.add(i, data.get(i));\n    }\n    return copy;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new ArrayList<>(end - start);\n    for (int i = start; i < end; i++) {\n        copy.data.add(i, this.data.get(i));\n    }\n    return copy;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new ArrayList<>(end - start);\n    for (int i = start; i < end; i++) {\n        copy.data.add(i, this.data.get(i));\n    }\n    return copy;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new ArrayList<>(end - start);\n    for (int i = start; i < end; i++) {\n        copy.data.add(i, data.get(i));\n    }\n    return copy;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new ArrayList<>(end - start);\n    for (int i = start; i < end; i++) {\n        copy.data.add(i, data.get(i));\n    }\n    return copy;\n    }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_6_/source/org/jfree/chart/util/ShapeList.java_111-112": {
      "loc": "111-112",
      "input": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n// buggy line:    return super.equals(obj);",
      "function range": "103,5-113,5",
      "output": [
        {
          "patch": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Chart_8_/source/org/jfree/data/time/Week.java_175-176": {
      "loc": "175-176",
      "input": "public Week(Date time, TimeZone zone) {\n// buggy line:    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
      "function range": "173,5-176,5",
      "output": [
        {
          "patch": "public Week(Date time, TimeZone zone) {\n        this(time, zone, Locale.getDefault());\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Week(Date time, TimeZone zone) {\n        this(time, zone, Locale.getDefault());\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Week(Date time, TimeZone zone) {\n        this(time, zone, Locale.getDefault());\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Week(Date time, TimeZone zone) {\n        this(time, zone, Locale.getDefault());\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Week(Date time, TimeZone zone) {\n        this(time, zone, Locale.getDefault());\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Week(Date time, TimeZone zone) {\n        this(time, zone, Locale.getDefault());\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Week(Date time, TimeZone zone) {\n        this(time, zone, Locale.getDefault());\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Week(Date time, TimeZone zone) {\n        this(time, zone, Locale.getDefault());\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Week(Date time, TimeZone zone) {\n        this(time, zone, Locale.getDefault());\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Week(Date time, TimeZone zone) {\n        this(time, zone, Locale.getDefault());\n    }",
          "correctness": "plausible"
        }
      ]
    },
    "Chart_9_/source/org/jfree/data/time/TimeSeries.java_944-945": {
      "loc": "944-945",
      "input": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null 'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {",
      "function range": "918,5-956,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex >= this.data.size()) {\n        endIndex = this.data.size() - 1;\n        emptyRange = true;\n    }\n    TimeSeries clone = (TimeSeries) super.clone();\n    clone.data = new java.util.ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = startIndex; index <= endIndex; index++) {\n            TimeSeriesDataItem item \n                = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem cloneItem \n                = (TimeSeriesDataItem) item.clone();\n            clone.data.add(cloneItem);\n        }\n    }\n    else {\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        clone.data.add(new TimeSeriesDataItem(start, 0.0, Double.NaN));\n    }\n    return clone;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex >= this.data.size()) {\n        endIndex = this.data.size() - 1;\n        emptyRange = true;\n    }\n    TimeSeries clone = (TimeSeries) super.clone();\n    clone.data = new java.util.ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = startIndex; index <= endIndex; index++) {\n            TimeSeriesDataItem item \n                = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem cloneItem \n                = (TimeSeriesDataItem) item.clone();\n            clone.data.add(cloneItem);\n        }\n    }\n    else {\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        clone.data.add(new TimeSeriesDataItem(start, 0.0, Double.NaN));\n    }\n    return clone;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_10_/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java_65-66": {
      "loc": "65-66",
      "input": "public String generateToolTipFragment(String toolTipText) {\n// buggy line:    return \" title=\\\"\" + toolTipText",
      "function range": "64,5-67,5",
      "output": [
        {
          "patch": "public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Chart_11_/source/org/jfree/chart/util/ShapeUtilities.java_275-276": {
      "loc": "275-276",
      "input": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n// buggy line:    PathIterator iterator2 = p1.getPathIterator(null);",
      "function range": "264,5-296,5",
      "output": [
        {
          "patch": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        iterator1.currentSegment(coords1);\n        iterator2.currentSegment(coords2);\n        if (coords1.length!= coords2.length) {\n            return false;\n        }\n        for (int i = 0; i < coords1.length; i++) {\n            if (coords1[i]!= coords2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        iterator1.currentSegment(coords1);\n        iterator2.currentSegment(coords2);\n        if (coords1.length!= coords2.length) {\n            return false;\n        }\n        for (int i = 0; i < coords1.length; i++) {\n            if (coords1[i]!= coords2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        iterator1.currentSegment(coords1);\n        iterator2.currentSegment(coords2);\n        if (coords1.length!= coords2.length) {\n            return false;\n        }\n        for (int i = 0; i < coords1.length; i++) {\n            if (coords1[i]!= coords2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        iterator1.currentSegment(coords1);\n        iterator2.currentSegment(coords2);\n        if (coords1.length!= coords2.length) {\n            return false;\n        }\n        for (int i = 0; i < coords1.length; i++) {\n            if (coords1[i]!= coords2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        iterator1.currentSegment(coords1);\n        iterator2.currentSegment(coords2);\n        if (coords1.length!= coords2.length) {\n            return false;\n        }\n        for (int i = 0; i < coords1.length; i++) {\n            if (coords1[i]!= coords2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        iterator1.currentSegment(coords1);\n        iterator2.currentSegment(coords2);\n        if (coords1.length!= coords2.length) {\n            return false;\n        }\n        for (int i = 0; i < coords1.length; i++) {\n            if (coords1[i]!= coords2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        iterator1.currentSegment(coords1);\n        iterator2.currentSegment(coords2);\n        if (coords1.length!= coords2.length) {\n            return false;\n        }\n        for (int i = 0; i < coords1.length; i++) {\n            if (coords1[i]!= coords2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        iterator1.currentSegment(coords1);\n        iterator2.currentSegment(coords2);\n        if (coords1.length!= coords2.length) {\n            return false;\n        }\n        for (int i = 0; i < coords1.length; i++) {\n            if (coords1[i]!= coords2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        iterator1.currentSegment(coords1);\n        iterator2.currentSegment(coords2);\n        if (coords1.length!= coords2.length) {\n            return false;\n        }\n        for (int i = 0; i < coords1.length; i++) {\n            if (coords1[i]!= coords2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    float[] coords1 = new float[6];\n    float[] coords2 = new float[6];\n    while (!iterator1.isDone()) {\n        iterator1.currentSegment(coords1);\n        iterator2.currentSegment(coords2);\n        if (coords1.length!= coords2.length) {\n            return false;\n        }\n        for (int i = 0; i < coords1.length; i++) {\n            if (coords1[i]!= coords2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return true;\n}",
          "correctness": "plausible"
        }
      ]
    },
    "Chart_12_/source/org/jfree/chart/plot/MultiplePiePlot.java_145-146": {
      "loc": "145-146",
      "input": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n// buggy line:    this.dataset = dataset;",
      "function range": "143,5-158,5",
      "output": [
        {
          "patch": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = new PieDataset();\n    this.dataset.setUnderlyingDataset(dataset);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = new PieDataset();\n    this.dataset.setUnderlyingDataset(dataset);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = new PieDataset();\n    this.dataset.setUnderlyingDataset(dataset);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = new PieDataset();\n    this.dataset.setUnderlyingDataset(dataset);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = new PieDataset();\n    this.dataset.setUnderlyingDataset(dataset);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = new PieDataset();\n    this.dataset.setUnderlyingDataset(dataset);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = new PieDataset();\n    this.dataset.setUnderlyingDataset(dataset);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = new PieDataset();\n    this.dataset.setUnderlyingDataset(dataset);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = new PieDataset();\n    this.dataset.setUnderlyingDataset(dataset);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = new PieDataset();\n    this.dataset.setUnderlyingDataset(dataset);\n  }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_13_/source/org/jfree/chart/block/BorderArrangement.java_455-456": {
      "loc": "455-456",
      "input": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock != null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock != null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock != null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock != null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy line:                new Range(0.0, constraint.getWidth() - w[2]),",
      "function range": "422,5-489,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_17_/source/org/jfree/data/time/TimeSeries.java_857-858": {
      "loc": "857-858",
      "input": "public Object clone() throws CloneNotSupportedException {\n// buggy line:    Object clone = createCopy(0, getItemCount() - 1);",
      "function range": "856,5-859,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount());\n        for (int i = 0; i < getItemCount(); i++) {\n            clone.setValueAt(getValueAt(i), i, 0);\n            clone.setValueAt(getValueAt(i), i, 1);\n            clone.setValueAt(getValueAt(i), i, 2);\n            clone.setValueAt(getValueAt(i), i, 3);\n            clone.setValueAt(getValueAt(i), i, 4);\n            clone.setValueAt(getValueAt(i), i, 5);\n            clone.setValueAt(getValueAt(i), i, 6);\n            clone.setValueAt(getValueAt(i), i, 7);\n            clone.setValueAt(getValueAt(i), i, 8);\n            clone.setValueAt(getValueAt(i), i, 9);\n            clone.setValueAt(getValueAt(i), i, 10);\n            clone.setValueAt(getValueAt(i), i, 11);\n            clone.setValueAt(getValueAt(i), i, 12);\n            clone.setValueAt(getValueAt(i), i, 13);\n            clone.setValueAt(getValueAt(i), i, 14);\n            clone.setValueAt(getValueAt(i), i, 15);\n            clone.setValueAt(getValueAt(i), i, 16);\n            clone.setValueAt(getValueAt(i), i, 17);\n            clone.setValueAt(getValueAt(i), i, 18);\n            clone.setValueAt(getValueAt(i), i, 19);\n            clone.setValueAt(getValueAt(i), i, 20);\n            clone.setValueAt(getValueAt(i), i, 21);\n            clone.setValueAt(getValueAt(i), i, 22);\n            clone.setValueAt(getValueAt(i), i, 23);\n        }\n        return clone;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount());\n        for (int i = 0; i < getItemCount(); i++) {\n            clone.setValueAt(getValueAt(i), i, 0);\n            clone.setValueAt(getValueAt(i), i, 1);\n            clone.setValueAt(getValueAt(i), i, 2);\n            clone.setValueAt(getValueAt(i), i, 3);\n            clone.setValueAt(getValueAt(i), i, 4);\n            clone.setValueAt(getValueAt(i), i, 5);\n            clone.setValueAt(getValueAt(i), i, 6);\n            clone.setValueAt(getValueAt(i), i, 7);\n            clone.setValueAt(getValueAt(i), i, 8);\n            clone.setValueAt(getValueAt(i), i, 9);\n            clone.setValueAt(getValueAt(i), i, 10);\n            clone.setValueAt(getValueAt(i), i, 11);\n            clone.setValueAt(getValueAt(i), i, 12);\n            clone.setValueAt(getValueAt(i), i, 13);\n            clone.setValueAt(getValueAt(i), i, 14);\n            clone.setValueAt(getValueAt(i), i, 15);\n            clone.setValueAt(getValueAt(i), i, 16);\n            clone.setValueAt(getValueAt(i), i, 17);\n            clone.setValueAt(getValueAt(i), i, 18);\n            clone.setValueAt(getValueAt(i), i, 19);\n            clone.setValueAt(getValueAt(i), i, 20);\n            clone.setValueAt(getValueAt(i), i, 21);\n            clone.setValueAt(getValueAt(i), i, 22);\n            clone.setValueAt(getValueAt(i), i, 23);\n        }\n        return clone;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount());\n        for (int i = 0; i < getItemCount(); i++) {\n            clone.setValueAt(getValueAt(i), i, 0);\n            clone.setValueAt(getValueAt(i), i, 1);\n            clone.setValueAt(getValueAt(i), i, 2);\n            clone.setValueAt(getValueAt(i), i, 3);\n            clone.setValueAt(getValueAt(i), i, 4);\n            clone.setValueAt(getValueAt(i), i, 5);\n            clone.setValueAt(getValueAt(i), i, 6);\n            clone.setValueAt(getValueAt(i), i, 7);\n            clone.setValueAt(getValueAt(i), i, 8);\n            clone.setValueAt(getValueAt(i), i, 9);\n            clone.setValueAt(getValueAt(i), i, 10);\n            clone.setValueAt(getValueAt(i), i, 11);\n            clone.setValueAt(getValueAt(i), i, 12);\n            clone.setValueAt(getValueAt(i), i, 13);\n            clone.setValueAt(getValueAt(i), i, 14);\n            clone.setValueAt(getValueAt(i), i, 15);\n            clone.setValueAt(getValueAt(i), i, 16);\n            clone.setValueAt(getValueAt(i), i, 17);\n            clone.setValueAt(getValueAt(i), i, 18);\n            clone.setValueAt(getValueAt(i), i, 19);\n            clone.setValueAt(getValueAt(i), i, 20);\n            clone.setValueAt(getValueAt(i), i, 21);\n            clone.setValueAt(getValueAt(i), i, 22);\n            clone.setValueAt(getValueAt(i), i, 23);\n        }\n        return clone;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount());\n        for (int i = 0; i < getItemCount(); i++) {\n            clone.setValueAt(getValueAt(i), i, 0);\n            clone.setValueAt(getValueAt(i), i, 1);\n            clone.setValueAt(getValueAt(i), i, 2);\n            clone.setValueAt(getValueAt(i), i, 3);\n            clone.setValueAt(getValueAt(i), i, 4);\n            clone.setValueAt(getValueAt(i), i, 5);\n            clone.setValueAt(getValueAt(i), i, 6);\n            clone.setValueAt(getValueAt(i), i, 7);\n            clone.setValueAt(getValueAt(i), i, 8);\n            clone.setValueAt(getValueAt(i), i, 9);\n            clone.setValueAt(getValueAt(i), i, 10);\n            clone.setValueAt(getValueAt(i), i, 11);\n            clone.setValueAt(getValueAt(i), i, 12);\n            clone.setValueAt(getValueAt(i), i, 13);\n            clone.setValueAt(getValueAt(i), i, 14);\n            clone.setValueAt(getValueAt(i), i, 15);\n            clone.setValueAt(getValueAt(i), i, 16);\n            clone.setValueAt(getValueAt(i), i, 17);\n            clone.setValueAt(getValueAt(i), i, 18);\n            clone.setValueAt(getValueAt(i), i, 19);\n            clone.setValueAt(getValueAt(i), i, 20);\n            clone.setValueAt(getValueAt(i), i, 21);\n            clone.setValueAt(getValueAt(i), i, 22);\n            clone.setValueAt(getValueAt(i), i, 23);\n        }\n        return clone;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount());\n        for (int i = 0; i < getItemCount(); i++) {\n            clone.setValueAt(getValueAt(i), i, 0);\n            clone.setValueAt(getValueAt(i), i, 1);\n            clone.setValueAt(getValueAt(i), i, 2);\n            clone.setValueAt(getValueAt(i), i, 3);\n            clone.setValueAt(getValueAt(i), i, 4);\n            clone.setValueAt(getValueAt(i), i, 5);\n            clone.setValueAt(getValueAt(i), i, 6);\n            clone.setValueAt(getValueAt(i), i, 7);\n            clone.setValueAt(getValueAt(i), i, 8);\n            clone.setValueAt(getValueAt(i), i, 9);\n            clone.setValueAt(getValueAt(i), i, 10);\n            clone.setValueAt(getValueAt(i), i, 11);\n            clone.setValueAt(getValueAt(i), i, 12);\n            clone.setValueAt(getValueAt(i), i, 13);\n            clone.setValueAt(getValueAt(i), i, 14);\n            clone.setValueAt(getValueAt(i), i, 15);\n            clone.setValueAt(getValueAt(i), i, 16);\n            clone.setValueAt(getValueAt(i), i, 17);\n            clone.setValueAt(getValueAt(i), i, 18);\n            clone.setValueAt(getValueAt(i), i, 19);\n            clone.setValueAt(getValueAt(i), i, 20);\n            clone.setValueAt(getValueAt(i), i, 21);\n            clone.setValueAt(getValueAt(i), i, 22);\n            clone.setValueAt(getValueAt(i), i, 23);\n        }\n        return clone;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount());\n        for (int i = 0; i < getItemCount(); i++) {\n            clone.setValueAt(getValueAt(i), i, 0);\n            clone.setValueAt(getValueAt(i), i, 1);\n            clone.setValueAt(getValueAt(i), i, 2);\n            clone.setValueAt(getValueAt(i), i, 3);\n            clone.setValueAt(getValueAt(i), i, 4);\n            clone.setValueAt(getValueAt(i), i, 5);\n            clone.setValueAt(getValueAt(i), i, 6);\n            clone.setValueAt(getValueAt(i), i, 7);\n            clone.setValueAt(getValueAt(i), i, 8);\n            clone.setValueAt(getValueAt(i), i, 9);\n            clone.setValueAt(getValueAt(i), i, 10);\n            clone.setValueAt(getValueAt(i), i, 11);\n            clone.setValueAt(getValueAt(i), i, 12);\n            clone.setValueAt(getValueAt(i), i, 13);\n            clone.setValueAt(getValueAt(i), i, 14);\n            clone.setValueAt(getValueAt(i), i, 15);\n            clone.setValueAt(getValueAt(i), i, 16);\n            clone.setValueAt(getValueAt(i), i, 17);\n            clone.setValueAt(getValueAt(i), i, 18);\n            clone.setValueAt(getValueAt(i), i, 19);\n            clone.setValueAt(getValueAt(i), i, 20);\n            clone.setValueAt(getValueAt(i), i, 21);\n            clone.setValueAt(getValueAt(i), i, 22);\n            clone.setValueAt(getValueAt(i), i, 23);\n        }\n        return clone;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount());\n        for (int i = 0; i < getItemCount(); i++) {\n            clone.setValueAt(getValueAt(i), i, 0);\n            clone.setValueAt(getValueAt(i), i, 1);\n            clone.setValueAt(getValueAt(i), i, 2);\n            clone.setValueAt(getValueAt(i), i, 3);\n            clone.setValueAt(getValueAt(i), i, 4);\n            clone.setValueAt(getValueAt(i), i, 5);\n            clone.setValueAt(getValueAt(i), i, 6);\n            clone.setValueAt(getValueAt(i), i, 7);\n            clone.setValueAt(getValueAt(i), i, 8);\n            clone.setValueAt(getValueAt(i), i, 9);\n            clone.setValueAt(getValueAt(i), i, 10);\n            clone.setValueAt(getValueAt(i), i, 11);\n            clone.setValueAt(getValueAt(i), i, 12);\n            clone.setValueAt(getValueAt(i), i, 13);\n            clone.setValueAt(getValueAt(i), i, 14);\n            clone.setValueAt(getValueAt(i), i, 15);\n            clone.setValueAt(getValueAt(i), i, 16);\n            clone.setValueAt(getValueAt(i), i, 17);\n            clone.setValueAt(getValueAt(i), i, 18);\n            clone.setValueAt(getValueAt(i), i, 19);\n            clone.setValueAt(getValueAt(i), i, 20);\n            clone.setValueAt(getValueAt(i), i, 21);\n            clone.setValueAt(getValueAt(i), i, 22);\n            clone.setValueAt(getValueAt(i), i, 23);\n        }\n        return clone;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount());\n        for (int i = 0; i < getItemCount(); i++) {\n            clone.setValueAt(getValueAt(i), i, 0);\n            clone.setValueAt(getValueAt(i), i, 1);\n            clone.setValueAt(getValueAt(i), i, 2);\n            clone.setValueAt(getValueAt(i), i, 3);\n            clone.setValueAt(getValueAt(i), i, 4);\n            clone.setValueAt(getValueAt(i), i, 5);\n            clone.setValueAt(getValueAt(i), i, 6);\n            clone.setValueAt(getValueAt(i), i, 7);\n            clone.setValueAt(getValueAt(i), i, 8);\n            clone.setValueAt(getValueAt(i), i, 9);\n            clone.setValueAt(getValueAt(i), i, 10);\n            clone.setValueAt(getValueAt(i), i, 11);\n            clone.setValueAt(getValueAt(i), i, 12);\n            clone.setValueAt(getValueAt(i), i, 13);\n            clone.setValueAt(getValueAt(i), i, 14);\n            clone.setValueAt(getValueAt(i), i, 15);\n            clone.setValueAt(getValueAt(i), i, 16);\n            clone.setValueAt(getValueAt(i), i, 17);\n            clone.setValueAt(getValueAt(i), i, 18);\n            clone.setValueAt(getValueAt(i), i, 19);\n            clone.setValueAt(getValueAt(i), i, 20);\n            clone.setValueAt(getValueAt(i), i, 21);\n            clone.setValueAt(getValueAt(i), i, 22);\n            clone.setValueAt(getValueAt(i), i, 23);\n        }\n        return clone;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount());\n        for (int i = 0; i < getItemCount(); i++) {\n            clone.setValueAt(getValueAt(i), i, 0);\n            clone.setValueAt(getValueAt(i), i, 1);\n            clone.setValueAt(getValueAt(i), i, 2);\n            clone.setValueAt(getValueAt(i), i, 3);\n            clone.setValueAt(getValueAt(i), i, 4);\n            clone.setValueAt(getValueAt(i), i, 5);\n            clone.setValueAt(getValueAt(i), i, 6);\n            clone.setValueAt(getValueAt(i), i, 7);\n            clone.setValueAt(getValueAt(i), i, 8);\n            clone.setValueAt(getValueAt(i), i, 9);\n            clone.setValueAt(getValueAt(i), i, 10);\n            clone.setValueAt(getValueAt(i), i, 11);\n            clone.setValueAt(getValueAt(i), i, 12);\n            clone.setValueAt(getValueAt(i), i, 13);\n            clone.setValueAt(getValueAt(i), i, 14);\n            clone.setValueAt(getValueAt(i), i, 15);\n            clone.setValueAt(getValueAt(i), i, 16);\n            clone.setValueAt(getValueAt(i), i, 17);\n            clone.setValueAt(getValueAt(i), i, 18);\n            clone.setValueAt(getValueAt(i), i, 19);\n            clone.setValueAt(getValueAt(i), i, 20);\n            clone.setValueAt(getValueAt(i), i, 21);\n            clone.setValueAt(getValueAt(i), i, 22);\n            clone.setValueAt(getValueAt(i), i, 23);\n        }\n        return clone;\n    }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_20_/source/org/jfree/chart/plot/ValueMarker.java_95-96": {
      "loc": "95-96",
      "input": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n// buggy line:    super(paint, stroke, paint, stroke, alpha);",
      "function range": "93,5-97,5",
      "output": [
        {
          "patch": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_24_/source/org/jfree/chart/renderer/GrayPaintScale.java_126-127": {
      "loc": "126-127",
      "input": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n// buggy line:    int g = (int) ((value - this.lowerBound) / (this.upperBound ",
      "function range": "123,5-129,5",
      "output": [
        {
          "patch": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.gradient.length - 1));\n    return this.gradient[g];\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.gradient.length - 1));\n    return this.gradient[g];\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.gradient.length - 1));\n    return this.gradient[g];\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.gradient.length - 1));\n    return this.gradient[g];\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.gradient.length - 1));\n    return this.gradient[g];\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.gradient.length - 1));\n    return this.gradient[g];\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.gradient.length - 1));\n    return this.gradient[g];\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.gradient.length - 1));\n    return this.gradient[g];\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.gradient.length - 1));\n    return this.gradient[g];\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.gradient.length - 1));\n    return this.gradient[g];\n  }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_4_/src/java/org/apache/commons/cli/Parser.java_298-299": {
      "loc": "298-299",
      "input": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n// buggy line:        StringBuffer buff = new StringBuffer();",
      "function range": "290,5-309,5",
      "output": [
        {
          "patch": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            if (options.get(option) == null)\n            {\n                throw new MissingOptionException(option);\n            }\n        }\n    }\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_8_/src/java/org/apache/commons/cli/HelpFormatter.java_812-813": {
      "loc": "812-813",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n// buggy line:        pos = findWrapPos(text, width, nextLineTabStop);",
      "function range": "792,5-823,5",
      "output": [
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
          "correctness": "plausible"
        }
      ]
    },
    "Cli_11_/src/java/org/apache/commons/cli/HelpFormatter.java_632-633": {
      "loc": "632-633",
      "input": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt() != null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n// buggy line:    if (option.hasArg() && (option.getArgName() != null))",
      "function range": "613,5-642,5",
      "output": [
        {
          "patch": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.hasArg() && option.getArgName()!= null)\n    {\n        buff.append(\" \").append(option.getArgName());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.hasArg() && option.getArgName()!= null)\n    {\n        buff.append(\" \").append(option.getArgName());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.hasArg() && option.getArgName()!= null)\n    {\n        buff.append(\" \").append(option.getArgName());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.hasArg() && option.getArgName()!= null)\n    {\n        buff.append(\" \").append(option.getArgName());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.hasArg() && option.getArgName()!= null)\n    {\n        buff.append(\" \").append(option.getArgName());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.hasArg() && option.getArgName()!= null)\n    {\n        buff.append(\" \").append(option.getArgName());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.hasArg() && option.getArgName()!= null)\n    {\n        buff.append(\" \").append(option.getArgName());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.hasArg() && option.getArgName()!= null)\n    {\n        buff.append(\" \").append(option.getArgName());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.hasArg() && option.getArgName()!= null)\n    {\n        buff.append(\" \").append(option.getArgName());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.hasArg() && option.getArgName()!= null)\n    {\n        buff.append(\" \").append(option.getArgName());\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
          "correctness": "plausible"
        }
      ]
    },
    "Cli_24_/src/java/org/apache/commons/cli/HelpFormatter.java_825-827": {
      "loc": "825-827",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n// buggy line:                                        \"- no room for the description\");",
      "function range": "809,5-852,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_25_/src/java/org/apache/commons/cli/HelpFormatter.java_825-826": {
      "loc": "825-826",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        nextLineTabStop = width - 1;",
      "function range": "809,5-851,5",
      "output": [
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        nextLineTabStop = width - 2;\n    }\n    while (text.length() > 0)\n    {\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        else\n        {\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            text = text.substring(pos);\n            nextLineTabStop = width - 1;\n        }\n    }\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        nextLineTabStop = width - 2;\n    }\n    while (text.length() > 0)\n    {\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        else\n        {\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            text = text.substring(pos);\n            nextLineTabStop = width - 1;\n        }\n    }\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        nextLineTabStop = width - 2;\n    }\n    while (text.length() > 0)\n    {\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        else\n        {\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            text = text.substring(pos);\n            nextLineTabStop = width - 1;\n        }\n    }\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        nextLineTabStop = width - 2;\n    }\n    while (text.length() > 0)\n    {\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        else\n        {\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            text = text.substring(pos);\n            nextLineTabStop = width - 1;\n        }\n    }\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        nextLineTabStop = width - 2;\n    }\n    while (text.length() > 0)\n    {\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        else\n        {\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            text = text.substring(pos);\n            nextLineTabStop = width - 1;\n        }\n    }\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        nextLineTabStop = width - 2;\n    }\n    while (text.length() > 0)\n    {\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        else\n        {\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            text = text.substring(pos);\n            nextLineTabStop = width - 1;\n        }\n    }\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        nextLineTabStop = width - 2;\n    }\n    while (text.length() > 0)\n    {\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        else\n        {\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            text = text.substring(pos);\n            nextLineTabStop = width - 1;\n        }\n    }\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        nextLineTabStop = width - 2;\n    }\n    while (text.length() > 0)\n    {\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        else\n        {\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            text = text.substring(pos);\n            nextLineTabStop = width - 1;\n        }\n    }\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        nextLineTabStop = width - 2;\n    }\n    while (text.length() > 0)\n    {\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        else\n        {\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            text = text.substring(pos);\n            nextLineTabStop = width - 1;\n        }\n    }\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        nextLineTabStop = width - 2;\n    }\n    while (text.length() > 0)\n    {\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)).append(defaultNewLine);\n            return sb;\n        }\n        else\n        {\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            text = text.substring(pos);\n            nextLineTabStop = width - 1;\n        }\n    }\n    return sb;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Cli_28_/src/java/org/apache/commons/cli/Parser.java_290-291": {
      "loc": "290-291",
      "input": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n// buggy line:                break;",
      "function range": "252,5-296,5",
      "output": [
        {
          "patch": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Cli_32_/src/main/java/org/apache/commons/cli/HelpFormatter.java_937-942": {
      "loc": "937-942",
      "input": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n            && (c != '\\n') && (c != '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n// buggy line:    while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n// buggy line:           && (c != '\\n') && (c != '\\r'))\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }        ",
      "function range": "902,5-943,5",
      "output": [
        {
          "patch": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    return -1;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    return -1;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    return -1;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    return -1;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    else\n    {\n        return -1;\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    else\n    {\n        return -1;\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    return -1;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    return -1;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    else\n    {\n        return -1;\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    return -1;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_40_/src/main/java/org/apache/commons/cli/TypeHandler.java_103-104": {
      "loc": "103-104",
      "input": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n// buggy line:        return null;",
      "function range": "62,5-105,5",
      "output": [
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return (T) createObject(str);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return (T) createObject(str);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return (T) createObject(str);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return (T) createObject(str);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return (T) createObject(str);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return (T) createObject(str);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return (T) createObject(str);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return (T) createObject(str);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return (T) createObject(str);\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return (T) createObject(str);\n    }\n}",
          "correctness": "plausible"
        }
      ]
    },
    "Closure_1_/src/com/google/javascript/jscomp/RemoveUnusedVars.java_379-380": {
      "loc": "379-380",
      "input": "private void removeUnreferencedFunctionArgs(Scope fnScope) {",
      "function range": "369,3-406,3",
      "output": [
        {
          "patch": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refCollection = fnScope.getReferences(arg);\n      if (refCollection.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refs = fnScope.getReferences(arg);\n      if (refs.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refCollection = fnScope.getReferences(arg);\n      if (refCollection.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refCollection = fnScope.getReferences(arg);\n      if (refCollection.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refs = fnScope.getReferences(arg);\n      if (refs.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refs = fnScope.getReferences(arg);\n      if (refs.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refCollection = fnScope.getReferences(arg);\n      if (refCollection.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refCollection = fnScope.getReferences(arg);\n      if (refCollection.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refs = fnScope.getReferences(arg);\n      if (refs.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Iterator<Var> argIt = fnScope.getArguments().iterator();\n    while (argIt.hasNext()) {\n      Var arg = argIt.next();\n      ReferenceCollection refCollection = fnScope.getReferences(arg);\n      if (refCollection.isEmpty()) {\n        argIt.remove();\n      }\n    }\n  }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_5_/src/com/google/javascript/jscomp/InlineObjectLiterals.java_176-177": {
      "loc": "176-177",
      "input": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }",
      "function range": "155,5-253,5",
      "output": [
        {
          "patch": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  ret = true;\n  return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  ret = true;\n  return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  ret = true;\n  return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  ret = true;\n  return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  ret = true;\n  return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  ret = true;\n  return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        validProperties.add(gramps.getString());\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      validProperties.add(parent.getString());\n    } else {\n      return false;\n    }\n  }\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      } else if (gramps.isName()) {\n        if (validProperties.contains(gramps.getString())) {\n          continue;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } else if (parent.isName()) {\n      if (validProperties.contains(parent.getString())) {\n        continue;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return ret;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_10_/src/com/google/javascript/jscomp/NodeUtil.java_1417-1418": {
      "loc": "1417-1418",
      "input": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n// buggy line:    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);",
      "function range": "1415,3-1421,3",
      "output": [
        {
          "patch": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.isString();\n      }\n    });\n  } else {\n    return n.isString();\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.isString();\n      }\n    });\n  } else {\n    return n.isString();\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.isString();\n      }\n    });\n  } else {\n    return n.isString();\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.isString();\n      }\n    });\n  } else {\n    return n.isString();\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.isString();\n      }\n    });\n  } else {\n    return n.isString();\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.isString();\n      }\n    });\n  } else {\n    return n.isString();\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.isString();\n      }\n    });\n  } else {\n    return n.isString();\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.isString();\n      }\n    });\n  } else {\n    return n.isString();\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.isString();\n      }\n    });\n  } else {\n    return n.isString();\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.isString();\n      }\n    });\n  } else {\n    return n.isString();\n  }\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_11_/src/com/google/javascript/jscomp/TypeCheck.java_1314-1316": {
      "loc": "1314-1316",
      "input": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n// buggy line:  } else if (n.getJSType() != null && parent.isAssign()) {\n// buggy line:    return;",
      "function range": "1303,3-1321,3",
      "output": [
        {
          "patch": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  } else {\n    validator.expectCanAssignToPropertyOf(t, n, getJSType(n.getFirstChild()),\n        property.getString(), childType);\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  } else {\n    validator.expectCanAssignToPropertyOf(t, n, getJSType(n.getFirstChild()),\n        property.getString(), childType);\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  } else {\n    validator.expectCanAssignToPropertyOf(t, n, getJSType(n.getFirstChild()),\n        property.getString(), childType);\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  } else {\n    validator.expectCanAssignToPropertyOf(t, n, getJSType(n.getFirstChild()),\n        property.getString(), childType);\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  } else {\n    validator.expectCanAssignToPropertyOf(t, n, getJSType(n.getFirstChild()),\n        property.getString(), childType);\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  } else {\n    validator.expectCanAssignToPropertyOf(t, n, getJSType(n.getFirstChild()),\n        property.getString(), childType);\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  } else {\n    validator.expectCanAssignToPropertyOf(t, n, getJSType(n.getFirstChild()),\n        property.getString(), childType);\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  } else {\n    validator.expectCanAssignToPropertyOf(t, n, getJSType(n.getFirstChild()),\n        property.getString(), childType);\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  } else {\n    validator.expectCanAssignToPropertyOf(t, n, getJSType(n.getFirstChild()),\n        property.getString(), getJSType(objNode));\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n  } else {\n    validator.expectCanAssignToPropertyOf(t, n, getJSType(n.getFirstChild()),\n        property.getString(), childType);\n  }\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_15_/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java_102-103": {
      "loc": "102-103",
      "input": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }",
      "function range": "83,7-109,7",
      "output": [
        {
          "patch": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_18_/src/com/google/javascript/jscomp/Compiler.java_1288-1289": {
      "loc": "1288-1289",
      "input": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {",
      "function range": "1240,3-1362,3",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_20_/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java_220-221": {
      "loc": "220-221",
      "input": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget != null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n// buggy line:    if (value != null) {",
      "function range": "208,3-230,3",
      "output": [
        {
          "patch": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = NodeUtil.newStringNode(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = IR.string(\"'\" + value.getString() + \"'\");\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = NodeUtil.newStringNode(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = NodeUtil.newStringNode(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = NodeUtil.newStringNode(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = IR.string(\"'\" + value.getString() + \"'\");\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = IR.string(\"'\" + value.getString() + \"'\");\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = IR.string(\"'\" + value.getString() + \"'\");\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = NodeUtil.newStringNode(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value!= null && value.isString()) {\n      Node replacement = NodeUtil.newStringNode(value.getString());\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return n;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_31_/src/com/google/javascript/jscomp/Compiler.java_1285-1286": {
      "loc": "1285-1286",
      "input": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&\n// buggy line:        !options.skipAllPasses &&",
      "function range": "1236,3-1387,3",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_33_/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java_557-558": {
      "loc": "557-558",
      "input": "@Override\npublic void matchConstraint(ObjectType constraintObj) {",
      "function range": "554,3-580,3",
      "output": [
        {
          "patch": "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n    this.constraintObj = constraintObj;\n  }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_35_/src/com/google/javascript/jscomp/TypeInference.java_1121-1136": {
      "loc": "1121-1136",
      "input": "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n// buggy line:  if (constraintObj != null && constraintObj.isRecordType()) {\n// buggy line:    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n// buggy line:    if (objType != null) {\n// buggy line:      for (String prop : constraintObj.getOwnPropertyNames()) {\n// buggy line:        JSType propType = constraintObj.getPropertyType(prop);\n// buggy line:        if (!objType.isPropertyTypeDeclared(prop)) {\n// buggy line:          JSType typeToInfer = propType;\n// buggy line:          if (!objType.hasProperty(prop)) {\n// buggy line:            typeToInfer =\n// buggy line:                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n// buggy line:          }\n// buggy line:          objType.defineInferredProperty(prop, typeToInfer, null);\n// buggy line:        }\n// buggy line:      }\n// buggy line:    }",
      "function range": "1113,3-1137,3",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj!= null && constraintObj.isRecordType()) {\n    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!objType.hasProperty(prop)) {\n            typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj!= null && constraintObj.isRecordType()) {\n    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!objType.hasProperty(prop)) {\n            typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_36_/src/com/google/javascript/jscomp/InlineVariables.java_575-576": {
      "loc": "575-576",
      "input": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      || !isValidInitialization(initialization)\n      || !isValidReference(reference)) {\n    return false;\n  }\n  if (declaration != initialization &&\n      !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock() != initialization.getBasicBlock()\n      || declaration.getBasicBlock() != reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value != null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship != null) {\n        return false;\n      }\n// buggy line:    }",
      "function range": "519,5-580,5",
      "output": [
        {
          "patch": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      if (!callNode.getFirstChild().isSuper()) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      FunctionType constructor = value.getJSType().toMaybeFunctionType();\n      JSDocInfo info = constructor.getJSDocInfo();\n      if (info == null ||!info.isConstructorOrInterface()) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      if (!callNode.getFirstChild().isSuper()) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      FunctionType constructor = value.getJSType().toMaybeFunctionType();\n      JSDocInfo info = constructor.getJSDocInfo();\n      if (info == null ||!info.isConstructorOrInterface()) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      if (!callNode.getFirstChild().isSuper()) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      FunctionType constructor = value.getJSType().toMaybeFunctionType();\n      JSDocInfo info = constructor.getJSDocInfo();\n      if (info == null ||!info.isConstructorOrInterface()) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      if (!callNode.getFirstChild().isSuper()) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      FunctionType constructor = value.getJSType().toMaybeFunctionType();\n      JSDocInfo info = constructor.getJSDocInfo();\n      if (info == null ||!info.isConstructorOrInterface()) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      if (!callNode.getFirstChild().isSuper()) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      FunctionType constructor = value.getJSType().toMaybeFunctionType();\n      JSDocInfo info = constructor.getJSDocInfo();\n      if (info == null ||!info.isConstructorOrInterface()) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      if (!callNode.getFirstChild().isSuper()) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      FunctionType constructor = value.getJSType().toMaybeFunctionType();\n      JSDocInfo info = constructor.getJSDocInfo();\n      if (info == null ||!info.isConstructorOrInterface()) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      if (!callNode.getFirstChild().isSuper()) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      FunctionType constructor = value.getJSType().toMaybeFunctionType();\n      JSDocInfo info = constructor.getJSDocInfo();\n      if (info == null ||!info.isConstructorOrInterface()) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      if (!callNode.getFirstChild().isSuper()) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      FunctionType constructor = value.getJSType().toMaybeFunctionType();\n      JSDocInfo info = constructor.getJSDocInfo();\n      if (info == null ||!info.isConstructorOrInterface()) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      if (!callNode.getFirstChild().isSuper()) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      FunctionType constructor = value.getJSType().toMaybeFunctionType();\n      JSDocInfo info = constructor.getJSDocInfo();\n      if (info == null ||!info.isConstructorOrInterface()) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n      if (!callNode.getFirstChild().isSuper()) {\n        return false;\n      }\n    } else if (reference.getParent().isNew()) {\n      FunctionType constructor = value.getJSType().toMaybeFunctionType();\n      JSDocInfo info = constructor.getJSDocInfo();\n      if (info == null ||!info.isConstructorOrInterface()) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_38_/src/com/google/javascript/jscomp/CodeConsumer.java_245-246": {
      "loc": "245-246",
      "input": "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n// buggy line:  if (x < 0 && prev == '-') {",
      "function range": "240,3-267,3",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_52_/src/com/google/javascript/jscomp/CodeGenerator.java_745-746": {
      "loc": "745-746",
      "input": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n// buggy line:  return len > 0;",
      "function range": "737,3-746,3",
      "output": [
        {
          "patch": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return true;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_55_/src/com/google/javascript/jscomp/FunctionRewriter.java_117-118": {
      "loc": "117-118",
      "input": "private static boolean isReduceableFunctionExpression(Node n) {\n// buggy line:  return NodeUtil.isFunctionExpression(n);",
      "function range": "116,3-118,3",
      "output": [
        {
          "patch": "private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionDeclaration(n)\n        || NodeUtil.isGetterDef(n)\n        || NodeUtil.isSetterDef(n)\n        || NodeUtil.isFunctionExpression(n);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionDeclaration(n)\n        || NodeUtil.isGetterDef(n)\n        || NodeUtil.isSetterDef(n)\n        || NodeUtil.isFunctionExpression(n);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionDeclaration(n)\n        || NodeUtil.isGetterDef(n)\n        || NodeUtil.isSetterDef(n)\n        || NodeUtil.isFunctionExpression(n);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionDeclaration(n)\n        || NodeUtil.isGetterDef(n)\n        || NodeUtil.isSetterDef(n)\n        || NodeUtil.isFunctionExpression(n);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionDeclaration(n)\n        || NodeUtil.isGetterDef(n)\n        || NodeUtil.isSetterDef(n)\n        || NodeUtil.isFunctionExpression(n);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionDeclaration(n)\n        || NodeUtil.isGetterDef(n)\n        || NodeUtil.isSetterDef(n)\n        || NodeUtil.isFunctionExpression(n);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionDeclaration(n)\n        || NodeUtil.isGetterDef(n)\n        || NodeUtil.isSetterDef(n)\n        || NodeUtil.isFunctionExpression(n);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionDeclaration(n)\n        || NodeUtil.isGetterDef(n)\n        || NodeUtil.isSetterDef(n)\n        || NodeUtil.isFunctionExpression(n);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionDeclaration(n)\n        || NodeUtil.isGetterDef(n)\n        || NodeUtil.isSetterDef(n)\n        || NodeUtil.isFunctionExpression(n);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionDeclaration(n)\n        || NodeUtil.isGetterDef(n)\n        || NodeUtil.isSetterDef(n)\n        || NodeUtil.isFunctionExpression(n);\n  }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_57_/src/com/google/javascript/jscomp/ClosureCodingConvention.java_197-198": {
      "loc": "197-198",
      "input": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee != null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n// buggy line:        if (target != null) {",
      "function range": "188,3-204,3",
      "output": [
        {
          "patch": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target!= null && target.getType() == Token.NAME) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_59_/src/com/google/javascript/jscomp/Compiler.java_255-256": {
      "loc": "255-256",
      "input": "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n// buggy line:  if (options.checkGlobalThisLevel.isOn()) {",
      "function range": "226,3-288,3",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  } else {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        CheckLevel.OFF);\n  }\n  if (options.checkMissingGetCssNameLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_GETCSSNAME,\n        options.checkMissingGetCssNameLevel);\n  } else {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_GETCSSNAME,\n        CheckLevel.OFF);\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_62_/src/com/google/javascript/jscomp/LightweightMessageFormatter.java_98-99": {
      "loc": "98-99",
      "input": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null ? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName != null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt != null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n// buggy line:        && 0 <= charno && charno < sourceExcerpt.length()) {",
      "function range": "66,3-111,3",
      "output": [
        {
          "patch": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n        && 0 <= charno) {\n      for (int i = 0; i < error.getCharno(); i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n      char c = sourceExcerpt.charAt(error.getCharno());\n      b.append(c == '\\t'? c :'');\n      b.append(error.description);\n      for (int i = error.getCharno() + 1; i < sourceExcerpt.length(); i++) {\n        c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n    }\n  }\n  return b.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n        && 0 <= charno) {\n      for (int i = 0; i < error.getCharno(); i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n      char c = sourceExcerpt.charAt(error.getCharno());\n      b.append(c == '\\t'? c :'');\n      b.append(error.description);\n      for (int i = error.getCharno() + 1; i < sourceExcerpt.length(); i++) {\n        c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n    }\n  }\n  return b.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n        && 0 <= charno) {\n      for (int i = 0; i < error.getCharno(); i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n      char c = sourceExcerpt.charAt(error.getCharno());\n      b.append(c == '\\t'? c :'');\n      b.append(error.description);\n      for (int i = error.getCharno() + 1; i < sourceExcerpt.length(); i++) {\n        c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n    }\n    b.append('\\n');\n  }\n  return b.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n        && 0 <= charno) {\n      for (int i = 0; i < error.getCharno(); i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n      char c = sourceExcerpt.charAt(error.getCharno());\n      b.append(c == '\\t'? c :'');\n      b.append(error.description);\n      for (int i = error.getCharno() + 1; i < sourceExcerpt.length(); i++) {\n        c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n    }\n  }\n  return b.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n        && 0 <= charno) {\n      for (int i = 0; i < error.getCharno(); i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n      char c = sourceExcerpt.charAt(error.getCharno());\n      b.append(c == '\\t'? c :'');\n      b.append(error.description);\n      for (int i = error.getCharno() + 1; i < sourceExcerpt.length(); i++) {\n        c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n    }\n  }\n  return b.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n        && 0 <= charno) {\n      for (int i = 0; i < error.getCharno(); i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n      char c = sourceExcerpt.charAt(error.getCharno());\n      b.append(c == '\\t'? c :'');\n      b.append(error.description);\n      for (int i = error.getCharno() + 1; i < sourceExcerpt.length(); i++) {\n        c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n    }\n  }\n  return b.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n        && 0 <= charno) {\n      for (int i = 0; i < error.getCharno(); i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n      char c = sourceExcerpt.charAt(error.getCharno());\n      b.append(c == '\\t'? c :'');\n      b.append(error.description);\n      for (int i = error.getCharno() + 1; i < sourceExcerpt.length(); i++) {\n        c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n    }\n    b.append('\\n');\n  }\n  return b.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n        && 0 <= charno) {\n      for (int i = 0; i < error.getCharno(); i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n      char c = sourceExcerpt.charAt(error.getCharno());\n      b.append(c == '\\t'? c :'');\n      b.append(error.description);\n      for (int i = error.getCharno() + 1; i < sourceExcerpt.length(); i++) {\n        c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n    }\n    b.append('\\n');\n  }\n  return b.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n        && 0 <= charno) {\n      for (int i = 0; i < error.getCharno(); i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n      char c = sourceExcerpt.charAt(error.getCharno());\n      b.append(c == '\\t'? c :'');\n      b.append(error.description);\n      for (int i = error.getCharno() + 1; i < sourceExcerpt.length(); i++) {\n        c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n    }\n  }\n  return b.toString();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n        && 0 <= charno) {\n      for (int i = 0; i < error.getCharno(); i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n      char c = sourceExcerpt.charAt(error.getCharno());\n      b.append(c == '\\t'? c :'');\n      b.append(error.description);\n      for (int i = error.getCharno() + 1; i < sourceExcerpt.length(); i++) {\n        c = sourceExcerpt.charAt(i);\n        if (c == '\\t') {\n          b.append('\\t');\n        } else {\n          b.append(' ');\n        }\n      }\n    }\n  }\n  return b.toString();\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_65_/src/com/google/javascript/jscomp/CodeGenerator.java_1015-1016": {
      "loc": "1015-1016",
      "input": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n// buggy line:      case '\\0': sb.append(\"\\\\0\"); break;",
      "function range": "1005,3-1075,3",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_67_/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java_318-319": {
      "loc": "318-319",
      "input": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n// buggy line:      ) {",
      "function range": "314,5-334,5",
      "output": [
        {
          "patch": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n      && n.getFirstChild().isQualifiedName()) {\n    Node recv = n.getFirstChild();\n    return recv.isQualifiedName()\n        && recv.getNext().isString()\n        && recv.getNext().getString().equals(\"prototype\");\n  }\n  return false;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n      && n.getFirstChild().isQualifiedName()) {\n    Node recv = n.getFirstChild();\n    return recv.isQualifiedName()\n        && recv.getNext().isString()\n        && recv.getNext().getString().equals(\"prototype\");\n  }\n  return false;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n      && n.getFirstChild().isQualifiedName()) {\n    Node recv = n.getFirstChild();\n    return recv.isQualifiedName()\n        && recv.getNext().isString()\n        && recv.getNext().getString().equals(\"prototype\");\n  }\n  return false;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n      && n.getFirstChild().isQualifiedName()) {\n    Node recv = n.getFirstChild();\n    return recv.isQualifiedName()\n        && recv.getNext().isString()\n        && recv.getNext().getString().equals(\"prototype\");\n  }\n  return false;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n      && n.getFirstChild().isQualifiedName()) {\n    Node recv = n.getFirstChild();\n    return recv.isQualifiedName()\n        && recv.getNext().isString()\n        && recv.getNext().getString().equals(\"prototype\");\n  }\n  return false;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n      && n.getFirstChild().isQualifiedName()) {\n    Node recv = n.getFirstChild();\n    return recv.isQualifiedName()\n        && recv.getNext().isString()\n        && recv.getNext().getString().equals(\"prototype\");\n  }\n  return false;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n      && n.getFirstChild().isQualifiedName()) {\n    Node recv = n.getFirstChild();\n    return recv.isQualifiedName()\n        && recv.getNext().isString()\n        && recv.getNext().getString().equals(\"prototype\");\n  }\n  return false;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n      && n.getFirstChild().isQualifiedName()) {\n    Node recv = n.getFirstChild();\n    return recv.isQualifiedName()\n        && recv.getNext().isString()\n        && recv.getNext().getString().equals(\"prototype\");\n  }\n  return false;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n      && n.getFirstChild().isQualifiedName()) {\n    Node recv = n.getFirstChild();\n    return recv.isQualifiedName()\n        && recv.getNext().isString()\n        && recv.getNext().getString().equals(\"prototype\");\n  }\n  return false;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n      && n.getFirstChild().isQualifiedName()) {\n    Node recv = n.getFirstChild();\n    return recv.isQualifiedName()\n        && recv.getNext().isString()\n        && recv.getNext().getString().equals(\"prototype\");\n  }\n  return false;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_70_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1745-1746": {
      "loc": "1745-1746",
      "input": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType != null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters != null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter != null) {\n          defineSlot(astParameter, functionNode,\n// buggy line:              jsDocParameter.getJSType(), true);",
      "function range": "1734,5-1753,5",
      "output": [
        {
          "patch": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              null, true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode,\n              null, true);\n        }\n      }\n    } else {\n      for (Node astParameter : astParameters.children()) {\n        defineSlot(astParameter, functionNode,\n              null, true);\n      }\n    }\n  } else {\n    for (Node astParameter : astParameters.children()) {\n      defineSlot(astParameter, functionNode,\n              null, true);\n    }\n  }\n  for (Node bodyChild = body.getFirstChild();\n       bodyChild!= null;\n       bodyChild = bodyChild.getNext()) {\n    if (bodyChild.isExprResult()) {\n      defineSlot(bodyChild.getFirstChild(), functionNode,\n              null, true);\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              null, true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode,\n              null, true);\n        }\n      }\n    } else {\n      for (Node astParameter : astParameters.children()) {\n        defineSlot(astParameter, functionNode,\n              null, true);\n      }\n    }\n  } else {\n    for (Node astParameter : astParameters.children()) {\n      defineSlot(astParameter, functionNode,\n              null, true);\n    }\n  }\n  for (Node bodyChild = body.getFirstChild();\n       bodyChild!= null;\n       bodyChild = bodyChild.getNext()) {\n    if (bodyChild.isExprResult()) {\n      defineSlot(bodyChild.getFirstChild(), functionNode,\n              null, true);\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              null, true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode,\n              null, true);\n        }\n      }\n    } else {\n      for (Node astParameter : astParameters.children()) {\n        defineSlot(astParameter, functionNode,\n              null, true);\n      }\n    }\n  } else {\n    for (Node astParameter : astParameters.children()) {\n      defineSlot(astParameter, functionNode,\n              null, true);\n    }\n  }\n  for (Node bodyChild = body.getFirstChild();\n       bodyChild!= null;\n       bodyChild = bodyChild.getNext()) {\n    if (bodyChild.isExprResult()) {\n      defineSlot(bodyChild.getFirstChild(), functionNode,\n              null, true);\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              null, true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode,\n              null, true);\n        }\n      }\n    } else {\n      for (Node astParameter : astParameters.children()) {\n        defineSlot(astParameter, functionNode,\n              null, true);\n      }\n    }\n  } else {\n    for (Node astParameter : astParameters.children()) {\n      defineSlot(astParameter, functionNode,\n              null, true);\n    }\n  }\n  for (Node bodyChild = body.getFirstChild();\n       bodyChild!= null;\n       bodyChild = bodyChild.getNext()) {\n    if (bodyChild.isExprResult()) {\n      defineSlot(bodyChild.getFirstChild(), functionNode,\n              null, true);\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              null, true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode,\n              null, true);\n        }\n      }\n    } else {\n      for (Node astParameter : astParameters.children()) {\n        defineSlot(astParameter, functionNode,\n              null, true);\n      }\n    }\n  } else {\n    for (Node astParameter : astParameters.children()) {\n      defineSlot(astParameter, functionNode,\n              null, true);\n    }\n  }\n\n  for (Node bodyChild = body.getFirstChild();\n       bodyChild!= null;\n       bodyChild = bodyChild.getNext()) {\n    if (bodyChild.isExprResult()) {\n      defineSlot(bodyChild.getFirstChild(), functionNode,\n              null, true);\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              null, true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode,\n              null, true);\n        }\n      }\n    } else {\n      for (Node astParameter : astParameters.children()) {\n        defineSlot(astParameter, functionNode,\n              null, true);\n      }\n    }\n  } else {\n    for (Node astParameter : astParameters.children()) {\n      defineSlot(astParameter, functionNode,\n              null, true);\n    }\n  }\n  for (Node bodyChild = body.getFirstChild();\n       bodyChild!= null;\n       bodyChild = bodyChild.getNext()) {\n    if (bodyChild.isExprResult()) {\n      defineSlot(bodyChild.getFirstChild(), functionNode,\n              null, true);\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              null, true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode,\n              null, true);\n        }\n      }\n    } else {\n      for (Node astParameter : astParameters.children()) {\n        defineSlot(astParameter, functionNode,\n              null, true);\n      }\n    }\n  } else {\n    for (Node astParameter : astParameters.children()) {\n      defineSlot(astParameter, functionNode,\n              null, true);\n    }\n  }\n  for (Node bodyChild = body.getFirstChild();\n       bodyChild!= null;\n       bodyChild = bodyChild.getNext()) {\n    if (bodyChild.isExprResult()) {\n      defineSlot(bodyChild.getFirstChild(), functionNode,\n              null, true);\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              null, true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode,\n              null, true);\n        }\n      }\n    } else {\n      for (Node astParameter : astParameters.children()) {\n        defineSlot(astParameter, functionNode,\n              null, true);\n      }\n    }\n  } else {\n    for (Node astParameter : astParameters.children()) {\n      defineSlot(astParameter, functionNode,\n              null, true);\n    }\n  }\n  for (Node bodyChild = body.getFirstChild();\n       bodyChild!= null;\n       bodyChild = bodyChild.getNext()) {\n    if (bodyChild.isExprResult()) {\n      defineSlot(bodyChild.getFirstChild(), functionNode,\n              null, true);\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              null, true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode,\n              null, true);\n        }\n      }\n    } else {\n      for (Node astParameter : astParameters.children()) {\n        defineSlot(astParameter, functionNode,\n              null, true);\n      }\n    }\n  } else {\n    for (Node astParameter : astParameters.children()) {\n      defineSlot(astParameter, functionNode,\n              null, true);\n    }\n  }\n  for (Node bodyChild = body.getFirstChild();\n       bodyChild!= null;\n       bodyChild = bodyChild.getNext()) {\n    if (bodyChild.isExprResult()) {\n      defineSlot(bodyChild.getFirstChild(), functionNode,\n              null, true);\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n              null, true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode,\n              null, true);\n        }\n      }\n    } else {\n      for (Node astParameter : astParameters.children()) {\n        defineSlot(astParameter, functionNode,\n              null, true);\n      }\n    }\n  } else {\n    for (Node astParameter : astParameters.children()) {\n      defineSlot(astParameter, functionNode,\n              null, true);\n    }\n  }\n  for (Node bodyChild = body.getFirstChild();\n       bodyChild!= null;\n       bodyChild = bodyChild.getNext()) {\n    if (bodyChild.isExprResult()) {\n      defineSlot(bodyChild.getFirstChild(), functionNode,\n              null, true);\n    }\n  }\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_71_/src/com/google/javascript/jscomp/CheckAccessControls.java_416-417": {
      "loc": "416-417",
      "input": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType != null) {\n// buggy line:    boolean isOverride = t.inGlobalScope() &&",
      "function range": "407,3-500,3",
      "output": [
        {
          "patch": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    boolean isOverride = t.inGlobalScope() &&!objectType.isFunctionPrototype();\n    if (isOverride) {\n      report(getprop, VISIBILITY_MISMATCH);\n    }\n    if (objectType.isConstructor() || objectType.isInterface()) {\n      FunctionType fn = objectType.toMaybeFunctionType();\n      if (fn!= null) {\n        JSDocInfo docInfo = fn.getJSDocInfo();\n        if (docInfo!= null && docInfo.getVisibility()!= Visibility.INHERITED) {\n          if (isOverride) {\n            report(getprop, VISIBILITY_MISMATCH);\n          }\n        }\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    boolean isOverride = t.inGlobalScope() &&!objectType.isFunctionPrototype();\n    if (isOverride) {\n      report(getprop, VISIBILITY_MISMATCH);\n    }\n    if (objectType.isConstructor() || objectType.isInterface()) {\n      FunctionType fn = objectType.toMaybeFunctionType();\n      if (fn!= null) {\n        JSDocInfo docInfo = fn.getJSDocInfo();\n        if (docInfo!= null && docInfo.getVisibility()!= Visibility.INHERITED) {\n          if (isOverride) {\n            report(getprop, VISIBILITY_MISMATCH);\n          }\n        }\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    boolean isOverride = t.inGlobalScope() &&!objectType.isFunctionPrototype();\n    if (isOverride) {\n      report(getprop, VISIBILITY_MISMATCH);\n    }\n    if (objectType.isConstructor() || objectType.isInterface()) {\n      FunctionType fn = objectType.toMaybeFunctionType();\n      if (fn!= null) {\n        JSDocInfo docInfo = fn.getJSDocInfo();\n        if (docInfo!= null && docInfo.getVisibility()!= Visibility.INHERITED) {\n          if (isOverride) {\n            report(getprop, VISIBILITY_MISMATCH);\n          }\n        }\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    boolean isOverride = t.inGlobalScope() &&!objectType.isFunctionPrototype();\n    if (isOverride) {\n      report(getprop, VISIBILITY_MISMATCH);\n    }\n    if (objectType.isConstructor() || objectType.isInterface()) {\n      FunctionType fn = objectType.toMaybeFunctionType();\n      if (fn!= null) {\n        JSDocInfo docInfo = fn.getJSDocInfo();\n        if (docInfo!= null && docInfo.getVisibility()!= Visibility.INHERITED) {\n          if (isOverride) {\n            report(getprop, VISIBILITY_MISMATCH);\n          }\n        }\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    boolean isOverride = t.inGlobalScope() &&!objectType.isFunctionPrototype();\n    if (isOverride) {\n      report(getprop, VISIBILITY_MISMATCH);\n    }\n    if (objectType.isConstructor() || objectType.isInterface()) {\n      FunctionType fn = objectType.toMaybeFunctionType();\n      if (fn!= null) {\n        JSDocInfo docInfo = fn.getJSDocInfo();\n        if (docInfo!= null && docInfo.getVisibility()!= Visibility.INHERITED) {\n          if (isOverride) {\n            report(getprop, VISIBILITY_MISMATCH);\n          }\n        }\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    boolean isOverride = t.inGlobalScope() &&!objectType.isFunctionPrototype();\n    if (isOverride) {\n      report(getprop, VISIBILITY_MISMATCH);\n    }\n    if (objectType.isConstructor() || objectType.isInterface()) {\n      FunctionType fn = objectType.toMaybeFunctionType();\n      if (fn!= null) {\n        JSDocInfo docInfo = fn.getJSDocInfo();\n        if (docInfo!= null && docInfo.getVisibility()!= Visibility.INHERITED) {\n          if (isOverride) {\n            report(getprop, VISIBILITY_MISMATCH);\n          }\n        }\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    boolean isOverride = t.inGlobalScope() &&!objectType.isFunctionPrototype();\n    if (isOverride) {\n      report(getprop, VISIBILITY_MISMATCH);\n    }\n    if (objectType.isConstructor() || objectType.isInterface()) {\n      FunctionType fn = objectType.toMaybeFunctionType();\n      if (fn!= null) {\n        JSDocInfo docInfo = fn.getJSDocInfo();\n        if (docInfo!= null && docInfo.getVisibility()!= Visibility.INHERITED) {\n          if (isOverride) {\n            report(getprop, VISIBILITY_MISMATCH);\n          }\n        }\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    boolean isOverride = t.inGlobalScope() &&!objectType.isFunctionPrototype();\n    if (isOverride) {\n      report(getprop, VISIBILITY_MISMATCH);\n    }\n    if (objectType.isConstructor() || objectType.isInterface()) {\n      FunctionType fn = objectType.toMaybeFunctionType();\n      if (fn!= null) {\n        JSDocInfo docInfo = fn.getJSDocInfo();\n        if (docInfo!= null && docInfo.getVisibility()!= Visibility.INHERITED) {\n          if (isOverride) {\n            report(getprop, VISIBILITY_MISMATCH);\n          }\n        }\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    boolean isOverride = t.inGlobalScope() &&!objectType.isFunctionPrototype();\n    if (isOverride) {\n      report(getprop, VISIBILITY_MISMATCH);\n    }\n    if (objectType.isConstructor() || objectType.isInterface()) {\n      FunctionType fn = objectType.toMaybeFunctionType();\n      if (fn!= null) {\n        JSDocInfo docInfo = fn.getJSDocInfo();\n        if (docInfo!= null && docInfo.getVisibility()!= Visibility.INHERITED) {\n          if (isOverride) {\n            report(getprop, VISIBILITY_MISMATCH);\n          }\n        }\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n    boolean isOverride = t.inGlobalScope() &&!objectType.isFunctionPrototype();\n    if (isOverride) {\n      report(getprop, VISIBILITY_MISMATCH);\n    }\n    if (objectType.isConstructor() || objectType.isInterface()) {\n      FunctionType fn = objectType.toMaybeFunctionType();\n      if (fn!= null) {\n        JSDocInfo docInfo = fn.getJSDocInfo();\n        if (docInfo!= null && docInfo.getVisibility()!= Visibility.INHERITED) {\n          if (isOverride) {\n            report(getprop, VISIBILITY_MISMATCH);\n          }\n        }\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_82_/src/com/google/javascript/rhino/jstype/JSType.java_163-164": {
      "loc": "163-164",
      "input": "public final boolean isEmptyType() {\n// buggy line:  return isNoType() || isNoObjectType() || isNoResolvedType();",
      "function range": "162,3-164,3",
      "output": [
        {
          "patch": "public final boolean isEmptyType() {\n        return isNoType() || isNoObjectType() || isNoResolvedType();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final boolean isEmptyType() {\n        return isNoType() || isNoObjectType() || isNoResolvedType();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final boolean isEmptyType() {\n        return isNoType() || isNoObjectType() || isNoResolvedType();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final boolean isEmptyType() {\n        return isNoType() || isNoObjectType() || isNoResolvedType();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final boolean isEmptyType() {\n        return isNoType() || isNoObjectType() || isNoResolvedType();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final boolean isEmptyType() {\n        return isNoType() || isNoObjectType() || isNoResolvedType();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final boolean isEmptyType() {\n        return isNoType() || isNoObjectType() || isNoResolvedType();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final boolean isEmptyType() {\n        return isNoType() || isNoObjectType() || isNoResolvedType();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final boolean isEmptyType() {\n        return isNoType() || isNoObjectType() || isNoResolvedType();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final boolean isEmptyType() {\n        return isNoType() || isNoObjectType() || isNoResolvedType();\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_83_/src/com/google/javascript/jscomp/CommandLineRunner.java_334-335": {
      "loc": "334-335",
      "input": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n// buggy line:  String param = params.getParameter(0);",
      "function range": "332,7-351,7",
      "output": [
        {
          "patch": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    String param = params.getParameter(0);\n    if (param == null || param.length() == 0) {\n        throw new CmdLineException(owner, \"\");\n    }\n    return super.parseArguments(params);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    String param = params.getParameter(0);\n    if (param == null || param.length() == 0) {\n        throw new CmdLineException(owner, \"\");\n    }\n    return super.parseArguments(params);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    String param = params.getParameter(0);\n    if (param == null || param.length() == 0) {\n        throw new CmdLineException(owner, \"\");\n    }\n    return super.parseArguments(params);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    String param = params.getParameter(0);\n    if (param == null || param.length() == 0) {\n        throw new CmdLineException(owner, \"\");\n    }\n    return super.parseArguments(params);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    String param = params.getParameter(0);\n    if (param == null || param.length() == 0) {\n        throw new CmdLineException(owner, \"\");\n    }\n    return super.parseArguments(params);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    String param = params.getParameter(0);\n    if (param == null || param.length() == 0) {\n        throw new CmdLineException(owner, \"\");\n    }\n    return super.parseArguments(params);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    String param = params.getParameter(0);\n    if (param == null || param.length() == 0) {\n        throw new CmdLineException(owner, \"\");\n    }\n    return super.parseArguments(params);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    String param = params.getParameter(0);\n    if (param == null || param.length() == 0) {\n        throw new CmdLineException(owner, \"\");\n    }\n    return super.parseArguments(params);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    String param = params.getParameter(0);\n    if (param == null || param.length() == 0) {\n        throw new CmdLineException(owner, \"\");\n    }\n    return super.parseArguments(params);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n    String param = params.getParameter(0);\n    if (param == null || param.length() == 0) {\n        throw new CmdLineException(owner, \"\");\n    }\n    return super.parseArguments(params);\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_86_/src/com/google/javascript/jscomp/NodeUtil.java_2465-2466": {
      "loc": "2465-2466",
      "input": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n// buggy line:      return true;",
      "function range": "2424,3-2489,3",
      "output": [
        {
          "patch": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      break;\n    default:\n      return true;\n    }\n    for (Node c = value.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!locals.apply(c)) {\n        return false;\n      }\n    }\n    return true;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      break;\n    default:\n      return true;\n    }\n    for (Node c = value.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!locals.apply(c)) {\n        return false;\n      }\n    }\n    return true;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      break;\n    default:\n      return true;\n    }\n    for (Node c = value.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!locals.apply(c)) {\n        return false;\n      }\n    }\n    return true;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      break;\n    default:\n      return true;\n    }\n    for (Node c = value.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!locals.apply(c)) {\n        return false;\n      }\n    }\n    return true;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      break;\n    default:\n      return true;\n    }\n    for (Node c = value.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!locals.apply(c)) {\n        return false;\n      }\n    }\n    return true;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      break;\n    default:\n      return true;\n    }\n    for (Node c = value.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!locals.apply(c)) {\n        return false;\n      }\n    }\n    return true;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      break;\n    default:\n      return true;\n    }\n    for (Node c = value.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!evaluatesToLocalValue(c, locals)) {\n        return false;\n      }\n    }\n    return true;\n  }",
          "correctness": "plausible"
        },
        {
          "patch": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      break;\n    default:\n      return true;\n    }\n    for (Node c = value.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!locals.apply(c)) {\n        return false;\n      }\n    }\n    return true;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      break;\n    default:\n      return true;\n    }\n    for (Node c = value.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!locals.apply(c)) {\n        return false;\n      }\n    }\n    return true;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      break;\n    default:\n      return true;\n    }\n    for (Node c = value.getFirstChild(); c!= null; c = c.getNext()) {\n      if (!locals.apply(c)) {\n        return false;\n      }\n    }\n    return true;\n  }",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_92_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_789-790": {
      "loc": "789-790",
      "input": "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition != null && explicitNode != null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n// buggy line:      int indexOfDot = namespace.indexOf('.');",
      "function range": "747,5-809,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_97_/src/com/google/javascript/jscomp/PeepholeFoldConstants.java_698-699": {
      "loc": "698-699",
      "input": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt != lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt != rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n// buggy line:        result = lvalInt >>> rvalInt;",
      "function range": "652,3-713,3",
      "output": [
        {
          "patch": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n                                 Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n                                 Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n                                 Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n\n    return newNumber;\n  }\n  return n;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n                                 Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n\n    return newNumber;\n  }\n\n  return n;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n                                 Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n\n    return newNumber;\n  }\n  return n;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n                                 Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n\n    return newNumber;\n  }\n\n  return n;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n                                 Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n                                 Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n                                 Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n                                 Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_104_/src/com/google/javascript/rhino/jstype/UnionType.java_291-292": {
      "loc": "291-292",
      "input": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result != null) {",
      "function range": "273,3-298,3",
      "output": [
        {
          "patch": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  return result;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_109_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_1908-1909": {
      "loc": "1908-1909",
      "input": "private Node parseContextTypeExpression(JsDocToken token) {\n// buggy line:        return parseTypeName(token);",
      "function range": "1907,3-1909,3",
      "output": [
        {
          "patch": "private Node parseContextTypeExpression(JsDocToken token) {\n        return parseTypeName(token);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private Node parseContextTypeExpression(JsDocToken token) {\n        return parseTypeName(token);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private Node parseContextTypeExpression(JsDocToken token) {\n        return parseTypeName(token);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private Node parseContextTypeExpression(JsDocToken token) {\n        return parseTypeName(token);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private Node parseContextTypeExpression(JsDocToken token) {\n        return parseTypeName(token);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private Node parseContextTypeExpression(JsDocToken token) {\n        return parseTypeName(token);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private Node parseContextTypeExpression(JsDocToken token) {\n        return parseTypeName(token);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private Node parseContextTypeExpression(JsDocToken token) {\n        return parseTypeName(token);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private Node parseContextTypeExpression(JsDocToken token) {\n        return parseTypeName(token);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private Node parseContextTypeExpression(JsDocToken token) {\n        return parseTypeName(token);\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_111_/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java_54-55": {
      "loc": "54-55",
      "input": "@Override\nprotected JSType caseTopType(JSType topType) {\n// buggy line:  return topType;",
      "function range": "52,9-55,9",
      "output": [
        {
          "patch": "@Override\nprotected JSType caseTopType(JSType topType) {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JSType caseTopType(JSType topType) {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JSType caseTopType(JSType topType) {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JSType caseTopType(JSType topType) {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JSType caseTopType(JSType topType) {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JSType caseTopType(JSType topType) {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JSType caseTopType(JSType topType) {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JSType caseTopType(JSType topType) {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JSType caseTopType(JSType topType) {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JSType caseTopType(JSType topType) {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_113_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_329-330": {
      "loc": "329-330",
      "input": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null || !provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph != null &&\n          module != providedModule &&\n          !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n// buggy line:    if (provided != null) {",
      "function range": "295,3-334,3",
      "output": [
        {
          "patch": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, arg.getString(), t.getSourceName()));\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, arg.getString(), t.getSourceName()));\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, null, t.getSourceName()));\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, null, t.getSourceName()));\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, arg.getString(), t.getSourceName()));\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, arg.getString(), t.getSourceName()));\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, arg.getString(), t.getSourceName()));\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, arg.getString(), t.getSourceName()));\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, arg.getString(), t.getSourceName()));\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n  } else {\n    unrecognizedRequires.add(\n        new UnrecognizedRequire(n, arg.getString(), t.getSourceName()));\n  }\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_114_/src/com/google/javascript/jscomp/NameAnalyzer.java_578-579": {
      "loc": "578-579",
      "input": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns != null) {\n    if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext() != n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n// buggy line:    } else {",
      "function range": "558,5-588,5",
      "output": [
        {
          "patch": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      recordDepScope(nameNode, ns);\n    }\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      recordDepScope(recordNode, ns);\n    }\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      recordDepScope(nameNode, ns);\n    }\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      recordDepScope(nameNode, ns);\n    }\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      recordDepScope(recordNode, ns);\n    }\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      recordDepScope(nameNode, ns);\n    }\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      recordDepScope(recordNode, ns);\n    }\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      recordDepScope(nameNode, ns);\n    }\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      recordDepScope(recordNode, ns);\n    }\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      recordDepScope(nameNode, ns);\n    }\n  }\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_118_/src/com/google/javascript/jscomp/DisambiguateProperties.java_495-496": {
      "loc": "495-496",
      "input": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child != null;\n      child = child.getNext()) {",
      "function range": "490,5-513,5",
      "output": [
        {
          "patch": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    switch (child.getType()) {\n      case Token.OBJECTLIT:\n        handleObjectLit(t, child);\n        break;\n      case Token.STRING:\n        handleString(t, child);\n        break;\n      default:\n        break;\n    }\n  }\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_120_/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java_431-432": {
      "loc": "431-432",
      "input": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block != null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;",
      "function range": "421,5-438,5",
      "output": [
        {
          "patch": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n      return true;\n    }\n  }\n  return false;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_122_/src/com/google/javascript/jscomp/parsing/IRFactory.java_252-253": {
      "loc": "252-253",
      "input": "private void handleBlockComment(Comment comment) {\n// buggy line:  if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {",
      "function range": "251,3-258,3",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_125_/src/com/google/javascript/jscomp/TypeCheck.java_1661-1662": {
      "loc": "1661-1662",
      "input": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n// buggy line:    if (fnType != null) {",
      "function range": "1656,3-1671,3",
      "output": [
        {
          "patch": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType!= null && fnType.hasInstanceType()) {\n      FunctionType ctorType = fnType.getInstanceType().getConstructor();\n      if (ctorType!= null && ctorType.isAbstract()) {\n        report(t, n, ABSTRACT_SUPER_METHOD_NOT_CALLABLE, type.toString());\n      }\n    }\n  }\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_126_/src/com/google/javascript/jscomp/MinimizeExitPoints.java_141-145": {
      "loc": "141-145",
      "input": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock != null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n// buggy line:    if (NodeUtil.hasFinally(n)) {\n// buggy line:      Node finallyBlock = n.getLastChild();\n// buggy line:      tryMinimizeExits(finallyBlock, exitType, labelName);\n// buggy line:    }",
      "function range": "106,3-201,3",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_129_/src/com/google/javascript/jscomp/PrepareAst.java_166-167": {
      "loc": "166-167",
      "input": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();",
      "function range": "158,5-177,5",
      "output": [
        {
          "patch": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSTypeRegistry.getType(info.getTypedefType()).toMaybeFunctionType();\n    if (methodType == null ||!methodType.isInterface()) {\n      continue;\n    }\n    String interfaceName = methodType.getInstanceType().getReferenceName();\n    if (interfaceName == null) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    compiler.reportChangeToEnclosingScope(n);\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSTypeRegistry.getType(info.getTypedefType()).toMaybeFunctionType();\n    if (methodType == null ||!methodType.isInterface()) {\n      continue;\n    }\n    String interfaceName = methodType.getInstanceType().getReferenceName();\n    if (interfaceName == null) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    compiler.reportChangeToEnclosingScope(n);\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSTypeRegistry.getType(info.getTypedefType()).toMaybeFunctionType();\n    if (methodType == null ||!methodType.isInterface()) {\n      continue;\n    }\n    String interfaceName = methodType.getInstanceType().getReferenceName();\n    if (interfaceName == null) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    compiler.reportChangeToEnclosingScope(n);\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSTypeRegistry.getType(info.getTypedefType()).toMaybeFunctionType();\n    if (methodType == null ||!methodType.isInterface()) {\n      continue;\n    }\n    String interfaceName = methodType.getInstanceType().getReferenceName();\n    if (interfaceName == null) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    compiler.reportChangeToEnclosingScope(n);\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSType.toMaybeFunctionType(c.getFirstChild().getJSType());\n    if (methodType == null\n        || methodType.isAbstract()\n        || methodType.isInterface()\n        || methodType.isConstructor()\n        || methodType.isEnumType()) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n    builder.recordConstructor();\n    c.setJSDocInfo(builder.build());\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSTypeRegistry.getType(info.getTypedefType()).toMaybeFunctionType();\n    if (methodType == null ||!methodType.isInterface()) {\n      continue;\n    }\n    String interfaceName = methodType.getInstanceType().getReferenceName();\n    if (interfaceName == null) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    compiler.reportChangeToEnclosingScope(n);\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSType.toMaybeFunctionType(c.getFirstChild().getJSType());\n    if (methodType == null\n        || methodType.isAbstract()\n        || methodType.isInterface()\n        || methodType.isConstructor()\n        || methodType.isEnumType()) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n    builder.recordConstructor();\n    c.setJSDocInfo(builder.build());\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSTypeRegistry.getType(info.getTypedefType()).toMaybeFunctionType();\n    if (methodType == null ||!methodType.isInterface()) {\n      continue;\n    }\n    String interfaceName = methodType.getInstanceType().getReferenceName();\n    if (interfaceName == null) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    compiler.reportChangeToEnclosingScope(n);\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSType.toMaybeFunctionType(c.getFirstChild().getJSType());\n    if (methodType == null\n        || methodType.isAbstract()\n        || methodType.isInterface()\n        || methodType.isConstructor()\n        || methodType.isEnumType()) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n    builder.recordConstructor();\n    c.setJSDocInfo(builder.build());\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (first == null) {\n    return;\n  }\n  for (Node c = first.getNext(); c!= null; c = c.getNext()) {\n    if (!c.isGetProp()) {\n      continue;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(c);\n    if (info == null ||!info.isConstructorOrInterface()) {\n      continue;\n    }\n    FunctionType methodType =\n        JSType.toMaybeFunctionType(c.getFirstChild().getJSType());\n    if (methodType == null\n        || methodType.isAbstract()\n        || methodType.isInterface()\n        || methodType.isConstructor()\n        || methodType.isEnumType()) {\n      continue;\n    }\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n    builder.recordConstructor();\n    c.setJSDocInfo(builder.build());\n  }\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_130_/src/com/google/javascript/jscomp/CollapseProperties.java_172-173": {
      "loc": "172-173",
      "input": "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n// buggy line:    if (name.globalSets == 1 && name.localSets == 0 &&",
      "function range": "161,3-197,3",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_133_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_2401-2402": {
      "loc": "2401-2402",
      "input": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n// buggy line:  return result;",
      "function range": "2399,3-2402,3",
      "output": [
        {
          "patch": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result == null) {\n    return \"\";\n  } else {\n    return result;\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result == null) {\n    return \"\";\n  } else {\n    return result;\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result == null) {\n    return \"\";\n  } else {\n    return result;\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result == null) {\n    return \"\";\n  } else {\n    return result;\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result == null) {\n    return \"\";\n  } else {\n    return result;\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result == null) {\n    return \"\";\n  } else {\n    return result;\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result == null) {\n    return \"\";\n  } else {\n    return result;\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result == null) {\n    return \"\";\n  } else {\n    return result;\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result == null) {\n    return \"\";\n  } else {\n    return result;\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  if (result == null) {\n    return \"\";\n  } else {\n    return result;\n  }\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_146_/src/com/google/javascript/rhino/jstype/JSType.java_706-707": {
      "loc": "706-707",
      "input": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);",
      "function range": "696,3-715,3",
      "output": [
        {
          "patch": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n    case FALSE:\n      return new TypePair(null, null);\n    case UNKNOWN:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n    case FALSE:\n      return new TypePair(null, null);\n    case UNKNOWN:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n    case FALSE:\n      return new TypePair(null, null);\n    case UNKNOWN:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n    case FALSE:\n      return new TypePair(null, null);\n    case UNKNOWN:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n    case FALSE:\n      return new TypePair(null, null);\n    case UNKNOWN:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n    case FALSE:\n      return new TypePair(null, null);\n    case UNKNOWN:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n    case FALSE:\n      return new TypePair(null, null);\n    case UNKNOWN:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n    case FALSE:\n      return new TypePair(null, null);\n    case UNKNOWN:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n    case FALSE:\n      return new TypePair(null, null);\n    case UNKNOWN:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n    case FALSE:\n      return new TypePair(null, null);\n    case UNKNOWN:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_150_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1451-1466": {
      "loc": "1451-1466",
      "input": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.VAR:\n// buggy line:      defineVar(n, parent);\n// buggy line:      break;\n// buggy line:  }",
      "function range": "1443,5-1466,5",
      "output": [
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n    default:\n      break;\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n    default:\n      break;\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n    default:\n      break;\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n    default:\n      break;\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n    default:\n      break;\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n    default:\n      break;\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n    default:\n      break;\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n    default:\n      break;\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n    default:\n      break;\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n    default:\n      break;\n  }\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_152_/src/com/google/javascript/rhino/jstype/FunctionType.java_871-872": {
      "loc": "871-872",
      "input": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n// buggy line:  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);",
      "function range": "861,3-892,3",
      "output": [
        {
          "patch": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  return this;\n}",
          "correctness": "plausible"
        }
      ]
    },
    "Closure_159_/src/com/google/javascript/jscomp/InlineFunctions.java_777-781": {
      "loc": "777-781",
      "input": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed != null);\n// buggy line:  if (node.getType() == Token.CALL) {\n// buggy line:    Node child = node.getFirstChild();\n// buggy line:    if (child.getType() == Token.NAME) {\n// buggy line:      changed.add(child.getString());",
      "function range": "773,3-787,3",
      "output": [
        {
          "patch": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_168_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1996-1997": {
      "loc": "1996-1997",
      "input": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild() != null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n// buggy line:  if (t.getScopeDepth() <= 2) {",
      "function range": "1987,5-2038,5",
      "output": [
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n  if (t.getScopeDepth() <= 1) {\n    data.get(t.getScopeRoot()).recordNonEmptyFunction();\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n  if (t.getScopeDepth() <= 1) {\n    data.get(t.getScopeRoot()).recordNonEmptyFunction();\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n  if (t.getScopeDepth() <= 1) {\n    data.get(t.getScopeRoot()).recordNonEmptyFunction();\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n  if (t.getScopeDepth() <= 1) {\n    data.get(t.getScopeRoot()).recordNonEmptyFunction();\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n  if (t.getScopeDepth() <= 1) {\n    data.get(t.getScopeRoot()).recordNonEmptyFunction();\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n  if (t.getScopeDepth() <= 1) {\n    data.get(t.getScopeRoot()).recordNonEmptyFunction();\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n  if (t.getScopeDepth() <= 1) {\n    data.get(t.getScopeRoot()).recordNonEmptyFunction();\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n  if (t.getScopeDepth() <= 1) {\n    data.get(t.getScopeRoot()).recordNonEmptyFunction();\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n  if (t.getScopeDepth() <= 1) {\n    data.get(t.getScopeRoot()).recordNonEmptyFunction();\n  }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n  if (t.getScopeDepth() <= 1) {\n    data.get(t.getScopeRoot()).recordNonEmptyFunction();\n  }\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_2_/src/java/org/apache/commons/codec/binary/Base64.java_446-447": {
      "loc": "446-447",
      "input": "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n// buggy line:        if (lineLength > 0) {",
      "function range": "414,5-473,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_4_/src/java/org/apache/commons/codec/binary/Base64.java_225-226": {
      "loc": "225-226",
      "input": "public Base64() {\n// buggy line:    this(false);",
      "function range": "224,5-226,5",
      "output": [
        {
          "patch": "public Base64() {\n        this(true);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Base64() {\n        this(true);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Base64() {\n        this(true);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Base64() {\n        this(true);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Base64() {\n        this(true);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Base64() {\n        this(true);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Base64() {\n        this(true);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Base64() {\n        this(true);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Base64() {\n        this(true);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Base64() {\n        this(true);\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Codec_7_/src/java/org/apache/commons/codec/binary/Base64.java_670-671": {
      "loc": "670-671",
      "input": "public static String encodeBase64String(byte[] binaryData) {\n// buggy line:    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));",
      "function range": "669,5-671,5",
      "output": [
        {
          "patch": "public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData));\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData));\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData));\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData));\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData));\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData));\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData));\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData));\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData));\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData));\n    }",
          "correctness": "plausible"
        }
      ]
    },
    "Codec_9_/src/java/org/apache/commons/codec/binary/Base64.java_827-828": {
      "loc": "827-828",
      "input": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n// buggy line:    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);",
      "function range": "822,5-837,5",
      "output": [
        {
          "patch": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n    }\n    byte[] base64Data = new byte[(int) len];\n    bin2b64(binaryData, 0, base64Data, 0, binaryData.length);\n    if (isChunked) {\n        base64Data[base64Data.length - 2] = (byte) CHUNK_SEPARATOR;\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    } else if (!urlSafe) {\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    }\n    return base64Data;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n    }\n    byte[] base64Data = new byte[(int) len];\n    bin2b64(binaryData, 0, base64Data, 0, binaryData.length);\n    if (isChunked) {\n        base64Data[base64Data.length - 2] = (byte) CHUNK_SEPARATOR;\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    } else if (!urlSafe) {\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    }\n    return base64Data;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n    }\n    byte[] base64Data = new byte[(int) len];\n    bin2b64(binaryData, 0, base64Data, 0, binaryData.length);\n    if (isChunked) {\n        base64Data[base64Data.length - 2] = (byte) CHUNK_SEPARATOR;\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    } else if (!urlSafe) {\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    }\n    return base64Data;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n    }\n    byte[] base64Data = new byte[(int) len];\n    bin2b64(binaryData, 0, base64Data, 0, binaryData.length);\n    if (isChunked) {\n        base64Data[base64Data.length - 2] = (byte) CHUNK_SEPARATOR;\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    } else if (!urlSafe) {\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    }\n    return base64Data;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n    }\n    byte[] base64Data = new byte[(int) len];\n    bin2b64(binaryData, 0, base64Data, 0, binaryData.length);\n    if (isChunked) {\n        base64Data[base64Data.length - 2] = (byte) CHUNK_SEPARATOR;\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    } else if (!urlSafe) {\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    }\n    return base64Data;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n    }\n    byte[] base64Data = new byte[(int) len];\n    bin2b64(binaryData, 0, base64Data, 0, binaryData.length);\n    if (isChunked) {\n        base64Data[base64Data.length - 2] = (byte) CHUNK_SEPARATOR;\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    } else if (!urlSafe) {\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    }\n    return base64Data;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n    }\n    byte[] base64Data = new byte[(int) len];\n    bin2b64(binaryData, 0, base64Data, 0, binaryData.length);\n    if (isChunked) {\n        base64Data[base64Data.length - 2] = (byte) CHUNK_SEPARATOR;\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    } else if (!urlSafe) {\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    }\n    return base64Data;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n    }\n    byte[] base64Data = new byte[(int) len];\n    bin2b64(binaryData, 0, base64Data, 0, binaryData.length);\n    if (isChunked) {\n        base64Data[base64Data.length - 2] = (byte) CHUNK_SEPARATOR;\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    } else if (!urlSafe) {\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    }\n    return base64Data;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n    }\n    byte[] base64Data = new byte[(int) len];\n    bin2b64(binaryData, 0, base64Data, 0, binaryData.length);\n    if (isChunked) {\n        base64Data[base64Data.length - 2] = (byte) CHUNK_SEPARATOR;\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    } else if (!urlSafe) {\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    }\n    return base64Data;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n    }\n    byte[] base64Data = new byte[(int) len];\n    bin2b64(binaryData, 0, base64Data, 0, binaryData.length);\n    if (isChunked) {\n        base64Data[base64Data.length - 2] = (byte) CHUNK_SEPARATOR;\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    } else if (!urlSafe) {\n        base64Data[base64Data.length - 1] = (byte) CHUNK_SEPARATOR;\n    }\n    return base64Data;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_10_/src/java/org/apache/commons/codec/language/Caverphone.java_76-77": {
      "loc": "76-77",
      "input": "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n// buggy line:    txt = txt.replaceAll(\"^mb\", \"m2\");",
      "function range": "50,5-142,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_17_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_339-340": {
      "loc": "339-340",
      "input": "public static String newStringIso8859_1(final byte[] bytes) {\n// buggy line:    return new String(bytes, Charsets.ISO_8859_1);",
      "function range": "338,5-340,5",
      "output": [
        {
          "patch": "public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charset.forName(\"ISO-8859-1\"));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charset.forName(\"ISO-8859-1\"));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charset.forName(\"ISO-8859-1\"));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charset.forName(\"ISO-8859-1\"));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charset.forName(\"ISO-8859-1\"));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charset.forName(\"ISO-8859-1\"));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charset.forName(\"ISO-8859-1\"));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charset.forName(\"ISO-8859-1\"));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charset.forName(\"ISO-8859-1\"));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charset.forName(\"ISO-8859-1\"));\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Codec_18_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_81-82": {
      "loc": "81-82",
      "input": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));",
      "function range": "71,5-82,5",
      "output": [
        {
          "patch": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    if (cs1.length()!= cs2.length()) {\n        return false;\n    }\n    for (int i = 0; i < cs1.length(); i++) {\n        if (cs1.charAt(i)!= cs2.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}",
          "correctness": "plausible"
        }
      ]
    },
    "Collections_26_/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java_277-278": {
      "loc": "277-278",
      "input": "\n// buggy line:private Object readResolve() {",
      "function range": "277,5-280,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        }
      ]
    },
    "Compress_5_/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java_239-241": {
      "loc": "239-241",
      "input": "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n                ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n// buggy line:        if (read == 0 && inf.finished()) {\n// buggy line:            return -1;",
      "function range": "191,5-246,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        }
      ]
    },
    "Compress_12_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java_198-199": {
      "loc": "198-199",
      "input": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n// buggy line:    currEntry = new TarArchiveEntry(headerBuf);",
      "function range": "172,5-238,5",
      "output": [
        {
          "patch": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    return currEntry;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    return currEntry;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    return currEntry;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    return currEntry;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    return currEntry;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    return currEntry;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    return currEntry;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    return currEntry;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    return currEntry;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    return currEntry;\n  }",
          "correctness": "wrong"
        }
      ]
    },
    "Compress_14_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_65-73": {
      "loc": "65-73",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n// buggy line:    boolean allNUL = true;\n// buggy line:    for (int i = start; i < end; i++){\n// buggy line:        if (buffer[i] != 0){\n// buggy line:            allNUL = false;\n// buggy line:            break;\n// buggy line:        }\n// buggy line:    }\n// buggy line:    if (allNUL) {",
      "function range": "56,5-112,5",
      "output": [
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0xFF);\n    }\n    return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0xFF);\n    }\n    return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0xFF);\n    }\n    return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0xFF);\n    }\n    return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0xFF);\n    }\n    return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0xFF);\n    }\n    return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0xFF);\n    }\n    return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0xFF);\n    }\n    return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0xFF);\n    }\n    return result;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0xFF);\n    }\n    return result;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Compress_19_/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java_259-260": {
      "loc": "259-260",
      "input": "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData != null) {\n        int expectedLength = (hasUncompressedSize ? DWORD : 0)\n            + (hasCompressedSize ? DWORD : 0)\n            + (hasRelativeHeaderOffset ? DWORD : 0)\n            + (hasDiskStart ? WORD : 0);\n// buggy line:        if (rawCentralDirectoryData.length != expectedLength) {",
      "function range": "249,5-287,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        }
      ]
    },
    "Compress_23_/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java_112-113": {
      "loc": "112-113",
      "input": "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n// buggy line:        dictSize |= (coder.properties[i + 1] << (8 * i));",
      "function range": "106,9-118,9",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_27_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_133-137": {
      "loc": "133-137",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n// buggy line:    if (start == end) {\n// buggy line:        throw new IllegalArgumentException(\n// buggy line:                exceptionMessage(buffer, offset, length, start, trailer));\n// buggy line:    }",
      "function range": "102,5-150,5",
      "output": [
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end){\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++){\n        if (buffer[i] < '0' || buffer[i] > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++){\n        if (buffer[i] < '0' || buffer[i] > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end){\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++){\n        if (buffer[i] < '0' || buffer[i] > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end){\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++){\n        if (buffer[i] < '0' || buffer[i] > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++){\n        if (buffer[i] < '0' || buffer[i] > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end){\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++){\n        if (buffer[i] < '0' || buffer[i] > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end){\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++){\n        if (buffer[i] < '0' || buffer[i] > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++){\n        if (buffer[i] < '0' || buffer[i] > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end){\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++){\n        if (buffer[i] < '0' || buffer[i] > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end){\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++){\n        if (buffer[i] < '0' || buffer[i] > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n        result = (result << 3) + (buffer[i] - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_31_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_135-138": {
      "loc": "135-138",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n// buggy line:        if (currentByte == 0) {\n// buggy line:            break;\n// buggy line:        }",
      "function range": "101,5-148,5",
      "output": [
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            break;\n        }\n        result = (result << 3) + (currentByte - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            break;\n        }\n        result = (result << 3) + (currentByte - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            break;\n        }\n        result = (result << 3) + (currentByte - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            break;\n        }\n        result = (result << 3) + (currentByte - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            break;\n        }\n        result *= 8;\n        result += currentByte - '0';\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            break;\n        }\n        result = (result << 3) + (currentByte - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            break;\n        }\n        result = (result << 3) + (currentByte - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            break;\n        }\n        result = (result << 3) + (currentByte - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            break;\n        }\n        result *= 8;\n        result += currentByte - '0';\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            break;\n        }\n        result = (result << 3) + (currentByte - '0');\n    }\n    return result;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_38_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java_859-860": {
      "loc": "859-860",
      "input": "@Override\npublic boolean isDirectory() {\n    if (file != null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n// buggy line:    if (getName().endsWith(\"/\")) {",
      "function range": "849,5-864,5",
      "output": [
        {
          "patch": "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n    return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n    return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n    return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n    return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n    return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n    return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n    return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n    return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n    return false;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n    return false;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Compress_46_/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java_529-531": {
      "loc": "529-531",
      "input": "private static ZipLong unixTimeToZipLong(long l) {\n// buggy line:    final long TWO_TO_32 = 0x100000000L;\n// buggy line:    if (l >= TWO_TO_32) {",
      "function range": "528,5-534,5",
      "output": [
        {
          "patch": "private static ZipLong unixTimeToZipLong(long l) {\n        final long TWO_TO_32 = 0x80000000L;\n        if (l >= TWO_TO_32) {\n            return new ZipLong(TWO_TO_32 - 1);\n        } else {\n            return new ZipLong(l);\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong(long l) {\n        final long TWO_TO_32 = 0x80000000L;\n        if (l >= TWO_TO_32) {\n            return new ZipLong(TWO_TO_32 - 1);\n        } else {\n            return new ZipLong(l);\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong(long l) {\n        final long TWO_TO_32 = 0x80000000L;\n        if (l >= TWO_TO_32) {\n            return new ZipLong(TWO_TO_32 - 1);\n        } else {\n            return new ZipLong(l);\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong(long l) {\n        final long TWO_TO_32 = 0x80000000L;\n        if (l >= TWO_TO_32) {\n            return new ZipLong(TWO_TO_32 - 1);\n        } else {\n            return new ZipLong(l);\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong(long l) {\n        final long TWO_TO_32 = 0x80000000L;\n        if (l >= TWO_TO_32) {\n            return new ZipLong(TWO_TO_32 - 1);\n        } else {\n            return new ZipLong(l);\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong(long l) {\n        final long TWO_TO_32 = 0x80000000L;\n        if (l >= TWO_TO_32) {\n            return new ZipLong(TWO_TO_32 - 1);\n        } else {\n            return new ZipLong(l);\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong(long l) {\n        final long TWO_TO_32 = 0x80000000L;\n        if (l >= TWO_TO_32) {\n            return new ZipLong(TWO_TO_32 - 1);\n        } else {\n            return new ZipLong(l);\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong(long l) {\n        final long TWO_TO_32 = 0x80000000L;\n        if (l >= TWO_TO_32) {\n            return new ZipLong(TWO_TO_32 - 1);\n        } else {\n            return new ZipLong(l);\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong(long l) {\n        final long TWO_TO_32 = 0x80000000L;\n        if (l >= TWO_TO_32) {\n            return new ZipLong(TWO_TO_32 - 1);\n        } else {\n            return new ZipLong(l);\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong(long l) {\n        final long TWO_TO_32 = 0x80000000L;\n        if (l >= TWO_TO_32) {\n            return new ZipLong(TWO_TO_32 - 1);\n        } else {\n            return new ZipLong(l);\n        }\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Csv_1_/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java_58-59": {
      "loc": "58-59",
      "input": "@Override\npublic int read() throws IOException {\n    int current = super.read();\n// buggy line:    if (current == '\\n') {",
      "function range": "55,5-63,5",
      "output": [
        {
          "patch": "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == '\\r') {\n        int next = super.read();\n        if (next!= '\\n') {\n            super.unread(next);\n        }\n    }\n    return current;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == '\\r') {\n        int next = super.read();\n        if (next!= '\\n') {\n            super.unread(next);\n        }\n    }\n    return current;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == '\\r') {\n        int next = super.read();\n        if (next!= '\\n') {\n            super.unread(next);\n        }\n    }\n    return current;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == '\\r') {\n        int next = super.read();\n        if (next!= '\\n') {\n            super.unread(next);\n        }\n    }\n    return current;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == '\\r') {\n        int next = super.read();\n        if (next!= '\\n') {\n            super.unread(next);\n        }\n    }\n    return current;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == '\\r') {\n        int next = super.read();\n        if (next!= '\\n') {\n            super.unread(next);\n        }\n    }\n    return current;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == '\\r') {\n        int next = super.read();\n        if (next!= '\\n') {\n            super.unread(next);\n        }\n    }\n    return current;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == '\\r') {\n        int next = super.read();\n        if (next!= '\\n') {\n            super.unread(next);\n        }\n    }\n    return current;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == '\\r') {\n        int next = super.read();\n        if (next!= '\\n') {\n            super.unread(next);\n        }\n    }\n    return current;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == '\\r') {\n        int next = super.read();\n        if (next!= '\\n') {\n            super.unread(next);\n        }\n    }\n    return current;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Csv_4_/src/main/java/org/apache/commons/csv/CSVParser.java_288-289": {
      "loc": "288-289",
      "input": "public Map<String, Integer> getHeaderMap() {\n// buggy line:    return new LinkedHashMap<String, Integer>(this.headerMap);",
      "function range": "287,5-289,5",
      "output": [
        {
          "patch": "public Map<String, Integer> getHeaderMap() {\n        LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(this.headerMap.size());\n        map.putAll(this.headerMap);\n        return map;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Map<String, Integer> getHeaderMap() {\n        LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(this.headerMap.size());\n        map.putAll(this.headerMap);\n        return map;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Map<String, Integer> getHeaderMap() {\n        LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(this.headerMap.size());\n        map.putAll(this.headerMap);\n        return map;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Map<String, Integer> getHeaderMap() {\n        LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(this.headerMap.size());\n        map.putAll(this.headerMap);\n        return map;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Map<String, Integer> getHeaderMap() {\n        LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(this.headerMap.size());\n        map.putAll(this.headerMap);\n        return map;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Map<String, Integer> getHeaderMap() {\n        LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(this.headerMap.size());\n        map.putAll(this.headerMap);\n        return map;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Map<String, Integer> getHeaderMap() {\n        LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(this.headerMap.size());\n        map.putAll(this.headerMap);\n        return map;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Map<String, Integer> getHeaderMap() {\n        LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(this.headerMap.size());\n        map.putAll(this.headerMap);\n        return map;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Map<String, Integer> getHeaderMap() {\n        LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(this.headerMap.size());\n        map.putAll(this.headerMap);\n        return map;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public Map<String, Integer> getHeaderMap() {\n        LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(this.headerMap.size());\n        map.putAll(this.headerMap);\n        return map;\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Csv_11_/src/main/java/org/apache/commons/csv/CSVParser.java_384-385": {
      "loc": "384-385",
      "input": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n// buggy line:                final boolean emptyHeader = header.trim().isEmpty();",
      "function range": "359,5-394,5",
      "output": [
        {
          "patch": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.isEmpty();\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.trim().isEmpty();\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.trim().isEmpty();\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.isEmpty();\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.trim().isEmpty();\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.trim().isEmpty();\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.isEmpty();\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.isEmpty();\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.isEmpty();\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.isEmpty();\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }",
          "correctness": "wrong"
        }
      ]
    },
    "Csv_14_/src/main/java/org/apache/commons/csv/CSVFormat.java_1039-1040": {
      "loc": "1039-1040",
      "input": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {",
      "function range": "1001,5-1106,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Csv_15_/src/main/java/org/apache/commons/csv/CSVFormat.java_1189-1192": {
      "loc": "1189-1192",
      "input": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n// buggy line:                quote = true;\n// buggy line:            } else if (c <= COMMENT) {",
      "function range": "1151,5-1256,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Gson_10_/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java_122-124": {
      "loc": "122-124",
      "input": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n// buggy line:  TypeAdapter t =\n// buggy line:    new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());",
      "function range": "118,7-125,7",
      "output": [
        {
          "patch": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Gson_15_/gson/src/main/java/com/google/gson/stream/JsonWriter.java_495-496": {
      "loc": "495-496",
      "input": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n// buggy line:  if (Double.isNaN(value) || Double.isInfinite(value)) {",
      "function range": "493,3-501,3",
      "output": [
        {
          "patch": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    generator.writeString(Double.toString(value));\n  } else {\n    generator.writeNumber(value);\n  }\n  return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    generator.writeString(Double.toString(value));\n  } else {\n    generator.writeNumber(value);\n  }\n  return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    generator.writeString(Double.toString(value));\n  } else {\n    generator.writeNumber(value);\n  }\n  return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    generator.writeString(Double.toString(value));\n  } else {\n    generator.writeNumber(value);\n  }\n  return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    generator.writeString(Double.toString(value));\n  } else {\n    generator.writeNumber(value);\n  }\n  return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    generator.writeString(Double.toString(value));\n  } else {\n    generator.writeNumber(value);\n  }\n  return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    generator.writeString(Double.toString(value));\n  } else {\n    generator.writeNumber(value);\n  }\n  return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    generator.writeString(Double.toString(value));\n  } else {\n    generator.writeNumber(value);\n  }\n  return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    generator.writeString(Double.toString(value));\n  } else {\n    generator.writeNumber(value);\n  }\n  return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    generator.writeString(Double.toString(value));\n  } else {\n    generator.writeNumber(value);\n  }\n  return this;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Gson_17_/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java_99-101": {
      "loc": "99-101",
      "input": "@Override\npublic Date read(JsonReader in) throws IOException {\n// buggy line:  if (in.peek() != JsonToken.STRING) {\n// buggy line:    throw new JsonParseException(\"The date should be a string value\");",
      "function range": "97,3-113,3",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_5_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-194": {
      "loc": "193-194",
      "input": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i++);",
      "function range": "185,5-205,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        switch (c) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case '_':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n                return i;\n            default:\n                return -1;\n        }\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        switch (c) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case '_':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n                return i;\n            default:\n                return -1;\n        }\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        switch (c) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case '_':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n                break;\n            default:\n                return -1;\n        }\n    }\n    return i;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        switch (c) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case '_':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n                return i;\n            default:\n                return -1;\n        }\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        switch (c) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case '_':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n                break;\n            default:\n                return -1;\n        }\n    }\n    return i;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        switch (c) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case '_':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n                break;\n            default:\n                return -1;\n        }\n    }\n    return i;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        switch (c) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n            case '_':\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n                break;\n            default:\n                return -1;\n        }\n    }\n    return i;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_6_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-195": {
      "loc": "193-195",
      "input": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n// buggy line:    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i);",
      "function range": "185,5-206,5",
      "output": [
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonCore_8_/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java_307-308": {
      "loc": "307-308",
      "input": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray != null)  return _resultArray;\n    if (_resultString != null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n// buggy line:    if (!_hasSegments)  return _currentSegment;",
      "function range": "298,5-310,5",
      "output": [
        {
          "patch": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    return null;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonCore_20_/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java_1330-1331": {
      "loc": "1330-1331",
      "input": "public void writeEmbeddedObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\",",
      "function range": "1328,5-1332,5",
      "output": [
        {
          "patch": "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object == null) {\n            writeNull();\n        } else if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Integer) {\n            writeNumber(((Integer) object).intValue());\n        } else if (object instanceof Long) {\n            writeNumber(((Long) object).longValue());\n        } else if (object instanceof Double) {\n            writeNumber(((Double) object).doubleValue());\n        } else if (object instanceof Float) {\n            writeNumber(((Float) object).floatValue());\n        } else if (object instanceof Short) {\n            writeNumber(((Short) object).shortValue());\n        } else if (object instanceof Byte) {\n            writeNumber(((Byte) object).byteValue());\n        } else if (object instanceof Character) {\n            writeString(String.valueOf(((Character) object).charValue()));\n        } else if (object instanceof Boolean) {\n            writeBoolean(((Boolean) object).booleanValue());\n        } else if (object instanceof byte[]) {\n            writeBinary((byte[]) object);\n        } else if (object instanceof BigInteger) {\n            writeNumber(((BigInteger) object).longValue());\n        } else if (object instanceof BigDecimal) {\n            writeNumber(((BigDecimal) object).doubleValue());\n        } else if (object instanceof Date) {\n            writeNumber(((Date) object).getTime());\n        } else if (object instanceof UUID) {\n            writeString(object.toString());\n        } else if (object instanceof Enum<?>) {\n            writeString(object.toString());\n        } else {\n            throw new JsonGenerationException(\"No native support for writing embedded objects of type \" + object.getClass().getName());\n        }\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object == null) {\n            writeNull();\n        } else if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Integer) {\n            writeNumber(((Integer) object).intValue());\n        } else if (object instanceof Long) {\n            writeNumber(((Long) object).longValue());\n        } else if (object instanceof Double) {\n            writeNumber(((Double) object).doubleValue());\n        } else if (object instanceof Float) {\n            writeNumber(((Float) object).floatValue());\n        } else if (object instanceof Short) {\n            writeNumber(((Short) object).shortValue());\n        } else if (object instanceof Byte) {\n            writeNumber(((Byte) object).byteValue());\n        } else if (object instanceof Character) {\n            writeString(String.valueOf(((Character) object).charValue()));\n        } else if (object instanceof Boolean) {\n            writeBoolean(((Boolean) object).booleanValue());\n        } else if (object instanceof byte[]) {\n            writeBinary((byte[]) object);\n        } else if (object instanceof BigInteger) {\n            writeNumber(((BigInteger) object).longValue());\n        } else if (object instanceof BigDecimal) {\n            writeNumber(((BigDecimal) object).doubleValue());\n        } else if (object instanceof Date) {\n            writeNumber(((Date) object).getTime());\n        } else if (object instanceof UUID) {\n            writeString(object.toString());\n        } else if (object instanceof Enum<?>) {\n            writeString(object.toString());\n        } else {\n            throw new JsonGenerationException(\"No native support for writing embedded objects of type \" + object.getClass().getName());\n        }\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object == null) {\n            writeNull();\n        } else if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Integer) {\n            writeNumber(((Integer) object).intValue());\n        } else if (object instanceof Long) {\n            writeNumber(((Long) object).longValue());\n        } else if (object instanceof Double) {\n            writeNumber(((Double) object).doubleValue());\n        } else if (object instanceof Float) {\n            writeNumber(((Float) object).floatValue());\n        } else if (object instanceof Short) {\n            writeNumber(((Short) object).shortValue());\n        } else if (object instanceof Byte) {\n            writeNumber(((Byte) object).byteValue());\n        } else if (object instanceof Character) {\n            writeString(String.valueOf(((Character) object).charValue()));\n        } else if (object instanceof Boolean) {\n            writeBoolean(((Boolean) object).booleanValue());\n        } else if (object instanceof byte[]) {\n            writeBinary((byte[]) object);\n        } else if (object instanceof BigInteger) {\n            writeNumber(((BigInteger) object).longValue());\n        } else if (object instanceof BigDecimal) {\n            writeNumber(((BigDecimal) object).doubleValue());\n        } else if (object instanceof Date) {\n            writeNumber(((Date) object).getTime());\n        } else if (object instanceof UUID) {\n            writeString(object.toString());\n        } else if (object instanceof Enum<?>) {\n            writeString(object.toString());\n        } else {\n            throw new JsonGenerationException(\"No native support for writing embedded objects of type \" + object.getClass().getName(), this);\n        }\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object == null) {\n            writeNull();\n        } else if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Integer) {\n            writeNumber(((Integer) object).intValue());\n        } else if (object instanceof Long) {\n            writeNumber(((Long) object).longValue());\n        } else if (object instanceof Double) {\n            writeNumber(((Double) object).doubleValue());\n        } else if (object instanceof Float) {\n            writeNumber(((Float) object).floatValue());\n        } else if (object instanceof Short) {\n            writeNumber(((Short) object).shortValue());\n        } else if (object instanceof Byte) {\n            writeNumber(((Byte) object).byteValue());\n        } else if (object instanceof Character) {\n            writeString(String.valueOf(((Character) object).charValue()));\n        } else if (object instanceof Boolean) {\n            writeBoolean(((Boolean) object).booleanValue());\n        } else if (object instanceof byte[]) {\n            writeBinary((byte[]) object);\n        } else if (object instanceof BigInteger) {\n            writeNumber(((BigInteger) object).toByteArray());\n        } else if (object instanceof BigDecimal) {\n            writeNumber(((BigDecimal) object).toByteArray());\n        } else if (object instanceof Date) {\n            writeNumber(((Date) object).getTime());\n        } else if (object instanceof UUID) {\n            writeString(object.toString());\n        } else if (object instanceof Enum<?>) {\n            writeString(object.toString());\n        } else {\n            throw new JsonGenerationException(\"No native support for writing embedded objects of type \" + object.getClass().getName());\n        }\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object == null) {\n            writeNull();\n        } else if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Integer) {\n            writeNumber(((Integer) object).intValue());\n        } else if (object instanceof Long) {\n            writeNumber(((Long) object).longValue());\n        } else if (object instanceof Double) {\n            writeNumber(((Double) object).doubleValue());\n        } else if (object instanceof Float) {\n            writeNumber(((Float) object).floatValue());\n        } else if (object instanceof Short) {\n            writeNumber(((Short) object).shortValue());\n        } else if (object instanceof Byte) {\n            writeNumber(((Byte) object).byteValue());\n        } else if (object instanceof Character) {\n            writeString(String.valueOf(((Character) object).charValue()));\n        } else if (object instanceof Boolean) {\n            writeBoolean(((Boolean) object).booleanValue());\n        } else if (object instanceof byte[]) {\n            writeBinary((byte[]) object);\n        } else if (object instanceof BigInteger) {\n            writeNumber(((BigInteger) object).longValue());\n        } else if (object instanceof BigDecimal) {\n            writeNumber(((BigDecimal) object).doubleValue());\n        } else if (object instanceof Date) {\n            writeNumber(((Date) object).getTime());\n        } else if (object instanceof UUID) {\n            writeString(object.toString());\n        } else if (object instanceof Enum<?>) {\n            writeString(object.toString());\n        } else {\n            throw new JsonGenerationException(\"No native support for writing embedded objects of type \" + object.getClass().getName(), this);\n        }\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object == null) {\n            writeNull();\n        } else if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Integer) {\n            writeNumber(((Integer) object).intValue());\n        } else if (object instanceof Long) {\n            writeNumber(((Long) object).longValue());\n        } else if (object instanceof Double) {\n            writeNumber(((Double) object).doubleValue());\n        } else if (object instanceof Float) {\n            writeNumber(((Float) object).floatValue());\n        } else if (object instanceof Short) {\n            writeNumber(((Short) object).shortValue());\n        } else if (object instanceof Byte) {\n            writeNumber(((Byte) object).byteValue());\n        } else if (object instanceof Character) {\n            writeString(String.valueOf(((Character) object).charValue()));\n        } else if (object instanceof Boolean) {\n            writeBoolean(((Boolean) object).booleanValue());\n        } else if (object instanceof byte[]) {\n            writeBinary((byte[]) object);\n        } else if (object instanceof BigInteger) {\n            writeNumber(((BigInteger) object).toByteArray());\n        } else if (object instanceof BigDecimal) {\n            writeNumber(((BigDecimal) object).toByteArray());\n        } else if (object instanceof Date) {\n            writeNumber(((Date) object).getTime());\n        } else if (object instanceof UUID) {\n            writeString(object.toString());\n        } else if (object instanceof Enum<?>) {\n            writeString(object.toString());\n        } else {\n            throw new JsonGenerationException(\"No native support for writing embedded objects of type \" + object.getClass().getName());\n        }\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object == null) {\n            writeNull();\n        } else if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Integer) {\n            writeNumber(((Integer) object).intValue());\n        } else if (object instanceof Long) {\n            writeNumber(((Long) object).longValue());\n        } else if (object instanceof Double) {\n            writeNumber(((Double) object).doubleValue());\n        } else if (object instanceof Float) {\n            writeNumber(((Float) object).floatValue());\n        } else if (object instanceof Short) {\n            writeNumber(((Short) object).shortValue());\n        } else if (object instanceof Byte) {\n            writeNumber(((Byte) object).byteValue());\n        } else if (object instanceof Character) {\n            writeString(String.valueOf(((Character) object).charValue()));\n        } else if (object instanceof Boolean) {\n            writeBoolean(((Boolean) object).booleanValue());\n        } else if (object instanceof byte[]) {\n            writeBinary((byte[]) object);\n        } else if (object instanceof BigInteger) {\n            writeNumber(((BigInteger) object).longValue());\n        } else if (object instanceof BigDecimal) {\n            writeNumber(((BigDecimal) object).doubleValue());\n        } else if (object instanceof Date) {\n            writeNumber(((Date) object).getTime());\n        } else if (object instanceof UUID) {\n            writeString(object.toString());\n        } else if (object instanceof Enum<?>) {\n            writeString(object.toString());\n        } else if (object instanceof Class<?>) {\n            writeString(((Class<?>) object).getName());\n        } else {\n            throw new JsonGenerationException(\"No native support for writing embedded objects of type \" + object.getClass().getName(), this);\n        }\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object == null) {\n            writeNull();\n        } else if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Integer) {\n            writeNumber(((Integer) object).intValue());\n        } else if (object instanceof Long) {\n            writeNumber(((Long) object).longValue());\n        } else if (object instanceof Double) {\n            writeNumber(((Double) object).doubleValue());\n        } else if (object instanceof Float) {\n            writeNumber(((Float) object).floatValue());\n        } else if (object instanceof Short) {\n            writeNumber(((Short) object).shortValue());\n        } else if (object instanceof Byte) {\n            writeNumber(((Byte) object).byteValue());\n        } else if (object instanceof Character) {\n            writeString(String.valueOf(((Character) object).charValue()));\n        } else if (object instanceof Boolean) {\n            writeBoolean(((Boolean) object).booleanValue());\n        } else if (object instanceof byte[]) {\n            writeBinary((byte[]) object);\n        } else if (object instanceof BigInteger) {\n            writeNumber(((BigInteger) object).longValue());\n        } else if (object instanceof BigDecimal) {\n            writeNumber(((BigDecimal) object).doubleValue());\n        } else if (object instanceof Date) {\n            writeNumber(((Date) object).getTime());\n        } else if (object instanceof UUID) {\n            writeString(object.toString());\n        } else if (object instanceof Enum<?>) {\n            writeString(object.toString());\n        } else if (object instanceof Class<?>) {\n            writeString(((Class<?>) object).getName());\n        } else {\n            throw new JsonGenerationException(\"No native support for writing embedded objects of type \" + object.getClass().getName());\n        }\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object == null) {\n            writeNull();\n        } else if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Integer) {\n            writeNumber(((Integer) object).intValue());\n        } else if (object instanceof Long) {\n            writeNumber(((Long) object).longValue());\n        } else if (object instanceof Double) {\n            writeNumber(((Double) object).doubleValue());\n        } else if (object instanceof Float) {\n            writeNumber(((Float) object).floatValue());\n        } else if (object instanceof Short) {\n            writeNumber(((Short) object).shortValue());\n        } else if (object instanceof Byte) {\n            writeNumber(((Byte) object).byteValue());\n        } else if (object instanceof Character) {\n            writeString(String.valueOf(((Character) object).charValue()));\n        } else if (object instanceof Boolean) {\n            writeBoolean(((Boolean) object).booleanValue());\n        } else if (object instanceof byte[]) {\n            writeBinary((byte[]) object);\n        } else if (object instanceof BigInteger) {\n            writeNumber(((BigInteger) object).longValue());\n        } else if (object instanceof BigDecimal) {\n            writeNumber(((BigDecimal) object).doubleValue());\n        } else if (object instanceof Date) {\n            writeNumber(((Date) object).getTime());\n        } else if (object instanceof UUID) {\n            writeString(object.toString());\n        } else if (object instanceof Enum<?>) {\n            writeString(object.toString());\n        } else if (object instanceof Class<?>) {\n            writeString(((Class<?>) object).getName());\n        } else {\n            throw new JsonGenerationException(\"No native support for writing embedded objects of type \" + object.getClass().getName());\n        }\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject(Object object) throws IOException {\n        if (object == null) {\n            writeNull();\n        } else if (object instanceof String) {\n            writeString((String) object);\n        } else if (object instanceof Integer) {\n            writeNumber(((Integer) object).intValue());\n        } else if (object instanceof Long) {\n            writeNumber(((Long) object).longValue());\n        } else if (object instanceof Double) {\n            writeNumber(((Double) object).doubleValue());\n        } else if (object instanceof Float) {\n            writeNumber(((Float) object).floatValue());\n        } else if (object instanceof Short) {\n            writeNumber(((Short) object).shortValue());\n        } else if (object instanceof Byte) {\n            writeNumber(((Byte) object).byteValue());\n        } else if (object instanceof Character) {\n            writeString(String.valueOf(((Character) object).charValue()));\n        } else if (object instanceof Boolean) {\n            writeBoolean(((Boolean) object).booleanValue());\n        } else if (object instanceof byte[]) {\n            writeBinary((byte[]) object);\n        } else if (object instanceof BigInteger) {\n            writeNumber(((BigInteger) object).longValue());\n        } else if (object instanceof BigDecimal) {\n            writeNumber(((BigDecimal) object).doubleValue());\n        } else if (object instanceof Date) {\n            writeNumber(((Date) object).getTime());\n        } else if (object instanceof UUID) {\n            writeString(object.toString());\n        } else if (object instanceof Enum<?>) {\n            writeString(object.toString());\n        } else if (object instanceof Class<?>) {\n            writeString(((Class<?>) object).getName());\n        } else {\n            throw new JsonGenerationException(\"No native support for writing embedded objects of type \" + object.getClass().getName());\n        }\n    }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_25_/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java_1963-1964": {
      "loc": "1963-1964",
      "input": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n// buggy line:        if (i <= maxCode) {",
      "function range": "1948,5-1990,5",
      "output": [
        {
          "patch": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode && codes[i]!= 0) {\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        ++_inputPtr;\n        if (outPtr == outBuf.length) {\n            _textBuffer.setCurrentLength(outPtr);\n            return _textBuffer.getTextBuffer();\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getTextBuffer();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode && codes[i]!= 0) {\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        ++_inputPtr;\n        if (outPtr == outBuf.length) {\n            _textBuffer.setCurrentLength(outPtr);\n            return _textBuffer.getTextBuffer();\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getTextBuffer();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode && codes[i]!= 0) {\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        ++_inputPtr;\n        if (outPtr == outBuf.length) {\n            _textBuffer.setCurrentLength(outPtr);\n            return _textBuffer.getTextBuffer();\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getTextBuffer();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode && codes[i]!= 0) {\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        ++_inputPtr;\n        if (outPtr == outBuf.length) {\n            _textBuffer.setCurrentLength(outPtr);\n            return _textBuffer.getTextBuffer();\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getTextBuffer();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode && codes[i]!= 0) {\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        ++_inputPtr;\n        if (outPtr == outBuf.length) {\n            _textBuffer.setCurrentLength(outPtr);\n            return _textBuffer.getTextBuffer();\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getTextBuffer();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode && codes[i]!= 0) {\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        ++_inputPtr;\n        if (outPtr == outBuf.length) {\n            _textBuffer.setCurrentLength(outPtr);\n            return _textBuffer.getTextBuffer();\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getTextBuffer();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode && codes[i]!= 0) {\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        ++_inputPtr;\n        if (outPtr == outBuf.length) {\n            _textBuffer.setCurrentLength(outPtr);\n            return _textBuffer.getTextBuffer();\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getTextBuffer();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode && codes[i]!= 0) {\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        ++_inputPtr;\n        if (outPtr == outBuf.length) {\n            _textBuffer.setCurrentLength(outPtr);\n            return _textBuffer.getTextBuffer();\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getTextBuffer();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode && codes[i]!= 0) {\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        ++_inputPtr;\n        if (outPtr == outBuf.length) {\n            _textBuffer.setCurrentLength(outPtr);\n            return _textBuffer.getTextBuffer();\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getTextBuffer();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode && codes[i]!= 0) {\n            codes[i] = hash;\n            outBuf[outPtr++] = c;\n        }\n        ++_inputPtr;\n        if (outPtr == outBuf.length) {\n            _textBuffer.setCurrentLength(outPtr);\n            return _textBuffer.getTextBuffer();\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getTextBuffer();\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_12_/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java_303-304": {
      "loc": "303-304",
      "input": "@Override\npublic boolean isCachable() {\n// buggy line:    return (_valueTypeDeserializer == null)",
      "function range": "298,5-305,5",
      "output": [
        {
          "patch": "@Override\npublic boolean isCachable() {\n        return _valueTypeDeserializer!= null && _valueTypeDeserializer.isCachable();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable() {\n        return _valueTypeDeserializer!= null && _valueTypeDeserializer.isCachable();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable() {\n        return _valueTypeDeserializer!= null && _valueTypeDeserializer.isCachable();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable() {\n        return _valueTypeDeserializer!= null && _valueTypeDeserializer.isCachable();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable() {\n        return _valueTypeDeserializer!= null && _valueTypeDeserializer.isCachable();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable() {\n        return _valueTypeDeserializer!= null && _valueTypeDeserializer.isCachable();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable() {\n        return _valueTypeDeserializer!= null && _valueTypeDeserializer.isCachable();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable() {\n        return _valueTypeDeserializer!= null && _valueTypeDeserializer.isCachable();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable() {\n        return _valueTypeDeserializer!= null && _valueTypeDeserializer.isCachable();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable() {\n        return _valueTypeDeserializer!= null && _valueTypeDeserializer.isCachable();\n    }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_16_/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java_112-113": {
      "loc": "112-113",
      "input": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy line:    return (previous != null) && previous.equals(ann);",
      "function range": "107,5-113,5",
      "output": [
        {
          "patch": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return previous == null || previous.equals(ann);\n  }",
          "correctness": "plausible"
        },
        {
          "patch": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return previous == null || previous.equals(ann);\n  }",
          "correctness": "plausible"
        },
        {
          "patch": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return previous == null || previous.equals(ann);\n  }",
          "correctness": "plausible"
        },
        {
          "patch": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return previous == null || previous.equals(ann);\n  }",
          "correctness": "plausible"
        },
        {
          "patch": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return previous == null || previous.equals(ann);\n  }",
          "correctness": "plausible"
        },
        {
          "patch": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return previous == null || previous.equals(ann);\n  }",
          "correctness": "plausible"
        },
        {
          "patch": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return previous == null || previous.equals(ann);\n  }",
          "correctness": "plausible"
        },
        {
          "patch": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return previous == null || previous.equals(ann);\n  }",
          "correctness": "plausible"
        },
        {
          "patch": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return previous == null || previous.equals(ann);\n  }",
          "correctness": "plausible"
        },
        {
          "patch": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return previous == null || previous.equals(ann);\n  }",
          "correctness": "plausible"
        }
      ]
    },
    "JacksonDatabind_17_/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java_180-181": {
      "loc": "180-181",
      "input": "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));",
      "function range": "167,9-193,9",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    case NON_CONCRETE_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_ARRAYS_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    case NON_CONCRETE_AND_OBJECTS_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS_AND_ARRAYS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    default:\n        return false;\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    case NON_CONCRETE_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_ARRAYS_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    case NON_CONCRETE_AND_OBJECTS_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS_AND_ARRAYS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    default:\n        return true;\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    case NON_CONCRETE_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_ARRAYS_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    case NON_CONCRETE_AND_OBJECTS_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS_AND_ARRAYS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    default:\n        return false;\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    case NON_CONCRETE_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECTS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_ARRAYS_AND_OBJECTS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    case NON_CONCRETE_AND_OBJECTS_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE_AND_OBJECTS_AND_ARRAYS:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                );\n    default:\n        return true;\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_27_/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java_794-795": {
      "loc": "794-795",
      "input": "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n// buggy line:            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {",
      "function range": "773,5-857,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_33_/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java_748-749": {
      "loc": "748-749",
      "input": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg != null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann != null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {",
      "function range": "730,5-755,5",
      "output": [
        {
          "patch": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonRawValue.class)) {\n            name = \"value\";\n        }\n    }\n    if (name!= null) {\n        return new PropertyName(name);\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonRawValue.class)) {\n            name = \"value\";\n        }\n    }\n    if (name!= null) {\n        return new PropertyName(name);\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonRawValue.class)) {\n            name = \"value\";\n        }\n    }\n    if (name!= null) {\n        return new PropertyName(name);\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonRawValue.class)) {\n            name = \"value\";\n        }\n    }\n    if (name!= null) {\n        return new PropertyName(name);\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonRawValue.class)) {\n            name = \"value\";\n        }\n    }\n    if (name!= null) {\n        return new PropertyName(name);\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonRawValue.class)) {\n            name = \"value\";\n        }\n    }\n    if (name!= null) {\n        return new PropertyName(name);\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonRawValue.class)) {\n            name = \"value\";\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonRawValue.class)) {\n            name = \"value\";\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}",
          "correctness": "timeout"
        },
        {
          "patch": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonRawValue.class)) {\n            name = \"value\";\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonRawValue.class)) {\n            name = \"value\";\n        }\n    }\n    if (name == null) {\n        name = a.getName();\n    }\n    return new PropertyName(name);\n}",
          "correctness": "timeout"
        }
      ]
    },
    "JacksonDatabind_34_/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java_81-82": {
      "loc": "81-82",
      "input": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n// buggy line:            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);",
      "function range": "73,5-87,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == BigInteger.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Byte.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BYTE);\n        } else if (h == Short.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.SHORT);\n        } else if (h == Integer.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Long.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Float.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.FLOAT);\n        } else if (h == Double.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE);\n        } else if (h == BigDecimal.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Number.class) {\n            visitNumberFormat(visitor, typeHint, JsonParser.NumberType.NUMBER);\n        }\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_37_/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java_135-136": {
      "loc": "135-136",
      "input": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,",
      "function range": "119,5-137,5",
      "output": [
        {
          "patch": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _componentType);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _annotations);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _typeParameters);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _typeParameters);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _typeParameters);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _typeParameters);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _componentType);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _typeParameters);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _annotations);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _annotations);\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_45_/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java_63-64": {
      "loc": "63-64",
      "input": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property != null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format != null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n// buggy line:            if (format.getShape() == JsonFormat.Shape.STRING) {",
      "function range": "49,5-81,5",
      "output": [
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n            if (shape == JsonFormat.Shape.STRING) {\n                return withFormat(Boolean.FALSE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n            if (shape == JsonFormat.Shape.STRING) {\n                return withFormat(Boolean.FALSE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n            if (shape == JsonFormat.Shape.STRING) {\n                return withFormat(Boolean.FALSE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n            if (shape == JsonFormat.Shape.STRING) {\n                return withFormat(Boolean.FALSE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n            if (shape == JsonFormat.Shape.STRING) {\n                return withFormat(Boolean.FALSE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n            if (shape == JsonFormat.Shape.STRING) {\n                return withFormat(Boolean.FALSE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n            if (shape == JsonFormat.Shape.STRING) {\n                return withFormat(Boolean.FALSE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n            if (shape == JsonFormat.Shape.STRING) {\n                return withFormat(Boolean.FALSE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n            if (shape == JsonFormat.Shape.STRING) {\n                return withFormat(Boolean.FALSE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n            if (shape == JsonFormat.Shape.STRING) {\n                return withFormat(Boolean.FALSE, null);\n            }\n        }\n    }\n    return super.createContextual(serializers, property);\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_46_/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java_156-157": {
      "loc": "156-157",
      "input": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n// buggy line:    sb.append(';');",
      "function range": "150,5-158,5",
      "output": [
        {
          "patch": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append('>');\n    return sb;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_57_/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java_1441-1442": {
      "loc": "1441-1442",
      "input": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders != null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), ",
      "function range": "1435,5-1443,5",
      "output": [
        {
          "patch": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), \n                                              src, offset, length), src, offset, length);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), \n                                              src, offset, length), src, offset, length);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), \n                                              src, offset, length), src, offset, length);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), \n                                              src, offset, length), src, offset, length);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), \n                                              src, offset, length), src, offset, length);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), \n                                              src, offset, length), src, offset, length);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), \n                                              src, offset, length), src, offset, length);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), \n                                              src, offset, length), src, offset, length);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), \n                                              src, offset, length), src, offset, length);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), \n                                              src, offset, length), src, offset, length);\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_70_/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java_440-441": {
      "loc": "440-441",
      "input": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n// buggy line:            found = key.equals(prop.getName());",
      "function range": "426,5-453,5",
      "output": [
        {
          "patch": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        for (int j = 0, end2 = props.size(); j < end2; j++) {\n            SettableBeanProperty prop2 = props.get(j);\n            if (prop == prop2) {\n                props.remove(j);\n                break;\n            }\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == null) {\n            continue;\n        }\n        _hashArea[i] = prop;\n    }\n    _size = props.size();\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        for (int j = 0, end2 = props.size(); j < end2; j++) {\n            SettableBeanProperty prop2 = props.get(j);\n            if (prop == prop2) {\n                props.remove(j);\n                break;\n            }\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == null) {\n            continue;\n        }\n        _hashArea[prop.getIndex()] = prop;\n    }\n    _size = props.size();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        for (int j = 0, end2 = props.size(); j < end2; j++) {\n            SettableBeanProperty prop2 = props.get(j);\n            if (prop == prop2) {\n                props.remove(j);\n                break;\n            }\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == null) {\n            continue;\n        }\n        _hashArea[i] = prop;\n    }\n    _size = props.size();\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        for (int j = 0, end2 = props.size(); j < end2; j++) {\n            SettableBeanProperty prop2 = props.get(j);\n            if (prop == prop2) {\n                props.remove(j);\n                break;\n            }\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == null) {\n            continue;\n        }\n        _hashArea[i] = prop;\n    }\n    _size = props.size();\n}",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        for (int j = 0, end2 = props.size(); j < end2; j++) {\n            SettableBeanProperty prop2 = props.get(j);\n            if (prop == prop2) {\n                props.remove(j);\n                break;\n            }\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == null) {\n            continue;\n        }\n        _hashArea[prop.getIndex()] = prop;\n    }\n    _size = props.size();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        for (int j = 0, end2 = props.size(); j < end2; j++) {\n            SettableBeanProperty prop2 = props.get(j);\n            if (prop == prop2) {\n                props.remove(j);\n                break;\n            }\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == null) {\n            continue;\n        }\n        _hashArea[prop.getIndex()] = prop;\n    }\n    _size = props.size();\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        for (int j = 0, end2 = props.size(); j < end2; j++) {\n            SettableBeanProperty prop2 = props.get(j);\n            if (prop == prop2) {\n                props.remove(j);\n                break;\n            }\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == null) {\n            continue;\n        }\n        _hashArea[i] = prop;\n    }\n    _size = props.size();\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        for (int j = 0, end2 = props.size(); j < end2; j++) {\n            SettableBeanProperty prop2 = props.get(j);\n            if (prop == prop2) {\n                props.remove(j);\n                break;\n            }\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == null) {\n            continue;\n        }\n        _hashArea[i] = prop;\n    }\n    _size = props.size();\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        for (int j = 0, end2 = props.size(); j < end2; j++) {\n            SettableBeanProperty prop2 = props.get(j);\n            if (prop == prop2) {\n                props.remove(j);\n                break;\n            }\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == null) {\n            continue;\n        }\n        _hashArea[prop.getIndex()] = prop;\n    }\n    _size = props.size();\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_71_/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java_75-76": {
      "loc": "75-76",
      "input": "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n// buggy line:    if (raw == String.class || raw == Object.class) {",
      "function range": "70,5-116,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_82_/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java_495-496": {
      "loc": "495-496",
      "input": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n            ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n            .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n// buggy line:        ignored = ignorals.getIgnored();",
      "function range": "472,5-615,5",
      "output": [
        {
          "patch": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        ignored = new HashSet<String>();\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            if (prop.isExplicitlyIncluded()) {\n                ignored.add(prop.getName());\n            }\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        ignored = new HashSet<String>();\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            if (prop.isExplicitlyIncluded()) {\n                ignored.add(prop.getName());\n            }\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        ignored = new HashSet<String>();\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            if (prop.isExplicitlyIncluded()) {\n                ignored.add(prop.getName());\n            }\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        ignored = new HashSet<String>();\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            if (prop.isExplicitlyIncluded()) {\n                ignored.add(prop.getName());\n            }\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        ignored = new HashSet<String>();\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            if (prop.isExplicitlyIncluded()) {\n                ignored.add(prop.getName());\n            }\n        }\n    }\n    if (ignored!= null) {\n        builder.addIgnorableProperties(ignored);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        ignored = new HashSet<String>();\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            if (prop.isExplicitlyIncluded()) {\n                ignored.add(prop.getName());\n            }\n        }\n    }\n    if (ignored!= null) {\n        builder.addIgnorableProperties(ignored);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        ignored = new HashSet<String>();\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            if (prop.isExplicitlyIncluded()) {\n                ignored.add(prop.getName());\n            }\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        ignored = new HashSet<String>();\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            if (prop.isExplicitlyIncluded()) {\n                ignored.add(prop.getName());\n            }\n        }\n    }\n    if (ignored!= null) {\n        builder.addIgnorableProperties(ignored);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        ignored = new HashSet<String>();\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            if (prop.isExplicitlyIncluded()) {\n                ignored.add(prop.getName());\n            }\n        }\n    }\n    if (ignored!= null) {\n        builder.addIgnorableProperties(ignored);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        ignored = new HashSet<String>();\n    } else {\n        ignored = null;\n    }\n    if (hasCreatorProps) {\n        if (ignored == null) {\n            ignored = new HashSet<String>();\n        }\n        for (SettableBeanProperty prop : creatorProps) {\n            if (prop.isExplicitlyIncluded()) {\n                ignored.add(prop.getName());\n            }\n        }\n    }\n    if (ignored!= null) {\n        builder.setIgnorableProperties(ignored);\n    }\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_93_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java_83-85": {
      "loc": "83-85",
      "input": "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n// buggy line:        if (full.startsWith(PREFIX_STRING)) {\n// buggy line:            for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {",
      "function range": "67,5-99,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_96_/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java_735-736": {
      "loc": "735-736",
      "input": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1 != candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName != null) || (injectId != null);\n    if (!useProps && (paramDef != null)) {\n// buggy line:        paramName = candidate.findImplicitParamName(0);",
      "function range": "701,5-752,5",
      "output": [
        {
          "patch": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        if (paramName!= null) {\n            useProps = true;\n        }\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        if (paramName!= null) {\n            useProps = true;\n        }\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        if (paramName!= null) {\n            useProps = true;\n        }\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        if (paramName!= null) {\n            useProps = true;\n        }\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        if (paramName!= null) {\n            useProps = true;\n        }\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        if (paramName!= null) {\n            useProps = true;\n        }\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        if (paramName!= null) {\n            useProps = true;\n        }\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        if (paramName!= null) {\n            useProps = true;\n        }\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        if (paramName!= null) {\n            useProps = true;\n        }\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n        if (paramName!= null) {\n            useProps = true;\n        }\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_97_/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java_114-115": {
      "loc": "114-115",
      "input": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);",
      "function range": "104,5-116,5",
      "output": [
        {
          "patch": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        _value.serialize(gen, ctxt);\n    }\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_98_/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java_298-299": {
      "loc": "298-299",
      "input": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n// buggy line:                buffer.assignParameter(typeProp, typeId);",
      "function range": "255,5-311,5",
      "output": [
        {
          "patch": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(_beanType, values);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(_beanType, values);\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_102_/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java_67-70": {
      "loc": "67-70",
      "input": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }",
      "function range": "61,5-136,5",
      "output": [
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property == null) {\n        return this;\n    }\n    JsonSerializer<?> ser = _serializers.serializerFor(property);\n    if (ser!= null) {\n        return ser;\n    }\n    return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property == null) {\n        return this;\n    }\n    JsonSerializer<?> ser = _serializers.serializerFor(property);\n    if (ser!= null) {\n        return ser;\n    }\n    return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property == null) {\n        return this;\n    }\n    JsonSerializer<?> ser = _serializers.serializerFor(property);\n    if (ser!= null) {\n        return ser;\n    }\n    return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property == null) {\n        return this;\n    }\n    JsonSerializer<?> ser = _serializers.serializerFor(property);\n    if (ser!= null) {\n        return ser;\n    }\n    return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property == null) {\n        return this;\n    }\n    JsonSerializer<?> ser = _serializers.serializerFor(property);\n    if (ser!= null) {\n        return ser;\n    }\n    return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property == null) {\n        return this;\n    }\n    JsonSerializer<?> ser = _serializers.serializerFor(property);\n    if (ser!= null) {\n        return ser;\n    }\n    return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property == null) {\n        return this;\n    }\n    JsonSerializer<?> ser = _serializers.serializerFor(property);\n    if (ser!= null) {\n        return ser;\n    }\n    return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property == null) {\n        return this;\n    }\n    JsonSerializer<?> ser = _serializers.serializerFor(property);\n    if (ser!= null) {\n        return ser;\n    }\n    return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property == null) {\n        return this;\n    }\n    JsonSerializer<?> ser = _serializers.serializerFor(property);\n    if (ser!= null) {\n        return ser;\n    }\n    return this;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property == null) {\n        return this;\n    }\n    JsonSerializer<?> ser = _serializers.serializerFor(property);\n    if (ser!= null) {\n        return ser;\n    }\n    return this;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_107_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java_165-166": {
      "loc": "165-166",
      "input": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n// buggy line:                    return null;",
      "function range": "146,5-199,5",
      "output": [
        {
          "patch": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    deser = _findDefaultImplDeserializer(ctxt);\n                } else {\n                    deser = _findDeserializer(ctxt, actual);\n                }\n            }\n        } else {\n            deser = _findDeserializer(ctxt, type);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonXml_5_/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java_59-60": {
      "loc": "59-60",
      "input": "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n// buggy line:    _rootNameLookup = src._rootNameLookup;",
      "function range": "55,5-60,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n    _namespacePrefixLookup = src._namespacePrefixLookup;\n    _namespaceUriLookup = src._namespaceUriLookup;\n    _elementNameLookup = src._elementNameLookup;\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n    _namespacePrefixLookup = src._namespacePrefixLookup;\n    _namespaceUriLookup = src._namespaceUriLookup;\n    _elementNameLookup = src._elementNameLookup;\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n    _namespacePrefixLookup = src._namespacePrefixLookup;\n    _namespaceUriLookup = src._namespaceUriLookup;\n    _elementNameLookup = src._elementNameLookup;\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n    _namespacePrefixLookup = src._namespacePrefixLookup;\n    _namespaceUriLookup = src._namespaceUriLookup;\n    _elementNameLookup = src._elementNameLookup;\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n    _namespacePrefixLookup = src._namespacePrefixLookup;\n    _namespaceUriLookup = src._namespaceUriLookup;\n    _elementNameLookup = src._elementNameLookup;\n    _attributeNameLookup = src._attributeNameLookup;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n    _namespacePrefixLookup = src._namespacePrefixLookup;\n    _namespaceUriLookup = src._namespaceUriLookup;\n    _elementNameLookup = src._elementNameLookup;\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n    _namespacePrefixLookup = src._namespacePrefixLookup;\n    _namespaceUriLookup = src._namespaceUriLookup;\n    _elementNameLookup = src._elementNameLookup;\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n    _namespacePrefixLookup = src._namespacePrefixLookup;\n    _namespaceUriLookup = src._namespaceUriLookup;\n    _elementNameLookup = src._elementNameLookup;\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n    _namespacePrefixLookup = src._namespacePrefixLookup;\n    _namespaceUriLookup = src._namespaceUriLookup;\n    _elementNameLookup = src._elementNameLookup;\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n    _namespacePrefixLookup = src._namespacePrefixLookup;\n    _namespaceUriLookup = src._namespaceUriLookup;\n    _elementNameLookup = src._elementNameLookup;\n    _attributeNameLookup = src._attributeNameLookup;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n    _namespacePrefixLookup = src._namespacePrefixLookup;\n    _namespaceUriLookup = src._namespaceUriLookup;\n    _elementNameLookup = src._elementNameLookup;\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n    _namespacePrefixLookup = src._namespacePrefixLookup;\n    _namespaceUriLookup = src._namespaceUriLookup;\n    _elementNameLookup = src._elementNameLookup;\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n    _namespacePrefixLookup = src._namespacePrefixLookup;\n    _namespaceUriLookup = src._namespaceUriLookup;\n    _elementNameLookup = src._elementNameLookup;\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n    _namespacePrefixLookup = src._namespacePrefixLookup;\n    _namespaceUriLookup = src._namespaceUriLookup;\n    _elementNameLookup = src._elementNameLookup;\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n    _namespacePrefixLookup = src._namespacePrefixLookup;\n    _namespaceUriLookup = src._namespaceUriLookup;\n    _elementNameLookup = src._elementNameLookup;\n    _attributeNameLookup = src._attributeNameLookup;\n    _namespaceNameLookup = src._namespaceNameLookup;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_1_/src/main/java/org/jsoup/nodes/Document.java_125-127": {
      "loc": "125-127",
      "input": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n// buggy line:        body().appendChild(new TextNode(\" \", \"\"));\n// buggy line:        body().appendChild(node);",
      "function range": "113,5-128,5",
      "output": [
        {
          "patch": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        body().appendChild(node);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        body().appendChild(node);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        body().appendChild(node);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        body().appendChild(node);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        body().appendChild(node);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        body().appendChild(node);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        body().appendChild(node);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        body().appendChild(node);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        body().appendChild(node);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        body().appendChild(node);\n    }\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_15_/src/main/java/org/jsoup/parser/TreeBuilderState.java_283-284": {
      "loc": "283-284",
      "input": "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n// buggy line:            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {",
      "function range": "246,9-761,9",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_24_/src/main/java/org/jsoup/parser/TokeniserState.java_558-559": {
      "loc": "558-559",
      "input": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n// buggy line:        r.advance();",
      "function range": "553,9-586,9",
      "output": [
        {
          "patch": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    } else if (r.matches('>')) {\n        t.emitTagPending();\n        t.transition(Data);\n    } else if (r.matchesAny('\\t', '\\n', '\\r', '\\f','', '\\u00A0')) {\n        t.transition(Data);\n    } else if (r.matches('/')) {\n        t.transition(CommentStart);\n    } else if (r.matches('/', '>')) {\n        t.error(this);\n        t.advance();\n        t.transition(Data);\n    } else if (r.matches('<')) {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    } else if (r.matches('\\u0000')) {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    } else {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    } else if (r.matches('>')) {\n        t.emitTagPending();\n        t.transition(Data);\n    } else if (r.matchesAny('\\t', '\\n', '\\r', '\\f','', '\\u00A0')) {\n        t.transition(Data);\n    } else if (r.matches('/')) {\n        t.transition(CommentStart);\n    } else if (r.matches('/', '>')) {\n        t.error(this);\n        t.advance();\n        t.transition(Data);\n    } else if (r.matches('<')) {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    } else if (r.matches('\\u0000')) {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    } else {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    } else if (r.matches('>')) {\n        t.emitTagPending();\n        t.transition(Data);\n    } else if (r.matchesAny('\\t', '\\n', '\\r', '\\f','', '\\u00A0')) {\n        t.transition(Data);\n    } else if (r.matches('/')) {\n        t.transition(CommentStart);\n    } else if (r.matches('/', '>')) {\n        t.error(this);\n        t.advance();\n        t.transition(Data);\n    } else if (r.matches('<')) {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    } else if (r.matches('\\u0000')) {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    } else {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    } else if (r.matches('>')) {\n        t.emitTagPending();\n        t.transition(Data);\n    } else if (r.matchesAny('\\t', '\\n', '\\r', '\\f','', '\\u00A0')) {\n        t.transition(Data);\n    } else if (r.matches('/')) {\n        t.transition(CommentStart);\n    } else if (r.matches('/', '>')) {\n        t.error(this);\n        t.advance();\n        t.transition(Data);\n    } else if (r.matches('<')) {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    } else if (r.matches('\\u0000')) {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    } else {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    } else if (r.matches('>')) {\n        t.emitTagPending();\n        t.transition(Data);\n    } else if (r.matchesAny('\\t', '\\n', '\\r', '\\f','', '\\u00A0')) {\n        t.transition(Data);\n    } else if (r.matches('/')) {\n        t.transition(CommentStart);\n    } else if (r.matches('/', '>')) {\n        t.error(this);\n        t.advance();\n        t.transition(Data);\n    } else if (r.matches('<')) {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    } else if (r.matches('\\u0000')) {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    } else {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    } else if (r.matches('>')) {\n        t.emitTagPending();\n        t.transition(Data);\n    } else if (r.matchesAny('\\t', '\\n', '\\r', '\\f','', '\\u00A0')) {\n        t.transition(Data);\n    } else if (r.matches('/')) {\n        t.transition(CommentStart);\n    } else if (r.matches('/', '>')) {\n        t.error(this);\n        t.advance();\n        t.transition(Data);\n    } else if (r.matches('<')) {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    } else if (r.matches('\\u0000')) {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    } else {\n        t.error(this);\n        t.advance();\n        t.transition(Rcdata);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    } else if (r.matches('>')) {\n        t.emitTagPending();\n        t.transition(Data);\n    } else if (r.matchesAny('\\t', '\\n', '\\r', '\\f','', '\\u00A0')) {\n        t.transition(Data);\n    } else if (r.matches('/')) {\n        t.transition(CommentStart);\n    } else if (r.matches('/', '>')) {\n        t.error(this);\n        t.advance();\n        t.transition(Data);\n    } else if (r.matches('<')) {\n        t.error(this);\n        t.advance();\n        t.transition(BogusComment);\n    } else if (r.matches('&')) {\n        t.advance();\n        t.transition(Reference);\n    } else if (r.matchesAny('\\u0000')) {\n        t.error(this);\n        t.advance();\n        t.transition(BogusComment);\n    } else {\n        t.error(this);\n        t.advance();\n        t.transition(BogusComment);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    } else if (r.matches('>')) {\n        t.emitTagPending();\n        t.transition(Data);\n    } else if (r.matchesAny('\\t', '\\n', '\\r', '\\f','', '\\u00A0')) {\n        t.transition(Data);\n    } else if (r.matches('/')) {\n        t.transition(CommentStart);\n    } else if (r.matches('/', '>')) {\n        t.error(this);\n        t.advance();\n        t.transition(Data);\n    } else if (r.matches('<')) {\n        t.error(this);\n        t.advance();\n        t.transition(TagOpen);\n    } else if (r.matches('=')) {\n        t.error(this);\n        t.advance();\n        t.transition(AttributeName);\n    } else if (r.matches('\"')) {\n        t.error(this);\n        t.advance();\n        t.transition(AttributeValue);\n    } else if (r.matches('\\'')) {\n        t.error(this);\n        t.advance();\n        t.transition(AttributeValue);\n    } else if (r.matches('&')) {\n        t.error(this);\n        t.advance();\n        t.transition(Entity);\n    } else if (r.matches('\\u0000')) {\n        t.error(this);\n        t.advance();\n        t.transition(Error);\n    } else {\n        t.error(this);\n        t.advance();\n        t.transition(Error);\n    }\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n    } else if (r.matches('>')) {\n        t.emitTagPending();\n        t.transition(Data);\n    } else if (r.matchesAny('\\t', '\\n', '\\r', '\\f','', '\\u00A0')) {\n        t.transition(Data);\n    } else if (r.matches('/')) {\n        t.transition(CommentStart);\n    } else if (r.matches('/', '>')) {\n        t.error(this);\n        t.advance();\n        t.transition(Data);\n    } else if (r.matches('<')) {\n        t.error(this);\n        t.advance();\n        t.transition(TagOpen);\n    } else if (r.matches('=')) {\n        t.error(this);\n        t.advance();\n        t.transition(AttributeName);\n    } else if (r.matches('\"')) {\n        t.error(this);\n        t.advance();\n        t.transition(AttributeValue);\n    } else if (r.matches('\\'')) {\n        t.error(this);\n        t.advance();\n        t.transition(AttributeValue);\n    } else if (r.matches('&')) {\n        t.error(this);\n        t.advance();\n        t.transition(Entity);\n    } else if (r.matches('\\u0000')) {\n        t.error(this);\n        t.advance();\n        t.transition(Error);\n    } else {\n        t.error(this);\n        t.advance();\n        t.transition(Error);\n    }\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_34_/src/main/java/org/jsoup/parser/CharacterReader.java_91-92": {
      "loc": "91-92",
      "input": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n// buggy line:        if (offset < length) {",
      "function range": "82,5-98,5",
      "output": [
        {
          "patch": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        while (i < last) {\n            if (input[i]!= seq.charAt(i - offset))\n                while(++i < last && input[i]!= seq.charAt(i - offset));\n            if (input[i] == seq.charAt(i - offset))\n                i++;\n            else\n                break;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        while (i < last) {\n            if (input[i]!= seq.charAt(i - offset))\n                while(++i < last && input[i]!= seq.charAt(i - offset));\n            if (input[i] == seq.charAt(i - offset))\n                i++;\n            else\n                break;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        while (i < last) {\n            if (input[i]!= seq.charAt(i - offset))\n                while(++i < last && input[i]!= seq.charAt(i - offset));\n            if (input[i] == seq.charAt(i - offset))\n                i++;\n            else\n                break;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        while (i < last) {\n            if (input[i]!= seq.charAt(i - offset))\n                while(++i < last && input[i]!= seq.charAt(i - offset));\n            if (input[i] == seq.charAt(i - offset))\n                i++;\n            else\n                break;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        while (i < last) {\n            if (input[i]!= seq.charAt(i - offset))\n                while(++i < last && input[i]!= seq.charAt(i - offset));\n            if (input[i] == seq.charAt(i - offset))\n                i++;\n            else\n                break;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        while (i < last) {\n            if (input[i]!= seq.charAt(i - offset))\n                while(++i < last && input[i]!= seq.charAt(i - offset));\n            if (input[i] == seq.charAt(i - offset))\n                i++;\n            else\n                break;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        while (i < last) {\n            if (input[i]!= seq.charAt(i - offset))\n                while(++i < last && input[i]!= seq.charAt(i - offset));\n            if (input[i] == seq.charAt(i - offset))\n                i++;\n            else\n                break;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        while (i < last) {\n            if (input[i]!= seq.charAt(i - offset))\n                while(++i < last && input[i]!= seq.charAt(i - offset));\n            if (input[i] == seq.charAt(i - offset))\n                i++;\n            else\n                break;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        while (i < last) {\n            if (input[i]!= seq.charAt(i - offset))\n                while(++i < last && input[i]!= seq.charAt(i - offset));\n            if (input[i] == seq.charAt(i - offset))\n                i++;\n            else\n                break;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        while (i < last) {\n            if (input[i]!= seq.charAt(i - offset))\n                while(++i < last && input[i]!= seq.charAt(i - offset));\n            if (input[i] == seq.charAt(i - offset))\n                i++;\n            else\n                break;\n        }\n        if (i == last)\n            return offset;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_37_/src/main/java/org/jsoup/nodes/Element.java_1101-1102": {
      "loc": "1101-1102",
      "input": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n// buggy line:    return accum.toString().trim();",
      "function range": "1098,5-1102,5",
      "output": [
        {
          "patch": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString();\n  }",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_40_/src/main/java/org/jsoup/nodes/DocumentType.java_22-23": {
      "loc": "22-23",
      "input": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n// buggy line:    Validate.notEmpty(name);",
      "function range": "19,5-26,5",
      "output": [
        {
          "patch": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_41_/src/main/java/org/jsoup/nodes/Element.java_1175-1176": {
      "loc": "1175-1176",
      "input": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n// buggy line:    return this == o;",
      "function range": "1167,5-1176,5",
      "output": [
        {
          "patch": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return name.equals(element.name);\n  }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_43_/src/main/java/org/jsoup/nodes/Element.java_574-575": {
      "loc": "574-575",
      "input": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n// buggy line:        if (element.equals(search))",
      "function range": "568,5-578,5",
      "output": [
        {
          "patch": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return null;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_45_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_394-395": {
      "loc": "394-395",
      "input": "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n// buggy line:        } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {",
      "function range": "382,5-429,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_46_/src/main/java/org/jsoup/nodes/Entities.java_118-119": {
      "loc": "118-119",
      "input": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n// buggy line:                        accum.append(c);",
      "function range": "79,5-154,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_47_/src/main/java/org/jsoup/nodes/Entities.java_122-123": {
      "loc": "122-123",
      "input": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n// buggy line:                    if (!inAttribute)",
      "function range": "79,5-155,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_51_/src/main/java/org/jsoup/parser/CharacterReader.java_300-301": {
      "loc": "300-301",
      "input": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');",
      "function range": "296,5-301,5",
      "output": [
        {
          "patch": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_57_/src/main/java/org/jsoup/nodes/Attributes.java_125-126": {
      "loc": "125-126",
      "input": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n// buggy line:            attributes.remove(attrKey);",
      "function range": "118,5-127,5",
      "output": [
        {
          "patch": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            it.remove();\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            it.remove();\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            it.remove();\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            it.remove();\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            it.remove();\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            it.remove();\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            it.remove();\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            it.remove();\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            it.remove();\n    }\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            it.remove();\n    }\n}",
          "correctness": "plausible"
        }
      ]
    },
    "Jsoup_61_/src/main/java/org/jsoup/nodes/Element.java_1092-1093": {
      "loc": "1092-1093",
      "input": "public boolean hasClass(String className) {\n// buggy line:    final String classAttr = attributes.get(\"class\");",
      "function range": "1091,5-1132,5",
      "output": [
        {
          "patch": "public boolean hasClass(String className) {\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        final StringTokenizer tokenizer = new StringTokenizer(classAttr, \" \");\n        while (tokenizer.hasMoreTokens()) {\n            if (className.equals(tokenizer.nextToken())) {\n                return true;\n            }\n        }\n        return false;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass(String className) {\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        final StringTokenizer tokenizer = new StringTokenizer(classAttr, \" \");\n        while (tokenizer.hasMoreTokens()) {\n            if (className.equals(tokenizer.nextToken())) {\n                return true;\n            }\n        }\n        return false;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass(String className) {\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        final StringTokenizer tokenizer = new StringTokenizer(classAttr, \" \");\n        while (tokenizer.hasMoreTokens()) {\n            if (className.equals(tokenizer.nextToken())) {\n                return true;\n            }\n        }\n        return false;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass(String className) {\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        final StringTokenizer st = new StringTokenizer(classAttr, \" \");\n        while (st.hasMoreTokens()) {\n            if (className.equals(st.nextToken())) {\n                return true;\n            }\n        }\n        return false;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass(String className) {\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        final StringTokenizer tokenizer = new StringTokenizer(classAttr, \" \");\n        while (tokenizer.hasMoreTokens()) {\n            if (className.equals(tokenizer.nextToken())) {\n                return true;\n            }\n        }\n        return false;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass(String className) {\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        final StringTokenizer tokenizer = new StringTokenizer(classAttr, \" \");\n        while (tokenizer.hasMoreTokens()) {\n            if (className.equals(tokenizer.nextToken())) {\n                return true;\n            }\n        }\n        return false;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass(String className) {\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        final StringTokenizer st = new StringTokenizer(classAttr, \" \");\n        while (st.hasMoreTokens()) {\n            if (className.equals(st.nextToken())) {\n                return true;\n            }\n        }\n        return false;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass(String className) {\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        final StringTokenizer st = new StringTokenizer(classAttr, \" \");\n        while (st.hasMoreTokens()) {\n            if (className.equals(st.nextToken())) {\n                return true;\n            }\n        }\n        return false;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass(String className) {\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        final StringTokenizer st = new StringTokenizer(classAttr, \" \");\n        while (st.hasMoreTokens()) {\n            if (className.equals(st.nextToken())) {\n                return true;\n            }\n        }\n        return false;\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass(String className) {\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        final StringTokenizer tokenizer = new StringTokenizer(classAttr, \" \");\n        while (tokenizer.hasMoreTokens()) {\n            if (className.equals(tokenizer.nextToken())) {\n                return true;\n            }\n        }\n        return false;\n    }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_68_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_468-472": {
      "loc": "468-472",
      "input": "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n// buggy line:    int bottom = stack.size() -1;\n// buggy line:    if (bottom > MaxScopeSearchDepth) {\n// buggy line:        bottom = MaxScopeSearchDepth;\n// buggy line:    }",
      "function range": "466,5-486,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_75_/src/main/java/org/jsoup/nodes/Attributes.java_319-321": {
      "loc": "319-321",
      "input": "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n// buggy line:        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n// buggy line:            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {",
      "function range": "310,5-326,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_77_/src/main/java/org/jsoup/parser/XmlTreeBuilder.java_117-118": {
      "loc": "117-118",
      "input": "private void popStackToClose(Token.EndTag endTag) {\n// buggy line:    String elName = endTag.name();",
      "function range": "116,5-136,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_86_/src/main/java/org/jsoup/nodes/Comment.java_78-79": {
      "loc": "78-79",
      "input": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n// buggy line:    if (doc.childNodeSize() > 0) {",
      "function range": "74,5-84,5",
      "output": [
        {
          "patch": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node n : doc.childNodes()) {\n      if (n instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) n;\n        break;\n      }\n    }\n    return decl;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node n : doc.childNodes()) {\n      if (n instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) n;\n        break;\n      }\n    }\n    return decl;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node n : doc.childNodes()) {\n      if (n instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) n;\n        break;\n      }\n    }\n    return decl;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    for (Node n : doc.childNodes()) {\n      if (n instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) n;\n        break;\n      }\n    }\n    return decl;\n  }",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_88_/src/main/java/org/jsoup/nodes/Attribute.java_80-81": {
      "loc": "80-81",
      "input": "public String getValue() {\n// buggy line:    return val;",
      "function range": "79,5-81,5",
      "output": [
        {
          "patch": "public String getValue() {\n        return val;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String getValue() {\n        return val;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String getValue() {\n        return val;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String getValue() {\n        return val;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String getValue() {\n        return val;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String getValue() {\n        return val;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String getValue() {\n        return val;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String getValue() {\n        return val;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String getValue() {\n        return val;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public String getValue() {\n        return val;\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "JxPath_5_/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java_665-668": {
      "loc": "665-668",
      "input": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0 ? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0 ? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1 != null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n// buggy line:        throw new JXPathException(\n// buggy line:                \"Cannot compare pointers that do not belong to the same tree: '\"\n// buggy line:                        + p1 + \"' and '\" + p2 + \"'\");",
      "function range": "642,5-675,5",
      "output": [
        {
          "patch": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n        + p1 + \"' and '\" + p2 + \"'\");\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n        + p1 + \"' and '\" + p2 + \"'\");\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n        + p1 + \"' and '\" + p2 + \"'\");\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n        + p1 + \"' and '\" + p2 + \"'\");\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n        + p1 + \"' and '\" + p2 + \"'\");\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n        + p1 + \"' and '\" + p2 + \"'\");\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n        + p1 + \"' and '\" + p2 + \"'\");\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n        + p1 + \"' and '\" + p2 + \"'\");\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n        + p1 + \"' and '\" + p2 + \"'\");\n}",
          "correctness": "wrong"
        },
        {
          "patch": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n        + p1 + \"' and '\" + p2 + \"'\");\n}",
          "correctness": "wrong"
        }
      ]
    },
    "JxPath_10_/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java_42-43": {
      "loc": "42-43",
      "input": "public final Object computeValue(EvalContext context) {\n// buggy line:    return compute(args[0].computeValue(context), args[1].computeValue(context)) ",
      "function range": "41,5-44,5",
      "output": [
        {
          "patch": "public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "JxPath_12_/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java_108-109": {
      "loc": "108-109",
      "input": "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);",
      "function range": "87,5-136,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "JxPath_21_/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java_152-153": {
      "loc": "152-153",
      "input": "public int getLength() {\n// buggy line:    return ValueUtils.getLength(getBaseValue());",
      "function range": "151,5-153,5",
      "output": [
        {
          "patch": "public int getLength() {\n        return ValueUtils.getLength(getBaseValue());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int getLength() {\n        return ValueUtils.getLength(getBaseValue());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int getLength() {\n        return ValueUtils.getLength(getBaseValue());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int getLength() {\n        return ValueUtils.getLength(getBaseValue());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int getLength() {\n        return ValueUtils.getLength(getBaseValue());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int getLength() {\n        return ValueUtils.getLength(getBaseValue());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int getLength() {\n        return ValueUtils.getLength(getBaseValue());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int getLength() {\n        return ValueUtils.getLength(getBaseValue());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int getLength() {\n        return ValueUtils.getLength(getBaseValue());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int getLength() {\n        return ValueUtils.getLength(getBaseValue());\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_6_/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java_95-96": {
      "loc": "95-96",
      "input": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n// buggy line:            pos += Character.charCount(Character.codePointAt(input, pos));",
      "function range": "75,5-98,5",
      "output": [
        {
          "patch": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            pos+= Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            pos+= Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            pos+= Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            pos+= Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            pos+= Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            pos+= Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            pos+= Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            pos+= Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            pos+= Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            pos+= Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_16_/src/main/java/org/apache/commons/lang3/math/NumberUtils.java_458-459": {
      "loc": "458-459",
      "input": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n// buggy line:    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {",
      "function range": "444,5-594,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_21_/src/main/java/org/apache/commons/lang3/time/DateUtils.java_265-266": {
      "loc": "265-266",
      "input": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n// buggy line:            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&",
      "function range": "258,5-270,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_YEAR) == cal2.get(Calendar.DAY_OF_WEEK_IN_YEAR) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET) &&\n            cal1.get(Calendar.DST_OFFSET) == cal2.get(Calendar.DST_OFFSET));\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_YEAR) == cal2.get(Calendar.DAY_OF_WEEK_IN_YEAR) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET));\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_YEAR) == cal2.get(Calendar.DAY_OF_WEEK_IN_YEAR) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET) &&\n            cal1.get(Calendar.ZONE_OFFSET) == cal2.get(Calendar.ZONE_OFFSET));\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_26_/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java_820-821": {
      "loc": "820-821",
      "input": "public String format(Date date) {\n// buggy line:    Calendar c = new GregorianCalendar(mTimeZone);",
      "function range": "819,5-823,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_29_/src/main/java/org/apache/commons/lang3/SystemUtils.java_1672-1673": {
      "loc": "1672-1673",
      "input": "\n// buggy line:static float toJavaVersionInt(String version) {",
      "function range": "1672,5-1674,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_33_/src/main/java/org/apache/commons/lang3/ClassUtils.java_910-911": {
      "loc": "910-911",
      "input": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n// buggy line:        classes[i] = array[i].getClass();",
      "function range": "902,5-913,5",
      "output": [
        {
          "patch": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_39_/src/java/org/apache/commons/lang3/StringUtils.java_3676-3677": {
      "loc": "3676-3677",
      "input": "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n// buggy line:        int greater = replacementList[i].length() - searchList[i].length();",
      "function range": "3605,5-3731,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_40_/src/java/org/apache/commons/lang/StringUtils.java_1048-1049": {
      "loc": "1048-1049",
      "input": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return contains(str.toUpperCase(), searchStr.toUpperCase());",
      "function range": "1044,5-1049,5",
      "output": [
        {
          "patch": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_43_/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java_422-423": {
      "loc": "422-423",
      "input": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n// buggy line:        return appendTo == null ? null : appendTo.append(QUOTE);",
      "function range": "417,5-444,5",
      "output": [
        {
          "patch": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        if (appendTo!= null) {\n            appendTo.append(QUOTE);\n        }\n        pos.setIndex(start + 1);\n    } else {\n        for (int i = start; i < c.length; i++) {\n            switch (c[i]) {\n            case QUOTE:\n                if (escapingOn) {\n                    if (appendTo!= null) {\n                        appendTo.append(QUOTE);\n                    }\n                    pos.setIndex(i + 1);\n                    return appendTo;\n                } else {\n                    if (appendTo == null) {\n                        appendTo = new StringBuffer();\n                    }\n                    appendTo.append(QUOTE);\n                }\n                break;\n            default:\n                if (appendTo!= null) {\n                    appendTo.append(c[i]);\n                }\n                break;\n            }\n        }\n        pos.setIndex(c.length);\n    }\n    return appendTo;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        if (appendTo!= null) {\n            appendTo.append(QUOTE);\n        }\n        pos.setIndex(start + 1);\n    } else {\n        for (int i = start; i < c.length; i++) {\n            switch (c[i]) {\n            case QUOTE:\n                if (escapingOn) {\n                    if (appendTo!= null) {\n                        appendTo.append(QUOTE);\n                    }\n                    pos.setIndex(i + 1);\n                    return appendTo;\n                } else {\n                    if (appendTo == null) {\n                        appendTo = new StringBuffer();\n                    }\n                    appendTo.append(QUOTE);\n                }\n                break;\n            default:\n                if (appendTo!= null) {\n                    appendTo.append(c[i]);\n                }\n                break;\n            }\n        }\n        pos.setIndex(c.length);\n    }\n    return appendTo;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        if (appendTo!= null) {\n            appendTo.append(QUOTE);\n        }\n        pos.setIndex(start + 1);\n    } else {\n        for (int i = start; i < c.length; i++) {\n            switch (c[i]) {\n            case QUOTE:\n                if (escapingOn) {\n                    if (appendTo!= null) {\n                        appendTo.append(QUOTE);\n                    }\n                    pos.setIndex(i + 1);\n                    return appendTo;\n                } else {\n                    if (appendTo == null) {\n                        appendTo = new StringBuffer();\n                    }\n                    appendTo.append(QUOTE);\n                }\n                break;\n            default:\n                if (appendTo!= null) {\n                    appendTo.append(c[i]);\n                }\n                break;\n            }\n        }\n        pos.setIndex(c.length);\n    }\n    return appendTo;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        if (appendTo!= null) {\n            appendTo.append(QUOTE);\n        }\n        pos.setIndex(start + 1);\n    } else {\n        for (int i = start; i < c.length; i++) {\n            switch (c[i]) {\n            case QUOTE:\n                if (escapingOn) {\n                    if (appendTo!= null) {\n                        appendTo.append(QUOTE);\n                    }\n                    pos.setIndex(i + 1);\n                    return appendTo;\n                } else {\n                    if (appendTo == null) {\n                        appendTo = new StringBuffer();\n                    }\n                    appendTo.append(QUOTE);\n                }\n                break;\n            default:\n                if (appendTo!= null) {\n                    appendTo.append(c[i]);\n                }\n                break;\n            }\n        }\n        pos.setIndex(c.length);\n    }\n    return appendTo;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        if (appendTo!= null) {\n            appendTo.append(QUOTE);\n        }\n        pos.setIndex(start + 1);\n    } else {\n        for (int i = start; i < c.length; i++) {\n            switch (c[i]) {\n            case QUOTE:\n                if (escapingOn) {\n                    if (appendTo!= null) {\n                        appendTo.append(QUOTE);\n                    }\n                    pos.setIndex(i + 1);\n                    return appendTo;\n                } else {\n                    if (appendTo == null) {\n                        appendTo = new StringBuffer();\n                    }\n                    appendTo.append(QUOTE);\n                }\n                break;\n            default:\n                if (appendTo!= null) {\n                    appendTo.append(c[i]);\n                }\n                break;\n            }\n        }\n        pos.setIndex(c.length);\n    }\n    return appendTo;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        if (appendTo!= null) {\n            appendTo.append(QUOTE);\n        }\n        pos.setIndex(start + 1);\n    } else {\n        for (int i = start; i < c.length; i++) {\n            switch (c[i]) {\n            case QUOTE:\n                if (escapingOn) {\n                    if (appendTo!= null) {\n                        appendTo.append(QUOTE);\n                    }\n                    pos.setIndex(i + 1);\n                    return appendTo;\n                } else {\n                    if (appendTo == null) {\n                        appendTo = new StringBuffer();\n                    }\n                    appendTo.append(QUOTE);\n                }\n                break;\n            default:\n                if (appendTo!= null) {\n                    appendTo.append(c[i]);\n                }\n                break;\n            }\n        }\n        pos.setIndex(c.length);\n    }\n    return appendTo;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        if (appendTo!= null) {\n            appendTo.append(QUOTE);\n        }\n        pos.setIndex(start + 1);\n    } else {\n        for (int i = start; i < c.length; i++) {\n            switch (c[i]) {\n            case QUOTE:\n                if (escapingOn) {\n                    if (appendTo!= null) {\n                        appendTo.append(QUOTE);\n                    }\n                    pos.setIndex(i + 1);\n                    return appendTo;\n                } else {\n                    if (appendTo == null) {\n                        appendTo = new StringBuffer();\n                    }\n                    appendTo.append(QUOTE);\n                }\n                break;\n            default:\n                if (appendTo!= null) {\n                    appendTo.append(c[i]);\n                }\n                break;\n            }\n        }\n        pos.setIndex(c.length);\n    }\n    return appendTo;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        if (appendTo!= null) {\n            appendTo.append(QUOTE);\n        }\n        pos.setIndex(start + 1);\n    } else {\n        for (int i = start; i < c.length; i++) {\n            switch (c[i]) {\n            case QUOTE:\n                if (escapingOn) {\n                    if (appendTo!= null) {\n                        appendTo.append(QUOTE);\n                    }\n                    pos.setIndex(i + 1);\n                    return appendTo;\n                } else {\n                    if (appendTo == null) {\n                        appendTo = new StringBuffer();\n                    }\n                    appendTo.append(QUOTE);\n                }\n                break;\n            default:\n                if (appendTo!= null) {\n                    appendTo.append(c[i]);\n                }\n                break;\n            }\n        }\n        pos.setIndex(c.length);\n    }\n    return appendTo;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        if (appendTo!= null) {\n            appendTo.append(QUOTE);\n        }\n        pos.setIndex(start + 1);\n    } else {\n        for (int i = start; i < c.length; i++) {\n            switch (c[i]) {\n            case QUOTE:\n                if (escapingOn) {\n                    if (appendTo!= null) {\n                        appendTo.append(QUOTE);\n                    }\n                    pos.setIndex(i + 1);\n                    return appendTo;\n                } else {\n                    if (appendTo == null) {\n                        appendTo = new StringBuffer();\n                    }\n                    appendTo.append(QUOTE);\n                }\n                break;\n            default:\n                if (appendTo!= null) {\n                    appendTo.append(c[i]);\n                }\n                break;\n            }\n        }\n        pos.setIndex(c.length);\n    }\n    return appendTo;\n}",
          "correctness": "plausible"
        },
        {
          "patch": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        if (appendTo!= null) {\n            appendTo.append(QUOTE);\n        }\n        pos.setIndex(start + 1);\n    } else {\n        for (int i = start; i < c.length; i++) {\n            switch (c[i]) {\n            case QUOTE:\n                if (escapingOn) {\n                    if (appendTo!= null) {\n                        appendTo.append(QUOTE);\n                    }\n                    pos.setIndex(i + 1);\n                    return appendTo;\n                } else {\n                    if (appendTo == null) {\n                        appendTo = new StringBuffer();\n                    }\n                    appendTo.append(QUOTE);\n                }\n                break;\n            default:\n                if (appendTo!= null) {\n                    appendTo.append(c[i]);\n                }\n                break;\n            }\n        }\n        pos.setIndex(c.length);\n    }\n    return appendTo;\n}",
          "correctness": "plausible"
        }
      ]
    },
    "Lang_51_/src/java/org/apache/commons/lang/BooleanUtils.java_682-683": {
      "loc": "682-683",
      "input": "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) == 's' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) == 's');\n            }\n// buggy line:        }",
      "function range": "649,5-700,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_57_/src/java/org/apache/commons/lang/LocaleUtils.java_223-224": {
      "loc": "223-224",
      "input": "public static boolean isAvailableLocale(Locale locale) {\n// buggy line:    return cAvailableLocaleSet.contains(locale);",
      "function range": "222,5-224,5",
      "output": [
        {
          "patch": "public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(new Locale(locale.getLanguage(), locale.getCountry(), locale.getVariant()));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(new Locale(locale.getLanguage(), locale.getCountry(), locale.getVariant()));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(new Locale(locale.getLanguage(), locale.getCountry(), locale.getVariant()));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(new Locale(locale.getLanguage(), locale.getCountry(), locale.getVariant()));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(new Locale(locale.getLanguage(), locale.getCountry(), locale.getVariant()));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(new Locale(locale.getLanguage(), locale.getCountry(), locale.getVariant()));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(new Locale(locale.getLanguage(), locale.getCountry(), locale.getVariant()));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(new Locale(locale.getLanguage(), locale.getCountry(), locale.getVariant()));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(new Locale(locale.getLanguage(), locale.getCountry(), locale.getVariant()));\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(new Locale(locale.getLanguage(), locale.getCountry(), locale.getVariant()));\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_59_/src/java/org/apache/commons/lang/text/StrBuilder.java_884-885": {
      "loc": "884-885",
      "input": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);",
      "function range": "878,5-895,5",
      "output": [
        {
          "patch": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n        return this;\n    } else {\n        return append(obj);\n    }\n  }",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_61_/src/java/org/apache/commons/lang/text/StrBuilder.java_1776-1777": {
      "loc": "1776-1777",
      "input": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0 ? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;",
      "function range": "1760,5-1787,5",
      "output": [
        {
          "patch": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (thisBuf[i + j]!= str.charAt(j)) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (thisBuf[i + j]!= str.charAt(j)) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (thisBuf[i + j]!= str.charAt(j)) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (thisBuf[i + j]!= str.charAt(j)) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (thisBuf[i + j]!= str.charAt(j)) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (thisBuf[i + j]!= str.charAt(j)) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (thisBuf[i + j]!= str.charAt(j)) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (thisBuf[i + j]!= str.charAt(j)) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (thisBuf[i + j]!= str.charAt(j)) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (thisBuf[i + j]!= str.charAt(j)) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Math_2_/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java_268-269": {
      "loc": "268-269",
      "input": "public double getNumericalMean() {\n// buggy line:    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
      "function range": "267,5-269,5",
      "output": [
        {
          "patch": "public double getNumericalMean() {\n        return (double) getSampleSize() / (double) getPopulationSize();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getNumericalMean() {\n        return (double) getSampleSize() / (double) getPopulationSize();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getNumericalMean() {\n        return (double) getSampleSize() / (double) getPopulationSize();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getNumericalMean() {\n        return (double) getSampleSize() / (double) getPopulationSize();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getNumericalMean() {\n        return (double) getSampleSize() / (double) getPopulationSize();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getNumericalMean() {\n        return (double) getSampleSize() / (double) getPopulationSize();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getNumericalMean() {\n        return (double) getSampleSize() / (double) getPopulationSize();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getNumericalMean() {\n        return (double) getSampleSize() / (double) getPopulationSize();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getNumericalMean() {\n        return (double) getSampleSize() / (double) getPopulationSize();\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getNumericalMean() {\n        return (double) getSampleSize() / (double) getPopulationSize();\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Math_5_/src/main/java/org/apache/commons/math3/complex/Complex.java_305-306": {
      "loc": "305-306",
      "input": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n// buggy line:        return NaN;",
      "function range": "299,5-321,5",
      "output": [
        {
          "patch": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return 0.0;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return 0.0;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return 0.0;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Math_9_/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java_87-88": {
      "loc": "87-88",
      "input": "public Line revert() {\n// buggy line:    final Line reverted = new Line(zero, zero.subtract(direction));",
      "function range": "86,5-89,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        }
      ]
    },
    "Math_11_/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java_183-184": {
      "loc": "183-184",
      "input": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length != dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return FastMath.pow(2 * FastMath.PI, -dim / 2) *",
      "function range": "177,5-186,5",
      "output": [
        {
          "patch": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(vals[0], dim / 2);\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(vals[0], dim / 2);\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(vals[0], dim / 2);\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(vals[0], dim / 2);\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(vals[0], dim / 2);\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(vals[0], dim / 2);\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(vals[0], dim / 2);\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(vals[0], dim / 2);\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(vals[0], dim / 2);\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(vals[0], dim / 2);\n  }",
          "correctness": "wrong"
        }
      ]
    },
    "Math_20_/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java_921-922": {
      "loc": "921-922",
      "input": "public double[] repairAndDecode(final double[] x) {\n// buggy line:    return",
      "function range": "920,9-923,9",
      "output": [
        {
          "patch": "public double[] repairAndDecode(final double[] x) {\n        return Arrays.copyOf(x, x.length);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double[] repairAndDecode(final double[] x) {\n        return Arrays.copyOf(x, x.length);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double[] repairAndDecode(final double[] x) {\n        return Arrays.copyOf(x, x.length);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double[] repairAndDecode(final double[] x) {\n        return Arrays.copyOf(x, x.length);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double[] repairAndDecode(final double[] x) {\n        return Arrays.copyOf(x, x.length);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double[] repairAndDecode(final double[] x) {\n        return Arrays.copyOf(x, x.length);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double[] repairAndDecode(final double[] x) {\n        return Arrays.copyOf(x, x.length);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double[] repairAndDecode(final double[] x) {\n        return Arrays.copyOf(x, x.length);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double[] repairAndDecode(final double[] x) {\n        return Arrays.copyOf(x, x.length);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double[] repairAndDecode(final double[] x) {\n        return Arrays.copyOf(x, x.length);\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Math_27_/src/main/java/org/apache/commons/math3/fraction/Fraction.java_597-598": {
      "loc": "597-598",
      "input": "public double percentageValue() {\n// buggy line:    return multiply(100).doubleValue();",
      "function range": "596,5-598,5",
      "output": [
        {
          "patch": "public double percentageValue() {\n        return multiply(100.0).doubleValue();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double percentageValue() {\n        return multiply(100.0).doubleValue();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double percentageValue() {\n        return multiply(100.0).doubleValue();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double percentageValue() {\n        return multiply(100.0).doubleValue();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double percentageValue() {\n        return multiply(100.0).doubleValue();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double percentageValue() {\n        return multiply(100.0).doubleValue();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double percentageValue() {\n        return multiply(100.0).doubleValue();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double percentageValue() {\n        return multiply(100.0).doubleValue();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double percentageValue() {\n        return multiply(100.0).doubleValue();\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double percentageValue() {\n        return multiply(100.0).doubleValue();\n    }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_30_/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java_173-174": {
      "loc": "173-174",
      "input": "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n// buggy line:    final int n1n2prod = n1 * n2;",
      "function range": "168,5-184,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_32_/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java_136-137": {
      "loc": "136-137",
      "input": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy line:        if ((Boolean) tree.getAttribute()) {",
      "function range": "129,5-181,5",
      "output": [
        {
          "patch": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (Boolean.TRUE.equals(tree.getAttribute())) {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(0.0, 0.0);\n                }\n            }\n        } else {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(1.0, 0.0);\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                v[i][j].normalize();\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (Boolean.TRUE.equals(tree.getAttribute())) {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(0.0, 0.0);\n                }\n            }\n        } else {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(1.0, 1.0);\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                v[i][j].normalize();\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (Boolean.TRUE.equals(tree.getAttribute())) {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(0.0, 0.0);\n                }\n            }\n        } else {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(1.0, 0.0);\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                v[i][j].normalize();\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (Boolean.TRUE.equals(tree.getAttribute())) {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(0.0, 0.0);\n                }\n            }\n        } else {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(1.0, 1.0);\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                v[i][j].normalize();\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (Boolean.TRUE.equals(tree.getAttribute())) {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(0.0, 0.0);\n                }\n            }\n        } else {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(1.0, 0.0);\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                v[i][j].normalize();\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (Boolean.TRUE.equals(tree.getAttribute())) {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(0.0, 0.0);\n                }\n            }\n        } else {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(1.0, 1.0);\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                v[i][j].normalize();\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (Boolean.TRUE.equals(tree.getAttribute())) {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(0.0, 0.0);\n                }\n            }\n        } else {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(1.0, 0.0);\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                v[i][j].normalize();\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (Boolean.TRUE.equals(tree.getAttribute())) {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(0.0, 0.0);\n                }\n            }\n        } else {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(1.0, 1.0);\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                v[i][j].normalize();\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (Boolean.TRUE.equals(tree.getAttribute())) {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(0.0, 0.0);\n                }\n            }\n        } else {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(1.0, 0.0);\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                v[i][j].normalize();\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (Boolean.TRUE.equals(tree.getAttribute())) {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(0.0, 0.0);\n                }\n            }\n        } else {\n            for (int i = 0; i < v.length; ++i) {\n                for (int j = 0; j < v[i].length; ++j) {\n                    v[i][j] = new Vector2D(1.0, 1.0);\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < v.length; ++i) {\n            for (int j = 0; j < v[i].length; ++j) {\n                v[i][j].normalize();\n            }\n        }\n    }\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Math_33_/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java_338-339": {
      "loc": "338-339",
      "input": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {",
      "function range": "327,5-367,5",
      "output": [
        {
          "patch": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    int[] columnsToDropArray = new int[columnsToDrop.size()];\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        columnsToDropArray[i] = columnsToDrop.get(i);\n    }\n\n    super.dropPhase1Objective(columnsToDropArray);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    int[] columnsToDropArray = new int[columnsToDrop.size()];\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        columnsToDropArray[i] = columnsToDrop.get(i);\n    }\n\n    super.dropPhase1Objective(columnsToDropArray);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    int[] columnsToDropArray = new int[columnsToDrop.size()];\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        columnsToDropArray[i] = columnsToDrop.get(i);\n    }\n\n    super.dropPhase1Objective(columnsToDropArray);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    int[] columnsToDropArray = new int[columnsToDrop.size()];\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        columnsToDropArray[i] = columnsToDrop.get(i);\n    }\n\n    super.dropPhase1Objective(columnsToDropArray);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    int[] columnsToDropArray = new int[columnsToDrop.size()];\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        columnsToDropArray[i] = columnsToDrop.get(i);\n    }\n\n    super.dropPhase1Objective(columnsToDropArray);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    int[] columnsToDropArray = new int[columnsToDrop.size()];\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        columnsToDropArray[i] = columnsToDrop.get(i);\n    }\n\n    super.dropPhase1Objective(columnsToDropArray);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    int[] columnsToDropArray = new int[columnsToDrop.size()];\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        columnsToDropArray[i] = columnsToDrop.get(i);\n    }\n\n    super.dropPhase1Objective(columnsToDropArray);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    int[] columnsToDropArray = new int[columnsToDrop.size()];\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        columnsToDropArray[i] = columnsToDrop.get(i);\n    }\n\n    super.dropPhase1Objective(columnsToDropArray);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    int[] columnsToDropArray = new int[columnsToDrop.size()];\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        columnsToDropArray[i] = columnsToDrop.get(i);\n    }\n\n    super.dropPhase1Objective(columnsToDropArray);\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    int[] columnsToDropArray = new int[columnsToDrop.size()];\n    for (int i = 0; i < columnsToDrop.size(); i++) {\n        columnsToDropArray[i] = columnsToDrop.get(i);\n    }\n\n    super.dropPhase1Objective(columnsToDropArray);\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_34_/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java_209-210": {
      "loc": "209-210",
      "input": "public Iterator<Chromosome> iterator() {\n// buggy line:    return chromosomes.iterator();",
      "function range": "208,5-210,5",
      "output": [
        {
          "patch": "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public Iterator<Chromosome> iterator() {\n        return new Iterator<Chromosome>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }",
          "correctness": "plausible"
        }
      ]
    },
    "Math_41_/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java_520-521": {
      "loc": "520-521",
      "input": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n// buggy line:            for (int i = 0; i < weights.length; i++) {",
      "function range": "501,5-532,5",
      "output": [
        {
          "patch": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (sumWts * accum2)) / (sumWts * (sumWts - 1.0));\n        }\n    }\n    return var;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = 0; i < weights.length; i++) {\n                sumWts += weights[i];\n            }\n            var = Math.sqrt(accum / sumWts - (accum2 / sumWts) * (accum2 / sumWts));\n        }\n    }\n    return var;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (sumWts * accum2)) / (sumWts * (sumWts - 1.0));\n        }\n    }\n    return var;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (sumWts * accum2)) / (sumWts * (sumWts - 1.0));\n        }\n    }\n    return var;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (sumWts * accum2)) / (sumWts * (sumWts - 1.0));\n        }\n    }\n    return var;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (sumWts * accum2)) / (sumWts * (sumWts - 1.0));\n        }\n    }\n    return var;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (sumWts * accum2)) / (sumWts * (sumWts - 1.0));\n        }\n    }\n    return var;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = 0; i < weights.length; i++) {\n                sumWts += weights[i];\n            }\n            var = Math.sqrt(accum / sumWts - (accum2 / sumWts) * (accum2 / sumWts));\n        }\n    }\n    return var;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            var = (accum - (sumWts * accum2)) / (sumWts * (sumWts - 1.0));\n        }\n    }\n    return var;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = 0; i < weights.length; i++) {\n                sumWts += weights[i];\n            }\n            var = Math.sqrt(accum / sumWts - (accum2 / sumWts) * (accum2 / sumWts));\n        }\n    }\n    return var;\n  }",
          "correctness": "wrong"
        }
      ]
    },
    "Math_48_/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java_189-190": {
      "loc": "189-190",
      "input": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                break;",
      "function range": "129,5-251,5",
      "output": [
        {
          "patch": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyInterval(x0, x1);\n        verifyBracketing(x0, x1);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyInterval(x0, x1);\n        verifyBracketing(x0, x1);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n            default:\n                break;\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        verifyBracketing(x0, x1);\n    }\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Math_50_/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java_187-191": {
      "loc": "187-191",
      "input": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                if (x == x1) {\n// buggy line:                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n// buggy line:                    f0 = computeObjectiveValue(x0);\n// buggy line:                }",
      "function range": "128,5-253,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        }
      ]
    },
    "Math_53_/src/main/java/org/apache/commons/math/complex/Complex.java_153-154": {
      "loc": "153-154",
      "input": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real + rhs.getReal(),",
      "function range": "150,5-155,5",
      "output": [
        {
          "patch": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(),\n                          imaginary + rhs.getImaginary());\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(),\n                         imaginary + rhs.getImaginary());\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(),\n                         imaginary + rhs.getImaginary());\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(),\n                         imaginary + rhs.getImaginary());\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(),\n                         imaginary + rhs.getImaginary());\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(),\n                         imaginary + rhs.getImaginary());\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(),\n                         imaginary + rhs.getImaginary());\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(),\n                         imaginary + rhs.getImaginary());\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(),\n                         imaginary + rhs.getImaginary());\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(),\n                         imaginary + rhs.getImaginary());\n  }",
          "correctness": "wrong"
        }
      ]
    },
    "Math_56_/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java_237-244": {
      "loc": "237-244",
      "input": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n// buggy line:    int idx = 1;\n// buggy line:    while (count < index) {\n// buggy line:        count += idx;\n// buggy line:        ++idx;\n// buggy line:    }\n// buggy line:    --idx;\n// buggy line:    indices[last] = idx;",
      "function range": "216,5-246,5",
      "output": [
        {
          "patch": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    indices[last] = count;\n    return indices;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    indices[last] = count;\n    return indices;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    indices[last] = count;\n    return indices;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    indices[last] = count;\n    return indices;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    indices[last] = count;\n    return indices;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    indices[last] = count;\n    return indices;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    indices[last] = count;\n    return indices;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    indices[last] = count;\n    return indices;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    indices[last] = count;\n    return indices;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    indices[last] = count;\n    return indices;\n  }",
          "correctness": "wrong"
        }
      ]
    },
    "Math_57_/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java_175-176": {
      "loc": "175-176",
      "input": "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n// buggy line:        int sum = 0;",
      "function range": "161,5-198,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n        int sum = 0;\n        for (int i = 0; i < pointSet.size(); i++) {\n            sum += Math.pow(pointSet.get(i).x - firstPoint.x, 2) + Math.pow(pointSet.get(i).y - firstPoint.y, 2);\n            dx2[i] = Math.pow(pointSet.get(i).x - firstPoint.x, 2) + Math.pow(pointSet.get(i).y - firstPoint.y, 2);\n        }\n        final double r = sum / pointSet.size();\n        for (int i = 0; i < pointSet.size(); i++) {\n            if (random.nextDouble() < r) {\n                resultSet.add(new Cluster<T>(pointSet.get(i)));\n            }\n        }\n    }\n    return resultSet;\n  }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_58_/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java_121-122": {
      "loc": "121-122",
      "input": "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n// buggy line:    return fit(new Gaussian.Parametric(), guess);",
      "function range": "119,5-122,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    return fit(new Gaussian.Parametric(guess[0], guess[1], guess[2], guess[3], guess[4], guess[5], guess[6], guess[7], guess[8], guess[9], guess[10], guess[11], guess[12], guess[13], guess[14], guess[15], guess[16], guess[17], guess[18], guess[19], guess[20], guess[21], guess[22], guess[23], guess[24], guess[25], guess[26], guess[27], guess[28], guess[29], guess[30], guess[31], guess[32], guess[33], guess[34], guess[35], guess[36], guess[37], guess[38], guess[39], guess[40], guess[41], guess[42], guess[43], guess[44], guess[45], guess[46], guess[47], guess[48], guess[49], guess[50], guess[51], guess[52], guess[53], guess[54], guess[55], guess[56], guess[57], guess[58], guess[59], guess[60], guess[61], guess[62], guess[63], guess[64], guess[65], guess[66], guess[67], guess[68], guess[69], guess[70], guess[71], guess[72], guess[73], guess[74], guess[75], guess[76], guess[77], guess[78], guess[79], guess[80], guess[81], guess[82], guess[83], guess[84], guess[85], guess[86], guess[87], guess[88], guess[89], guess[90], guess[91], guess[92], guess[93], guess[94], guess[95], guess[96], guess[97], guess[98], guess[99], guess[100], guess[101], guess[102], guess[103], guess[104], guess[105], guess[106], guess[107], guess[108], guess[109], guess[110], guess[111]);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    return fit(new Gaussian.Parametric(guess[0], guess[1], guess[2], guess[3], guess[4], guess[5], guess[6], guess[7], guess[8], guess[9], guess[10], guess[11], guess[12], guess[13], guess[14], guess[15], guess[16], guess[17], guess[18], guess[19], guess[20], guess[21], guess[22], guess[23], guess[24], guess[25], guess[26], guess[27], guess[28], guess[29], guess[30], guess[31], guess[32], guess[33], guess[34], guess[35], guess[36], guess[37], guess[38], guess[39], guess[40], guess[41], guess[42], guess[43], guess[44], guess[45], guess[46], guess[47], guess[48], guess[49], guess[50], guess[51], guess[52], guess[53], guess[54], guess[55], guess[56], guess[57], guess[58], guess[59], guess[60], guess[61], guess[62], guess[63], guess[64], guess[65], guess[66], guess[67], guess[68], guess[69], guess[70], guess[71], guess[72], guess[73], guess[74], guess[75], guess[76], guess[77], guess[78], guess[79], guess[80], guess[81], guess[82], guess[83], guess[84], guess[85], guess[86], guess[87], guess[88], guess[89], guess[90], guess[91], guess[92], guess[93], guess[94], guess[95], guess[96], guess[97], guess[98], guess[99], guess[100], guess[101], guess[102], guess[103], guess[104], guess[105], guess[106], guess[107], guess[108], guess[109], guess[110], guess[111]);\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    return fit(new Gaussian.Parametric(guess[0], guess[1], guess[2], guess[3], guess[4], guess[5], guess[6], guess[7], guess[8], guess[9], guess[10], guess[11], guess[12], guess[13], guess[14], guess[15], guess[16], guess[17], guess[18], guess[19], guess[20], guess[21], guess[22], guess[23], guess[24], guess[25], guess[26], guess[27], guess[28], guess[29], guess[30], guess[31], guess[32], guess[33], guess[34], guess[35], guess[36], guess[37], guess[38], guess[39], guess[40], guess[41], guess[42], guess[43], guess[44], guess[45], guess[46], guess[47], guess[48], guess[49], guess[50], guess[51], guess[52], guess[53], guess[54], guess[55], guess[56], guess[57], guess[58], guess[59], guess[60], guess[61], guess[62], guess[63], guess[64], guess[65], guess[66], guess[67], guess[68], guess[69], guess[70], guess[71], guess[72], guess[73], guess[74], guess[75], guess[76], guess[77], guess[78], guess[79], guess[80], guess[81], guess[82], guess[83], guess[84], guess[85], guess[86], guess[87], guess[88], guess[89], guess[90], guess[91], guess[92], guess[93], guess[94], guess[95], guess[96], guess[97], guess[98], guess[99], guess[100], guess[101], guess[102], guess[103], guess[104], guess[105], guess[106], guess[107], guess[108], guess[109], guess[110], guess[111]);\n\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    return fit(new Gaussian.Parametric(guess[0], guess[1], guess[2], guess[3], guess[4], guess[5], guess[6], guess[7], guess[8], guess[9], guess[10], guess[11], guess[12], guess[13], guess[14], guess[15], guess[16], guess[17], guess[18], guess[19], guess[20], guess[21], guess[22], guess[23], guess[24], guess[25], guess[26], guess[27], guess[28], guess[29], guess[30], guess[31], guess[32], guess[33], guess[34], guess[35], guess[36], guess[37], guess[38], guess[39], guess[40], guess[41], guess[42], guess[43], guess[44], guess[45], guess[46], guess[47], guess[48], guess[49], guess[50], guess[51], guess[52], guess[53], guess[54], guess[55], guess[56], guess[57], guess[58], guess[59], guess[60], guess[61], guess[62], guess[63], guess[64], guess[65], guess[66], guess[67], guess[68], guess[69], guess[70], guess[71], guess[72], guess[73], guess[74], guess[75], guess[76], guess[77], guess[78], guess[79], guess[80], guess[81], guess[82], guess[83], guess[84], guess[85], guess[86], guess[87], guess[88], guess[89], guess[90], guess[91], guess[92], guess[93], guess[94], guess[95], guess[96], guess[97], guess[98], guess[99], guess[100], guess[101], guess[102], guess[103], guess[104], guess[105], guess[106], guess[107], guess[108], guess[109]);\n    return guess;\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    return fit(new Gaussian.Parametric(guess[0], guess[1], guess[2], guess[3], guess[4], guess[5], guess[6], guess[7], guess[8], guess[9], guess[10], guess[11], guess[12], guess[13], guess[14], guess[15], guess[16], guess[17], guess[18], guess[19], guess[20], guess[21], guess[22], guess[23], guess[24], guess[25], guess[26], guess[27], guess[28], guess[29], guess[30], guess[31], guess[32], guess[33], guess[34], guess[35], guess[36], guess[37], guess[38], guess[39], guess[40], guess[41], guess[42], guess[43], guess[44], guess[45], guess[46], guess[47], guess[48], guess[49], guess[50], guess[51], guess[52], guess[53], guess[54], guess[55], guess[56], guess[57], guess[58], guess[59], guess[60], guess[61], guess[62], guess[63], guess[64], guess[65], guess[66], guess[67], guess[68], guess[69], guess[70], guess[71], guess[72], guess[73], guess[74], guess[75], guess[76], guess[77], guess[78], guess[79], guess[80], guess[81], guess[82], guess[83], guess[84], guess[85], guess[86], guess[87], guess[88], guess[89], guess[90], guess[91], guess[92], guess[93], guess[94], guess[95], guess[96], guess[97], guess[98], guess[99], guess[100], guess[101], guess[102], guess[103], guess[104], guess[105], guess[106], guess[107], guess[108], guess[109]);\n    return guess;\n  }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_59_/src/main/java/org/apache/commons/math/util/FastMath.java_3482-3483": {
      "loc": "3482-3483",
      "input": "public static float max(final float a, final float b) {\n// buggy line:    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);",
      "function range": "3481,5-3483,5",
      "output": [
        {
          "patch": "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }",
          "correctness": "plausible"
        },
        {
          "patch": "public static float max(final float a, final float b) {\n        return Math.max(a, b);\n    }",
          "correctness": "plausible"
        }
      ]
    },
    "Math_63_/src/main/java/org/apache/commons/math/util/MathUtils.java_417-418": {
      "loc": "417-418",
      "input": "public static boolean equals(double x, double y) {\n// buggy line:    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;",
      "function range": "416,5-418,5",
      "output": [
        {
          "patch": "public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Math_69_/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java_171-172": {
      "loc": "171-172",
      "input": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n// buggy line:                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));",
      "function range": "160,5-176,5",
      "output": [
        {
          "patch": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * tDistribution.cumulativeProbability(t);\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * tDistribution.cumulativeProbability(t);\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * tDistribution.cumulativeProbability(t);\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * tDistribution.cumulativeProbability(t);\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * tDistribution.cumulativeProbability(t);\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * tDistribution.cumulativeProbability(t);\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_70_/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java_72-73": {
      "loc": "72-73",
      "input": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n// buggy line:    return solve(min, max);",
      "function range": "70,5-73,5",
      "output": [
        {
          "patch": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max, initial);\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Math_73_/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java_136-137": {
      "loc": "136-137",
      "input": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }",
      "function range": "98,5-140,5",
      "output": [
        {
          "patch": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Math_75_/src/main/java/org/apache/commons/math/stat/Frequency.java_303-304": {
      "loc": "303-304",
      "input": "@Deprecated\npublic double getPct(Object v) {\n// buggy line:    return getCumPct((Comparable<?>) v);",
      "function range": "301,5-304,5",
      "output": [
        {
          "patch": "@Deprecated\npublic double getPct(Object v) {\n        return getCumPct((Number) v);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic double getPct(Object v) {\n        return getCumPct((Number) v);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic double getPct(Object v) {\n        return getCumPct((Number) v);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic double getPct(Object v) {\n        return getCumPct((Number) v);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic double getPct(Object v) {\n        return getCumPct((Number) v);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic double getPct(Object v) {\n        return getCumPct((Number) v);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic double getPct(Object v) {\n        return getCumPct((Number) v);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic double getPct(Object v) {\n        return getCumPct((Number) v);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic double getPct(Object v) {\n        return getCumPct((Number) v);\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic double getPct(Object v) {\n        return getCumPct((Number) v);\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Math_80_/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java_1135-1136": {
      "loc": "1135-1136",
      "input": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n// buggy line:        int j = 4 * n - 1;",
      "function range": "1132,5-1147,5",
      "output": [
        {
          "patch": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n        int j = 4 * (n - 1);\n        work[pingPong] = work[j];\n        work[j] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        work[pingPong] = work[step];\n        work[step] = work[j];\n        work[j] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        work[pingPong] = work[step];\n        work[step] = work[j];\n        work[j] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        return true;\n    }\n    return false;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n        int j = 4 * (n - 1);\n        work[pingPong] = work[j];\n        work[j] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        work[pingPong] = work[step];\n        work[step] = work[j];\n        work[j] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        work[pingPong] = work[step];\n        work[step] = work[j];\n        work[j] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        return true;\n    }\n    return false;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n        int j = 4 * (n - 1);\n        work[pingPong] = work[j];\n        work[j] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        work[pingPong] = work[step];\n        work[step] = work[j];\n        work[j] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        work[pingPong] = work[step];\n        work[step] = work[j];\n        work[j] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        return true;\n    }\n    return false;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n        int j = 4 * (n - 1);\n        work[pingPong] = work[j];\n        work[j] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        work[pingPong] = work[step];\n        work[step] = work[j];\n        work[j] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        work[pingPong] = work[step];\n        work[step] = work[j];\n        work[j] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        return true;\n    }\n    return false;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n        int j = 4 * (n - 1);\n        work[pingPong] = work[j];\n        work[j] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        work[pingPong] = work[step];\n        work[step] = work[j];\n        work[j] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        work[pingPong] = work[step];\n        work[step] = work[j];\n        work[j] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        return true;\n    }\n    return false;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n        int j = 4 * (n - 1);\n        work[pingPong] = work[j];\n        work[j] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[pingPong];\n        work[pingPong] = work[step];\n        work[step] = work[j];\n        work[j] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[pingPong];\n        work[pingPong] = work[step];\n        work[step] = work[j];\n        work[j] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[pingPong];\n        work[pingPong] = work[step];\n        work[step] = work[j];\n        work[j] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[4 * (n - 1) + pingPong];\n        work[4 * (n - 1) + pingPong] = work[4 * (n - 1) + step];\n        work[4 * (n - 1) + step] = work[pingPong];\n        return true;\n    }\n    return false;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_82_/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java_82-83": {
      "loc": "82-83",
      "input": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n// buggy line:        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {",
      "function range": "76,5-91,5",
      "output": [
        {
          "patch": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n            final double ratio = rhs / entry;\n            if (MathUtils.compareTo(ratio, minRatio) < 0) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n            final double ratio = rhs / entry;\n            if (MathUtils.compareTo(ratio, minRatio) < 0) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n            final double ratio = rhs / entry;\n            if (MathUtils.compareTo(ratio, minRatio) < 0) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n            final double ratio = rhs / entry;\n            if (MathUtils.compareTo(ratio, minRatio) < 0) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n            final double ratio = rhs / entry;\n            if (MathUtils.compareTo(ratio, minRatio) < 0) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n            final double ratio = rhs / entry;\n            if (MathUtils.compareTo(ratio, minRatio) < 0) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n            final double ratio = rhs / entry;\n            if (MathUtils.compareTo(ratio, minRatio) < 0) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n            final double ratio = rhs / entry;\n            if (MathUtils.compareTo(ratio, minRatio) < 0) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n            final double ratio = rhs / entry;\n            if (MathUtils.compareTo(ratio, minRatio) < 0) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n            final double ratio = rhs / entry;\n            if (MathUtils.compareTo(ratio, minRatio) < 0) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_85_/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java_198-199": {
      "loc": "198-199",
      "input": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n// buggy line:    if (fa * fb >= 0.0 ) {",
      "function range": "165,5-208,5",
      "output": [
        {
          "patch": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb >= 0.0 || (a > lowerBound) || (b < upperBound)) {\n        return new double[] { a, b };\n    } else {\n        throw new ConvergenceException(\n            \"number of iterations={0}, maximum iterations={1}, lower bound={2}, upper bound={3}\",\n            numIterations, maximumIterations, lowerBound, upperBound);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb >= 0.0 || (a > lowerBound) || (b < upperBound)) {\n        return new double[] { a, b };\n    } else {\n        throw new ConvergenceException(\n            \"number of iterations={0}, maximum iterations={1}, lower bound={2}, upper bound={3}\",\n            numIterations, maximumIterations, lowerBound, upperBound);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb >= 0.0 || (a > lowerBound) || (b < upperBound)) {\n        return new double[] { a, b };\n    } else {\n        throw new ConvergenceException(\n            \"number of iterations={0}, maximum iterations={1}, lower bound={2}, upper bound={3}\",\n            numIterations, maximumIterations, lowerBound, upperBound);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb >= 0.0 || (a > lowerBound) || (b < upperBound)) {\n        return new double[] { a, b };\n    } else {\n        throw new ConvergenceException(\n            \"number of iterations={0}, maximum iterations={1}, lower bound={2}, upper bound={3}\",\n            numIterations, maximumIterations, lowerBound, upperBound);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (numIterations == maximumIterations) {\n        throw new ConvergenceException(\n            \"maximum iterations ({0}) exceeded\", maximumIterations);\n    }\n    if (fa * fb > 0.0) {\n        throw new ConvergenceException(\n            \"cannot bracket root, f(a) and f(b) have opposite signs\");\n    }\n    return new double[] {a, b};\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (numIterations == maximumIterations) {\n        throw new ConvergenceException(\n            \"maximum iterations ({0}) exceeded\", maximumIterations);\n    }\n    if (fa * fb > 0.0) {\n        throw new ConvergenceException(\n            \"cannot bracket root, f(a) and f(b) have opposite signs\");\n    }\n    return new double[] {a, b};\n}",
          "correctness": "plausible"
        },
        {
          "patch": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb >= 0.0 || (a > lowerBound) || (b < upperBound)) {\n        return new double[] { a, b };\n    } else {\n        throw new ConvergenceException(\n            \"number of iterations={0}, maximum iterations={1}, lower bound={2}, upper bound={3}\",\n            numIterations, maximumIterations, lowerBound, upperBound);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb >= 0.0 || (a > lowerBound) || (b < upperBound)) {\n        return new double[] { a, b };\n    } else {\n        throw new ConvergenceException(\n            \"number of iterations={0}, maximum iterations={1}, lower bound={2}, upper bound={3}\",\n            numIterations, maximumIterations, lowerBound, upperBound);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb >= 0.0 || (a > lowerBound) || (b < upperBound)) {\n        return new double[] { a, b };\n    } else {\n        throw new ConvergenceException(\n            \"number of iterations={0}, maximum iterations={1}, lower bound={2}, upper bound={3}\",\n            numIterations, maximumIterations, lowerBound, upperBound);\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb >= 0.0 || (a > lowerBound) || (b < upperBound)) {\n        return new double[] { a, b };\n    } else {\n        throw new ConvergenceException(\n            \"number of iterations={0}, maximum iterations={1}, lower bound={2}, upper bound={3}\",\n            numIterations, maximumIterations, lowerBound, upperBound);\n    }\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Math_91_/src/java/org/apache/commons/math/fraction/Fraction.java_259-261": {
      "loc": "259-261",
      "input": "public int compareTo(Fraction object) {\n// buggy line:    double nOd = doubleValue();\n// buggy line:    double dOn = object.doubleValue();",
      "function range": "258,5-262,5",
      "output": [
        {
          "patch": "public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        if (nOd < dOn) {\n            return -1;\n        } else if (nOd > dOn) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        if (nOd < dOn) {\n            return -1;\n        } else if (nOd > dOn) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        if (nOd < dOn) {\n            return -1;\n        } else if (nOd > dOn) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        if (nOd < dOn) {\n            return -1;\n        } else if (nOd > dOn) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        if (nOd < dOn) {\n            return -1;\n        } else if (nOd > dOn) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        if (nOd < dOn) {\n            return -1;\n        } else if (nOd > dOn) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        if (nOd < dOn) {\n            return -1;\n        } else if (nOd > dOn) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        if (nOd < dOn) {\n            return -1;\n        } else if (nOd > dOn) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        if (nOd < dOn) {\n            return -1;\n        } else if (nOd > dOn) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        if (nOd < dOn) {\n            return -1;\n        } else if (nOd > dOn) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Math_94_/src/java/org/apache/commons/math/util/MathUtils.java_412-413": {
      "loc": "412-413",
      "input": "public static int gcd(int u, int v) {\n// buggy line:    if (u * v == 0) {",
      "function range": "411,5-460,5",
      "output": [
        {
          "patch": "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            u = -u;\n        }\n        if (v < 0) {\n            v = -v;\n        }\n        if (u > v) {\n            int t = u;\n            u = v;\n            v = t;\n        }\n        while (v!= 0) {\n            int q = u % v;\n            u = v;\n            v = q;\n        }\n        return u;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            u = -u;\n        }\n        if (v < 0) {\n            v = -v;\n        }\n        if (u > v) {\n            int t = u;\n            u = v;\n            v = t;\n        }\n        while (v!= 0) {\n            int q = u % v;\n            u = v;\n            v = q;\n        }\n        return u;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            u = -u;\n        }\n        if (v < 0) {\n            v = -v;\n        }\n        if (u > v) {\n            int t = u;\n            u = v;\n            v = t;\n        }\n        while (v!= 0) {\n            int q = u % v;\n            u = v;\n            v = q;\n        }\n        return u;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            u = -u;\n        }\n        if (v < 0) {\n            v = -v;\n        }\n        if (u > v) {\n            int t = u;\n            u = v;\n            v = t;\n        }\n        while (v!= 0) {\n            int q = u % v;\n            u = v;\n            v = q;\n        }\n        return u;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            u = -u;\n        }\n        if (v < 0) {\n            v = -v;\n        }\n        if (u > v) {\n            int t = u;\n            u = v;\n            v = t;\n        }\n        while (v!= 0) {\n            int q = u % v;\n            u = v;\n            v = q;\n        }\n        return u;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            u = -u;\n        }\n        if (v < 0) {\n            v = -v;\n        }\n        if (u > v) {\n            int t = u;\n            u = v;\n            v = t;\n        }\n        while (v!= 0) {\n            int q = u % v;\n            u = v;\n            v = q;\n        }\n        return u;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            u = -u;\n        }\n        if (v < 0) {\n            v = -v;\n        }\n        if (u > v) {\n            int t = u;\n            u = v;\n            v = t;\n        }\n        while (v!= 0) {\n            int q = u % v;\n            u = v;\n            v = q;\n        }\n        return u;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            u = -u;\n        }\n        if (v < 0) {\n            v = -v;\n        }\n        if (u > v) {\n            int t = u;\n            u = v;\n            v = t;\n        }\n        while (v!= 0) {\n            int q = u % v;\n            u = v;\n            v = q;\n        }\n        return u;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            u = -u;\n        }\n        if (v < 0) {\n            v = -v;\n        }\n        if (u > v) {\n            int t = u;\n            u = v;\n            v = t;\n        }\n        while (v!= 0) {\n            int q = u % v;\n            u = v;\n            v = q;\n        }\n        return u;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd(int u, int v) {\n        if (u == 0) {\n            return v;\n        }\n        if (v == 0) {\n            return u;\n        }\n        if (u < 0) {\n            u = -u;\n        }\n        if (v < 0) {\n            v = -v;\n        }\n        if (u > v) {\n            int t = u;\n            u = v;\n            v = t;\n        }\n        while (v!= 0) {\n            int q = u % v;\n            u = v;\n            v = q;\n        }\n        return u;\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Math_96_/src/java/org/apache/commons/math/complex/Complex.java_258-259": {
      "loc": "258-259",
      "input": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n// buggy line:                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); ",
      "function range": "245,5-267,5",
      "output": [
        {
          "patch": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n}",
          "correctness": "wrong"
        }
      ]
    },
    "Math_101_/src/java/org/apache/commons/math/complex/ComplexFormat.java_377-378": {
      "loc": "377-378",
      "input": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n// buggy line:    if (",
      "function range": "320,5-389,5",
      "output": [
        {
          "patch": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    c = parseNextCharacter(source, pos);\n    if (c!= getImaginaryCharacter()) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), sign * im.doubleValue());\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_105_/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java_264-265": {
      "loc": "264-265",
      "input": "public double getSumSquaredErrors() {\n// buggy line:    return sumYY - sumXY * sumXY / sumXX;",
      "function range": "263,5-265,5",
      "output": [
        {
          "patch": "public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Mockito_1_/src/org/mockito/internal/invocation/InvocationMatcher.java_123-124": {
      "loc": "123-124",
      "input": "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n// buggy line:        throw new UnsupportedOperationException();",
      "function range": "120,5-150,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_5_/src/org/mockito/internal/verification/VerificationOverTimeImpl.java_91-92": {
      "loc": "91-92",
      "input": "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n// buggy line:        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {",
      "function range": "75,5-99,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n        } catch (AssertionError e) {\n            error = handleVerifyException(e);\n        }\n    }",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n    }\n    if (error!= null) {\n        throw error;\n    }\n}",
          "correctness": "wrong"
        },
        {
          "patch": "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n        }\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Mockito_7_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_379-380": {
      "loc": "379-380",
      "input": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n// buggy line:    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));",
      "function range": "375,9-380,9",
      "output": [
        {
          "patch": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }",
          "correctness": "timeout"
        },
        {
          "patch": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }",
          "correctness": "timeout"
        },
        {
          "patch": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }",
          "correctness": "timeout"
        },
        {
          "patch": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }",
          "correctness": "timeout"
        },
        {
          "patch": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n  }",
          "correctness": "timeout"
        }
      ]
    },
    "Mockito_8_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_79-80": {
      "loc": "79-80",
      "input": "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n// buggy line:        } else {",
      "function range": "66,5-84,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_22_/src/org/mockito/internal/matchers/Equality.java_13-14": {
      "loc": "13-14",
      "input": "public static boolean areEqual(Object o1, Object o2) {\n// buggy line:    if (o1 == null || o2 == null) {",
      "function range": "12,5-20,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_24_/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java_76-77": {
      "loc": "76-77",
      "input": "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n// buggy line:        return 1;",
      "function range": "63,5-81,5",
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_27_/src/org/mockito/internal/util/MockUtil.java_64-66": {
      "loc": "64-66",
      "input": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n// buggy line:    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n// buggy line:    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));",
      "function range": "62,5-67,5",
      "output": [
        {
          "patch": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    setMockHandler(mock, newMockHandler, newFilter);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    setMockHandler(mock, newMockHandler, newFilter);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    setMockHandler(mock, newMockHandler, newFilter);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    setMockHandler(mock, newMockHandler, newFilter);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    setMockHandler(mock, newMockHandler, newFilter);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    setMockHandler(mock, newFilter);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    setMockHandler(mock, newFilter);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    setMockHandler(mock, newMockHandler, newFilter);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    setMockHandler(mock, newMockHandler, newFilter);\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    setMockHandler(mock, newMockHandler, newFilter);\n  }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_28_/src/org/mockito/internal/configuration/DefaultInjectionEngine.java_93-94": {
      "loc": "93-94",
      "input": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n// buggy line:        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();",
      "function range": "91,5-95,5",
      "output": [
        {
          "patch": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n    }\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n    }\n  }",
          "correctness": "wrong"
        }
      ]
    },
    "Mockito_29_/src/org/mockito/internal/matchers/Same.java_29-30": {
      "loc": "29-30",
      "input": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n// buggy line:    description.appendText(wanted.toString());",
      "function range": "26,5-32,5",
      "output": [
        {
          "patch": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted.toString());\n    description.appendText(\")\");\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted.toString());\n    description.appendText(\")\");\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted.toString());\n    description.appendText(\")\");\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted.toString());\n    description.appendText(\")\");\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted.toString());\n    description.appendText(\")\");\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted.toString());\n    description.appendText(\")\");\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted.toString());\n    description.appendText(\")\");\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted.toString());\n    description.appendText(\")\");\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted.toString());\n    description.appendText(\")\");\n  }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted.toString());\n    description.appendText(\")\");\n  }",
          "correctness": "wrong"
        }
      ]
    },
    "Mockito_34_/src/org/mockito/internal/invocation/InvocationMatcher.java_106-107": {
      "loc": "106-107",
      "input": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n// buggy line:        if (m instanceof CapturesArguments) {",
      "function range": "103,5-111,5",
      "output": [
        {
          "patch": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      if (m instanceof CapturesArguments) {\n        CapturesArguments ca = (CapturesArguments) m;\n        ca.capture(i, k);\n      }\n      k++;\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      if (m instanceof CapturesArguments) {\n        CapturesArguments ca = (CapturesArguments) m;\n        ca.captureArgumentsFrom(i, k);\n      }\n      k++;\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      if (m instanceof CapturesArguments) {\n        CapturesArguments ca = (CapturesArguments) m;\n        ca.capture(i, k);\n      }\n      k++;\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      if (m instanceof CapturesArguments) {\n        CapturesArguments ca = (CapturesArguments) m;\n        ca.capture(i, k);\n      }\n      k++;\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      if (m instanceof CapturesArguments) {\n        CapturesArguments ca = (CapturesArguments) m;\n        ca.captureArgumentsFrom(i, k);\n      }\n      k++;\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      if (m instanceof CapturesArguments) {\n        CapturesArguments ca = (CapturesArguments) m;\n        ca.capture(i, k);\n      }\n      k++;\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      if (m instanceof CapturesArguments) {\n        CapturesArguments ca = (CapturesArguments) m;\n        ca.capture(i, k);\n      }\n      k++;\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      if (m instanceof CapturesArguments) {\n        CapturesArguments ca = (CapturesArguments) m;\n        ca.capture(i, k);\n      }\n      k++;\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      if (m instanceof CapturesArguments) {\n        CapturesArguments ca = (CapturesArguments) m;\n        ca.captureArgumentsFrom(i, k);\n      }\n      k++;\n    }\n  }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n      if (m instanceof CapturesArguments) {\n        CapturesArguments ca = (CapturesArguments) m;\n        ca.capture(i, k);\n      }\n      k++;\n    }\n  }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_38_/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java_48-49": {
      "loc": "48-49",
      "input": "private boolean toStringEquals(Matcher m, Object arg) {\n// buggy line:    return StringDescription.toString(m).equals(arg.toString());",
      "function range": "47,5-49,5",
      "output": [
        {
          "patch": "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean toStringEquals(Matcher m, Object arg) {\n        return m.toString().equals(arg.toString());\n    }",
          "correctness": "wrong"
        }
      ]
    },
    "Time_4_/src/main/java/org/joda/time/Partial.java_464-465": {
      "loc": "464-465",
      "input": "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n// buggy line:        Partial newPartial = new Partial(iChronology, newTypes, newValues);",
      "function range": "426,5-474,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        }
      ]
    },
    "Time_15_/src/main/java/org/joda/time/field/FieldUtils.java_138-139": {
      "loc": "138-139",
      "input": "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n// buggy line:            return -val1;",
      "function range": "135,5-149,5",
      "output": [
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        },
        {
          "patch": "",
          "correctness": "wrong"
        }
      ]
    },
    "Time_16_/src/main/java/org/joda/time/format/DateTimeFormatter.java_709-710": {
      "loc": "709-710",
      "input": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);",
      "function range": "697,5-724,5",
      "output": [
        {
          "patch": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    instantMillis = bucket.getInstantMillis();\n    chrono = bucket.getChronology();\n    instant.setMillis(instantMillis);\n    instant.setChronology(chrono);\n    return newPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    instantMillis = bucket.getInstantMillis();\n    chrono = bucket.getChronology();\n    instant.setMillis(instantMillis);\n    instant.setChronology(chrono);\n    return newPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    instantMillis = bucket.getInstantMillis();\n    chrono = bucket.getChronology();\n    instant.setMillis(instantMillis);\n    instant.setChronology(chrono);\n    return newPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    instantMillis = bucket.getInstantMillis();\n    chrono = bucket.getChronology();\n    instant.setMillis(instantMillis);\n    instant.setChronology(chrono);\n    return newPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    instantMillis = bucket.getInstantMillis();\n    chrono = bucket.getChronology();\n    instant.setMillis(instantMillis);\n    instant.setChronology(chrono);\n    return newPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    instantMillis = bucket.getInstantMillis();\n    chrono = bucket.getChronology();\n    instant.setMillis(instantMillis);\n    instant.setChronology(chrono);\n    return newPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    instantMillis = bucket.getInstantMillis();\n    chrono = bucket.getChronology();\n    instant.setMillis(instantMillis);\n    instant.setChronology(chrono);\n    return newPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    instantMillis = bucket.getInstantMillis();\n    chrono = bucket.getChronology();\n    instant.setMillis(instantMillis);\n    instant.setChronology(chrono);\n    return newPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    instantMillis = bucket.getInstantMillis();\n    chrono = bucket.getChronology();\n    instant.setMillis(instantMillis);\n    instant.setChronology(chrono);\n    return newPos;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    if (newPos < 0) {\n        return newPos;\n    }\n    instantMillis = bucket.getInstantMillis();\n    chrono = bucket.getChronology();\n    instant.setMillis(instantMillis);\n    instant.setChronology(chrono);\n    return newPos;\n}",
          "correctness": "uncompilable"
        }
      ]
    },
    "Time_19_/src/main/java/org/joda/time/DateTimeZone.java_900-901": {
      "loc": "900-901",
      "input": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal != offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n// buggy line:    } else if (offsetLocal > 0) {",
      "function range": "880,5-911,5",
      "output": [
        {
          "patch": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n        if (offsetLocal > 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n        if (offsetLocal > 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n        if (offsetLocal > 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n        if (offsetLocal > 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n        if (offsetLocal > 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n        if (offsetLocal > 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n        if (offsetLocal > 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n        if (offsetLocal > 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n        if (offsetLocal > 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n        if (offsetLocal > 0) {\n            long prevLocal = prevTransition(instantAdjusted);\n            long prevAdjusted = prevTransition(instantLocal - offsetAdjusted);\n            if (prevLocal!= prevAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
          "correctness": "uncompilable"
        }
      ]
    }
  }
}